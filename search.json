[{"title":"Telegraf 與 InfluxDB：輕鬆實現資料收集與存儲","url":"/2025/01/17/Telegraf-與-InfluxDB：輕鬆實現資料收集與存儲/","content":"\n# Telegraf 與 InfluxDB：輕鬆實現資料收集與存儲\n\n現代的應用程式和系統都需要高效能的監控與分析工具，而 Telegraf 與 InfluxDB 正是一對強大的搭檔。這篇文章將帶你快速了解它們的功能與應用。\n\n---\n\n## **什麼是 Telegraf？**\n\nTelegraf 是由 **InfluxData** 開發的一款輕量級資料收集代理程式（Agent）。它專注於從多種來源收集指標資料，並將資料傳輸到多種儲存目的地。作為 **TICK 堆疊** 的一部分，Telegraf 具有以下特點：\n\n### **主要特點**\n\n1. **插件架構**：支援超過 300 種插件，涵蓋資料輸入（Input）、處理（Processor/Aggregator）與輸出（Output）。\n2. **高效與輕量**：使用 Go 語言開發，資源佔用小，效能表現優異。\n3. **多平台支持**：可在 Linux、Windows、macOS 等多種作業系統上運行。\n4. **靈活的資料流轉**：能處理各種系統指標、應用程式性能資料，甚至 IoT 裝置的數據。\n\n### **工作原理**\n\nTelegraf 通過以下流程運作：\n\n1. **輸入（Input）**：從多種來源（如系統、應用程式、資料庫）收集資料。\n2. **處理（Processor/Aggregator）**：在資料傳輸前進行轉換或聚合。\n3. **輸出（Output）**：將資料傳輸到目標位置（如 InfluxDB）。\n\n---\n\n## **什麼是 InfluxDB？**\n\nInfluxDB 是一款專為時序資料設計的開源資料庫，適合存儲和分析大規模的時序資料。它同樣由 InfluxData 開發，與 Telegraf 天生相容。\n\n### **主要特點**\n\n1. **時序資料專用**：優化存儲時間標記的資料（如指標、事件）。\n2. **高效查詢語言**：支持 InfluxQL 與 Flux，簡化資料分析。\n3. **自動壓縮與保留策略**：降低存儲成本，支援資料的生命周期管理。\n4. **擴展性**：從單機到分散式架構均可支持。\n\n---\n\n## **Telegraf 與 InfluxDB 的合作方式**\n\nTelegraf 與 InfluxDB 是一種天然的組合：\n\n1. Telegraf 收集系統或應用的指標資料。\n2. 通過 Output 插件，將資料輸出到 InfluxDB。\n3. InfluxDB 負責存儲並提供高效的查詢接口，供分析或可視化工具（如 Chronograf、Grafana）使用。\n\n### **簡單配置範例**\n\n假設我們希望收集系統的 CPU 與記憶體使用狀況，並將其存入 InfluxDB。\n\n#### **步驟 1：安裝 Telegraf**\n```bash\nsudo apt-get update\nsudo apt-get install telegraf\n```\n\n#### **步驟 2：編輯配置檔案**\n配置檔案位於 `/etc/telegraf/telegraf.conf`，內容如下：\n\n```toml\n# Global Agent Configuration\n[agent]\n  interval = \"10s\"  # 資料收集間隔\n\n# Input Plugins\n[[inputs.cpu]]\n  percpu = true\n  totalcpu = true\n\n[[inputs.mem]]\n\n# Output Plugins\n[[outputs.influxdb]]\n  urls = [\"http://localhost:8086\"] # InfluxDB 位址\n  database = \"telegraf\"            # 儲存的資料庫名稱\n```\n\n#### **步驟 3：啟動 Telegraf**\n```bash\nsudo systemctl start telegraf\n```\n\n---\n\n## **應用場景**\n\n1. **系統監控**：收集伺服器的 CPU、記憶體、磁碟使用率等指標。\n2. **應用性能監控**：監控 Nginx、MySQL 等服務的性能。\n3. **IoT 資料分析**：從 IoT 裝置收集感測器資料，進行實時分析。\n4. **多源資料聚合**：整合來自不同系統的資料，統一儲存於 InfluxDB。\n\n---\n\n## **優勢與限制**\n\n### **優勢**\n- 快速部署，輕鬆配置。\n- 支援多種資料來源與目標。\n- 高效處理大規模時序資料。\n\n### **限制**\n- InfluxDB 的查詢語言需要學習成本。\n- 對於非時序資料，可能不如關聯式資料庫方便。\n\n---\n\n## **總結**\n\nTelegraf 與 InfluxDB 是一組強大的工具組合，可以幫助你輕鬆實現資料的收集、存儲與分析。無論是系統監控、應用性能分析，還是 IoT 資料處理，這兩者都能快速滿足需求。\n\n開始使用它們，讓你的資料管理更加高效！\n","tags":["Telegraf","InfluxDB"]},{"title":"在 *Grafana* 中查詢 *InfluxDB* 資料庫中的 table（資料表）","url":"/2025/01/17/在-Grafana-中查詢-InfluxDB-資料庫中的-table（資料表）/","content":"\n在 **Grafana** 中查詢 **InfluxDB** 資料庫中的 table（資料表）需要先完成數據源的設定，然後使用正確的查詢語法來檢索資料。以下是詳細的步驟說明：\n\n---\n\n## **為什麼選擇 Grafana 與 InfluxDB？**\nGrafana 是一款強大的開源數據可視化工具，InfluxDB 則是專門為時序數據設計的資料庫。兩者結合可以實現：\n- 系統與應用的性能監控。\n- 即時數據的可視化分析。\n- 快速部署與靈活查詢。\n\n無論是 DevOps、IoT，還是數據分析，這套組合都能滿足需求。\n\n---\n\n## **步驟 1：添加 InfluxDB 作為數據源**\n1. **進入 Grafana 的設定頁面**：\n   - 點擊左側的齒輪圖標（⚙️），選擇 **Data Sources**。\n\n   ![Data Sources 設定頁面](https://hackmd.io/_uploads/BJMtZ4Pw1l.png)\n\n2. **新增資料源**：\n   - 點擊 **Add data source**，選擇 **InfluxDB**。\n\n   ![選擇 InfluxDB 資料源](https://hackmd.io/_uploads/Hy9cb4Dvkl.png)\n\n   ![選擇後的設定頁面](https://hackmd.io/_uploads/HkhjbVDDyg.png)\n\n3. **設定資料源參數**：\n   - **URL**：填寫 InfluxDB 的 HTTP API 位址（如 `http://localhost:8086`）。\n   - **Database**：指定要查詢的 InfluxDB 資料庫名稱。\n   - **Auth**：若使用者名稱與密碼已啟用，填寫相應的認證資訊。\n   - **Query Language**：選擇正確的查詢語言：\n     - **InfluxQL**（InfluxDB 1.x）。\n     - **Flux**（InfluxDB 2.x）。\n   - 點擊 **Save & Test** 確認連線成功。\n\n   ![設定並測試連線](https://hackmd.io/_uploads/SyApZNvP1x.png)\n\n**小提示**：確保 InfluxDB 服務正在運行，且 Grafana 能夠訪問正確的 URL。\n\n---\n\n## **步驟 2：建立面板並查詢資料**\n1. **新增面板**：\n   - 返回 Grafana 主頁，點擊 **Create → Dashboard → Add a new panel**。\n\n   ![新增面板步驟](https://hackmd.io/_uploads/r1eefEvDkx.png)\n\n   ![面板編輯畫面](https://hackmd.io/_uploads/rJk-fEDDkl.png)\n\n2. **選擇資料源**：\n   - 在面板的查詢設定區域，選擇剛剛新增的 **InfluxDB** 資料源。\n\n   ![選擇資料源](https://hackmd.io/_uploads/BkcQMNvD1e.png)\n\n3. **撰寫查詢語法**：\n   - 根據 InfluxDB 的版本選擇合適的語法。\n\n---\n\n## **InfluxQL 查詢（InfluxDB 1.x）**\nInfluxQL 是類似 SQL 的查詢語言，用於檢索時序數據。\n\n### **基本查詢範例**\n```sql\nSELECT field1, field2 FROM measurement WHERE time > now() - 1h\n```\n\n#### **常用語法說明**\n- `field1, field2`：要查詢的欄位名稱。\n- `measurement`：資料表名稱（類似 SQL 的 table）。\n- `time > now() - 1h`：篩選最近一小時內的資料。\n\n#### **顯示所有 measurement 名稱**\n```sql\nSHOW MEASUREMENTS\n```\n\n#### **顯示某個 measurement 的欄位結構**\n```sql\nSHOW FIELD KEYS FROM measurement\n```\n\n#### **顯示資料庫中所有標籤（tags）**\n```sql\nSHOW TAG KEYS\n```\n\n**小提示**：在撰寫查詢語法時，可利用測試功能檢查語法是否正確。\n\n---\n\n## **Flux 查詢（InfluxDB 2.x）**\nFlux 是功能更強大的查詢語言，適用於 InfluxDB 2.x。\n\n### **基本查詢範例**\n```flux\nfrom(bucket: \"example_bucket\")\n  |> range(start: -1h)\n  |> filter(fn: (r) => r._measurement == \"measurement\")\n  |> filter(fn: (r) => r._field == \"field1\" or r._field == \"field2\")\n```\n\n#### **常用語法說明**\n- `bucket`：資料表所屬的 bucket 名稱。\n- `range(start: -1h)`：篩選時間範圍（最近一小時）。\n- `filter`：篩選條件，例如特定 measurement 或 field。\n\n#### **顯示所有 bucket 名稱**\n```flux\nbuckets()\n```\n\n#### **列出特定 bucket 的 schema**\n```flux\nimport \"influxdata/influxdb/schema\"\nschema.measurements(bucket: \"example_bucket\")\n```\n\n**小提示**：Flux 語法支援高度客製化，可針對複雜的需求進行數據處理。\n\n---\n\n## **步驟 3：調整面板設定**\n1. **數據可視化**：\n   - 選擇合適的圖表類型（如折線圖、柱狀圖）。\n   \n2. **格式化數據**：\n   - 在 **Field** 區域調整資料格式，例如時間戳、單位等。\n\n3. **應用並保存**：\n   - 點擊 **Apply** 儲存面板設定。\n\n**注意**：根據不同數據類型，選擇適合的可視化類型，能讓圖表更具可讀性。\n\n---\n\n## **結語**\n在 Grafana 中查詢 InfluxDB table 主要是通過撰寫合適的查詢語法（InfluxQL 或 Flux）來檢索資料。根據 InfluxDB 的版本選擇語言，然後結合 Grafana 的可視化工具即可輕鬆展示資料。 \n\n**小總結**：\n- InfluxQL 適合簡單查詢，學習成本低。\n- Flux 功能強大，適用於更複雜的數據處理需求。\n\n希望這篇指南能幫助你更快上手！如有其他問題，請隨時聯繫我。\n\n","tags":["InfluxDB","Grafana"]},{"title":"🎯 常見會議紀錄 AI 工具總攬","url":"/2025/01/16/🎯-常見會議紀錄-AI-工具總攬/","content":"\n# 🎯 常見會議紀錄 AI 工具總攬\n\n## 1. **Otter.ai**\nOtter.ai 是目前市場上最受歡迎的會議紀錄工具之一。它能自動轉錄語音內容，並生成會議摘要。\n\n**功能特色：**\n- 自動語音轉錄並生成會議摘要。\n- 支援實時文字筆記和時間標記。\n- 多人共享筆記與協作功能。\n\n**適用場合：**\n適合線上會議（如 Zoom、Google Meet）或現場會議。\n\n**優勢：**\n- 支援中文和其他多語言。\n- 與 Zoom、Microsoft Teams 無縫整合。\n\n![image](https://hackmd.io/_uploads/H1p99ArDke.png)\n>https://otter.ai\n\n---\n\n## 2. **Fireflies.ai**\nFireflies.ai 是一款專注於自動化會議錄音和轉錄的工具，特別適合企業團隊使用。\n\n**功能特色：**\n- 自動錄音和會議轉錄。\n- 智能生成會議摘要和提取關鍵內容。\n- 搜尋和標記關鍵詞功能。\n\n**適用場合：**\n企業團隊會議、專案討論。\n\n**優勢：**\n- 與 Google Meet、Zoom、Teams 等整合。\n- 免費計劃提供基本功能。\n\n![image](https://hackmd.io/_uploads/ByjacArw1e.png)\n>https://fireflies.ai\n\n---\n\n## 3. **Notion AI**\nNotion AI 是一個嵌入在 Notion 平台中的智能工具，能生成精美的會議紀錄。\n\n**功能特色：**\n- 使用 AI 自動生成會議內容。\n- 提供行動項目建議和摘要。\n- 支援模板化紀錄。\n\n**適用場合：**\n簡單會議紀錄與團隊合作。\n\n**優勢：**\n- 與其他文檔、任務管理工具無縫整合。\n- 可高度自定義紀錄格式。\n\n![image](https://hackmd.io/_uploads/rkZ6-J8w1x.png)\n>https://www.notion.so\n\n\n---\n\n## 4. **Zoom IQ for Meetings**\nZoom 的內建 AI 助理專為 Zoom 用戶打造，提供高效的會議紀錄與摘要。\n\n**功能特色：**\n- 即時生成會議摘要和行動項目。\n- 支援與 Zoom 原生整合。\n\n**適用場合：**\nZoom 線上會議。\n\n**優勢：**\n- 原生工具，無需額外設定。\n\n![image](https://hackmd.io/_uploads/S1w0-kUPJx.png)\n>https://www.zoom.com/zh-tw/blog/zoom-ai-companion/\n\n---\n\n## 5. **Microsoft Teams Copilot**\nMicrosoft Teams 的 Copilot 是專為企業用戶設計的會議紀錄 AI 工具，與 Microsoft 365 完美結合。\n\n**功能特色：**\n- 提供智能會議摘要和行動項目。\n- 與 Microsoft 365 生態系統深度整合。\n\n**適用場合：**\n使用 Microsoft Teams 的企業團隊。\n\n**優勢：**\n- 深度集成 Microsoft 生態，提升協作效率。\n\n![image](https://hackmd.io/_uploads/H1pxG1UPkl.png)\n>https://support.microsoft.com/zh-tw/office/%E9%96%8B%E5%A7%8B%E5%9C%A8-microsoft-teams-%E6%9C%83%E8%AD%B0%E4%B8%AD%E4%BD%BF%E7%94%A8-copilot-0bf9dd3c-96f7-44e2-8bb8-790bedf066b1\n\n---\n\n## 6. **Fathom**\nFathom 專注於線上會議（如 Zoom）的即時紀錄和摘要。\n\n**功能特色：**\n- 提供自動生成的會議重點。\n\n**適用場合：**\n需要即時記錄會議的情境。\n\n**優勢：**\n- 易用，對於快速會議特別有效。\n- 免費提供基本功能。\n\n![image](https://hackmd.io/_uploads/BktMfJIPJx.png)\n>https://www.fathom.video\n\n---\n\n## 7. **Gong.io**\nGong.io 專為銷售團隊設計，提供會議紀錄和銷售建議。\n\n**功能特色：**\n- 智能分析會議內容，提供銷售建議。\n\n**適用場合：**\n銷售會議、商業洽談。\n\n**優勢：**\n- 深入數據分析，提升業績。\n- 支援語音分析和行動建議。\n\n![image](https://hackmd.io/_uploads/SJS4z1Uwkx.png)\n>https://www.gong.io\n\n---\n\n## 8. **Krisp AI**\nKrisp AI 注重音訊質量，同時提供高質量的會議紀錄。\n\n**功能特色：**\n- 自動降噪，確保清晰錄音。\n- 提供會議後的摘要報告。\n\n**適用場合：**\n需要高質量錄音與紀錄的情境。\n\n**優勢：**\n- 專注於音訊質量。\n- 提供即時降噪與錄音功能。\n\n![image](https://hackmd.io/_uploads/ryCBMyUv1l.png)\n>https://krisp.ai/\n\n---\n\n## 9. **Sembly AI**\nSembly AI 為商業和技術團隊提供專業的會議紀錄服務。\n\n**功能特色：**\n- 自動生成會議摘要。\n- 支援多語言轉錄與分析。\n\n**適用場合：**\n商業和技術團隊會議。\n\n**優勢：**\n- 智能提取行動項目和會議決策。\n- 易於分享摘要。\n\n[了解更多](https://www.sembly.ai)\n\n![image](https://hackmd.io/_uploads/r1cwf1Ivkg.png)\n>https://www.sembly.ai/\n\n---\n\n# 🛠️ 會議紀錄工具功能比較表\n\n| 工具名稱              | 功能特色                                                                 | 適用場合                            | 優勢                                                                                   | 價格資訊 (概述)      |\n|-----------------------|--------------------------------------------------------------------------|-------------------------------------|---------------------------------------------------------------------------------------|----------------------|\n| **Otter.ai**          | 自動語音轉錄、生成摘要，支持多人共享與協作。                             | 線上會議或現場會議                  | 支持多語言，與 Zoom、Microsoft Teams 無縫整合。                                       | 免費計劃+進階付費方案|\n| **Fireflies.ai**      | 自動錄音與轉錄，智能生成摘要，支持關鍵詞標記和搜尋。                      | 企業團隊會議、專案討論              | 與多種線上會議工具整合，提供免費基本功能。                                             | 免費計劃+進階付費方案|\n| **Notion AI**         | 自動生成紀錄，支持行動項目建議與摘要，自定義格式模板。                   | 簡單會議紀錄與團隊合作              | 深度整合 Notion 的文檔與管理功能，支持高度自定義。                                     | Notion Pro 訂閱內含 |\n| **Zoom IQ**           | 即時摘要與行動項目，內建於 Zoom。                                       | Zoom 線上會議                      | 原生整合 Zoom，使用簡單，無需額外設定。                                               | Zoom 訂閱內含       |\n| **Microsoft Teams Copilot** | 智能摘要與行動項目，與 Microsoft 365 深度整合。                     | 使用 Microsoft Teams 的企業團隊     | 提升 Microsoft 生態內的協作效率，支持豐富的商業場景。                                  | Microsoft 365 訂閱  |\n| **Fathom**            | 自動生成重點摘要，針對 Zoom 即時記錄。                                   | 線上會議，特別是快速會議             | 簡單易用，免費提供基本功能，對於快速會議有效。                                         | 免費計劃            |\n| **Gong.io**           | 智能分析內容，提供銷售建議。                                             | 銷售會議、商業洽談                  | 提供深入數據分析與銷售策略建議，專注提升業績。                                         | 定制價格方案        |\n| **Krisp AI**          | 即時降噪，確保高質量錄音，提供會後摘要報告。                            | 需要高音訊質量與紀錄的場景          | 確保錄音清晰，適合噪音環境使用。                                                     | 免費計劃+進階付費方案|\n| **Sembly AI**         | 自動摘要，支持多語言，智能提取行動項目和決策。                           | 商業和技術團隊會議                  | 簡化複雜會議紀錄，支持多語言，易於分享。                                              | 免費計劃+進階付費方案|\n\n---\n\n# 🎉 推薦工具\n\n根據你的需求，選擇適合的工具：\n\n- **需要中文支援？** 選擇 Otter.ai 或 Fireflies.ai。\n- **使用 Zoom 或 Microsoft Teams？** Zoom IQ 或 Microsoft Teams Copilot 是最佳選擇。\n- **尋求完整紀錄與行動建議？** Notion AI 或 Fireflies.ai 是不錯的選擇。\n\n現代化的會議管理，離不開這些 AI 工具的幫助。透過這些工具，讓你的會議不僅高效，還能減少會後整理的負擔。趕快試試看，找到最適合你的會議紀錄神器吧！\n\n","tags":["會議紀錄 AI","Otter.ai","Fireflies.ai","Notion AI","Zoom IQ","Microsoft Teams Copilot","Fathom","Gong.io","Krisp AI","Sembly AI"]},{"title":"學習 Headless UI：打造靈活的前端設計","url":"/2025/01/08/學習-Headless-UI：打造靈活的前端設計/","content":"\n## 什麼是 Headless UI？  \n\n\n![image](https://hackmd.io/_uploads/BJRyTDsL1x.png)\n>https://github.com/tailwindlabs/headlessui\n\n在前端開發中，**Headless UI** 是一種專注於功能而非外觀的 UI 元件庫。它提供了基礎的交互邏輯與功能，但不附帶預設樣式，開發者可以完全自由地設計視覺呈現，讓應用程式能夠更靈活地滿足不同的設計需求。  \n\n\n## 為什麼選擇 Headless UI？  \n\n1. **完全的樣式自由**  \n   Headless UI 不會強制使用任何特定的樣式表，開發者可以用自己的 CSS 或框架（如 Tailwind CSS、SCSS）來控制外觀。  \n\n2. **專注於功能**  \n   它提供了預建的功能邏輯，例如無障礙支援（Accessibility）和狀態管理，開發者可以減少處理細節的時間，專注於業務邏輯與設計。  \n\n3. **框架無關**  \n   雖然 Headless UI 目前主要支援 React 和 Vue，但它的概念適用於任何框架甚至原生 JavaScript。  \n\n---\n\n## 常見功能與範例  \n\n### 1. 無樣式的彈出式選單（Dropdown Menu）  \n\n**範例使用 Tailwind CSS 與 React:**  \n```jsx\nimport { Menu } from '@headlessui/react';\n\nfunction Dropdown() {\n  return (\n    <Menu>\n      <Menu.Button className=\"bg-blue-500 text-white px-4 py-2 rounded\">選單</Menu.Button>\n      <Menu.Items className=\"absolute bg-white border mt-2 rounded shadow-md\">\n        <Menu.Item>\n          {({ active }) => (\n            <a\n              className={`block px-4 py-2 ${active ? 'bg-blue-100' : ''}`}\n              href=\"/profile\"\n            >\n              個人資料\n            </a>\n          )}\n        </Menu.Item>\n        <Menu.Item>\n          {({ active }) => (\n            <a\n              className={`block px-4 py-2 ${active ? 'bg-blue-100' : ''}`}\n              href=\"/settings\"\n            >\n              設定\n            </a>\n          )}\n        </Menu.Item>\n      </Menu.Items>\n    </Menu>\n  );\n}\nexport default Dropdown;\n```\n\n### 2. 無樣式的對話框（Dialog）  \n\nHeadless UI 內建了彈性對話框元件，適用於模態視窗：  \n\n```jsx\nimport { Dialog } from '@headlessui/react';\nimport { useState } from 'react';\n\nfunction Modal() {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    <>\n      <button onClick={() => setIsOpen(true)} className=\"bg-green-500 text-white px-4 py-2 rounded\">開啟對話框</button>\n      <Dialog open={isOpen} onClose={() => setIsOpen(false)} className=\"fixed inset-0 z-10\">\n        <div className=\"fixed inset-0 bg-black opacity-30\" aria-hidden=\"true\" />\n        <div className=\"relative p-6 bg-white max-w-sm mx-auto mt-20 rounded\">\n          <Dialog.Title className=\"text-lg font-bold\">對話框標題</Dialog.Title>\n          <Dialog.Description>這是對話框的內容描述。</Dialog.Description>\n          <button onClick={() => setIsOpen(false)} className=\"mt-4 bg-red-500 text-white px-4 py-2 rounded\">關閉</button>\n        </div>\n      </Dialog>\n    </>\n  );\n}\nexport default Modal;\n```\n\n---\n\n## Headless UI 的優點  \n\n- **無縫整合 CSS 框架：** 與 Tailwind CSS 搭配時，能輕鬆建立自訂的外觀設計。  \n- **無障礙支援：** 預設支援 ARIA 屬性，符合 WCAG 標準。  \n- **提升開發效率：** 開發者不需從零實作交互邏輯。  \n\n---\n\n## 使用建議  \n\n1. **結合設計系統：** 將 Headless UI 元件作為基礎，打造符合團隊需求的設計系統。  \n2. **熟悉無障礙規範：** 善用 Headless UI 提供的無障礙功能，提升應用程式的易用性。  \n3. **配合框架生態系：** 選擇適合的樣式工具（如 Tailwind CSS）能大幅減少樣式設計的重工。  \n"},{"title":"Celebrate Lunar New Year with Surfshark VPN and MapleStory Worlds-Artale","url":"/2025/01/06/Celebrate-Lunar-New-Year-with-Surfshark-VPN-and-MapleStory-Worlds-Artale/","content":"# Celebrate Lunar New Year with Surfshark VPN and MapleStory Worlds-Artale  \n\n---\n\n**Looking for a way to make your holiday season unforgettable?**  \nWith **[Surfshark VPN](https://get.surfshark.net/aff_c?offer_id=926&aff_id=36065)**, you can play the global server of *Artale: MapleStory Nostalgia* right from the comfort of your home! Relive your childhood memories, explore iconic maps, and embark on nostalgic adventures with friends.  \n\n---\n\n### **Why Choose Surfshark VPN?**  \n\n1. **Access Global Game Servers Anywhere**  \n   Play *Artale: MapleStory Nostalgia* on global servers with Surfshark’s stable cross-region connection.  \n\n2. **Fast and Reliable Performance**  \n   Say goodbye to lag and disconnections. Surfshark ensures a smooth gaming experience with high-speed servers.  \n\n3. **Protect Your Privacy Online**  \n   Whether you're on public Wi-Fi or at home, Surfshark safeguards your IP and personal data from hackers.  \n\n4. **Connect All Your Devices**  \n   One account covers unlimited devices! Play *Artale* on your PC while chatting with friends on your smartphone—securely.  \n\n---\n\n### **How to Get Started**  \n\n1️⃣ **[Click Here](https://get.surfshark.net/aff_c?offer_id=926&aff_id=36065)** to subscribe to Surfshark VPN and grab your New Year deal.  \n2️⃣ Install the Surfshark VPN app and choose your preferred server location.  \n3️⃣ Visit *Artale: MapleStory Nostalgia*’s official site, download the game, and start your adventure!  \n\n👉 [Play Artale Here](https://maplestoryworlds.nexon.com/en/play/79ff3d4d4aba4796baa484e411754533)  \n\n![image](https://hackmd.io/_uploads/SJ2qAzKI1x.png)\n\n---\n\n### **Exclusive Lunar New Year Offers**  \nSubscribe to Surfshark using **[my special link](https://get.surfshark.net/aff_c?offer_id=926&aff_id=36065)** and enjoy full VPN features at an exclusive discount.  \n\n---\n\n**Join me this Lunar New Year with Surfshark VPN and dive into the world of *Artale: MapleStory Nostalgia*!**  \nHappy gaming, and Happy Lunar New Year! 🎉🎮  \n","tags":["Surfshark VPN"]},{"title":"過年在家用 Surfshark VPN 玩 Artale 懷舊版楓之谷","url":"/2025/01/03/過年在家用-Surfshark-VPN-玩-Artale-懷舊版楓之谷/","content":"\n# 過年在家用 Surfshark VPN 玩 Artale 懷舊版楓之谷\n\n---\n\n**新年假期即將到來，還在尋找讓假期更豐富的方式嗎？**  \n現在，透過 **Surfshark VPN**，您可以在家無憂無慮地暢玩全球服的《Artale 懷舊版楓之谷》，重溫童年經典，和朋友一起探索那些熟悉的地圖與故事！\n\n---\n\n### **為什麼選擇 Surfshark VPN？**\n\n1. **跨區暢玩全球遊戲**  \n   想玩全球伺服器的《Artale 懷舊版楓之谷》嗎？Surfshark VPN 提供穩定的跨區連接，讓您無論身處何地，都能順暢登入。\n\n2. **極速穩定，不掉線**  \n   新年假期最煩人的就是延遲與掉線！Surfshark 的高速伺服器網絡確保您的遊戲體驗順暢無卡頓。\n\n3. **保護隱私，安心連線**  \n   無論您是使用公用 Wi-Fi 還是家中網路，Surfshark 都能幫助您隱藏 IP，保護個人隱私，避免駭客入侵。\n\n4. **多設備同時使用**  \n   一個帳號即可覆蓋多個設備！不管您是用 PC 玩《Artale》，還是用手機與朋友聊天，都能同時享受 Surfshark 的保護。\n\n---\n\n### **如何開始使用？**\n\n**步驟 1**: [點擊這裡](https://get.surfshark.net/aff_c?offer_id=926&aff_id=36065) 訂閱 Surfshark VPN，享受新年超值優惠！  \n**步驟 2**: 安裝 Surfshark VPN，選擇您要連線的國家伺服器。  \n**步驟 3**: 登入《Artale 懷舊版楓之谷》官網，下載遊戲並開始您的冒險！  \n\nhttps://maplestoryworlds.nexon.com/en/play/79ff3d4d4aba4796baa484e411754533/\n\n![image](https://hackmd.io/_uploads/HkDbBmHI1e.png)\n\n---\n\n### **Surfshark 新年特惠等您來拿！**  \n透過 **[我的專屬連結](https://get.surfshark.net/aff_c?offer_id=926&aff_id=36065)** 訂閱 Surfshark，不僅可以享受 VPN 的全方位功能，還能獲得專屬折扣，讓您的新年假期更有趣！\n\n---\n\n**和我一起用 Surfshark VPN 進入《Artale 懷舊版楓之谷》的世界吧！**  \n新年快樂，冒險家們！🎉","tags":["Surfshark VPN"]},{"title":"Leetcode 練習 - 596. Classes More Than 5 Students","url":"/2024/12/27/Leetcode-練習-596-Classes-More-Than-5-Students/","content":"\n\n![image](https://hackmd.io/_uploads/Hkc-Tcirkl.png)\n\n### **背景**\n在學校課程系統中，我們經常需要統計學生選課的情況，特別是找出那些參加人數較多的課程。例如，我們可能想了解哪些課程非常受歡迎，以便更好地分配教學資源。\n\n這次，我們將解決一個類似的問題：找出學生人數至少 5 人的課程。\n\n---\n\n### **題目**\n\n**Table**: `Courses`\n\n```\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| student     | varchar |\n| class       | varchar |\n+-------------+---------+\n```\n\n- `(student, class)` 是表的主鍵，表示每位學生唯一對應一門課程。\n- 每行表示學生的名字以及他選修的課程名稱。\n\n我們需要寫出一個 SQL 查詢，找出所有至少有 5 位學生的課程，並以 **任意順序** 返回。\n\n---\n\n### **範例**\n\n**輸入：**\n\nCourses 表：\n```\n+---------+----------+\n| student | class    |\n+---------+----------+\n| A       | Math     |\n| B       | English  |\n| C       | Math     |\n| D       | Biology  |\n| E       | Math     |\n| F       | Computer |\n| G       | Math     |\n| H       | Math     |\n| I       | Math     |\n+---------+----------+\n```\n\n**輸出：**\n```\n+---------+\n| class   |\n+---------+\n| Math    |\n+---------+\n```\n\n**解釋：**\n- **Math**：有 6 位學生，符合條件。\n- **English**、**Biology**、**Computer**：各只有 1 位學生，不符合條件。\n\n---\n\n### **解法**\n\n我們可以用 SQL 查詢來解決這個問題，步驟如下：\n\n```sql\nSELECT class\nFROM Courses\nGROUP BY class\nHAVING COUNT(student) >= 5;\n```\n\n**逐步解析：**\n1. **`GROUP BY class`**：將所有行按 `class` 分組，每個課程成為一組。\n2. **`COUNT(student)`**：計算每個課程組中的學生數量。\n3. **`HAVING COUNT(student) >= 5`**：篩選出學生數量大於等於 5 的課程。\n4. **`SELECT class`**：返回符合條件的課程名稱。\n\n---\n\n### **延伸思考**\n\n1. 如果要查找學生少於 5 人的課程，只需將 `HAVING` 條件改為：\n   ```sql\n   HAVING COUNT(student) < 5;\n   ```\n\n2. 如果需要同時返回課程名稱和學生數量：\n   ```sql\n   SELECT class, COUNT(student) AS student_count\n   FROM Courses\n   GROUP BY class\n   HAVING COUNT(student) >= 5;\n   ```\n\n3. 如果要返回學生數量最多的課程，可以用：\n   ```sql\n   SELECT class, COUNT(student) AS student_count\n   FROM Courses\n   GROUP BY class\n   ORDER BY student_count DESC\n   LIMIT 1;\n   ```\n\n---\n\n### **結語**\n\n這題幫助我們練習了 SQL 中的分組與聚合操作，也是數據分析中的基礎技巧。在實際工作中，類似的問題可以應用於課程報名、人數統計等場景。希望大家能舉一反三，應用到更多的場景中！\n","tags":["Leetcode"]},{"title":"使用 n8n 打造屬於你的自動化工作流程","url":"/2024/12/26/使用-n8n-打造屬於你的自動化工作流程/","content":"\n# 使用 n8n 打造屬於你的自動化工作流程\n\n![image](https://hackmd.io/_uploads/rklSEHcr1g.png)\n\nn8n 是一款 開源、免費 的工作流程自動化工具，具有高度靈活性與可擴展性。不僅支援桌面版，還可透過自建環境或 Docker 快速架設，讓使用者能透過拖拉點選的方式輕鬆創建屬於自己的工作流程。\n\n可以輕鬆串接多個應用程式與服務，實現流程自動化。\n\n不僅如此，n8n 提供靈活的設計，讓開發者能輕鬆擴展功能，是一款適合各種場景的自動化解決方案。\n\n---\n\n## 什麼是 n8n？\n\n![image](https://hackmd.io/_uploads/rJl0QB5Syx.png)\n>https://n8n.io/\n\nn8n（pronounced as \"nodemation\"）是一個用 Node.js 打造的自動化工具，具有以下特性：\n\n1. **豐富的整合功能**  \n   - 提供多種節點，例如：Webhook、Cron Job、HTTP Request、HTML Extract 等功能，幾乎涵蓋網站資料處理的所有需求。\n\n2. **完整的官方文件**  \n   - 每個功能都有詳細的基礎教學與說明，初學者也能快速上手。詳見 [n8n 官方文件](https://docs.n8n.io)。\n\n3. **支援 JavaScript 自定義節點**  \n   - 使用者可以撰寫自己的 JavaScript 節點，也能在現有節點中運用 JavaScript 進行操作（例如：日期處理、字串運算、計算長度等）。  \n\n4. **多元社群與平台整合**  \n   - 支援整合的社群與聯絡平台包括：  \n     - SendGrid  \n     - LINE  \n     - Slack  \n     - Telegram  \n     - Twitter  \n\n5. **雲端服務整合**  \n   - 支援整合的雲端平台如：  \n     - GCP  \n     - AWS  \n     - Azure  \n     - Airtable  \n     - Box  \n\n![image](https://hackmd.io/_uploads/HyhQOr5Byl.png)\n\n\n## **特點總結**  \n- **完全開源**：n8n 是全開源工具，提供最大自由度。\n- **可擴展性**：不僅支援大量現成服務，還能根據需求自定義新功能。\n- **學習成本低**：官方提供的文件與範例教學友好，適合快速入門。  \n\nGitHub Repo：[https://github.com/n8n-io/n8n](https://github.com/n8n-io/n8n) \n\n\n---\n\n## n8n 安裝與啟用\n\n以下是如何快速在本地運行 n8n 的步驟：\n\n### 步驟 1. 下載 n8n 專案\n\n首先，將 n8n 的原始碼下載到本地。\n\n```bash\ngit clone git@github.com:n8n-io/n8n.git\n```\n\n### 步驟 2. 使用 Docker 啟動 n8n\n\n假設你的專案放在 `/home/nalson/練習/n8n`，可以使用以下指令啟動：\n\n```bash\nsudo docker run -it --rm --name n8n \\\n  -p 5678:5678 \\\n  -v /home/nalson/練習/n8n:/home/node/.n8n \\\n  n8nio/n8n\n```\n\n### 步驟 3. 設定時區\n\n為了確保 Cron job 或時間相關功能正確運行，可以設定服務的時區。例如：\n\n```bash\nsudo docker run -it --rm \\\n  --name n8n \\\n  -p 5678:5678 \\\n  -e GENERIC_TIMEZONE=\"Asia/Taipei\" \\\n  -e TZ=\"Asia/Taipei\" \\\n  n8nio/n8n\n```\n\n---\n\n## 執行結果\n\n![image](https://hackmd.io/_uploads/SyUyIBcH1g.png)\n\n成功啟動後，打開瀏覽器並輸入 [localhost:5678](http://localhost:5678)，進入 n8n 的 Web UI。\n\n![image](https://hackmd.io/_uploads/Hy8ZIr5Syl.png)\n設定完成後可以看到這邊的問卷\n![image](https://hackmd.io/_uploads/HkQfUSqS1g.png)\n\n![image](https://hackmd.io/_uploads/ryufUBqrJg.png)\n結果畫面:\n![image](https://hackmd.io/_uploads/SkmwIrqHke.png)\n\n完成註冊並登入後，你就可以開始設計屬於你的自動化工作流程！\n\n---\n\n## 使用情境\n以下是一些常見的應用場景：\n- **定時抓取資料**：從 API 或網頁擷取數據並儲存到資料庫。\n- **跨服務整合**：將新電子郵件自動同步到 Google Sheets。\n- **通知提醒**：當指定條件滿足時，發送 Slack 通知。\n\nn8n 的官方網站提供了豐富的文件與範例，幫助使用者快速上手。你可以參考這些資源，探索更多可能性：\n![image](https://hackmd.io/_uploads/rycCDB5HJx.png)\n\n---\n\n## 注意事項\n\n1. **記得註冊後再使用**：n8n 的工作流程會存儲在用戶資料中。如果未註冊，重啟 Docker 後將無法找回編輯過的工作流程。\n2. **慎記密碼**：在啟用電子郵件服務之前，「忘記密碼」功能無法使用。\n\n---\n\n## 結語\n\nn8n 是一個功能強大且靈活的自動化工具，無論是處理日常任務，還是搭建複雜的數據工作流程，都能輕鬆勝任。試試看，讓 n8n 為你節省時間並提高效率吧！\n\n","tags":["自動化","n8n"]},{"title":"如何在 TailwindCSS 中隱藏捲軸 - scrollbar","url":"/2024/12/24/如何在-TailwindCSS-中隱藏捲軸-scrollbar/","content":"\n# 如何在 TailwindCSS 中隱藏捲軸 - scrollbar\n## 你不想讓你的 UI 看起來像這樣嗎？\n\n**在隱藏捲軸前：**\n\n![image](https://hackmd.io/_uploads/Bkh29KPSJe.png)\n\n本篇將教你 **如何使用 TailwindCSS 隱藏 HTML 元素的捲軸**，只需兩個簡單步驟即可完成！\n\n---\n\n## 步驟一：新增自定義樣式\n\n首先，打開你的專案中的 `global.css`（或 `styles/global.css`），並新增以下樣式代碼：  \n\n```css\n/* global.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* 新增以下代碼 */\n@layer utilities {\n  /* 隱藏 Chrome、Safari 和 Opera 的捲軸 */\n  .no-scrollbar::-webkit-scrollbar {\n    display: none;\n  }\n\n  /* 隱藏 IE、Edge 和 Firefox 的捲軸 */\n  .no-scrollbar {\n    -ms-overflow-style: none; /* IE 和 Edge */\n    scrollbar-width: none;    /* Firefox */\n  }\n}\n```\n\n### 解釋：\n1. **`::-webkit-scrollbar`**：針對 Chrome、Safari 和 Opera 定義捲軸樣式。\n2. **`.no-scrollbar`**：提供給其他瀏覽器（如 IE、Edge 和 Firefox）使用。\n\n至此，已新增名為 `no-scrollbar` 的自定義 TailwindCSS 工具類別。\n\n---\n\n## 步驟二：在 HTML 元素中使用 `no-scrollbar`\n\n接下來，將 `no-scrollbar` 類別添加到需要隱藏捲軸的元素上。例如：\n\n```html\n<div class=\"w-full overflow-y-scroll no-scrollbar\">\n  <!-- 你的內容 -->\n</div>\n```\n\n## 注意：\n- `overflow-y-scroll`：仍然允許內容滾動，但隱藏捲軸。\n- 如果需要針對水平捲軸，也可以使用 `overflow-x-scroll`。\n\n---\n\n## 總結\n\n透過以上兩個步驟，我們成功在 **TailwindCSS** 中隱藏捲軸，讓介面看起來更整潔。同時保持了捲動的功能，這對於需要隱藏視覺元素但保留互動性的設計非常有幫助。\n\n希望這篇教學能幫助到你！🎉\n","tags":["tailwindcss"]},{"title":"Leetcode 解題紀錄 SQL 50 - 550. Game Play Analysis IV","url":"/2024/12/20/Leetcode-解題紀錄-SQL-50-550-Game-Play-Analysis-IV/","content":"\n# Leetcode 解題紀錄 SQL 50 - 550. Game Play Analysis IV\n\n\n![image](https://hackmd.io/_uploads/B1DiYYzSyg.png)\n\n### 題目背景\n\n這題的目標是計算 **玩家首次登入後第二天是否再次登入的比例**，並將結果四捨五入至小數點後兩位。\n\n---\n\n### 資料表結構\n\n```sql\nTable: Activity\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n```\n\n#### 解釋：\n- **Primary Key**: `(player_id, event_date)`，代表每位玩家在某天的唯一活動記錄。\n- **數據描述**：`player_id` 是玩家的 ID，`event_date` 是登入日期，`games_played` 是當天玩的遊戲數量。\n\n---\n\n### 題目要求\n\n計算 **首次登入後第二天有再次登入的玩家比例**。若符合條件的玩家數量為 1，總玩家數為 3，則結果為：`1 / 3 = 0.33`。\n\n---\n\n### 解法：CTE 實現\n\n```sql\nWITH FirstLogin AS (\n    SELECT \n        player_id,\n        MIN(event_date) AS first_login_date\n    FROM \n        Activity\n    GROUP BY \n        player_id\n),\nNextDayLogin AS (\n    SELECT \n        f.player_id\n    FROM \n        FirstLogin f\n    JOIN \n        Activity a\n    ON \n        f.player_id = a.player_id\n        AND a.event_date = DATE_ADD(f.first_login_date, INTERVAL 1 DAY)\n)\nSELECT \n    ROUND(COUNT(DISTINCT n.player_id) / COUNT(DISTINCT f.player_id), 2) AS fraction\nFROM \n    FirstLogin f\nLEFT JOIN \n    NextDayLogin n\nON \n    f.player_id = n.player_id;\n```\n\n---\n\n### 解題步驟解析\n\n#### 1. 獲取首次登入日期 (`FirstLogin`)\n利用 `MIN(event_date)` 找出每個玩家的首次登入日期：\n\n```sql\nWITH FirstLogin AS (\n    SELECT \n        player_id,\n        MIN(event_date) AS first_login_date\n    FROM \n        Activity\n    GROUP BY \n        player_id\n)\n```\n\n#### 2. 確認首次登入後第二天是否有登入 (`NextDayLogin`)\n將首次登入日期與原始資料表 `Activity` 做連結，篩選出在 `first_login_date + 1` 有再次登入的玩家：\n\n```sql\nWITH NextDayLogin AS (\n    SELECT \n        f.player_id\n    FROM \n        FirstLogin f\n    JOIN \n        Activity a\n    ON \n        f.player_id = a.player_id\n        AND a.event_date = DATE_ADD(f.first_login_date, INTERVAL 1 DAY)\n)\n```\n\n#### 3. 計算比例並四捨五入\n計算符合條件的玩家數量與總玩家數比例，並用 `ROUND` 將結果四捨五入至小數點後兩位：\n\n```sql\nSELECT \n    ROUND(COUNT(DISTINCT n.player_id) / COUNT(DISTINCT f.player_id), 2) AS fraction\nFROM \n    FirstLogin f\nLEFT JOIN \n    NextDayLogin n\nON \n    f.player_id = n.player_id;\n```\n\n---\n\n### 範例數據與輸出\n\n#### 輸入數據：\n\n| player_id | device_id | event_date  | games_played |\n|-----------|-----------|-------------|--------------|\n| 1         | 2         | 2016-03-01  | 5            |\n| 1         | 2         | 2016-03-02  | 6            |\n| 2         | 3         | 2017-06-25  | 1            |\n| 3         | 1         | 2016-03-02  | 0            |\n| 3         | 4         | 2018-07-03  | 5            |\n\n#### 輸出結果：\n\n| fraction |\n|----------|\n| 0.33     |\n\n---\n\n### 小結\n\n這題的核心在於：\n1. **找出每個玩家的首次登入日期**。\n2. **檢查首次登入的第二天是否有登入記錄**。\n3. **計算符合條件玩家數與總玩家數的比例，並格式化結果**。\n\n希望這篇文章能幫助你解題，並對 SQL 的聚合函數與日期操作有更深入的理解！\n\n","tags":["Leetcode"]},{"title":"Auth.js 功能介紹與安裝流程","url":"/2024/12/12/Auth-js-功能介紹與安裝流程/","content":"\n\n日常工作上有遇到一個需求: 開發登入驗證功能，這邊在討論的時候發現到需求是要可以SSO登入多個平台，加上目前公司主要前端使用的是Next.js ，所以我在網路上找到了 Auth.js 這個工具。\n\n![image](https://hackmd.io/_uploads/H1F7KnPVke.png)\n>https://authjs.dev/\n\n接下來我們點擊 Getting Started 開始進入Auth.js 的Introduction 介紹頁面\n\n# 什麼是 Auth.js？\n\nAuth.js 是一個與執行環境無關的函式庫(runtime agnostic library)，基於標準的 Web API 開發，與多種現代 JavaScript 框架深度整合。\n\n提供的身份驗證體驗具有以下特點：\n\n1. 簡單開始：對於初學者來說，設置和使用非常直觀。\n2. 易於擴展：可根據需求自定義和擴充功能。\n3. 隱私與安全：高度注重用戶數據的隱私和安全性。\n\n![image](https://hackmd.io/_uploads/HkS4Y2D4Jl.png)\n>https://authjs.dev/getting-started\n\n目前可以看到 Auth.js 支援多個前端框架像是Next.js、Qwik、SvelteKit、Express，我目前主要是以Next.js 的功能為主，目標是開發一個SSO的認證功能。\n\n## Auth.js 支援的身份驗證方式\n\nAuth.js 支援四種身份驗證方法，滿足不同的應用場景：\n\n1. OAuth：方便用戶快速登錄。\n2. Magic Links：用戶僅需使用電子郵件即可登錄，無需記憶密碼。\n3. Credentials：適合傳統系統和定制化驗證邏輯。\n4. WebAuthn：提供最現代化的無密碼驗證，增強安全性與便利性。\n\n![image](https://hackmd.io/_uploads/BJFBYnPE1g.png)\n>https://authjs.dev/getting-started\n\n## Auth.js 支援的資料庫\n\n* Auth.js 支援與資料庫整合，但這是可選的功能。\n* 通過 Database adapters，您可以輕鬆對接資料庫來存儲用戶數據。\n* 這對於需要完整用戶管理或數據存儲功能的應用尤為重要。\n\n![image](https://hackmd.io/_uploads/SkOUt2wEyx.png)\n>https://authjs.dev/getting-started \n\n這邊可以看到支援的資料庫有這些\n\n如果您需要用戶數據的長期存儲，建議選擇一個支援的資料庫並利用適配器進行整合。例如，使用 MongoDB 或 PostgreSQL 存儲用戶賬號和登入歷史資訊。\n\n像是我這次想要用的是 MongoDB\n\n# 如何升版? Migrate to NextAuth.js v5\n接下來我們會看到Upgrade Guide (NextAuth.js v5)\n![image](https://hackmd.io/_uploads/rJA_K3D41e.png)\n>https://authjs.dev/getting-started/migrating-to-v5\n\n從這邊的說明可以看到Auth.js 之前叫做NextAuth.js，NextAuth.js 版本 5 是 next-auth 套件的一次重大重寫\n\n![image](https://hackmd.io/_uploads/ByRFK3vVkx.png)\n>https://next-auth.js.org/\n\n這邊的NextAuth.js也是我第一次在網路上搜尋 Next.js 的登入驗證套件找到的文件。\n\n在最上方可以看到 NextAuth.js is becoming Auth.js! 🎉\n\n所以如果你專案之前是第一次使用Auth.js那可以跳過這一段的說明。\n\n## 新功能（New Features）\n   - App Router-first\n     支援 App Router 架構，但仍然兼容傳統的 `pages/` 目錄。\n   - OAuth 支援預覽部署 \n     在預覽環境中也可以支援 OAuth 身份驗證（[詳細說明](https://authjs.dev/getting-started/deployment#securing-a-preview-deployment)）。\n   - 簡化設定\n     使用共享配置與推斷環境變數[env variables](https://authjs.dev/guides/environment-variables#environment-variable-inference)，減少手動配置工作。\n   - 新功能 `account()` 回調\n     在提供者上新增 `account()` 回調功能，可用於自定義帳號邏輯（[`account()` docs](https://authjs.dev/reference/core/providers#account)）。\n     \n   - Edge-compatible\n     提供與 Edge 環境相容的身份驗證支持。\n   - 統一的 `auth()` 方法\n     - 一個統一的方法來處理身份驗證，不再需要單獨使用 `getServerSession`、`getSession`、`withAuth`、`getToken` 或 `useSession`。\n     - 簡化開發者的身份驗證流程（[詳細說明](https://authjs.dev/getting-started/migrating-to-v5#authenticating-server-side)）。\n\n---\n\n## 重大變更（Breaking Changes）\n - **使用更嚴格的 OAuth/OIDC 規範**\n   - Auth.js 現在基於 `@auth/core`，並且符合更嚴格的 OAuth/OIDC 規範。\n   - 一些現有的 OAuth 提供者可能會因此出現不兼容的問題，可參考 [[GitHub 問題追蹤]](https://github.com/nextauthjs/next-auth/issues?q=is%3Aopen+is%3Aissue+label%3Aproviders)。\n   \n - **OAuth 1.0 停止支持**\n   - 不再支持 OAuth 1.0，建議開發者轉向 OAuth 2.0 或更新的身份驗證協議。\n\n - **最低 Next.js 版本要求**\n   - 現在 Auth.js 需要 **Next.js 14.0 或更高版本**，請檢查並升級應用程序。\n\n - **匯入路徑的變更**\n   - `next-auth/next` 和 `next-auth/middleware` 的匯入方式已更改：\n     - 舊版的匯入方式已被替換，詳細請參考 [Authenticating server-side](https://authjs.dev/getting-started/migrating-to-v5#authenticating-server-side) 文檔。\n\n - **`idToken: false` 行為調整**\n   - 當 `idToken: false` 時，不再完全停用 ID token。\n   - 現在會額外訪問 `userinfo_endpoint` 來獲取用戶的最終數據。\n   - 舊版則完全跳過 ID token 的檢查。\n\n## Migration 版本遷移步驟\n\n如果說是使用舊版本的`NextAuth.js`的話，這邊詳細的版本遷移步驟可以參考官方文件說明一步一步操作。\n![image](https://hackmd.io/_uploads/rJJstnwNke.png)\n>https://authjs.dev/getting-started/migrating-to-v5\n\n## Cookie 命名變更\n\n過去版本中，與 Cookie 相關的內容是以 next-auth 為前綴命名的。\n在新版 Auth.js 中，這些 Cookie 的前綴名稱已經改為 authjs。\n\n# Installation - 安裝 Auth.js 操作步驟\n\n\n要在 Next.js 專案中安裝 Auth.js，可以按照以下步驟進行設定：  \n\n---\n\n## **步驟 1：建立或進入 Next.js 專案**\n1. 如果尚未建立專案，請運行以下指令來創建一個新的 Next.js 專案，假設專案名稱是`next-auth-app`：\n   ```bash\n   npx create-next-app@latest next-auth-app\n   cd next-auth-app\n   ```\n2. 如果已經有一個 Next.js 專案，直接進入該專案目錄：\n   ```bash\n   cd next-auth-app\n   ```\n\n![image](https://hackmd.io/_uploads/Hk4nt2PV1e.png)\n> 實際運行畫面\n\n成功安裝後會顯示Success! Created next-auth-app at `你設定的路徑`\n\n![image](https://hackmd.io/_uploads/rJXaY3D4yl.png)\n\n---\n\n## **步驟 2：安裝 Auth.js**\n運行以下指令安裝 Auth.js 的 beta 版本：\n```bash\nnpm install next-auth@beta\n```\n這個版本的 Auth.js 適用於最新功能和更新。\n\n## **步驟 3：生成 `AUTH_SECRET`**\n\n在這一步中，您需要設置一個 `AUTH_SECRET` 環境變數，它用於加密 token 和電子郵件驗證的哈希。這是 Auth.js 中必須配置的環境變數。\n\n您可以使用官方的 Auth.js CLI 工具來生成這個隨機的 `AUTH_SECRET` 字串。\n\n1. 在終端機中運行以下指令來生成 `AUTH_SECRET`：\n   ```bash\n   npx auth secret\n   ```\n\n2. 這會自動生成一個隨機的密鑰並將它添加到您的 `.env.local` 檔案中（對於 Next.js 專案）。\n\n![image](https://hackmd.io/_uploads/BJX0K2PN1x.png)\n>實際執行畫面\n\n![image](https://hackmd.io/_uploads/By3RK2vNkg.png)\n>可以看到多出一個 .env.local 檔案\n\n\n---\n\n## **步驟 4：設置 Configure**\n這一段說明了如何配置 Auth.js 並設置身份驗證邏輯，以下是逐步解釋：\n\n### **1. 創建 `auth.ts` 配置文件**\n\n首先，您需要在專案的根目錄中創建一個 `auth.ts` 檔案，內容如下:\n\n```ts\nimport NextAuth from \"next-auth\"\n \nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  providers: [],\n})\n```\n這個檔案用來配置 Auth.js，並在其中使用 `NextAuth` 來配置設定。您可以在這個文件中設置身份驗證提供者、調整認證邏輯等。\n\n- `providers` 是將用來認證用戶的身份驗證提供者（如 Google、GitHub 等）列表，目前是空的，需要在後續步驟中填寫。\n\n### **2. 新增 Route Handler**\n\n在 `app/api/auth/[...nextauth]/route.ts` 中設定一個 Route Handler，內容如下:\n\n\n```ts\nimport { handlers } from \"@/auth\" // 引用我們剛才創建的 auth.ts\nexport const { GET, POST } = handlers\n```\n\n:::warning\n這個路由必須是 App Router 的路由處理程序，不過你可以選擇其他頁面結構（如使用 `page/` 目錄）來維持應用程式的其餘結構。\n:::\n\n### **3. 添加 Middleware 設定（可選）**\n\n創建 `middleware.ts` 文件並加入以下程式碼：\n\n```ts\nexport { auth as middleware } from \"@/auth\"\n```\n\n為了確保用戶會話的持續有效，您可以在應用中添加一個 Middleware。這個 Middleware 每次被調用時，都會更新會話的過期時間，保持會話活躍。\n\n這會把 `auth.ts` 中的 `auth` 方法當作 middleware 引入，確保會話不會過期。\n\n\n## **步驟 5：設置身份驗證方法**\n\n到這一步，您的基礎設置已經完成，接下來可以開始配置具體的身份驗證方法（如 Google、GitHub 等）並填充 `providers` 陣列。\n\n\n完成這些步驟後，Auth.js 已成功整合進入你的 Next.js 專案！ 🎉\n\n\n# 總結\n\nAuth.js 是一個強大且靈活的身份驗證函式庫，它與多種現代 JavaScript 框架深度整合，提供簡單易用的設置和高度的擴展性，並且非常注重用戶數據的隱私和安全性。\n\n在本文中，我們詳細介紹了 Auth.js 的功能特點、支援的身份驗證方式和資料庫整合，並提供了從安裝到配置的完整步驟。無論是初學者還是有經驗的開發者，都能輕鬆上手並快速實現身份驗證功能。\n\n如果你正在尋找一個可靠且功能豐富的身份驗證解決方案，Auth.js 絕對是值得考慮的選擇。希望這篇教學對你有所幫助，讓你的 Next.js 專案更安全、更高效。如果在設定過程中遇到問題，歡迎留言討論 😊","tags":["Next.js","Auth.js"]},{"title":"TFT聯盟戰棋S13追尋奧術賽季陣容分享 - 黑玫瑰征服者","url":"/2024/12/03/聯盟戰棋S13追尋奧術賽季陣容分享-黑玫瑰征服者/","content":"\n\n大家好我是Nalson，這次跟大家分享聯盟戰棋第13賽季的追尋奧術主題陣容 - 黑玫瑰征服者。\n\n# 英雄\n陣容組成有弗拉迪米爾![image](https://hackmd.io/_uploads/ByKeWCtX1l.png)、銳兒![image](https://hackmd.io/_uploads/H1WGZRKQJe.png)、斯溫![image](https://hackmd.io/_uploads/S1VQWRKQkx.png)、卡莎碧雅![image](https://hackmd.io/_uploads/SJVEbAtmyg.png)、努努和威朗普![image](https://hackmd.io/_uploads/H1lIW0FQ1g.png)、伊莉絲![image](https://hackmd.io/_uploads/ry2L-CK71l.png)、安比薩![image](https://hackmd.io/_uploads/By4hxCYQyg.png)、魔鬥凱薩![image](https://hackmd.io/_uploads/B1dDx0YXyg.png)、勒布朗![image](https://hackmd.io/_uploads/Hkl0eCt7kg.png)。\n\n# 羈絆\n羈絆組合有4黑玫瑰、4征服者、2巫師、2先知、2蠻勇打手、2變形大師、2霸主、1使者\n\n這個陣容坦度高，後期有魔豆跟勒布朗可以開高陣容上限，是升8等D排營運陣容\n\n\n# 完整陣容圖與分享碼\n![TFT_OPGG_Builder (2)](https://hackmd.io/_uploads/H1PPnat7yl.png)\n\n陣容分享碼 : 011d382930022209102600TFTSet13\n\n目前這個賽季在手機板可以直接貼上陣容，非常方便\n\n# 陣容思路 \n完這陣容前棋利用4征服過度並且盡早連勝疊加層數換取裝備，\n後期升上8等D出安比薩跟魔豆凱薩這兩張主C鬥士，並且本身這兩隻角色技能可以達成combo效果:\n\n魔豆開大放出範圍技 - 金屬亡靈之握 ![image](https://hackmd.io/_uploads/SJVLeRtm1l.png) -> 安比薩使出無情獵手![image](https://hackmd.io/_uploads/SJ-5xAKXkl.png)單體爆發收割戰場 -> 觸發使者羈絆:擊殺敵軍，隊友增加物防/魔防\n\n\n# 裝備推薦\n物攻主C: 安比薩拿物攻裝備![image](https://hackmd.io/_uploads/Hy_oWAtmkx.png) ![image](https://hackmd.io/_uploads/H1m3-CtX1e.png)![image](https://hackmd.io/_uploads/SJR2WRt7kx.png)\n\n魔攻主C: 魔豆凱薩拿摩攻裝備 ![image](https://hackmd.io/_uploads/B1eWz0K71x.png)![image](https://hackmd.io/_uploads/H19bfAKXyg.png)![image](https://hackmd.io/_uploads/rkTGG0FQJg.png)![image](https://hackmd.io/_uploads/rJJUzAY7ke.png)\n\n主坦裝備可以選擇養斯溫或是伊莉絲  ![image](https://hackmd.io/_uploads/rJNEz0Ymyx.png)![image](https://hackmd.io/_uploads/HJcNMAtQJl.png)![image](https://hackmd.io/_uploads/rJJUzAY7ke.png)![image](https://hackmd.io/_uploads/ryi8GAtmJg.png)\n\n\n# 前期優勢連勝條件： \n\n一、物攻裝開局 \n二、胡征服者體系牌 \n\n\n# 陣容過渡：\n前期可以利用 【達瑞文】【達瑞斯】先過度物攻裝備組成 4征服者 2守望 2巫師 連勝疊加層數\n\n![TFT_OPGG_Builder (3)](https://hackmd.io/_uploads/rkh27CF7kl.png)\n\n\n# 實戰影片\n聯盟戰棋 - 征服者黑玫瑰\nhttps://youtu.be/UX9j6BnnFsw\n","tags":["聯盟戰棋","TFT"]},{"title":"PM2：提升 Node.js 應用程式管理與性能的利器","url":"/2024/11/29/PM2：提升-Node-js-應用程式管理與性能的利器/","content":"\n\n![PM2：提升 Node.js 應用程式管理與性能的利器](https://hackmd.io/_uploads/HJH6Jzwmke.png)\n\n在開發和部署 Node.js 應用程式時，如何高效地管理應用程式的啟動、監控、記錄以及處理高可用性等問題，一直是開發者面對的重要挑戰。\n\nPM2 是一個功能強大且廣泛使用的 Node.js 應用程式管理工具，它能夠讓我們輕鬆解決這些問題，並提高應用程式的穩定性和性能。\n\n![image](https://hackmd.io/_uploads/HkmrVWP71g.png)\n>https://pm2.keymetrics.io/\n\n# 什麼是 PM2？\n\nPM2 是一個進程管理器，專門設計用來管理 Node.js 應用程式。它支持多進程運行、應用程式監控、記錄管理，並且提供了自動重啟、性能優化等功能。PM2 能夠幫助開發者更高效地運行和維護 Node.js 應用，特別是在生產環境中。\n\n以下是加入你部落格文章的內容，已經整理過，並以條列方式呈現：\n\n---\n\n# PM2 解決的問題\n\nPM2 是一個 Node.js 進程管理器，能夠解決許多在開發與部署過程中常見的問題，特別是針對生產環境的需求。以下是 PM2 解決的一些問題與功能：\n\n1. **自動重啟服務**  \n   當 Node.js 服務崩潰時，PM2 能自動重啟服務，確保應用程序的高可用性。\n\n2. **服務重啟後自動重啟 PM2 進程**  \n   當伺服器重啟時，PM2 會自動幫助我們重新啟動 Node.js 服務，確保應用在伺服器啟動後仍持續運行。\n\n3. **利用多核心 CPU 的多進程支持**  \n   PM2 可以利用 CPU 的多個核心來啟動多個進程，達到負載平衡的效果，提升應用的效能。\n\n4. **Graceful Reload (優雅重啟)**  \n   使用 PM2 的 Graceful Reload 功能，可以達成類似於 Rolling Upgrade 的效果，實現零停機時間的升級。\n\n5. **多進程、多服務提高處理請求的速度**  \n   PM2 支持多進程運行，有助於提升處理大量請求的速度，提升系統的可擴展性。\n\n6. **自動重啟排程設定**  \n   PM2 允許設定定時任務，根據預設的時間自動重啟服務，保證服務穩定運行。\n\n7. **提供豐富的監控資訊**  \n   PM2 提供了各種監控資訊，包括已重啟次數、CPU 使用量、記憶體使用量、進程 ID 等，幫助管理者輕鬆掌握應用運行狀態。\n\n8. **條件式重啟**  \n   PM2 可以根據自定義條件自動重啟服務，如基於「運行時間」或「記憶體使用量」等條件進行重啟，確保服務持續穩定。\n\n9. **日志管理**  \n   PM2 提供強大的日誌管理功能，支持將日志按預設週期切割並保存，超過設定的數量時自動刪除舊的日志文件，幫助清理磁碟空間。\n\n10. **簡單的部署方式**  \n    PM2 支持簡單的一次性部署，可以將應用同時部署到多台伺服器上，讓大規模的部署變得更加容易。\n\n11. **與 CI/CD 工具結合**  \n    PM2 可以與 CI/CD 工具無縫整合，支持自動化的持續集成與持續部署，提升開發與運維效率。\n\n# PM2 的安裝\n\n要開始使用 PM2，我們需要先進行安裝。使用 npm 可以輕鬆安裝 PM2：\n\n```bash\nnpm install pm2 -g\n```\n\n安裝完成後，我們可以在命令行中使用 `pm2` 指令來管理應用程式。\n\n# 使用 PM2 管理應用程式\n\n## 啟動應用程式\n\n假設我們有一個名為 `app.js` 的 Node.js 應用程式，我們可以使用 PM2 來啟動它：\n\n```bash\npm2 start app.js\n```\n\n這會啟動 `app.js` 並將其置於後台運行。\n\n## 查看運行中的應用程式\n\n可以使用以下命令查看當前運行的所有應用程式：\n\n```bash\npm2 list\n```\n\n這將顯示正在運行的應用程式及其狀態、CPU 使用率等資訊。\n\n![image](https://hackmd.io/_uploads/HyNL8Wv7Jl.png)\n\n## 停止與重啟應用程式\n\n若需要停止或重啟某個應用程式，可以使用以下命令：\n\n```bash\npm2 stop app_name\npm2 restart app_name\n```\n\n這樣可以靈活地管理應用程式，並且在應用程式崩潰或需要重啟時迅速恢復。\n\n## 查看應用程式日誌\n\nPM2 也提供了日誌管理功能，能夠幫助開發者查看應用程式的輸出和錯誤日誌。使用以下指令即可查看日誌：\n\n```bash\npm2 logs\n```\n\n# 多進程管理\n\nNode.js 是單執行緒的，這意味著它在處理繁重的任務時可能會遇到性能瓶頸。PM2 提供了多進程管理功能，可以幫助我們充分利用多核處理器，提升應用程式的並行處理能力。\n\n使用以下命令啟動應用程式並利用最大進程數：\n\n```bash\npm2 start app.js -i max\n```\n\n`-i max` 參數告訴 PM2 啟動最大數量的進程，這樣就能夠更好地分配工作負載，提高性能。\n\n## 永久運行應用程式\n\n在生產環境中，我們通常希望應用程式在系統重啟後仍然能自動啟動。PM2 提供了自動啟動功能，可以讓我們在系統重啟後重新啟動應用程式。\n\n首先，執行以下指令以生成啟動腳本：\n\n```bash\npm2 startup\n```\n\n根據輸出的提示執行額外的設定指令，例如：\n\n```bash\nsudo env PATH=$PATH:/usr/bin pm2 startup systemd -u <username> --hp /home/<username>\n```\n\n接著，保存當前的應用程式配置：\n\n```bash\npm2 save\n```\n\n這樣一來，PM2 就會在系統啟動時自動啟動並運行應用程式。\n\n# 性能監控\n\nPM2 還提供了監控工具，幫助開發者追蹤應用程式的 CPU 和記憶體使用情況。可以使用以下命令啟動監控模式：\n\n```bash\npm2 monit\n```\n\n這樣會彈出一個即時監控面板，讓你清楚看到每個進程的狀況。\n\n![image](https://hackmd.io/_uploads/Syu4_-DmJx.png)\n\n\n### 配置文件\n\nPM2 支援使用 JSON 配置文件來設定應用程式的運行參數。配置文件可以包含多個應用程式的設置，並且能夠指定不同的環境變數和啟動參數。\n\n範例配置文件（`ecosystem.config.js`）：\n\n```json\n{\n  \"apps\": [\n    {\n      \"name\": \"app\",\n      \"script\": \"app.js\",\n      \"env\": {\n        \"NODE_ENV\": \"production\"\n      },\n      \"env_development\": {\n        \"NODE_ENV\": \"development\"\n      }\n    }\n  ]\n}\n```\n\n這樣，我們可以使用 `pm2 start ecosystem.config.js` 來啟動所有配置的應用程式。\n\n這邊看起來給我感覺有點像 docker-compose \n\n### PM2 的進階應用\n\n- **集群模式**：PM2 支援集群模式，能夠讓你的應用程式在多個處理器核心上運行，以便提高性能和可擴展性。\n- **日誌輪替 (Log Rotate)**：PM2 提供了日誌輪替功能，防止日誌檔案過大，導致磁碟空間不足。\n\n### 常見問題與故障排除\n\n1. **應用程式崩潰**：使用 `pm2 logs` 查看日誌，確定應用程式崩潰的原因。\n2. **應用程式無法啟動**：檢查配置文件是否正確，並確保所需的環境變數已經設置。\n\n### 結語\n\nPM2 是一個強大的工具，能夠幫助我們有效地管理 Node.js 應用程式。在生產環境中，PM2 不僅能提高應用程式的可用性，還能夠提供監控、日誌管理等多種功能，讓開發者能夠專注於應用程式的開發而不必擔心運行和維護的問題。\n\n如果你還沒有使用 PM2，現在就可以開始體驗這個強大的工具，讓你的 Node.js 應用程式更穩定、更高效。\n\n希望這篇教學對你有所幫助！如果在設定過程中遇到問題，歡迎留言討論 😊\n","tags":["node.js"]},{"title":"使用 SSH Key 與 GitHub 連線教學","url":"/2024/11/15/使用-SSH-Key-與-GitHub-連線教學/","content":"\n\n![SSH Key 與 GitHub 連線教學](https://hackmd.io/_uploads/rJ1AkKNMkl.jpg)\n\n## 前言\n\n對於每位軟體工程師來說，**Git** 是日常工作中不可或缺的工具之一。無論是軟體開發中的團隊協作，還是程式碼的維護與更新，Git 都能有效地幫助我們管理版本並保持團隊同步。\n\n然而，經常使用 Git 的你是否遇過這樣的情況：  \n每次執行 `git push` 或 `git pull` 時，總是需要輸入帳號密碼，既耗時又不方便。其實，這些問題都可以透過 **SSH Key** 來解決。不僅能讓操作更高效，也能提升安全性。\n\n除此之外，當我們在團隊合作中，需要快速抓取程式碼進行開發時，使用 SSH Key 更是非常實用且推薦的做法！  \n如下圖所示，設定好 SSH 後，團隊開發的效率將更進一步：  \n![團隊合作使用 SSH key](https://hackmd.io/_uploads/r124dtVf1x.png)\n\n接下來，就讓我們一起學習如何設定 SSH Key 並與 **GitHub** 建立安全連線吧！\n\n---\n\n## SSH Key 是什麼？\n\n**SSH Key** 是一組用於身份驗證的加密金鑰對，常用於安全地連接伺服器、版本控制系統（如 GitHub）或其他需要安全性驗證的服務。它是實現 **SSH（Secure Shell）協議**的重要部分，能夠在不使用密碼的情況下實現高安全性的加密連線。\n\n---\n\n### SSH Key 的結構\nSSH Key 包含兩部分：\n1. **公鑰（Public Key）**  \n   - 這部分可公開分享，例如上傳到 GitHub 或伺服器。\n   - 公鑰會用於加密資料。\n\n2. **私鑰（Private Key）**  \n   - 這部分必須妥善保管，不能外洩。\n   - 私鑰會用於解密資料並證明你的身份。\n\n當伺服器收到你的公鑰並匹配到你的私鑰時，就可以確定是你本人在進行連線。\n\n---\n\n### 為什麼要使用 SSH Key？\n\n1. **更安全**  \n   相比使用帳號密碼，SSH Key 基於加密技術，比密碼更難破解。\n\n2. **免密碼登入**  \n   設定好 SSH Key 後，連線時不再需要手動輸入密碼，節省時間且方便。\n\n3. **防範中間人攻擊**  \n   SSH Key 的加密機制可以有效防止中間人攔截與破解。\n\n---\n\n### 使用 SSH Key 的場景\n1. **遠端伺服器連線**  \n   例如使用 SSH 登入 Linux 伺服器進行管理。\n\n2. **版本控制系統（如 GitHub/GitLab）**  \n   用於身份驗證，避免每次 `git push` 或 `git pull` 時都需要輸入帳號密碼。\n\n3. **自動化部署**  \n   在 CI/CD 系統中，使用 SSH Key 無需手動干預即可進行自動部署。\n\n---\n\n## 操作流程\n\n### 1. 產生 SSH Key\n\n我們首先需要在本地端生成 SSH Key，這是一組用於身份驗證的加密金鑰對（包含私鑰與公鑰）。\n\n執行以下指令來產生金鑰：  \n```bash\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```\n\n以下是指令的參數解釋：\n- **`-t rsa`**：指定金鑰類型為 RSA。\n- **`-b 4096`**：設定金鑰長度為 4096 位元，以提高安全性。\n- **`-C \"your_email@example.com\"`**：附加你的電子郵件地址作為標識，方便管理。\n\n執行後，系統會要求指定存放金鑰的路徑與名稱（預設為 `~/.ssh/id_rsa`），以及是否設定密碼（可自行選擇）。\n\n---\n\n### 2. 將公鑰上傳至 GitHub\n\n生成完金鑰後，下一步是將公鑰上傳至 GitHub：\n\n1. 使用以下指令查看生成的公鑰內容：  \n   ```bash\n   cat ~/.ssh/id_rsa.pub\n   ```\n   結果會是一串以 **`ssh-rsa`** 開頭的長字符串。\n\n2. 登入你的 GitHub 帳戶，前往 **Settings** > **SSH and GPG keys**，點擊 **New SSH Key** 按鈕。\n\n3. 在 **Key** 欄位中，將剛剛複製的公鑰內容貼上，並為該金鑰設定一個描述性名稱（例如 \"My Laptop SSH Key\"）。  \n   完成後點擊 **Add SSH Key** 儲存。  \n   參考下圖操作：  \n   ![GitHub SSH Key 設定畫面](https://hackmd.io/_uploads/SyWdLHEzkl.png)\n\n---\n\n## 結語\n\n透過 SSH Key，不僅可以省去每次輸入帳號密碼的麻煩，也能讓連線更加安全且高效。無論是個人專案開發還是團隊合作，這都是一個實用且推薦的最佳實踐。\n\n希望這篇教學對你有所幫助！如果在設定過程中遇到問題，歡迎留言討論 😊\n\n--- \n","tags":["SSH","Git"]},{"title":"使用 Docker-Compose 部署 Next.js 應用程式","url":"/2024/11/15/使用-Docker-Compose-部署-Next-js-應用程式/","content":"\n\n![使用 Docker-Compose 部署 Next.js 應用程式](https://hackmd.io/_uploads/HkLJfPNfyl.jpg)\n\n將 Next.js 應用程式容器化是一種高效的開發方式，因為它提供了更具隔離性和可重現的環境。\n在部屬的時候可以省下一些重複的工作。\n在本篇文章中，我將介紹如何使用 Docker 和 Docker-Compose 快速建立與執行 Next.js 應用程式。\n讓我們一步步實作，從建立專案到成功啟動。\n\n---\n\n## 1. 建立 Next.js 專案\n\n首先，我們需要建立一個 Next.js 應用程式。執行以下指令：\n\n```bash\nnpx create-next-app docker-next\n```\n\n執行完畢後，將會建立一個名為 `docker-next` 的資料夾。\n\n\n![image](https://hackmd.io/_uploads/r1r826-fJx.png)\n\n\n![image](https://hackmd.io/_uploads/rJF5nTWMJx.png)\n\n進入該資料夾：\n\n```bash\ncd docker-next\n```\n\n---\n\n\n\n## 2. 建立 Dockerfile\n\n在 `docker-next` 資料夾中，新增一個名為 `Dockerfile` 的檔案，並填入以下內容：\n\n```dockerfile\nFROM node:20\n\nWORKDIR /app\n\nCOPY package.json ./\n\nRUN npm install\n\nCOPY . .\n\nCMD [\"npm\", \"run\", \"dev\"]\n```\n\n> **注意：** 如果你使用不同版本的 Node.js，請將 `FROM node:20` 替換為對應版本。\n\n---\n\n\n## 3. 建立 Docker Image 並執行容器\n\n### 建立 Docker Image\n執行以下指令建立 Image：\n\n```bash\ndocker build -t docker-next .\n```\n\n### 執行容器\n使用以下指令運行容器：\n\n```bash\ndocker run docker-next -p 3000:3000 -v /app/node_modules -v .:/app\n```\n\n- `-p 3000:3000`：將容器內的 3000 埠對應到主機的 3000 埠。\n- `-v .:/app`：將當前目錄映射到容器內的 `/app` 目錄。\n\n完成後，可透過瀏覽器訪問 [http://localhost:3000](http://localhost:3000) 查看效果。\n\n---\n\n\n## 4. 設定 Docker-Compose\n\n為了簡化操作，可以使用 Docker-Compose 管理服務。建立一個 `docker-compose.yml` 檔案，內容如下：\n\n```yaml\nservices:\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: docker-next\n    ports:\n      - '3000:3000'\n    volumes:\n      - .:/app\n      - /app/node_modules\n```\n\n---\n\n\n## 5. 使用 Docker-Compose 啟動專案\n\n執行以下指令啟動專案：\n\n```bash\ndocker-compose up\n```\n\n執行後，終端機會顯示成功啟用的訊息。此時，打開瀏覽器並輸入 [http://localhost:3000](http://localhost:3000)，應該可以看到預設的 Next.js 頁面。\n\n![image](https://hackmd.io/_uploads/H1DwomNG1g.png)\n\n![image](https://hackmd.io/_uploads/BJR-oQNzJe.png)\n>成功啟用的畫面\n\n---\n\n## 6. 使用 Docker Desktop 驗證容器狀態（可選）\n\n如果你使用 Docker Desktop，可以在應用程式中檢查容器的執行狀態，確認服務是否正常啟動。\n\n![image](https://hackmd.io/_uploads/r1V2sX4GJg.png)\n\n---\n\n## 總結\n\n今天整理的文章步驟如下\n\n- **建立專案：** `npx create-next-app`\n- **撰寫 Dockerfile：** 定義運行環境與應用程式啟動方式。\n- **建立與執行容器：** 使用 Docker 指令啟動 Next.js。\n- **簡化部署：** 配置 Docker-Compose，自動化服務管理。\n\n這篇文章適合初學者，也可以作為日後快速部署 Next.js 的參考。如果有任何問題或建議，歡迎在留言區與我交流！ 😊\n\n---","tags":["Next.js","Docker-Compose"]},{"title":"命名這檔事：snake_case、camelCase 與 kebab-case 的選擇之道","url":"/2024/11/07/命名這檔事：snake-case、camelCase-與-kebab-case-的選擇之道/","content":"\n![image](https://hackmd.io/_uploads/B1tb4yo-kl.png)\n>https://juniortoexpert.com/en/naming-convention/\n\n在程式開發中，清晰、一致的命名風格對於程式碼的可讀性與維護性至關重要。本文將介紹三種常見的命名規則：snake_case、camelCase 和 kebab-case，並說明它們的使用場合及特性。\n\n---\n\n#  命名規則簡介\n\n## snake_case\n定義：單詞之間以底線（`_`）分隔，所有字母均小寫。\n範例：\n  - `user_name`\n  - `sell_power_request`\n  - `start_date`\n常見應用：\n  - Python 和 Ruby 中的變數和函式名稱。\n  - 資料庫欄位名稱（如 SQL）。\n  - 用於增加可讀性，特別適合需要簡潔和規則分明的環境。\n\n## camelCase\n- 定義：第一個單詞小寫，後續每個單詞首字母大寫，單詞之間不使用任何分隔符，看起來像是駝峰一樣，可以進一步細分為 upper camel case，與lower camel case  差別在於開頭第一個字是否為大寫\n- 範例：\n  - `userName`\n  - `sellPowerRequest`\n  - `startDate`\n- 常見應用：\n  - JavaScript、Java、C# 等語言中的變數與函式命名。\n  - JSON 格式的屬性名稱。\n  - 強調簡潔並與其他命名規則有所區隔。\n\n## kebab-case\n- 定義：單詞之間以連字符（`-`）分隔，所有字母均小寫，有許多另外的別稱 spinal-case,Train-Case,Lisp-case\n- 範例：\n  - `user-name`\n  - `sell-power-request`\n  - `start-date`\n- 常見應用：\n  - URL 和 HTML 屬性命名（如 `data-attribute`）。\n  - 前端框架中的 CSS 類名（如 `my-component`）。\n  - 強調跨環境兼容性，特別是在 Web 開發中。\n\n---\n\n# 三種命名規則的區別\n\n| **規則**        | **分隔方式**         | **範例**            | **常見應用場景**                |\n|-----------------|--------------------|--------------------|-------------------------------|\n| **snake_case**  | 底線 `_`            | `user_name`         | Python、Ruby 變數與資料庫欄位名稱 |\n| **camelCase**   | 無分隔，後單詞首字母大寫 | `userName`          | JavaScript 函式與變數名稱      |\n| **kebab-case**  | 連字符 `-`          | `user-name`         | URL、CSS 類名                 |\n\n---\n\n# 什麼時候使用哪種規則？\n\n選擇命名規則時，需考慮語言的慣例及使用場景：\n\n## snake_case\n- 優點：清晰易讀，適合跨平台處理。\n- 缺點：在某些語言（如 JavaScript）中顯得笨重。\n- 使用場景：\n  - Python 變數、函式名稱。\n  - SQL 資料表欄位名稱。\n\n## camelCase\n- 優點：簡潔且符合 JavaScript、Java 等語言的習慣。\n- 缺點：單詞長時會降低可讀性。\n- 使用場景：\n  - 前端框架的變數、函式命名。\n  - JSON 屬性。\n\n## kebab-case\n- 優點：與 URL 和 HTML 屬性名稱自然契合。\n- 缺點：無法直接用於變數或函式名稱（不合法）。\n- 使用場景：\n  - CSS 類名和 ID 名稱。\n  - RESTful API 的 URL。\n\n---\n\n# 範例應用\n\n## snake_case 範例\n```python\n# Python 變數和函式命名\ndef calculate_total_price(price_per_item, quantity):\n    total_price = price_per_item * quantity\n    return total_price\n```\n\n## camelCase 範例\n```javascript\n// JavaScript 函式和變數命名\nfunction calculateTotalPrice(pricePerItem, quantity) {\n    let totalPrice = pricePerItem * quantity;\n    return totalPrice;\n}\n```\n\n## kebab-case 範例\n```html\n<!-- HTML 屬性 -->\n<div class=\"user-profile\" data-user-id=\"123\"></div>\n\n/* CSS 類名 */\n.user-profile {\n    background-color: #f5f5f5;\n}\n```\n\n---\n\n# 總結\n\n1. 選擇語言約定：遵循語言或框架的命名慣例。例如：\n   - Python 使用 **snake_case**。\n   - JavaScript 使用 **camelCase**。\n   - CSS 和 URL 使用 **kebab-case**。\n\n2. 團隊統一風格*：在團隊協作中，統一命名規範能提升程式碼的一致性與可讀性。\n\n3. 語意清晰優先：無論使用哪種規則，確保命名能反映實際功能或用途。\n\n最後，良好的命名是可讀程式碼的基石，選擇適合的規範，讓你的程式碼更具可讀性與可維護性！\n\n目前在工作經驗上其實三種都有使用過，主要還是看開發團隊大家想要一起使用哪一種，說好就行了。","tags":["snake_case","camelCase","kebab-case","命名規則"]},{"title":"資料庫:Ubuntu 使用 PostgreSql，搭配 pgAdmin4 圖形化介面操作","url":"/2024/11/01/資料庫-Ubuntu-使用-PostgreSql，搭配-pgAdmin4-圖形化介面操作/","content":"\n\n![image](https://hackmd.io/_uploads/SJZCoyfZJg.png)\n\n\n我在之前專案都是習慣使用 MySQL 做開發，在新專案中，我們選擇 PostgreSQL 作為主要資料庫管理系統，它具有強大的 ACID 特性和可擴展性。\n為了便於管理資料庫，我使用 pgAdmin4 作為圖形化界面操作，本文將分享如何在 Ubuntu 上安裝 PostgreSQL 以及 pgAdmin4 的基本設定方法。\n\n# 什麼是 PostgreSQL？\n\n![image](https://hackmd.io/_uploads/Hy_3GVUgkl.png)\n>https://www.postgresql.org/\n\nPostgreSQL（常縮寫為 Postgres）是一個功能強大的開源關聯式資料庫管理系統（RDBMS）。它由加州大學柏克萊分校於 1986 年開發而來，並且自 1996 年正式以 PostgreSQL 名稱發布。PostgreSQL 以其高穩定性、豐富的功能和開放的社群支持而聞名，成為眾多企業和開發者在建構資料密集型應用時的首選。\n\n# PostgreSQL 的核心功能\n\n1. 完全的 ACID 支援\nPostgreSQL 遵循 ACID（原子性、一致性、隔離性、持久性）原則，提供強大的事務處理功能，保證數據操作的安全性和一致性，這使其適合處理關鍵任務的應用程式。\n\n2. 先進的查詢優化器\nPostgreSQL 內建一個強大的查詢優化器，可以針對每個查詢自動選擇最佳的執行計畫，以提升執行效率，尤其在面對大型資料集時效果更為顯著。\n\n3. 擴展性與模組化設計\nPostgreSQL 支援使用者自訂的函式、型別和索引，甚至可以創建自訂演算子，滿足多樣化的業務需求。此外，透過擴充模組，使用者可以將 PostGIS 等擴展功能加入 PostgreSQL，進行地理資料處理。\n\n4. 多樣的資料型別\n除了標準的數值、文字、時間等型別外，PostgreSQL 還支援 JSON、hstore、陣列、範圍等複雜型別，這使得開發者可以更靈活地儲存非結構化數據。\n\n5. 多版本併發控制（MVCC）\nPostgreSQL 內建多版本併發控制技術，可以在不鎖定資料的情況下實現並發操作，減少系統阻塞的情況，提升整體性能。\n\n# PostgreSQL 的優勢\n\n1. 穩定可靠：多年來，PostgreSQL 已被證明為高可靠性、高穩定性的資料庫解決方案，適合用於要求嚴謹的生產環境。\n\n2. 開源與活躍的社群：PostgreSQL 是完全開源的，並擁有龐大的開發社群，為其提供持續的支援與更新，使其可以快速回應新技術需求和安全漏洞。\n\n3. 支援 NoSQL 功能：PostgreSQL 除了是關聯式資料庫，還能處理 JSON 等非結構化數據，具備 NoSQL 資料庫的靈活性。這讓它成為一個同時支援 SQL 和 NoSQL 的多功能資料庫。\n\n4. 跨平台支援：PostgreSQL 可以在多種作業系統（如 Linux、Windows、macOS）上運行，適合不同的開發環境需求。\n\n# PostgreSQL 的適用場景\n\n1. 企業級應用\n由於 PostgreSQL 的高穩定性和強大事務支援，許多企業選擇將其用於金融、電信等關鍵任務應用程式。例如，大量需要保證數據一致性的財務系統就非常適合採用 PostgreSQL。\n\n2. 資料密集型應用\nPostgreSQL 能處理龐大的數據量，並且在查詢和操作速度上表現良好。對於需要大量數據分析的應用，例如電子商務、用戶行為分析等，PostgreSQL 是理想的選擇。\n\n3. 地理資訊系統（GIS）\n透過 PostGIS 擴展，PostgreSQL 提供了豐富的空間資料處理功能，支援地理座標、地圖等數據的處理。這對於地理資訊系統或與地理位置相關的應用非常實用，例如地圖應用、物流管理系統等。\n\n4. 結合 NoSQL 的應用\n當應用程序同時需要處理結構化和非結構化數據時，PostgreSQL 的 JSON 和 XML 支援使其成為合適的選擇，這樣開發者可以在一個資料庫中同時處理關聯式和非關聯式數據。\n\n# MySQL 與 PostgreSQL 之間有什麼差異？\n\n跟相同是關聯式資料庫的 Mysql 有什麼差異呢?\n以下aws有整理出一個比對\n\n![image](https://hackmd.io/_uploads/ryGF9JzWJg.png)\n>https://aws.amazon.com/tw/compare/the-difference-between-mysql-vs-postgresql/\n\nMySQL 是一個關聯式資料庫管理系統，可讓您將資料做為包含資料列和資料欄的資料表來存放。這是一種常用的系統，可為眾多 Web 應用程式、動態網站和內嵌式系統提供支援。PostgreSQL 是一個物件關聯式資料庫管理系統，可提供比 MySQL 更多的功能。使用該系統，您在資料類型、可擴展性、並行性和資料完整性方面具有更大的靈活性。\n\n也就是說 PostgreSQL 是一個物件關連式資料庫提供比 MySQL 更多進階功能。\n\nPostgreSQL 與 MySQL 的差異摘要:\n\n| 類別         | MySQL                                      | PostgreSQL                                                                                                                                                  |\n|--------------|-------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **資料庫技術** | 純粹的關聯式資料庫管理系統                | 物件型關聯式資料庫管理系統                                                                                                                                  |\n| **功能**      | 對檢視、觸發程序和程序等功能的支援有限   | 支援進階功能，如具體化視觀表、INSTEAD OF 觸發程序、多種語言的預存程序                                                                                     |\n| **資料類型**  | 支援數字、字元、日期與時間、空間、JSON  | 支援所有 MySQL 的資料類型，並額外支援幾何、枚舉、網路地址、陣列、範圍、XML、hstore、複合等多樣化資料類型                                                  |\n| **ACID 合規** | 僅在 InnoDB 和 NDB 叢集存儲引擎符合 ACID | 始終符合 ACID                                                                                                                                               |\n| **索引**      | 支援 B 型樹狀結構和 R 型樹狀結構索引      | 支援多種索引類型，如表達式索引、部分索引、雜湊索引和多種樹狀結構                                                                                          |\n| **效能**      | 高頻讀取操作效能較佳                      | 高頻寫入操作效能較佳                                                                                                                                       |\n| **初學者支援**| 容易上手，工具支援較廣泛                  | 相對較複雜，非技術使用者的工具集有限                                                                                                                       |\n\n\n\n# PostgreSQL 安裝與基本使用\n\n官方安裝 PostgreSQL 的頁面\n\n點選Download\n![image](https://hackmd.io/_uploads/r100MEUgkg.png)\n\n## Linux 系統安裝\n![image](https://hackmd.io/_uploads/rJEu3fwlkl.png)\n\n這邊我選擇 Ubuntu\n![image](https://hackmd.io/_uploads/B1vAnMvlJl.png)\n\n##  Linux 安裝 PostgreSQL 步驟 \n\n### 選項 1：Linux 使用內建套件庫安裝 PostgreSQL\n這個方式簡單快速，但可能不是最新版本。\n\n#### 更新套件庫：\n```\nsudo apt update\n```\n\n#### 安裝 Postgres 套件以及添加一些額外實用程式和功能的 -contrib 套件：\n```\nsudo apt install postgresql postgresql-client postgresql-contrib postgresql-common\n```\n\n#### 檢查 PostgreSQL 服務狀態：\n```\nsudo systemctl start postgresql.service\n```\n\n若服務正常運行，你應該會看到類似於 active (running) 的訊息。\n![image](https://hackmd.io/_uploads/rJ3vyXPeJl.png)\n>像圖中這邊有 active (exited)代表正在運行\n\n#### 連接到 PostgreSQL： 使用 psql 工具進入 PostgreSQL。\n```\nsudo -u postgres psql\n```\n![image](https://hackmd.io/_uploads/Hk_wxQvlJe.png)\n\n在 psql 內，你可以執行 SQL 指令。例如：\n```\n\\l   -- 列出所有資料庫\n\\q   -- 退出 psql\n```\n![image](https://hackmd.io/_uploads/ryPieXvl1l.png)\n\n#### 檢查 PostgreSQL 版本\n```\npsql --version\n```\n![image](https://hackmd.io/_uploads/SJJpfXwe1l.png)\n\n### 選項 2：透過 PostgreSQL 官方 Apt Repository 安裝（建議使用）\n如果你想使用較新的 PostgreSQL 版本，請依照以下步驟：\n\n#### 安裝所需工具\n```\nsudo apt install -y curl ca-certificates gnupg\n```\n![image](https://hackmd.io/_uploads/r1sgz7wlyg.png)\n\n\n#### 匯入 PostgreSQL 簽名金鑰\n```\nsudo mkdir -p /usr/share/keyrings\ncurl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo tee /usr/share/keyrings/postgresql.asc\n```\n![image](https://hackmd.io/_uploads/Byy4fmwl1e.png)\n\n\n#### 添加 PostgreSQL 官方 Repository\n```\necho \"deb [signed-by=/usr/share/keyrings/postgresql.asc] https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\" | sudo tee /etc/apt/sources.list.d/pgdg.list\n```\n![image](https://hackmd.io/_uploads/rJAYGmwx1x.png)\n\n\n#### 更新套件列表：\n\n```\nsudo apt update\n```\n![image](https://hackmd.io/_uploads/Sye_jMmPlyg.png)\n\n#### 安裝 PostgreSQL： 這裡將安裝最新版本。如果你需要特定版本，如 PostgreSQL 16，可以將 postgresql 替換為 postgresql-16。\n\n```\nsudo apt -y install postgresql\n```\n\n![image](https://hackmd.io/_uploads/SyDEmmwx1x.png)\n\n\n#### 啟動並檢查 PostgreSQL 服務狀態：\n```\nsudo systemctl enable postgresql\nsudo systemctl start postgresql\nsudo systemctl status postgresql\n```\n![image](https://hackmd.io/_uploads/rkg877PxJg.png)\n\n\n#### 使用 psql 連接 PostgreSQL：\n```\nsudo -u postgres psql\n\n```\n\n![image](https://hackmd.io/_uploads/SkwkV7wgyg.png)\n\n#### 檢查 PostgreSQL 版本\n```\npsql --version\n```\n![image](https://hackmd.io/_uploads/SJvEVQDgJl.png)\n\n這邊可以看到使用方法二安裝的postgreSQL 版本是 17.0\n\n#### 建立新資料庫與使用者（選用）： 在 psql 內，你可以使用以下指令建立新的資料庫和使用者：\n```\nCREATE DATABASE mydb;\nCREATE USER myuser WITH ENCRYPTED PASSWORD 'mypassword';\nGRANT ALL PRIVILEGES ON DATABASE mydb TO myuser;\n```\n\n## 驗證安裝是否成功\n### 檢查 PostgreSQL 版本\n```\npsql --version\n```\n\n### 確認你可以登入資料庫並執行 SQL 指令：\n```\nsudo -u postgres psql\n```\n\n# 問題排解\n\n## 常見問題與解決方式\n\n### 檢查 `public` Schema 權限\n\n\n應用程式在使用 TypeORM 連接 PostgreSQL 資料庫時，遇到 `permission denied for schema public` 的權限問題。\n\n---\n即使你已授予部分權限，可能還有一些權限不足或授權未正確應用。\n\n1. **確認用戶是否擁有 `public` schema 的完整權限：**\n   重新進入 PostgreSQL 並檢查目前的權限：\n\n   ```bash\n   sudo -u postgres psql\n   \\c <your_db>\n   ```\n\n   執行：\n   ```sql\n   SELECT grantee, privilege_type \n   FROM information_schema.role_table_grants \n   WHERE table_schema = 'public';\n   ```\n\n2. **確保授予足夠的權限：**\n   再次執行以下指令，確保 `<user>` 用戶擁有所有必須的權限：\n\n   ```sql\n   GRANT USAGE, CREATE ON SCHEMA public TO <user>;\n   GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO <user>;\n   GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO <user>;\n   ALTER SCHEMA public OWNER TO <user>;\n   ```\n\n\n### PostgreSQL 服務無法啟動\n確保安裝過程順利完成，並檢查服務日誌：\n```\nsudo journalctl -u postgresql\n```\n\n### 防火牆阻擋遠端連線\n如果需要從遠端連接 PostgreSQL，請確保防火牆已開啟所需的埠（預設為 5432）\n```\nsudo ufw allow 5432/tcp\n\n```\n### 修改 PostgreSQL 設定允許遠端連線\n編輯 PostgreSQL 的設定檔 /etc/postgresql/版本號/main/postgresql.conf：\n```\nlisten_addresses = '*'\n\n```\n\n然後在 /etc/postgresql/版本號/main/pg_hba.conf 中新增：\n```css\nhost    all             all             0.0.0.0/0            md5\n\n```\n重新啟動服務\n```\nsudo systemctl restart postgresql\n\n```\n\n## windows系統安裝\n\n{% note warning simple %}\n我這邊實測windows安裝比較多問題，我決定要先嘗試用linux下載postgresql設定server ，但是後續會使用到`pgAdmin4` 功能來圖形化連接操作，所以大家可以先跳到設定 `pgAdmin4`這邊\n\n{% endnote %}\n點選Windows\n![image](https://hackmd.io/_uploads/HyIl7VLlJx.png)\n點選 Download the installer\n\n![image](https://hackmd.io/_uploads/HypzmEIg1e.png)\n選擇合適的版本\n\n下載完成後執行開始安裝\n![image](https://hackmd.io/_uploads/HyN37VLeJg.png)\n\n\n![image](https://hackmd.io/_uploads/r1A27EUxkl.png)\n\n![image](https://hackmd.io/_uploads/By66QV8x1l.png)\n\n\n![image](https://hackmd.io/_uploads/rJUCX4UlJx.png)\n選擇安裝路徑\n\n![image](https://hackmd.io/_uploads/rJOkENIlkl.png)\n這邊設定資料庫密碼\n\n![image](https://hackmd.io/_uploads/H12gVV8xkx.png)\n這邊設定PORT \n\n![image](https://hackmd.io/_uploads/SJQ_NNUgke.png)\n選擇地點，這邊可以選擇Taiwan\n\n![image](https://hackmd.io/_uploads/r1jjNELgkx.png)\n\n![image](https://hackmd.io/_uploads/BkB3EE8gyl.png)\n\n![image](https://hackmd.io/_uploads/BJz6V4Uekx.png)\n\n\n開啟  PostgreSQL \n\n開啟開始工具列，搜尋並打開 PostgreSQL 的目錄，點選執行＂SQL Shell (psql)＂。\n\n![image](https://hackmd.io/_uploads/S1qYY4Ie1x.png)\n\n{% note warning simple %}\n這邊我有遇到這個錯誤\n![image](https://hackmd.io/_uploads/H1lr4r8l1l.png)\n\n這邊應該是權限不足，可以使用系統管理員再安裝一次\n{% endnote %}\n\n 輸入連線資訊，先按預設值照著打。Password 就前面安裝時輸入的密碼。\n\n![image](https://hackmd.io/_uploads/Byta9EUxkx.png)\n\n\n# 設定 `pgAdmin4`\n## Step 1. 設定 PostgreSQL 所在位置\n\n點選 `Add New Server`\n\n![image](https://hackmd.io/_uploads/rkMBPVUgJg.png)\n\n\n## Step 2. 設定連線名稱\n設定Server資料，通常這個Server我會直接設成local，因為它代表著local的資料\n\n![image](https://hackmd.io/_uploads/SkvoDNLe1g.png)\n\n## Step 3. 設定所要連線到的 `PostgreSQL` 的 `IP`\n\n`Connection` 頁籤中的 `Host name/address` 欄位輸入 `PostgreSQL` 的 `IP`\n\n`Connection` 頁籤中的 `Password` 欄位輸入 `postgres` 帳號的登入密碼\n\n\n![image](https://hackmd.io/_uploads/r1Q3PwyZke.png)\n\n之後就可以成功進入該Server的Database了\n\n![image](https://hackmd.io/_uploads/HJZ4_DJZyx.png)\n\n\n接下來點擊資料庫之後可以下 query 開始查詢使用資料庫，這邊使用起來就跟phpmyadmin大同小異了。\n\n# 總結\n\nPostgreSQL 是一個非常強大且靈活的資料庫解決方案，其豐富的功能、穩定性、擴展性和開源性，使其成為現代企業和開發者的理想選擇。無論是處理高併發的應用場景，還是需要處理複雜查詢的分析應用，PostgreSQL 都能夠滿足需求。\n\n如果你正在尋找一個穩定、擴展性高且支持 NoSQL 功能的資料庫，那麼 PostgreSQL 無疑是一個值得考慮的選擇。希望這篇文章能幫助你更好地了解 PostgreSQL 的特點與應用！\n","tags":["資料庫","PostgreSQl"]},{"title":"GCP - 儲存選擇 Block Storage 與 File Storage 的應用與比較","url":"/2024/10/07/GCP-儲存選擇-Block-Storage-與-File-Storage-的應用與比較/","content":"![未命名設計](https://hackmd.io/_uploads/rkooImZJkx.jpg)\n在 Google Cloud Platform (GCP) 上，雲端儲存解決方案分為多種類型，以滿足不同的工作負載需求。其中，**Block Storage** 和 **File Storage** 是兩種非常常見的儲存類型，分別適用於不同的應用場景。本文將簡單介紹它們的特點、適用場景，以及在 GCP 中的具體服務。\n\n以下是Google Cloud Storage Options 官方指南\n![image](https://hackmd.io/_uploads/SkP1RWbJ1l.png)\n>https://cloud.google.com/products/storage/?hl=zh-TW\n\n## 什麼是 Block Storage？\n\n以下是Google cloud 區塊儲存空間官方說明文件\n![image](https://hackmd.io/_uploads/SJLgxzZkkx.png)\n>https://cloud.google.com/products/block-storage?hl=zh-TW\n\n**Block Storage（區塊存儲）** 是將數據分割成固定大小的區塊，並將每個區塊單獨儲存和管理的一種存儲方式。這種存儲方法類似於傳統的硬碟驅動器，因為每個區塊都可以被單獨存取，並且不需要依賴整個文件結構來讀取數據。這使得 Block Storage 特別適合對於高性能和低延遲有較高需求的應用程序，如數據庫和虛擬機。\n\n### GCP 上的 Block Storage 服務：Persistent Disk\n\n以下是 Google Cloud Persistent Disk 官方文件\n![image](https://hackmd.io/_uploads/rJZrp--Jke.png)\n>https://cloud.google.com/persistent-disk?hl=zh-TW\n\n在 GCP 中，**Persistent Disk** (PD) 是最主要的 Block Storage 服務。Persistent Disk 提供持久性、高可靠性及可擴展的區塊存儲，且能與虛擬機（VM）無縫整合。\n\n- **特點**：\n  - **持久性**：數據存儲在多個物理位置，確保在硬體故障時仍可恢復數據。\n  - **高效能**：PD 提供高 IOPS（每秒輸入輸出操作次數）與低延遲，適合高性能的工作負載。\n  - **彈性擴展**：PD 可以隨時動態調整大小，無需中斷服務。\n  \n- **適用場景**：\n  - 數據庫應用程式，如 MySQL、PostgreSQL。\n  - 高性能虛擬機的存儲需求。\n  - 需要頻繁讀寫操作的工作負載。\n\n### Persistent Disk 的類型\n在 GCP 上，Persistent Disk 提供了多種選擇，以滿足不同需求：\n- **Standard Persistent Disk**：適合標準工作負載的成本效益型選擇。\n- **SSD Persistent Disk**：提供更高的讀寫速度，適合需要快速存取的應用。\n- **Balanced Persistent Disk**：在性能和成本之間提供平衡，適合大多數應用程式。\n\n## 什麼是 File Storage？\n以下是 Google Cloud Filestore 官方文件\n![image](https://hackmd.io/_uploads/HkJqab-ykg.png)\n>https://cloud.google.com/filestore?hl=zh-TW\n\n**File Storage（文件存儲）** 是基於文件和文件夾的存儲系統，允許用戶通過標準的檔案存取協議（如 NFS）來存取數據。這種存儲方式類似於傳統的文件伺服器，適合需要共享文件的應用程序，例如內容管理系統和媒體處理工作負載。\n\n### GCP 上的 File Storage 服務：**Filestore**\n在 GCP 中，**Filestore** 是主要的 File Storage 服務。它是一個完全託管的 NFS 文件系統，專為與虛擬機或容器環境中的應用程式整合而設計。\n\n**特點**：\n  - **簡單易用**：提供類似於傳統文件伺服器的操作體驗，支持標準 NFS 協議。\n  - **高性能**：適合高吞吐量工作負載，例如視頻處理、軟體開發工作流。\n  - **彈性配置**：Filestore 提供多種性能層級，從標準到高性能檔案存儲，以滿足不同的需求。\n\n**適用場景**：\n  - 共享文件系統，例如企業內部文件存取與共享。\n  - 多個 VM 之間的協同工作，特別是需要頻繁存取大文件的應用。\n  - 容器化環境中的數據共享，例如 GKE 中的工作負載。\n\n### Filestore 的類型\nFilestore 提供了多種配置選項：\n- **Filestore Basic**：適合一般用途的文件存取需求。\n- **Filestore High Scale**：提供更高的性能和容量，適合需要高吞吐量的應用程式。\n\n## Block Storage 和 File Storage 的選擇\n\n在選擇 Block Storage 和 File Storage 時，應根據具體需求來決定：\n- **Block Storage（Persistent Disk）** 更適合需要低延遲、高性能的應用，如數據庫和需要大量隨機存取的工作負載。\n- **File Storage（Filestore）** 則更適合需要文件共享或多個應用程式協同工作的情境，例如軟件開發、內容管理系統或多媒體處理。\n\n## 結論\n\nGCP 提供了多樣化的存儲解決方案，包括 Block Storage（Persistent Disk）和 File Storage（Filestore）。這兩種存儲類型各有優勢，能夠滿足不同的應用需求。選擇合適的存儲方案，不僅可以提升應用程式的性能，還能降低成本並提高系統的靈活性。\n","tags":["GCP","Block Storage"]},{"title":"GCP - 深入解讀 GKE Kubernetes 中的 Service 概念與應用","url":"/2024/09/30/GCP-深入解讀-GKE-Kubernetes-中的-Service-概念與應用/","content":"\n![image](https://hackmd.io/_uploads/HyRbG9w0A.png)\n\n\n今天要來跟大家分享Kubernetes的 Service設定，這篇是我在學習Kubernetes的時候看到官方文件的資料整理。\n\n在 Kubernetes 中，Service 是一個重要的資源，它提供了一個抽象層，將動態變化的 Pod 集合與外部或內部網路的請求進行連接。\n\n在 Google Kubernetes Engine (GKE) 上使用 Service，可以讓我們更靈活地管理和分配應用的流量，並提升應用的可用性和擴展性。\n\n本文將帶你深入了解 Kubernetes Service 的類型、其如何運作，以及在 GKE 上如何使用這些 Service。\n\n以下是官方Kubernetes 的服務介紹文件\n![image](https://hackmd.io/_uploads/rkwgatD0C.png)\n> https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-clusterip\n\n## 什麼是 Kubernetes Service？\n\nKubernetes 中的 Pod 是應用程序的基本運行單元，但 Pod 的生命週期短暫，IP 地址會隨著創建和刪除而不斷變動。為了解決這個問題，Kubernetes 引入了 Service 概念。Service 是一個穩定的網路實體，能夠自動為一組動態變化的 Pod 提供固定的網路訪問路徑。這使得即使 Pod 被重建或移動，應用也能保持連續的服務。\n\n## Kubernetes Service 的類型\n\nKubernetes 提供了多種不同類型的 Service，每一種類型都有其特定的應用場景。以下是主要的 Service 類型：\n\n### 1. **ClusterIP**\n   這是 Kubernetes 中的預設 Service 類型。ClusterIP 為 Service 分配一個集群內部的 IP 地址，僅允許集群內部的 Pod 之間進行通訊。這種 Service 適合內部應用之間的互相調用，而不需要暴露給外部。\n\n### 2. **NodePort**\n   NodePort 將 Service 暴露在每個節點的特定端口上，允許外部通過節點的 IP 地址和端口號來訪問服務。\n   這種方式非常簡單，但如果應用需要高流量或高可用性時，則需要配合其他負載平衡技術。\n\n以下是`type: NodePort`服務的清單範例，其中指定了NodePort 值（在本例中為30007）：\n\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  type: NodePort\n  selector:\n    app.kubernetes.io/name: MyApp\n  ports:\n    # 默認情況下，為了方便起見，`targetPort` 被設置為與 `port` 欄位相同的值。\n    - port: 80\n      targetPort: 80\n      # 可選欄位\n      # 默認情況下，為了方便起見，Kubernetes 控制平面會從某個範圍內分配一個端口號\n      #（默認：30000-32767）\n      nodePort: 30007\n```\n\n\n### 3. **LoadBalancer**\n   LoadBalancer 主要用於雲環境中，它會為每個 Service 創建一個雲端提供的負載平衡器（如 GCP 的 LoadBalancer），並自動分配一個外部 IP 地址，方便外部流量直接訪問。這是大多數公有雲平台上應用最廣泛的 Service 類型之一，特別適合需要對外提供服務的應用。\n\n以下是官方的使用範例:\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app.kubernetes.io/name: MyApp\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 9376\n  clusterIP: 10.0.171.239\n  type: LoadBalancer\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 192.0.2.127\n```\n\n### 4. **ExternalName**\n   ExternalName 讓 Service 能夠將請求轉發到集群外部的 DNS 名稱。這類 Service 尤其適合集群中的應用需要訪問外部資源時使用。\n\n例如，下列Service 定義將prod名字空間中的my-service服務對應到 `my.database.example.com`：\n\n\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\n  namespace: prod\nspec:\n  type: ExternalName\n  externalName: my.database.example.com\n```\n\n## Service 與 Pod 的連結\n\nKubernetes 使用 Label Selector 將 Service 與一組特定的 Pod 連結在一起。當一個 Service 創建後，會根據 Pod 的標籤來選擇對應的 Pod，並動態維護這些 Pod 的列表。這樣即使 Pod 發生變更，Service 仍然能夠自動更新其連接的目標，保持應用的正常運行。\n\n此外，Service 會創建一個名為 Endpoints 的資源，記錄與該 Service 連接的 Pod 的實際 IP 地址。這樣，當流量到達 Service 時，Kubernetes 會根據 Endpoints 將流量正確地分發到對應的 Pod。\n\n以下是 Kubernetes Service 類型的官方說明文件\n![image](https://hackmd.io/_uploads/HJZqTYwRC.png)\n>https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#publishing-services-service-types\n\n## GKE 中的 Service 運作方式\n\n在 GKE 上，使用 Service 更加簡單和高效。當你在 GKE 上創建一個 LoadBalancer 類型的 Service 時，GCP 會自動創建一個對應的雲端負載平衡器，並分配一個外部 IP 地址。這樣的整合大大簡化了應用對外提供服務的配置過程，讓你無需手動配置複雜的負載平衡器。\n\nGKE 還提供了 Internal LoadBalancer，讓你可以僅在 VPC 內部使用負載平衡器，這對於內部流量管理和安全隔離來說非常重要。\n\n## 實際應用場景\n\n以下是一些 Kubernetes Service 的常見應用場景：\n\n1. **NodePort 開放外部訪問**：如果你希望將應用程序暴露給外部訪問，但又不想使用負載平衡器，可以選擇 NodePort 類型的 Service。這種方法雖然簡單，但不適合處理大量流量。\n   \n2. **使用 LoadBalancer 支援高可用性**：當應用需要對外提供高流量或高可用性的服務時，LoadBalancer 是最佳選擇。它能夠自動調整流量並確保應用在多個節點之間進行負載均衡。\n\n3. **選擇合適的 Service 類型**：在 Kubernetes 中選擇合適的 Service 類型至關重要。對於內部服務，可以選擇 ClusterIP 或 Internal LoadBalancer，而對於需要暴露給外部的應用，則應使用 LoadBalancer 以提供穩定的外部訪問路徑。\n\n## Service 與 Ingress 的區別\n\nService 和 Ingress 常常一起使用，但它們在 Kubernetes 中的角色有所不同。Service 主要負責將流量分發給特定的一組 Pod，而 Ingress 則是一種更高層次的資源，提供了基於路徑的流量管理功能。例如，Ingress 可以根據 URL 路徑或主機名將請求轉發到不同的 Service，這對於實現複雜的流量路由非常有用。\n\n## 結論\n\nKubernetes Service 是管理和分發網路流量的核心組件，尤其是在 GKE 這樣的雲端環境中，它可以無縫整合 Google Cloud Platform 的負載平衡器服務。無論是內部應用還是對外的服務，Kubernetes Service 都能提供靈活且高效的解決方案，幫助開發者更好地管理應用的網路需求。\n\n透過瞭解 Kubernetes Service 的各種類型和運作原理，你將能夠更好地設計和部署應用，確保在各種情境下，應用的可用性和性能都能夠得到充分保障。","tags":["雲端服務","GCP","Kubernetes"]},{"title":"GCP - 儲存服務與資料庫工具整理與選擇整理","url":"/2024/09/20/GCP-儲存服務與資料庫工具整理與選擇整理/","content":"\n![image](https://hackmd.io/_uploads/B1XjX8cpC.png)\n> GCP的儲存服務與\n\n![image](https://hackmd.io/_uploads/HJOPXL9pC.png)\n> GCP的資料庫\n\nGoogle 推出了很多種儲存跟資料庫的服務，選擇合適的儲存解決方案對於確保應用程式的效能與可擴展性至關重要。Google Cloud Platform (GCP) 提供了多樣化的儲存產品，每種產品針對不同的應用場景與需求進行了優化。今天將透過一個決策流程，幫助您快速理解並選擇適合的 GCP 儲存方案。\n\n大家可以在下面這個網址找到GCP具體總共有哪些服務與圖示\n![image](https://hackmd.io/_uploads/ryV1cDY6R.png)\n\n>https://googlecloudcheatsheet.withgoogle.com/\n\n# GCP 有哪些儲存服務與資料庫工具?\n![image](https://hackmd.io/_uploads/Hk8cKwK6R.png)\n\n\n## Cloud Storage\n![cloud-storage-productcard](https://hackmd.io/_uploads/B1gG2vtTC.jpg)\n\nCloud Storage 是 Google Cloud 提供的物件存儲解決方案，適合儲存大量的非結構化數據，如圖片、影片、備份文件等。它具備高度耐久性和可擴展性，適合需要長期存儲和全球訪問的應用程式。\n\n## Cloud Bigtable\n![cloud-bigtable-productcard](https://hackmd.io/_uploads/SkxV3PF60.jpg)\n\nCloud Bigtable 是一個高效能的 NoSQL 資料庫，特別適合大規模數據分析、物聯網數據處理和金融資料管理。它以極低延遲和高吞吐量著稱，適用於需要快速讀寫大量資料的應用場景。\n\n## Cloud Datastore\n![datastore-productcard](https://hackmd.io/_uploads/r17PhPYTC.jpg)\n\nCloud Datastore 是一個分散式 NoSQL 文件資料庫，專為需要高擴展性的應用程式設計。它支持強一致性和事務處理，適合用於儲存具有複雜查詢需求的半結構化數據。\n\n## Cloud Firestore\n![firestore](https://hackmd.io/_uploads/ryP3aDF6A.png)\n\nCloud Firestore 是 Firebase 的一部分，提供即時同步功能，支援 Web 和移動應用程式。它與 Cloud Datastore 有相似之處，但針對即時應用進行了優化，特別適合多設備同步和快速更新數據的應用程式。\n\n## Cloud SQL\n![cloud-sql-productcard](https://hackmd.io/_uploads/H1B_3PtaR.jpg)\n\nCloud SQL 是一個全託管的關聯式資料庫服務，支持 MySQL、PostgreSQL 和 SQL Server。它提供自動化的備份、擴展和維護功能，適合需要傳統 SQL 資料庫的應用程式。\n\n## Persistent Disk\n![persistent-disk-productcard](https://hackmd.io/_uploads/H1ASnvtaC.jpg)\n\nPersistent Disk 是一個高性能的持久化塊存儲，主要用於虛擬機器（VM）的數據存儲。它具備高可用性和可擴展性，適合需要快速存取和持久化數據的 VM 應用場景。\n\n## Filestore\n![filestore](https://hackmd.io/_uploads/ByTv6vY6A.png)\nFilestore 是一個完全託管的檔案存儲服務，支援 NFS（網路檔案系統）協議，適合需要低延遲、高效能的工作負載，如機器學習模型訓練和基於檔案的應用程式。\n\n## MemoryStore\n![memorystore](https://hackmd.io/_uploads/HJ8q6PKaC.png)\n\nMemoryStore 是一個完全託管的內存資料庫服務，支持 Redis 和 Memcached。它主要用於緩存數據，提升應用程式的讀取性能，適合需要極低延遲的應用場景。\n\n## Local SSD\n![image](https://hackmd.io/_uploads/r1NxV85a0.png)\n\nLocal SSD 是 Google Cloud 提供的高速本地存儲，直接連接到虛擬機器（VM）。與 Persistent Disk 不同，Local SSD 提供更高的 IOPS 和更低的延遲，適合需要極高效能的工作負載，如數據庫應用和實時數據處理。需要注意的是，Local SSD 的數據在 VM 停止時不會保留，因此適合臨時數據的存儲需求。\n\n## Backup And DR Service\n![image](https://hackmd.io/_uploads/S1LfNL96R.png)\nBackup and DR Service 是 GCP 提供的備份與災難恢復解決方案，專為確保數據安全和業務連續性設計。它支持自動化備份管理，幫助企業快速從故障或災難中恢復數據。此服務適合需要數據保護和高可用性的業務。\n\n## Alloy DB\n![image](https://hackmd.io/_uploads/HytrQUcT0.png)\n\nAlloyDB 是 Google Cloud 針對高效能工作負載打造的託管 PostgreSQL 資料庫服務。它結合了 Google Cloud 的基礎架構與開源 PostgreSQL，提供極高的性能、可用性和擴展性，適合需要同時滿足高效能與 SQL 功能的應用場景。\n\n什麼是 Alloy DB? 官方介紹影片\nhttps://youtu.be/YODa-x0_3l0\n\n![image](https://hackmd.io/_uploads/SybfmI5T0.png)\n\n\n## Cloud Spanner\n![cloud_spanner](https://hackmd.io/_uploads/HkBSx_taR.png)\n\nCloud Spanner 是全球分散式的關聯式資料庫，支援水平擴展和強一致性，適合需要高可用性、可擴展性和一致性的應用程式。它是 GCP 的旗艦數據庫服務之一，能同時支持全球分佈的資料寫入和複雜查詢。\n\n## Database Migration Service\n![database_migration_service](https://hackmd.io/_uploads/B1uUgdYaC.png)\n\nDatabase Migration Service 是一個完全託管的資料庫遷移工具，支持將 MySQL、PostgreSQL 和 SQL Server 資料庫無中斷地遷移到 Google Cloud。它簡化了數據庫的遷移過程，確保應用程式能在遷移期間持續運行。\n\n# 如何判斷要選擇什麼產品?\n\n這邊有一個決策樹可以參考\n![image](https://hackmd.io/_uploads/B1cTEwKaA.png)\n\n### 1. 資料是否需要直接與使用者互動？\n\n這是選擇儲存方案的第一個問題。如果您的應用程式需要處理來自使用者的即時請求（例如文件上傳或下載），這將大大影響您的選擇。\n\n- **需要 Media SDK**：如果您的應用程式需要支援多媒體處理，則 **Firebase Storage** 是最合適的選擇。Firebase 提供了強大的 SDK，讓您可以輕鬆地與客戶端互動。\n- **不需要 Media SDK**：如果不需要多媒體處理，那麼 **Cloud Storage** 是最常用的選擇。它是一個物件存儲服務，適合處理大規模非結構化數據，如圖片、影片、備份檔案等。\n\n### 2. 您的工作負載是否需要分析？\n\n如果您的應用程式需要對數據進行大量的查詢和分析，這將引導您使用不同的儲存方案。\n\n- **需要數據分析**：如果需要進行即時或批量分析，**BigQuery** 是一個理想的選擇。它是一個伺服器無需管理的數據倉儲解決方案，提供了大規模並行查詢的能力。\n- **不需要數據分析**：如果您的數據主要用於存儲，而非大量查詢或分析，您可以進一步考慮數據的持久性和一致性需求。\n\n### 3. 您的數據是否需要一致性？\n\n數據的一致性與分佈式系統中的複雜性息息相關。如果數據需要確保高一致性，則會有不同的儲存選項。\n\n- **需要強一致性**：如果您需要強一致性並且您的應用程式數據高度關聯，**Cloud SQL** 或 **Cloud Spanner** 是不錯的選擇。**Cloud SQL** 支援關聯數據庫如 MySQL、PostgreSQL 和 SQL Server，適合傳統應用。**Cloud Spanner** 則是一個全球分佈式的關聯數據庫，適合處理水平擴展的需求。\n- **不需要強一致性**：如果應用對於一致性的需求較低，或者資料是非結構化的，您可以考慮 NoSQL 方案，例如 **Firebase Realtime Database** 或 **Cloud Datastore**，這些解決方案更適合快速存取和非結構化資料。\n\n### 4. 是否需要高可用性與橫向擴展？\n\n如果您的應用程式預期將需要大規模的橫向擴展，那麼選擇具有高可用性與自動擴展功能的存儲解決方案是關鍵。\n\n- **需要橫向擴展**：如果您的應用程式需要處理大量的讀寫請求並保持高可用性，**Cloud Spanner** 是最好的選擇之一。它支援全球分佈式存儲，並且具有極高的擴展能力和一致性保證。\n- **不需要橫向擴展**：如果應用程式的需求相對穩定並且不需要大規模擴展，**Cloud SQL** 提供了一個簡單且熟悉的選擇，適合中小型應用。\n\n---\n\n# 總結\n\nGCP 提供了各種儲存解決方案，從物件存儲的 **Cloud Storage** 到關聯數據庫的 **Cloud SQL**，再到專為高效能分析設計的 **BigQuery**。根據應用程式的需求，我們可以針對數據的互動性、持久性、一致性和可擴展性來選擇最適合的方案。\n\n","tags":["雲端服務","GCP","資料庫"]},{"title":"GCP - 權限控管功能 Identity and Access Management (IAM)","url":"/2024/09/19/GCP-權限控管功能-Identity-and-Access-Management-IAM/","content":"\n在 Google Cloud Platform（GCP）中，**Identity and Access Management (IAM)** 是一個核心的安全性功能，它用來控制誰可以訪問什麼資源。IAM 提供精細的權限控制，允許組織為每個資源設置適當的存取權限，並確保數據安全。\n\n![image](https://hackmd.io/_uploads/rkH-_IF6A.png)\n＞https://cloud.google.com/security/products/iam?hl=zh-tw\n\n\n# 什麼是 IAM？\n\n![image](https://hackmd.io/_uploads/SycNdIYpR.png)\n＞https://cloud.google.com/security/products/iam?hl=zh-tw\n\nGCP IAM 是一種基於角色的訪問控制系統，通過定義特定的角色和權限，讓使用者、群組或應用程式擁有恰當的資源存取權限。它透過以下三個基本元素來實現訪問控制：\n- **身份 (Identity)**：可以是使用者、群組、服務帳號等。\n- **角色 (Role)**：權限的集合，用來授予身份訪問特定 GCP 資源的權限。\n- **資源 (Resource)**：GCP 上的任何可管理物件，如 Compute Engine VM、Cloud Storage bucket、BigQuery 資料集等。\n\n#  IAM 的主要特點\n![image](https://hackmd.io/_uploads/HkM8OIFpR.png)\n\n- **精細化控制**：IAM 允許您為每個資源設置非常細緻的存取控制。可以為單一用戶或群組分配不同層級的權限，從而避免過度的存取權限。\n\n- **基於角色的存取控制 (RBAC)**：IAM 使用角色來管理權限，每個角色包含不同的操作權限。例如，\"查看者\"角色只能查看資源，而\"編輯者\"角色則能修改資源。\n![image](https://hackmd.io/_uploads/rJODdUFpA.png)\n\n- **預定義角色 (Predefined Roles)**：GCP 提供了多種預定義的角色，這些角色是針對特定的 GCP 服務設計的。例如，`storage.admin` 角色允許管理 Cloud Storage 資源，而 `compute.viewer` 角色允許查看 Compute Engine 資源。\n![image](https://hackmd.io/_uploads/By9F_IFT0.png)\n\n- **自定義角色 (Custom Roles)**：除了預定義的角色，您還可以創建自定義角色來滿足特定需求。自定義角色允許您選擇並組合不同的權限來完全控制訪問。\n\n# IAM 的核心概念\n![image](https://hackmd.io/_uploads/HJjquItp0.png)\n\n- **身份 (Identities)**：可以是 GCP 中的使用者帳號、群組、服務帳號或 Google 帳號。這些身份是授予角色的主體。\n\n- **角色 (Roles)**：角色是權限的集合，每個角色都可以包含多個權限。GCP 提供了三種類型的角色：\n  - **基本角色 (Basic Roles)**：如 `Viewer`、`Editor`、`Owner`。這些是傳統角色，適用於所有 GCP 服務。\n  - **預定義角色 (Predefined Roles)**：針對特定 GCP 服務的角色，提供精細化的權限控制。\n  - **自定義角色 (Custom Roles)**：您可以根據需求創建自定義角色，包含您選擇的權限。\n\n- **權限 (Permissions)**：權限定義了身份能夠執行哪些操作。例如，`storage.buckets.create` 是一個允許創建 Cloud Storage bucket 的權限。\n\n# 如何管理 IAM 角色與權限？\n\n最簡單的說法就是:誰可以做什麼，在哪些資源上?\n\n![image](https://hackmd.io/_uploads/HJ98YIYaR.png)\n\n管理 IAM 主要是通過為身份授予適當的角色。可以通過 GCP 控制台、命令列工具 (`gcloud`)、或 API 來設置角色。\n\n以下是基本的操作流程：\n1. **選擇要管理的資源**：選擇您想要管理存取權限的資源，如特定的 Compute Engine、Cloud Storage bucket 或 BigQuery 資料集。\n  \n2. **為身份分配角色**：選擇身份（如使用者、群組或服務帳號），並為其分配適當的角色。\n\n3. **檢查和修改權限**：根據需求，檢查現有權限是否符合安全性要求，並調整角色或權限。\n\n# 最佳實踐\n![image](https://hackmd.io/_uploads/SkkK_LKTA.png)\n  \n- **最小權限原則**：只授予身份最低限度的權限，以減少風險。例如，對於需要查看數據的使用者，僅分配 `Viewer` 角色，而非 `Editor` 角色。\n\n- **定期審查權限**：定期檢查和更新 IAM 角色和權限，確保使用者或服務帳號的權限符合當前業務需求。\n\n- **使用自定義角色**：當預定義角色無法滿足需求時，考慮創建自定義角色來精細化控制權限。\n\n# 結論\n\n![image](https://hackmd.io/_uploads/Hyz5dIYp0.png)\nIAM 是一個強大的存取控制工具，通過角色和權限的組合，讓組織能夠靈活管理資源的訪問權限。正確地設置和管理 IAM 角色是保障 GCP 資源安全的關鍵。通過遵循最小權限原則和定期審查權限，您可以確保系統的安全性和合規性。\n","tags":["雲端服務","GCP","IAM"]},{"title":"TFT聯盟戰旗 - 7邪術使魔鬥凱薩","url":"/2024/09/19/TFT聯盟戰旗-7邪術使魔鬥凱薩/","content":"\n![TFT_OPGG_Builder (1)](https://hackmd.io/_uploads/Hkdb7D_pC.png)\n\n今天要跟大家介紹的陣容是高邪術使魔鬥凱薩，爭其我發現高邪術使的好處是可以保血量，加上有妮可跟卡莎碧雅可以開出女巫+變形師+咒術師3羈絆，強度很高而且後期有機會湊出10邪術使拉高很多上限。\n\n# 陣容組成\n\n## 魔鬥凱薩\n![image](https://hackmd.io/_uploads/rkXo5lYTR.png)\n![image](https://hackmd.io/_uploads/SyOicetTA.png)\n泯殺\n獲得會在接下來2秒內遞減的[ 300 / 350 / 400 ](AP)護盾，並猛擊目標，對2格的直線距離內造成[ 180 / 270 / 430 ](AP)魔法傷害。獲得12%傷害增幅，持續到戰鬥結束。\n\n魔鬥是在前期的主坦，續戰力很強\n推薦裝備: 好戰者鎧甲![image](https://hackmd.io/_uploads/S1R4CltpA.png)+龍之爪![image](https://hackmd.io/_uploads/HyxU0gKTA.png)\n\n## 星朵拉\n![image](https://hackmd.io/_uploads/Hk4U9gYaC.png)\n![image](https://hackmd.io/_uploads/S13U9lY6R.png)\n超凡入聖\n在目標位置召喚一道裂隙，造成[ 220 / 330 / 495 ] (AP)魔法傷害和20%削抗，持續6秒。此技能會隨著施放次數的增加而升級。(總施放次數：3次)\n\n15施放：與目標相鄰的敵軍將受到削抗並受到[ 110 / 165 / 245 ] (AP)魔法傷害。\n30+ 施放：每施放30次，在附近敵軍的位置額外生成一道裂隙，造成30%傷害。 \n\n削抗：降低魔法防禦\n\n星朵拉是在前期時的主C，很需要啟動裝來疊加技能強度\n\n推薦裝備:![image](https://hackmd.io/_uploads/HJ8ETxFp0.png)精進之矛+![image](https://hackmd.io/_uploads/S1WDTlFpC.png)鬼索的狂暴之刃\n\n## 布蕾爾 \n![image](https://hackmd.io/_uploads/BkuKD8VTC.png)\n![image](https://hackmd.io/_uploads/By4QJDVTR.png)必死無疑\n\n跳躍至最多敵軍聚集處，對2格內的敵軍造成[ 65 / 98 / 731 ] (AD)物理傷害，並使其暈眩，持續1.25秒。接著進入狂熱狀態，獲得[ 75 / 75 / 666 ]% (AP)攻速、[ 15 / 15 / 100 ]%全能吸血，並對目標和鄰近敵軍造成[ 26 / 39 / 293 ] (AD)額外物理傷害。\n\n如果已進入狂熱狀態，則強化下一次普攻為撕咬，造成[ 163 / 244 / 2925 ] (AD)物理傷害。\n\n布蕾爾是核心英雄，也是後期可以開高上限的主C\n\n推薦裝備:![image](https://hackmd.io/_uploads/HyKSSvVaC.png)嗜血者+![image](https://hackmd.io/_uploads/BylUSvVTC.png)泰坦的決意\n\n## 卡莎碧雅\n![image](https://hackmd.io/_uploads/HkcvKlYp0.png)\n\n![image](https://hackmd.io/_uploads/HkbTKxFpC.png)\n女巫鋒牙\n強化下3次普攻，造成[ 135 / 200 / 300 ] (AP)魔法傷害。\n\n\n## 伊莉絲 \n![image](https://hackmd.io/_uploads/B1c1jgF6A.png)\n\n![image](https://hackmd.io/_uploads/HkzxjlFTA.png)\n蜘蛛型態\n\n轉化為蜘蛛型態，將此技能替換為石化毒液，然後施放該技能。\n\n石化毒液：使目標暈眩1.5秒並對其造成[ 132 / 194 / 289 ] (HP+AP)魔法傷害。治療[ 160 / 190 / 230 ] (AP)。\n\n\n## 妮可\n![image](https://hackmd.io/_uploads/r1X-ixKaC.png)\n![image](https://hackmd.io/_uploads/S1O-olFpA.png)驚喜！！！\n\n幻化為螃蟹，持續2秒。在持續時間內，回復12% (HP)生命，並對3名鄰近友軍和3名鄰近敵軍釋放河蟹攻擊。命中的友軍會回復[ 75 / 100 / 125 ] (AP)生命；命中的敵軍則會受到[ 100 / 150 / 240 ] (AP)魔法傷害並暈眩1.25秒。\n\n## 艾希\n\n## 納瑟斯\n![image](https://hackmd.io/_uploads/SJrdw8Np0.png)\n![image](https://hackmd.io/_uploads/rytd5gDnC.png)地獄犬\n從最靠近的[ 3 / 4 / 10 ]名敵軍身上分別偷取總共[ 300 / 480 / 5000 ]生命。之後每次施放改為治療[ 250 / 300 / 900 ] (AP)生命並對目標造成[ 165 / 297 / 610 ] (HP)物理傷害。\n\n## 淣菈\n![image](https://hackmd.io/_uploads/Bkz3jlF6A.png)\n![image](https://hackmd.io/_uploads/S1A2jgtaR.png)\n百變之刃\n被動：護盾增加60%攻速，持續3秒。\n\n主動：衝刺最多2格，然後穿過目標對直線上的敵軍造成[ 180 / 270 / 405 ]()物理傷害。獲得[ 100 / 140 / 180 ] (AP)護盾，持續3秒。\n\n## 娜米\n![image](https://hackmd.io/_uploads/HyZtoxF6C.png)\n![image](https://hackmd.io/_uploads/ByLtjgt60.png)\n利維坦\n朝範圍內最多敵軍聚集處發射泡泡，造成[ 240 / 360 / 1800 ](AP)魔法傷害。每3次施放後，改為召喚利維坦，使直線上的敵軍暈眩並造成[ 200 / 300 / 1200 ](AP)魔法傷害。\n\n\n\n# 實戰影片\n聯盟戰棋 - 邪術使變形師\nhttps://youtu.be/X-XLZOici4k?si=wUQ4bKDcrCK6bwek\n\n聯盟戰棋 - 邪術使\nhttps://youtu.be/ZGpv7BlMGHU?si=alp5oUDgdroauXaI\n\n聯盟戰棋 - 7邪術使變形師\nhttps://www.youtube.com/watch?v=We_fPpmJ8uo\n\n","tags":["聯盟戰棋"]},{"title":"TFT聯盟戰旗 - 陣容介紹變形師龍族納瑟斯","url":"/2024/09/16/TFT聯盟戰旗-變形師龍族納瑟斯/","content":"今天要跟大家介紹的陣容是變形師龍族整體下來坦克很多，且後期有布蕾爾可以一直變強，但是我覺得中期的物理輸出爆發不夠，常常會沒有辦法第一時間灌倒對方前排坦克\n\n\n\n![TFT_OPGG_Builder (1)](https://hackmd.io/_uploads/SyTO8NBnC.png)\n\n![image](https://hackmd.io/_uploads/r1wLDLE60.png)![image](https://hackmd.io/_uploads/S1ALwL4aR.png)![image](https://hackmd.io/_uploads/BJAvDINTR.png)![image](https://hackmd.io/_uploads/SJrdw8Np0.png)![image](https://hackmd.io/_uploads/SyetDIE6R.png)![image](https://hackmd.io/_uploads/BkuKD8VTC.png)![image](https://hackmd.io/_uploads/B16FvL46A.png)\n\n\n\n# 陣容組成\n\n##  納瑟斯 \n![image](https://hackmd.io/_uploads/SJrdw8Np0.png)\n![image](https://hackmd.io/_uploads/rytd5gDnC.png)地獄犬\n從最靠近的[ 3 / 4 / 10 ]名敵軍身上分別偷取總共[ 300 / 480 / 5000 ]生命。之後每次施放改為治療[ 250 / 300 / 900 ] (AP)生命並對目標造成[ 165 / 297 / 610 ] (HP)物理傷害。\n\n狗頭是主要的核心英雄\n\n建議道具:![image](https://hackmd.io/_uploads/B1e1HP4aC.png)石像鬼磐核+![image](https://hackmd.io/_uploads/HkreHPEp0.png)好戰者鎧甲\n\n## 布蕾爾 \n![image](https://hackmd.io/_uploads/BkuKD8VTC.png)\n![image](https://hackmd.io/_uploads/By4QJDVTR.png)必死無疑\n\n跳躍至最多敵軍聚集處，對2格內的敵軍造成[ 65 / 98 / 731 ] (AD)物理傷害，並使其暈眩，持續1.25秒。接著進入狂熱狀態，獲得[ 75 / 75 / 666 ]% (AP)攻速、[ 15 / 15 / 100 ]%全能吸血，並對目標和鄰近敵軍造成[ 26 / 39 / 293 ] (AD)額外物理傷害。\n\n如果已進入狂熱狀態，則強化下一次普攻為撕咬，造成[ 163 / 244 / 2925 ] (AD)物理傷害。\n\n布蕾爾是核心英雄，也是後期可以開高上限的主C\n\n推薦裝備:![image](https://hackmd.io/_uploads/HyKSSvVaC.png)嗜血者+![image](https://hackmd.io/_uploads/BylUSvVTC.png)泰坦的決意\n\n\n## 史矛德\n![image](https://hackmd.io/_uploads/B16FvL46A.png)\n![image](https://hackmd.io/_uploads/ryT5yPVTC.png)學習飛行\n被動：四處飛行並攻擊最靠近的敵軍。\n\n主動：接下來的[ 4 / 4 / 30 ]次普攻增加[ 50 / 50 / 500 ]%攻速。這幾次普攻會發射火球，造成[ 173 / 268 / 2486 ] (AD+AP)物理傷害。\n\n龍族升級：改為接下來的[ 6 / 6 / 99 ]次普攻。火球造成30%(AD+AP)物理傷害。\n\n史矛德是核心英雄擔任後排主C\n\n核心道具有: ![image](https://hackmd.io/_uploads/rJWprDN6A.png)鬼索的狂暴之刃 + ![image](https://hackmd.io/_uploads/HJO3SwNpC.png)無盡之刃\n\n\n## 伊莉絲 \n![image](https://hackmd.io/_uploads/S1Or3UNpR.png)\n\n![image](https://hackmd.io/_uploads/rybx_UETR.png)蜘蛛型態\n\n轉化為蜘蛛型態，將此技能替換為石化毒液，然後施放該技能。\n\n石化毒液：使目標暈眩1.5秒並對其造成[ 132 / 194 / 289 ] (HP+AP)魔法傷害。治療[ 160 / 190 / 230 ] (AP)。\n\n## 嚼嚼\n![image](https://hackmd.io/_uploads/BkfUvIVaR.png)\n![image](https://hackmd.io/_uploads/SkGn_I4aR.png)熾熱龍息\n對目標噴射龍焰，造成[ 224 / 336 / 514 ] (AD+AP) 物理傷害。對最靠近的2個目標造成50%的超量傷害。\n\n龍族升級：改為造成[ 295 / 443 / 674 ] (AD+AP) 物理傷害。超量傷害可以命中4個目標。\n\n# 希瓦納\n![image](https://hackmd.io/_uploads/r1wLDLE60.png)\n\n![image](https://hackmd.io/_uploads/BknR3LV60.png)真龍轉生\n化為龍形，獲得一個每秒對鄰近敵軍造成[ 68 / 104 / 159 ] (HP+AP)魔法傷害的氣場。然後飛過2格內最大群的敵軍並使其暈眩[ 1 / 1 / 1.25 ]秒。\n\n龍族升級：氣場大小加倍，造成的傷害提升30%。\n\n## 妮可\n![image](https://hackmd.io/_uploads/S1ALwL4aR.png)\n![image](https://hackmd.io/_uploads/r1Tdp8N60.png)驚喜！！！\nActive\n50 / 125\n幻化為螃蟹，持續2秒。在持續時間內，回復12% (HP)生命，並對3名鄰近友軍和3名鄰近敵軍釋放河蟹攻擊。命中的友軍會回復[ 75 / 100 / 125 ] (AP)生命；命中的敵軍則會受到[ 100 / 150 / 240 ] (AP)魔法傷害並暈眩1.25秒。\n\n## 斯溫\n![image](https://hackmd.io/_uploads/BJAvDINTR.png)\n\n![image](https://hackmd.io/_uploads/r16x08VTA.png)暴雪\n幻化，增加[ 300 / 375 / 450 ](AP)最大生命。幻化時，每秒對2格內的敵軍造成[ 20 / 30 / 50 ](AP)魔法傷害。\n\n如已幻化，則增加[ 180 / 230 / 280 ](AP)額外最大生命，並提升傷害[ 10 / 15 / 25 ](AP)。\n\n\n## 法洛士\n![image](https://hackmd.io/_uploads/SyetDIE6R.png)\n![image](https://hackmd.io/_uploads/BJBa08EaA.png)地獄火雨\n對5 (攻擊範圍)格內一群敵軍發射一個超新星，對目標和相鄰敵軍造成[ 325 / 488 / 1438 ] (AD+AP)物理傷害。它會爆炸化為連環火球，對3格內其他所有敵軍造成[ 163 / 244 / 1438 ] (AD+AP)物理傷害。\n\n\n\n# 羈絆組成\n\n羈絆組合有 6變形師![image](https://hackmd.io/_uploads/SJvCZDNTR.png)+3龍族![image](https://hackmd.io/_uploads/H1jMzPNpC.png)\n+2煉獄使者![image](https://hackmd.io/_uploads/S1ggMPETA.png)+2轟炸槍手![image](https://hackmd.io/_uploads/BJk-MDVa0.png)!\n\n![image](https://hackmd.io/_uploads/SJo_GwNp0.png)![image](https://hackmd.io/_uploads/ByecGPN60.png)\n![image](https://hackmd.io/_uploads/BJcazvETA.png)\n![image](https://hackmd.io/_uploads/HyF3MDEpA.png)\n\n其中前期的龍族可以降治癒，後期有變形師的高血量，整體來說算是營運的陣容，不適合在低等賭狗。\n\n# 增幅裝置\n\n龍族專精![image](https://hackmd.io/_uploads/BkrY7D4aC.png) > 永恆生長 ![image](https://hackmd.io/_uploads/S18n7PE60.png) > 潘朵拉的道具 II ![image](https://hackmd.io/_uploads/Hk1C7DNaR.png)\n\n# 首選道具\n暴風之劍![image](https://hackmd.io/_uploads/ry28VvVT0.png)>反曲弓![image](https://hackmd.io/_uploads/HJSvVPN6A.png)>巨人腰帶![image](https://hackmd.io/_uploads/rJpvVv4a0.png)>格鬥手套![image](https://hackmd.io/_uploads/H14_4wE6A.png)\n\n\n# 實戰影片\n\n以下是我的頻道紀錄的實戰影片\nhttps://youtu.be/4jrcxdVzvbg?si=21RPggQIFkPA85Zw\nhttps://youtu.be/TOVzoUnCiwU?si=bCoKu9zeQzi4zZ0e\nhttps://youtu.be/TBrnuIPQ1L0?si=Bb5L61i29d0Dq3B1","tags":["聯盟戰棋"]},{"title":"GCP - 身分識別管理工具 Identity-Aware Proxy (IAP)","url":"/2024/09/12/GCP-身分識別管理工具-Identity-Aware-Proxy-IAP/","content":"\n隨著雲端應用的普及，安全性成為各企業不可忽視的重要議題。Google Cloud Platform（GCP）提供了眾多安全性工具，而其中一個強大的功能就是 **Identity-Aware Proxy（IAP）**。IAP 透過基於身份的存取控制來保護應用程式，確保只有授權用戶可以存取特定的應用或服務。\n\n以下是GCP  Identity-Aware Proxy（IAP）的官方介紹文件 \n![image](https://hackmd.io/_uploads/B1N4W6k6A.png)\n>https://cloud.google.com/security/products/iap?hl=en\n\n# 什麼是 Identity-Aware Proxy？\n\nIdentity-Aware Proxy 是 GCP 提供的一項服務，允許您基於使用者身份來控制應用或虛擬機器的存取權限。IAP 讓傳統的防火牆概念更進一步，將網路安全保護由 IP 位址轉移到使用者身份層級，這有助於確保您的資源能夠被正確的使用者存取，而不需要暴露在網路中。\n\n# 核心功能\n\n## 基於身份的存取控制\n   IAP 使用 Google Account 驗證使用者身份，並基於特定角色或權限來允許或拒絕使用者的存取請求，確保敏感資料不會被未經授權的個人看到。\n\n## 無需暴露公眾 IP\n   傳統的網路安全措施常常依賴防火牆規則，允許特定 IP 位址存取應用程式。但透過 IAP，您可以將應用程式或服務完全保護在內部網路中，僅允許具備正確身份驗證的使用者進行訪問。\n\n## 與其他 GCP 服務整合\n   IAP 能與 GCP 的其他安全性服務整合，如 **Cloud Identity** 和 **Google OAuth 2.0**，為 GCP 應用和 VM 提供全面的安全保護。\n\n## 支持多種應用架構 \n   不論您使用的是 GCP 上的 Compute Engine、Kubernetes Engine 還是 App Engine，都可以透過 IAP 進行身份驗證和存取控制，保護不同類型的應用和服務。\n\n### App Engine\n![image](https://hackmd.io/_uploads/HJJUMa1TC.png)\n>https://cloud.google.com/iap/docs/concepts-overview\n\n### Cloud Run\n![image](https://hackmd.io/_uploads/H1iY7ay6R.png)\n>https://cloud.google.com/iap/docs/concepts-overview\n\n### Compute Engine\n![image](https://hackmd.io/_uploads/HyHo7pkTR.png)\n>https://cloud.google.com/iap/docs/concepts-overview\n\n### GKE\n![image](https://hackmd.io/_uploads/HyzAQTJpC.png)\n>https://cloud.google.com/iap/docs/concepts-overview\n\n### On-premises\n![image](https://hackmd.io/_uploads/B1LeNpyaA.png)\n>https://cloud.google.com/iap/docs/concepts-overview\n\n# 運作流程\n\n1. **使用者驗證**\n   當使用者試圖存取受 IAP 保護的應用或資源時，IAP 會首先確認使用者是否已經登入 Google 帳戶，並進行身份驗證。\n\n2. **權限檢查**\n   IAP 會根據 IAM（Identity and Access Management）中的角色與權限設定來決定使用者是否可以存取特定應用或服務。\n\n3. **應用授權**\n   一旦身份和權限驗證通過，IAP 會允許該使用者存取應用程式，並將流量轉送到後端服務。\n\n\n\n## 主要優勢\n\n1. **強化安全性**：避免將應用程式暴露在公網中，僅允許經身份驗證的用戶存取。\n2. **簡化存取管理**：整合 Google 帳戶系統，不需要手動管理 IP 白名單。\n3. **彈性部署**：支持多種雲端應用程式架構，適用於不同規模的企業。\n\n## 如何配置 GCP Identity-Aware Proxy？\n\n1. **啟用 IAP**\n   在 GCP Console 中，導航至 **IAP 設定頁面**，選擇需要保護的資源並啟用 IAP 功能。\n\n2. **設置 IAM 角色與權限**\n   為使用者賦予適當的 IAM 角色，例如 IAP-secured Web App User 或 Viewer，來決定哪些使用者可以存取受保護的應用。\n\n3. **測試與驗證**\n   配置完成後，測試使用者存取，確認身份驗證與存取控制是否如預期運作。\n\n## 結論\n\nGCP 的 Identity-Aware Proxy 是一個強大的工具，讓企業能夠基於身份來控制應用和資源的存取，進一步強化雲端安全性。透過簡單的配置，您可以確保敏感應用僅能被授權的使用者存取，降低外部攻擊的風險。\n","tags":["雲端服務","GCP","IAP"]},{"title":"吉伊卡哇 - 找回躲在心理的小可愛","url":"/2024/09/10/吉伊卡哇-找回躲在心理的小可愛/","content":"\n今天想跟大家分享我最近在看的療育可愛動漫，吉伊卡哇 （ちいかわ）《Chiikawa》（日語：ちいかわ）一開始是由日本漫畫家ナガノ（Nagano）創作的漫畫該系列自2020年1月起透過Twitter進行連載，以「希望變成這樣的樣子」的說明一起被描繪出來。\n\n原來這個漫畫已經4年這麼久了呀?! 大家對個漫畫有興趣的話可以去追蹤作者的X哦 ngnchiikawa＠twitter\n\n![image](https://hackmd.io/_uploads/SJJK4FhhC.png)\n>圖片來源 ngnchiikawa＠twitter\n\n\n吉伊卡哇是由日文的小的ちいさい（chiisai）跟可愛的かわいい（kawaii）組合起來意思就是小可愛，故事是由吉依卡哇、小八貓與烏薩奇這三個角色展開，每一集的時間都不長大約一分半，而且角色大部分都沒有台詞，主要會講話的是小八貓而且聲音超級可愛，現在看來感覺每一集都好療育，搭配上水墨的畫風線條跟簡單的配色整體的感覺很舒服。\n\n# 吉伊卡哇（ちいかわ）\n![image](https://hackmd.io/_uploads/SkGcXth2R.png)\n>圖片來源 ngnchiikawa＠twitter\n\n吉伊卡哇是一隻小白鼠，個性給我的感覺就是內向害羞又膽小，遇到很多事情都不敢主動表達，而且常常看到它在哭，臉上都是有眼淚的表情，搭配上哭哭的配音就覺得好可憐又可愛，是個非常善良的小可愛，雖然常常看到膽小的吉伊卡哇在害怕，但是愈到了關鍵時刻又會為了朋友奮不顧身，真是一個勇敢的好孩子。\n\n![image](https://hackmd.io/_uploads/SyYC7YnnC.png)\n>圖片來源 ngnchiikawa＠twitter\n\n\n# 小八（ハチワレ）\n\n![image](https://hackmd.io/_uploads/r1djEF3nR.png)\n>圖片來源 ngnchiikawa＠twitter\n\n小八是吉伊卡哇最好的朋友，是一隻白色的小貓有藍色的耳朵，也是這部作品裡面最常說話的角色，常常幫助吉依卡哇，雖然小八貓家裡很窮又住在山洞裡，但是小八貓常常表現得很樂觀，而且很願意跟朋友分享食物，也很重視朋友送給它的東西，又是個有夢想的小可愛，雖然很窮但是很願意存錢買自己喜歡的東西，像是相機與吉他，小八貓還有自己彈吉他唱歌的劇情超級可愛\n\n![image](https://hackmd.io/_uploads/HkVvEF22R.png)\n>圖片來源 ngnchiikawa＠twitter\n\n\n\n![image](https://hackmd.io/_uploads/SyFXVKnnC.png)\n>圖片來源 ngnchiikawa＠twitter\n\n![image](https://hackmd.io/_uploads/SydNVFn3C.png)\n>圖片來源 ngnchiikawa＠twitter\n\n\n# 烏薩奇（うさぎ）\n\n烏薩奇是裡面最活潑的小可愛，形象是一隻兔子，出場就會發出很開心的叫聲，感覺隨時都很興奮的狀態有點瘋瘋的，常常會「嗚啦」、「呀哈」，其中我最喜歡的是烏薩奇常常發出「蛤」的聲音，是小可愛中最勇敢的角色，看似神經大條，但卻很聰明，常常幫小八跟吉伊卡哇解決困難，而且還有很厲害的討伐武器\n\n![image](https://hackmd.io/_uploads/Hy2SXY32A.png)\n>圖片來源 ngnchiikawa＠twitter\n\n![image](https://hackmd.io/_uploads/SJFrEthnA.png)\n>圖片來源 ngnchiikawa＠twitter\n\n\n# 世界觀設定\n![image](https://hackmd.io/_uploads/HJLWz5nhC.png)\n>圖片來源 ngnchiikawa＠twitter\n\n在吉伊卡哇的世界中，存在著嚴苛的階級與勞動制度。居民們必須透過大量的勞動，如除草、討伐、工廠作業，才能賺取足夠的金錢維持生活。\n\n儘管角色們十分可愛，吉伊卡哇的很多情節實際上都讓人聯想到社會的黑暗面，可愛的畫風和懸疑劇情的搭配更讓讀者毛骨悚然。\n\n# 總結\n![image](https://hackmd.io/_uploads/HJmvXY3nR.png)\n>圖片來源 ngnchiikawa＠twitter\n\n以上就是吉伊卡哇的介紹，我很喜歡看吉伊卡哇日常享受食物的劇情，而且他們的生活也都需要工作賺錢，辛苦完成討伐來取得錢來購買生活中需要的物品，也常常讓我帶入到我的日常生活上挑戰的感覺，看著吉依卡哇露出可憐的哭哭表情說著不要，或是小八常常保持樂觀積極，又或是烏薩奇聰明又神經大條的化解難題，也是我想要成為的樣子，很羨慕吉伊卡哇身邊有小八跟烏薩奇這麼好的朋友，好期待後續吉伊卡哇的劇情發展。\n\n","tags":["動漫","吉伊卡哇","療育","卡通","可愛"]},{"title":"GCP - Qwiklabs課程紀錄 Orchestrating the Cloud with Kubernetes","url":"/2024/09/05/GCP-Google-Cloud-Skills-Boost-的-Qwiklabs課程紀錄-Orchestrating-the-Cloud-with-Kubernetes/","content":"\n\n![image](https://hackmd.io/_uploads/rkwy8lD3A.png)\n\n今天這篇文章是在記錄我練習Google Cloud Skills Boost 官方學習資源平台的過程，今天練習的課程是 Orchestrating the Cloud with Kubernetes，這個 實踐實驗室（Qwiklabs） 主題是在介紹 透過 Kubernetes 自動化調度管理雲端資源 功能。\n![image](https://hackmd.io/_uploads/BJ42MxP3R.png)\n\n# GSP021\n![image](https://hackmd.io/_uploads/ry3n7gD2C.png)\n\n# 總覽\n\nKubernetes 是開放原始碼專案 (可透過 kubernetes.io 存取)，能夠在許多不同環境中運作，包括筆記型電腦、高可用性的多節點叢集、公有雲、地端部署、虛擬機器和裸機環境。\n\n在本研究室中，使用 Kubernetes Engine 等代管環境可讓您專心體驗 Kubernetes，不必費心設定基礎架構。Kubernetes Engine 是專用於部署容器化應用程式的代管環境。這項服務匯集了開發人員效率提升、資源效率、自動化作業和開放原始碼靈活性等方面的最新技術，有助於縮短上市時間。\n\n\n{% note info simple %}\n應用程式託管於 GitHub，並提供 12 因子應用程式範例。在本研究室中，將使用以下 Docker 映像檔：\n* kelseyhightower/monolith：包含 Auth 和 Hello 服務的單體。\n* kelseyhightower/auth：Auth 微服務，可為通過驗證的使用者產生 JWT 權杖。\n* kelseyhightower/hello：Hello 微服務，會向通過驗證的使用者打招呼。\n* nginx：Auth 和 Hello 服務的前端。\n{% endnote %}\n\n# 目標\n\n* 使用 Kubernetes Engine 佈建完整的 Kubernetes 叢集。\n* 使用 kubectl 部署及管理 Docker 容器。\n* 使用 Kubernetes 的 Deployment 和 Service 將應用程式拆解成微服務。\n\n\n# Google Kubernetes Engine\n\n1. 在 Cloud Shell 環境中，輸入以下指令來設定可用區：\n```\ngcloud config set compute/zone us-central1-c\n```\n\n2. 啟動要使用的cluster：\n```\ngcloud container clusters create io --zone us-central1-c\n```\n\n# 工作 1：取得程式碼範例\n1. 從 Cloud Shell 指令列複製原始碼：\n```\ngsutil cp -r gs://spls/gsp021/* .\n```\n2. 變更為本研究室所需的目錄：\n\n```\ncd orchestrate-with-kubernetes/kubernetes\n```\n3. 列出檔案以便查看：\n\n```\nls\n```\n\n# 工作 2：Kubernetes 快速示範\n如要開始使用 Kubernetes，最簡單的方法是運用 `kubectl create` 指令。\n\n1. 使用這項指令啟動 nginx 容器的單一執行個體：\n\n```\nkubectl create deployment nginx --image=nginx:1.10.0\n```\n\nKubernetes 已建立 Deployment。稍後會再針對 Deployment 進行說明，目前您只需要知道 Deployment 可讓 Pod 保持運作，即使執行 Pod 的節點發生問題也沒關係。\n\nKubernetes 中的所有容器都是透過 Pod 執行。\n\n2. 使用 `kubectl get pods` 指令查看運作中的 nginx 容器：\n\n```\nkubectl get pods\n```\n\n3. nginx 容器處於「運作中」狀態後，您就可以使用 kubectl expose 指令，在 Kubernetes 外部公開該容器：\n\n```\nkubectl expose deployment nginx --port 80 --type LoadBalancer\n```\n\n4. 使用 `kubectl get services` 指令列出服務：\n```\nkubectl get services\n```\n{% note info simple %}\n「ExternalIP」欄位可能需要幾秒鐘才會填入服務的外部 IP 位址。這是正常現象，只要每隔幾秒重新執行 kubectl get services 指令，直到該欄位填入位址即可。\n{% endnote %}\n\n5. 在這項指令中加入外部 IP，從遠端連至該 Nginx 容器：\n\n```\ncurl http://<External IP>:80\n```\n\n![image](https://hackmd.io/_uploads/HkOmZA8hC.png)\n\n![image](https://hackmd.io/_uploads/BJ-SW0U2A.png)\n\n# 工作 3：Pod\nKubernetes 的核心是 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/)。\n\nPod 代表並存放了一或多個容器。一般來說，如果多個容器之間有硬相依性，就可以包裝在同一個 Pod 中。\n\n![image](https://hackmd.io/_uploads/H1wD-RLn0.png)\n\n這個範例中有一個包含單體和 nginx 容器的 Pod。\n\nPod 也有[磁碟區](https://kubernetes.io/docs/concepts/storage/volumes/)。磁碟區是效期與 Pod 相同的資料磁碟，可由該 Pod 中的容器使用。Pod 為所含內容提供共用命名空間，因此範例 Pod 中的兩個容器可互相通訊，並且共用所連接的磁碟區。\n\n不同的 Pod 還會共用網路命名空間，因此每個 Pod 都有一個 IP 位址。\n\n接著讓我們來深入瞭解 Pod。\n\n# 工作 4：建立 Pod\nPod 可使用 Pod 設定檔建立。請花點時間瞭解單體 Pod 設定檔。\n1.前往目錄：\n```\ncd ~/orchestrate-with-kubernetes/kubernetes\n```\n\n2.執行以下指令：\n```\ncat pods/monolith.yaml\n```\n\n![image](https://hackmd.io/_uploads/Sk2CbRI3A.png)\n\n輸出結果會顯示公開設定檔：\n```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: monolith\n  labels:\n    app: monolith\nspec:\n  containers:\n    - name: monolith\n      image: kelseyhightower/monolith:1.0.0\n      args:\n        - \"-http=0.0.0.0:80\"\n        - \"-health=0.0.0.0:81\"\n        - \"-secret=secret\"\n      ports:\n        - name: http\n          containerPort: 80\n        - name: health\n          containerPort: 81\n      resources:\n        limits:\n          cpu: 0.2\n          memory: \"10Mi\"\n```\n\n這裡有幾點要注意。從輸出結果可看出：\n\n* Pod 包含一個容器 (單體)。\n* 您在容器啟動時傳遞了幾個引數至容器。\n* 您開啟了用於 http 流量的通訊埠 80。\n\n3. 使用 `kubectl` 建立單體 Pod：\n\n```\nkubectl create -f pods/monolith.yaml\n```\n![image](https://hackmd.io/_uploads/B1iVz08hA.png)\n\n\n4. 檢查 Pod。請使用 `kubectl get pods` 指令列出在預設命名空間中運作的所有 Pod：\n\n```\nkubectl get pods\n```\n\n![image](https://hackmd.io/_uploads/rJ-IMC83R.png)\n\n{% note info simple %}\n單體 Pod 可能需要幾秒鐘才會開始運作。單體容器映像檔必須先從 Docker Hub 提取出來才能執行。\n{% endnote %}\n\n5. Pod 開始運作後，請使用 `kubectl describe` 指令取得更多有關該單體 Pod 的資訊：\n\n```\nkubectl describe pods monolith\n```\n\n您會看到許多關於該單體 Pod 的資訊，包括 Pod 的 IP 位址和事件記錄。這些資訊在疑難排解時可派上用場。\n\n![image](https://hackmd.io/_uploads/HkVe7A8n0.png)\n\nKubernetes 可根據設定檔中的描述建立 Pod，並讓您在 Pod 運作時輕鬆查看相關資訊。到了這個階段，您已經可以建立 Deployment 所需的所有 Pod！\n\n\n# 工作 5：與 Pod 互動\n\n根據預設，Pod 會獲分配私人 IP 位址，且無法從叢集外部連線。請使用 `kubectl port-forward` 指令將本機通訊埠對應至單體 Pod 內部的通訊埠。\n\n{% note info simple %}\n在本研究室的後續部分中，您必須透過多個 Cloud Shell 分頁設定 Pod 之間的通訊。如果指令是透過第二或第三個指令殼層執行，則會在指令的操作說明中標示。\n{% endnote %}\n\n1. 開啟第二個 Cloud Shell 終端機。您現在有兩個終端機，分別用於執行 `kubectl port-forward` 指令及下達 `curl` 指令。\n\n![image](https://hackmd.io/_uploads/Hk44Q0I3C.png)\n\n2. 在第 2 個終端機中，執行以下指令來設定通訊埠轉送：\n\n```\nkubectl port-forward monolith 10080:80\n```\n\n![image](https://hackmd.io/_uploads/BytLXAInC.png)\n\n3.接著在第 1 個終端機中使用 curl 開始與 Pod 通訊：\n```\ncurl http://127.0.0.1:10080\n```\n![image](https://hackmd.io/_uploads/rJItmCI3A.png)\n\n很好！容器傳回了友善的回應：「Hello」。\n\n4. 接著使用 `curl` 指令，看看連到安全端點時會發生什麼事：\n\n```\ncurl http://127.0.0.1:10080/secure\n```\n\n![image](https://hackmd.io/_uploads/SJe6XAI3C.png)\n\n糟糕！\n\n5. 嘗試登入，從單體取回驗證權杖：\n\n```\ncurl -u user http://127.0.0.1:10080/login\n```\n![image](https://hackmd.io/_uploads/SJgmHVA8nC.png)\n\n6. 畫面上顯示登入提示時，使用密碼登入。\n![image](https://hackmd.io/_uploads/rypEHRIhR.png)\n這邊的密碼在這邊\n\n7. 由於 Cloud Shell 無法妥善複製較長的字串，因此請為權杖建立環境變數。\n\n```\nTOKEN=$(curl http://127.0.0.1:10080/login -u user|jq -r '.token')\n```\n\n![image](https://hackmd.io/_uploads/HJvYHCI2A.png)\n\n8. 系統提示您輸入主機密碼時，再次輸入密碼。\n9. 使用以下指令複製權杖，並透過 `curl` 使用該權杖連至安全端點：\n```\ncurl -H \"Authorization: Bearer $TOKEN\" http://127.0.0.1:10080/secure\n```\n應用程式應該會傳回回應，讓我們知道一切都運作正常。\n\n10. 使用 `kubectl logs` 指令查看 `monolith` Pod 的記錄。\n\n```\nkubectl logs monolith\n```\n\n![image](https://hackmd.io/_uploads/r13L8AIn0.png)\n\n11. 開啟第 3 個終端機，並使用 -f 標記取得即時記錄串流：\n\n```\nkubectl logs -f monolith\n```\n![image](https://hackmd.io/_uploads/BkB9LRL3C.png)\n\n\n12. 如果您在第 1 個終端機中使用 curl 與單體互動，記錄就會在第 3 個終端機中更新：\n\n```\ncurl http://127.0.0.1:10080\n```\n\n![image](https://hackmd.io/_uploads/Bk5hI0Ln0.png)\n\n![image](https://hackmd.io/_uploads/BkhTUAUnR.png)\n\n13.使用 `kubectl exec` 指令在單體 Pod 內執行互動式殼層。如要在容器內進行疑難排解，這個殼層就能派上用場：\n```\nkubectl exec monolith --stdin --tty -c monolith -- /bin/sh\n```\n\n![image](https://hackmd.io/_uploads/rkS7D0L30.png)\n\n14. 舉例來說，在單體容器中建立殼層後，您就能使用 ping 指令測試外部連線：\n```\nping -c 3 google.com\n```\n\n![image](https://hackmd.io/_uploads/SydLw08hR.png)\n\n15.使用完這個互動式殼層後，請務必登出。\n```\nexit\n```\n\n![image](https://hackmd.io/_uploads/Hy8KvA8hA.png)\n\n如您所見，只要使用 `kubectl` 指令，就能輕鬆與 Pod 互動。如需從遠端連至容器，或是取得登入殼層，Kubernetes 提供所有必要資源。\n\n# 工作 6：Service\n\nPod 不會永久有效，可能會因許多因素停止或啟動 (例如未通過有效性或完備性檢查)，進而造成一個問題：\n\n與一組 Pod 通訊會發生什麼情形？這些 Pod 重新啟動時可能會有不同的 IP 位址。\n\n在這種時候，[Service](https://kubernetes.io/docs/concepts/services-networking/service/) 便能派上用場。Service 可為 Pod 提供穩定的端點。\n\n![image](https://hackmd.io/_uploads/HkHnwRI3R.png)\n\nService 會根據標籤決定要在哪個 Pod 上運作。如果 Pod 的標籤正確，Service 就會自動辨識並公開 Pod。\n\nService 為一組 Pod 提供的存取層級取決於 Service 類型。目前 Service 分為以下三種：\n\n* ClusterIP (內部)：這是預設類型，表示這項 Service 只會在叢集內部顯示\n* NodePort：為叢集中的每個節點提供可從外部存取的 IP\n* LoadBalancer：新增雲端服務供應商的負載平衡器，用於將 Service 的流量轉送至當中的節點\n\n接下來您將瞭解如何：\n\n* 建立 Service\n* 使用標籤選取器，對外公開一部分的 Pod\n\n# 工作 7：建立 Service\n\n在建立 Service 前，請先建立可處理 https 流量的安全 Pod。\n\n1. 如果您變更了目錄，請務必返回 `~/orchestrate-with-kubernetes/kubernetes` 目錄：\n\n```\ncd ~/orchestrate-with-kubernetes/kubernetes\n```\n\n2. 查看單體 Service 設定檔：\n\n```\ncat pods/secure-monolith.yaml\n```\n\n![image](https://hackmd.io/_uploads/S1a6OAI3C.png)\n\n3. 建立安全單體 Pod 及其設定資料：\n```\nkubectl create secret generic tls-certs --from-file tls/\nkubectl create configmap nginx-proxy-conf --from-file nginx/proxy.conf\nkubectl create -f pods/secure-monolith.yaml\n```\n\n您已建立安全的 Pod，接著要對外公開安全單體 Pod。為此，請建立 Kubernetes Service。\n\n![image](https://hackmd.io/_uploads/SyXWYA830.png)\n\n\n4. 查看單體 Service 設定檔：\n\n```\ncat services/monolith.yaml\n```\n輸出內容：\n```\nkind: Service\napiVersion: v1\nmetadata:\n  name: \"monolith\"\nspec:\n  selector:\n    app: \"monolith\"\n    secure: \"enabled\"\n  ports:\n    - protocol: \"TCP\"\n      port: 443\n      targetPort: 443\n      nodePort: 31000\n  type: NodePort\n```\n\n![image](https://hackmd.io/_uploads/BJbQtCIhC.png)\n\n{% note info simple %}\n注意事項：\n* 輸出內容包含選取器，用來自動尋找及公開含有「app: monolith」和「secure: enabled」標籤的 Pod。\n\n* 現在您必須公開節點通訊埠，這樣才能將外部流量從通訊埠 31000 轉送至位於通訊埠 443 的 nginx。\n{% endnote %}\n\n5. 使用 `kubectl create` 指令，透過單體 Service 設定檔建立單體 Service：\n\n```\nkubectl create -f services/monolith.yaml\n```\n\n輸出內容：\n```\nservice/monolith created6\n```\n\n![image](https://hackmd.io/_uploads/B1zUYRU3A.png)\n\n\n測試已完成的工作\n\n請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功建立單體 Pod 和 Service，就會看到評量分數。\n![image](https://hackmd.io/_uploads/B1Jj_C830.png)\n\n您是使用通訊埠公開 Service，因此如果其他應用程式嘗試繫結至其中一個伺服器的通訊埠 31000，可能會發生通訊埠衝突。\n\n在一般情況下，Kubernetes 會處理通訊埠指派作業，但在本研究室中，您自行選擇了通訊埠，以便之後設定健康狀態檢查。\n\n6. 使用 `gcloud compute firewall-rules` 指令，允許流量傳送到公開節點通訊埠上的單體 Service：\n```\ngcloud compute firewall-rules create allow-monolith-nodeport \\\n  --allow=tcp:31000\n```\n\n![image](https://hackmd.io/_uploads/Byc3tAU3C.png)\n\n測試已完成的工作\n請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功建立防火牆規則來允許通訊埠 31000 的 TCP 流量，就會看到評量分數。\n\n![image](https://hackmd.io/_uploads/HJVoY08n0.png)\n\n一切都設定完成後，您應該就能從叢集外部連至安全單體 Service，不必使用通訊埠轉送。\n\n1. 首先，取得其中一個節點的外部 IP 位址。\n\n```\ngcloud compute instances list\n```\n![image](https://hackmd.io/_uploads/r1EQ508nA.png)\n\n2. 接著使用 curl 嘗試連至安全單體 Service：\n\n```\ncurl -k https://<EXTERNAL_IP>:31000\n```\n\n![image](https://hackmd.io/_uploads/HyPDqCU2A.png)\n\n\n糟糕！作業逾時。發生了什麼事？\n\n{% note info simple %}\n附註：來驗收一下您的學習成果吧。\n\n請使用以下指令回答下方問題：\nkubectl get services monolith\n\nkubectl describe services monolith\n\n問題：\n\n為何單體 Service 無法傳回回應？\n單體 Service 有幾個端點？\nPod 必須有哪些標籤，單體 Service 才能辨識？\n{% endnote %}\n\n提示：關鍵在於標籤。您將在下一節修正錯誤。\n\n# 工作 8：為 Pod 新增標籤\n\n目前單體 Service 沒有端點。如要排解這類問題，其中一個方法是使用 `kubectl get pods` 指令和標籤查詢。\n\n1.您會發現有幾個包含單體標籤的 Pod 正在運作。\n```\nkubectl get pods -l \"app=monolith\"\n```\n\n![image](https://hackmd.io/_uploads/Sy-3qRIhA.png)\n\n\n2.但如果是「app=monolith」和「secure=enabled」呢？\n```\nkubectl get pods -l \"app=monolith,secure=enabled\"\n```\n![image](https://hackmd.io/_uploads/By3aqAIhA.png)\n\n您會發現這個標籤查詢並未顯示任何結果。您似乎需要加上「secure=enabled」標籤。\n\n3. 使用 `kubectl label` 指令，為安全單體 Pod 新增缺少的 `secure=enabled` 標籤。完成後，您可以確認標籤是否已更新。\n\n```\nkubectl label pods secure-monolith 'secure=enabled'\nkubectl get pods secure-monolith --show-labels\n```\n\n![image](https://hackmd.io/_uploads/HJY-jRI2C.png)\n\n\n4. 為 Pod 加上正確標籤後，請查看單體 Service 的端點清單：\n```\nkubectl describe services monolith | grep Endpoints\n```\n![image](https://hackmd.io/_uploads/HyX4oC8hC.png)\n\n5. 再次連到其中一個節點進行測試。\n\n```\ngcloud compute instances list\ncurl -k https://<EXTERNAL_IP>:31000\n```\n\n![image](https://hackmd.io/_uploads/SJSDoAIhA.png)\n\n測試已完成的工作\n請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功為單體 Pod 新增標籤，就會看到評量分數。\n![image](https://hackmd.io/_uploads/SyW_oA8hR.png)\n\n\n# 工作 9：透過 Kubernetes 部署應用程式\n\n本研究室的目標是協助您做好準備，以便在實際工作環境中調度資源及管理容器。在這種時候，[Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#what-is-a-deployment) 便能派上用場。Deployment 可透過宣告方式，確保運作中的 Pod 數量與使用者指定的所需 Pod 數量相同。\n\n![image](https://hackmd.io/_uploads/Hk15oR8h0.png)\n\nDeployment 的主要好處在於簡化了 Pod 管理作業的低層級細節。Deployment 實際上會使用 [ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/) 來啟動及停止 Pod。如果 Pod 需要更新或調度資源，Deployment 就會處理。假如 Pod 因故停止運作，Deployment 也可重新啟動 Pod。\n\n請查看以下簡短範例：\n\n![image](https://hackmd.io/_uploads/SkS3iRIhR.png)\n\n\nPod 的生命週期取決於建立時所在的節點。在上方範例中，Node3 已停止運作，並連帶使一個 Pod 停止運作。在這個情況下，Deployment 建立了新的 Pod 並在 Node2 上啟動該 Pod，因此您不必手動建立新的 Pod 及尋找節點。\n\n很方便吧！\n\n接著來運用您學到的所有 Pod 和 Service 相關知識，使用 Deployment 將單體式應用程式拆解成較小的 Service。\n\n# 工作 10：建立 Deployment\n您要將單體式應用程式拆解成三個不同的部分：\n\n* Auth：為通過驗證的使用者產生 JWT 權杖。\n* Hello：向通過驗證的使用者打招呼。\n* Frontend：將流量轉送至 Auth 和 Hello Service。\n\n您現在可以為每項 Service 分別建立 Deployment。之後，您將為 Auth 和 Hello Deployment 定義內部 Service，並為 Frontend Deployment 定義外部 Service。完成後，您就能像處理單體一樣與微服務互動，只不過每項微服務都能獨立調度資源和部署！\n\n1.首先檢查 Auth Deployment 設定檔。\n\n```\ncat deployments/auth.yaml\n```\n輸出內容\n\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: auth\nspec:\n  selector:\n    matchlabels:\n      app: auth\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: auth\n        track: stable\n    spec:\n      containers:\n        - name: auth\n          image: \"kelseyhightower/auth:2.0.0\"\n          ports:\n            - name: http\n              containerPort: 80\n            - name: health\n              containerPort: 81\n...\n```\n\nDeployment 建立了 1 個備用資源，而您使用的是 2.0.0 版的 Auth 容器。\n\n執行 `kubectl create` 指令來建立 Auth Deployment 時，會產生一個符合 Deployment 資訊清單資料的 Pod。這表示您可以變更「Replicas」欄位指定的數字來調整 Pod 數量。\n\n2.總之，請建立 Deployment 物件：\n```\nkubectl create -f deployments/auth.yaml\n```\n\n3. 接著來建立 Auth Deployment 的 Service。使用 kubectl create 指令建立 Auth Service：\n\n```\nkubectl create -f services/auth.yaml\n```\n\n4. 現在使用相同指令來建立並公開 Hello Deployment：\n\n```\nkubectl create -f deployments/hello.yaml\nkubectl create -f services/hello.yaml\n```\n\n5. 再次使用相同指令來建立並公開 Frontend Deployment：\n\n```\nkubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.conf\nkubectl create -f deployments/frontend.yaml\nkubectl create -f services/frontend.yaml\n```\n\n{% note info simple %}\n您必須透過容器儲存設定資料，因此要另外建立 Frontend。\n{% endnote %}\n\n6. 與 Frontend 互動，擷取其外部 IP 並執行 curl 指令：\n\n```\nkubectl get services frontend\n```\n\n![image](https://hackmd.io/_uploads/rkX52RL2R.png)\n\n{% note info simple %}\n外部 IP 位址可能需要一分鐘才能產生。如果 EXTERNAL-IP 欄狀態為「待處理」，請再次執行上方指令。\n{% endnote %}\n\n```\ncurl -k https://<EXTERNAL-IP>\n```\n\n您會收到「hello」回應！\n\n測試已完成的工作\n請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功建立 Auth、Hello 和 Frontend Deployment，就會看到評量分數。\n\n![image](https://hackmd.io/_uploads/HJZPhRIhA.png)\n\n# 總結\n這篇文章記錄在 Google Cloud Skills Boost 上學習 \"Orchestrating the Cloud with Kubernetes\" 的過程，並介紹了 Kubernetes 的基本概念與實際操作流程。內容涵蓋如何建立 Kubernetes 叢集、部署容器、與 Pod 互動等，使用 kubectl 指令來進行 Kubernetes 管理與資源操作。","tags":["GCP","Kubernetes"]},{"title":"GCP - 微服務管理工具 Anthos Service Mesh","url":"/2024/09/05/GCP-微服務管理工具-Anthos-Service-Mesh/","content":"\n隨著微服務架構在現代應用程式開發中的普及，如何有效管理和保護這些服務成為了企業面臨的一大挑戰。GCP Anthos Service Mesh 正是為了解決這些問題而設計的。本文將帶您深入了解這項強大的工具，並展示它如何幫助企業提升微服務的可觀察性、安全性和管理效率。\n\n![image](https://hackmd.io/_uploads/rkpXM8H2C.png)\n>https://cloud.google.com/anthos/service-mesh?hl=zh-tw \n\n\n# 什麼是 Anthos Service Mesh?\n\n![image](https://hackmd.io/_uploads/BJLIMLSnA.png)\n> https://cloud.google.com/anthos/service-mesh?hl=zh-tw\n\nAnthos Service Mesh 是由 Google Cloud 提供的一種開源服務網格解決方案，它建立在 Istio 架構之上，專門用於管理微服務之間的流量和安全性。它為企業提供了一個統一的平台來管理分散在多個 Kubernetes 集群中的微服務，並確保這些服務之間的通信安全和高效。\n\nAnthos Service Mesh 的核心功能包括：\n**服務發現**：自動識別並管理微服務之間的相互依賴關係。\n**負載均衡**：根據服務的運行狀態和性能自動調整流量分配。\n**安全通信**：通過啟用自動化的 mTLS 加密，確保所有服務之間的通信安全。\n**監控和可觀察性**：提供深入的監控工具，讓運維人員可以實時查看服務的性能數據。\n\n# 什麼是 Istio?\n\nIstio 是一個開源的**服務網格 (Service Mesh)**，它為微服務架構提供了統一的連線、安全性、可觀察性和策略管理功能。具體來說，Istio 可以幫助管理服務之間的通信，無需改動應用程式的程式碼，並且能在複雜的分散式系統中實現流量控制、服務間安全通信、故障處理、以及性能監控等功能。\n\n## Istio 的核心功能：\n1. **流量管理**：Istio 提供細粒度的流量控制能力，允許設定服務之間的流量分配，如負載平衡、故障轉移、AB 測試、金絲雀發布等。\n   \n2. **安全性**：透過強化身份驗證、授權控制和加密通信，Istio 確保微服務之間的通信是安全的。\n\n3. **可觀察性**：它自動收集微服務間的網路流量數據，並生成詳細的日誌、度量和追蹤資料，方便監控和排查問題。\n\n4. **策略管理**：Istio 可以應用不同的策略，如速率限制 (Rate Limiting)、配額控制、重試等，來保護和管理服務。\n\n## Istio 的架構：\nIstio 主要由兩個核心組件構成：\n- **Data Plane** (資料平面)：使用 Envoy 代理，攔截並管理所有服務之間的網路流量。\n- **Control Plane** (控制平面)：管理和配置代理，並處理流量的路由策略和安全政策。\n\n總的來說，Istio 是專為微服務架構設計的，能夠提升應用的可觀察性、安全性和可靠性，是現代分散式系統中的重要工具之一。\n\n# Anthos Service Mesh 的關鍵優勢\n\n## 可觀察性\n![image](https://hackmd.io/_uploads/Syw3GIrhR.png)\n\nAnthos Service Mesh 提供了豐富的監控和分析工具，可以讓企業深入了解微服務的運行狀況。透過服務網格的拓撲圖、請求流量分析和錯誤率統計，運維人員可以快速發現並解決潛在問題，從而提高整體系統的穩定性。\n\n## 安全性\n![image](https://hackmd.io/_uploads/H1jizLB20.png)\n\n在現代企業應用中，安全性始終是重中之重。Anthos Service Mesh 自動啟用 mTLS 加密，確保所有微服務之間的通信都是安全的。此外，它還支持基於策略的訪問控制，允許企業精細化地管理每個服務的訪問權限。\n\n## 流量管理\n![image](https://hackmd.io/_uploads/Sy0nfLBnC.png)\n\nAnthos Service Mesh 支持多種流量控制策略，如藍綠部署和金絲雀發布，這使得企業能夠在不影響用戶體驗的情況下安全地推出新版本。這些功能讓開發和運維團隊能夠更靈活地管理應用的升級過程。\n\n## 跨集群支持\n![image](https://hackmd.io/_uploads/H1kJm8H2C.png)\n\nAnthos Service Mesh 能夠在多個 GKE 集群之間提供一致的服務網格管理，支持跨區域的服務部署和高可用性。這意味著即使某一個集群發生故障，其他集群依然能夠承擔流量，確保應用的連續性。\n\n# 如何使用 Anthos Service Mesh\n\n可以進入google 官方文件查看入門導覽教學\n![image](https://hackmd.io/_uploads/HklMXIH3C.png)\n>https://cloud.google.com/kubernetes-engine/enterprise/docs/learn/scalable-apps?_ga=2.238410240.1494422275.1592695936-1900483699.1589728994&%3B_gac=1.91806056.1592697064.Cj0KCQjwoaz3BRDnARIsAF1RfLd1AG6iP5E0DlpdRVXB9SYvt2H_ML7e7Jg99akGivXs32s4NfgQge8aAmUxEALw_wcB\n\n\n還有有以下介紹資源\n![image](https://hackmd.io/_uploads/rJ-v7LH2A.png)\n>https://cloud.google.com/anthos/service-mesh?hl=zh-tw\n\n## 部署過程\n首先，您需要在 GKE 上啟用並配置 Anthos Service Mesh。這通常涉及到設置 Istio 控制平面和數據平面，並將其集成到您的現有 Kubernetes 集群中。\n\n## 服務發現與流量路由\n一旦 Anthos Service Mesh 部署完成，您可以使用它來進行跨集群的服務發現與流量管理。這允許您將流量根據需求分配到不同的集群，並確保服務始終可用。\n\n## 監控與可觀察性\nAnthos Service Mesh 提供了豐富的監控工具，讓您可以實時查看微服務的運行狀況。您可以設置服務級別目標（SLOs），並根據這些指標來監控服務的健康狀況，及時發現並解決潛在問題。\n\n\n# 結論\n\nAnthos Service Mesh 是一個功能強大且靈活的微服務管理解決方案，特別適合那些需要管理複雜微服務架構的企業。它的核心優勢在於其卓越的可觀察性、安全性和流量管理能力，讓企業能夠更輕鬆地管理和擴展其應用。","tags":["GCP","Anthos"]},{"title":"考救生員訓練紀錄 - 報名體育署救生檢定","url":"/2024/09/03/考救生員訓練紀錄-報名體育署救生檢定/","content":"\n# 前言\n\n![image](https://hackmd.io/_uploads/BkkkvN4hR.png)\n\n繼上一篇文章 [我想要再去當救生員](https://gahgah147.github.io/2024/07/26/%E6%88%91%E6%83%B3%E8%A6%81%E5%86%8D%E5%8E%BB%E7%95%B6%E6%95%91%E7%94%9F%E5%93%A1/?highlight=%E6%88%91%E6%83%B3%E8%A6%81%E5%86%8D%E5%8E%BB%E7%95%B6%E6%95%91%E7%94%9F%E5%93%A1)之後，順利過完了2週的訓練，其實覺得還蠻充實的，而且還有三天的海訓在福隆，感覺特別充實當天在旁邊還有音樂季耶，感覺夏天的海邊就是很棒，結訓之後就是要準備報名體育署的檢定了。\n\n# 線上報名檢定流程\n\n報名流程教學網址如下:\n![image](https://hackmd.io/_uploads/SJjduN2qR.png)\n>https://isports.sa.gov.tw/apps/Fessay.aspx?SYS=LGM&MENU_CD=M10&ITEM_CD=T15&MENU_PRG_CD=3&ITEM_PRG_CD=6\n\n首先新進入教育部體育署救生員報名網頁\n\n\n會員註冊畫面如下\n![image](https://hackmd.io/_uploads/B187ENnqA.png)\n>https://isports.sa.gov.tw/Apps/MEM/MEM01/MEM0100M_01V1.aspx?SYS=LGM\n\n![image](https://hackmd.io/_uploads/BJY97VhcA.png)\n![image](https://hackmd.io/_uploads/ryzb4Eh9A.png)\n\n\n註冊完成後登入點選**救生員證書檢定報名**\n![image](https://hackmd.io/_uploads/rkcOENh9R.png)\n\n\n在這邊可以點選擇場次開始選擇\n![image](https://hackmd.io/_uploads/Bya0NNhc0.png)\n\n選取檢定場次，這邊可以找一下離家近的場次\n![image](https://hackmd.io/_uploads/H1kGrNh5R.png)\n\n我這邊選的是國立臺灣科技大學的場次\n![image](https://hackmd.io/_uploads/HkLp8Vhc0.png)\n\n報名資格我選的是訓練證明，因為是最近完成新訓取得的證明\n\n設定可服務地點，我這邊選擇新北市跟台北市\n![image](https://hackmd.io/_uploads/rynNP43qR.png)\n\n接下來填寫報名資料\n![image](https://hackmd.io/_uploads/SyqgFE39A.png)\n\n接下來是提供相關證明文件\n![image](https://hackmd.io/_uploads/HyHFYV25A.png)\n\n這邊有些資料要填寫像是\n\n* 身分證正反面\n* 警察刑事紀錄證明\n* 健康諮詢表\n* 證照大頭照\n\n# 申請良民證\n\n這邊要先去警察局辦良民證，可以先找附近進的警察局線上辦好，再找時間去現場領。\n\n可以進入以下頁面警察刑事紀錄證明網站申請\n![image](https://hackmd.io/_uploads/rJkfr4E20.png)\n\n>https://eli.npa.gov.tw/E7WebO/index01.jsp\n\n要滑下來到這邊按申辦\n![image](https://hackmd.io/_uploads/H16jB4VnR.png)\n\n\n![image](https://hackmd.io/_uploads/HJGCSNNhA.png)\n\n在這邊建議選網路申請臨櫃領證，因為我用另外一邊MyData覺得不好用，會一直重複跳不出去。\n\n# 考前準備\n## 救生員題庫\n在檢定資訊 > 救生員題庫這邊可以下載題庫練習\n![image](https://hackmd.io/_uploads/SkTIOEE3C.png)\n\n## 檢定科目示範影片區\n在檢定資訊 > 檢定科目示範影片區這邊可以看到術科項目\n![image](https://hackmd.io/_uploads/BkWVKVVhR.png)\n>https://isports.sa.gov.tw/apps/FvideoList.aspx?SYS=LGM&MENU_CD=M10&ITEM_CD=T08&MENU_PRG_CD=3&ITEM_PRG_CD=4\n\n有以下項目:基本能力、救援能力、綜合評定、急救能力測驗、救援器材運用\n\n### 基本能力\n#### 200公尺救生四式\n![image](https://hackmd.io/_uploads/B1yPoEV2R.png)\nhttps://youtu.be/sEQtR8LEYaE\n\n#### 踩水\n![image](https://hackmd.io/_uploads/SywHsN4nR.png)\nhttps://youtu.be/1QMk_Y7lrys\n\n### 救援能力\n#### 20公尺潛泳\n![image](https://hackmd.io/_uploads/SyPUsVNhC.png)\nhttps://youtu.be/2zGyJD20fD4\n\n#### 25公尺拖帶假人\n![image](https://hackmd.io/_uploads/BkgSiN42A.png)\nhttps://youtu.be/AgwEw73VOrk\n\n### 綜合評定\n#### 模擬救溺 項目一\n![image](https://hackmd.io/_uploads/rJ2OcEVnC.png)\nhttps://youtu.be/SfbAescgqJQ\n\n#### 模擬救溺 項目二\n![image](https://hackmd.io/_uploads/HyFecNV2C.png)\nhttps://youtu.be/aSSLUgJemRE\n\n#### 模擬救溺 項目三\n![image](https://hackmd.io/_uploads/HJWZ5E4n0.png)\nhttps://youtu.be/aKVrXbq0P9g\n\n### 急救能力測驗\n#### 心肺復甦術及自動體外心臟電擊去顫器\n![image](https://hackmd.io/_uploads/rJeNqEV3C.png)\n\nhttps://youtu.be/A_TOTWW_Gz8\n\n#### 異物哽塞含復甦姿勢\n![image](https://hackmd.io/_uploads/SyTS54E3R.png)\nhttps://youtu.be/Cg9Q1ecb2rk\n\n#### 長背板救援\n![image](https://hackmd.io/_uploads/H1ZEo4EnC.png)\nhttps://youtu.be/sMmV6eiuI_E\n\n### 救援器材運用\n#### 拋繩救援\n![image](https://hackmd.io/_uploads/HJFwoN4hA.png)\nhttps://youtu.be/j9cFR6K4CzM\n\n# 總結\n\n後來終於是在9月3號完成報名繳費了，我這次是報名9月22號的考試，考試地點是在台科大，希望之後考試一切順利，可以順利拿到體育署的救生員證照。","tags":["救生員"]},{"title":"GCP - VPC Network 虛擬私有雲","url":"/2024/08/30/GCP-VPC-Network-虛擬私有雲/","content":"\n\n![image](https://hackmd.io/_uploads/HkB4ZMyhR.png)\n\n# 什麼是 VPC Network ? \n![image](https://hackmd.io/_uploads/Syll6bJnA.png)\n>https://cloud.google.com/vpc?hl=zh-TW\n\nGoogle Cloud Platform (GCP) 提供的虛擬私有雲（Virtual Private Cloud，VPC）是用來管理和控制網路資源的核心工具。VPC 是一個邏輯隔離的網路環境，允許用戶在 GCP 中創建和管理他們的網路基礎架構。透過 VPC，您可以靈活地配置子網路、路由、網路安全規則以及多個區域內的網路流量。\n\n## 主要功能與特性\n\n### 1. **全球範圍的網路**\nGCP VPC 是一個全球性虛擬網路，允許您在全球範圍內創建子網路並管理其資源。無論是將資源分佈在一個區域或是多個區域，VPC 都能確保流量在 Google 的全球骨幹網路上快速且安全地傳輸，減少延遲並提升性能。\n\n### 2. **子網路 (Subnet) 和路由**\nVPC 支持區域化的子網路配置，讓用戶能夠根據需要在不同的區域中劃分子網路。每個子網路都可以與一個或多個區域相關聯，並通過靈活的路由策略來管理內部和外部的網路流量。\n\n### 3. **防火牆規則**\nGCP VPC 提供細緻的防火牆規則，允許您控制進出 VPC 的流量。這些規則可以根據 IP 地址、端口、協議等條件來設定，確保網路的安全性和隔離性。您可以使用這些規則來保護網路中的資源，並根據業務需求靈活調整。\n\n### 4. **VPC 內的私有 IP 與外部 IP**\n在 VPC 中，您可以分配私有 IP 地址給虛擬機器，這些 IP 地址僅在 VPC 內部使用。此外，您也可以為需要對外連線的資源分配外部 IP 地址。VPC 支持使用 NAT (Network Address Translation) 來管理私有 IP 的外部訪問，確保網路資源的安全性。\n\n### 5. **跨項目和跨區域的互聯 (VPC Peering)**\nGCP VPC 提供了跨項目和跨區域的 VPC Peering 功能，允許不同的 VPC 之間建立私有網路連接。這使得跨不同項目或區域的資源可以無縫地通信，同時保持網路的安全性和隔離性。\n\n### 6. **Shared VPC**\n透過 Shared VPC 功能，您可以在組織內部跨項目共享一個 VPC。這樣，您可以集中管理網路資源，而不需要在每個項目中單獨配置 VPC。Shared VPC 使得多個團隊能夠在同一個 VPC 內安全地協作。\n\n## GCP VPC 的應用場景\n\n1. **企業級網路設計**：大型企業可以利用 GCP VPC 創建全球範圍的網路架構，並透過細緻的子網路和路由配置，實現高度可擴展和安全的網路設計。\n\n2. **跨區域應用程序**：對於需要在多個地理區域運行的應用程序，VPC 提供了低延遲、高性能的全球網路環境，確保用戶無論身處何地，都能獲得一致的應用體驗。\n\n3. **混合雲連接**：透過 VPC 和 Cloud VPN 或 Cloud Interconnect 的結合，企業可以將本地數據中心與 GCP 的 VPC 安全地連接起來，實現混合雲部署，保留現有的投資並提升靈活性。\n\n4. **多租戶隔離**：利用 GCP VPC 的防火牆規則和 VPC Peering 功能，企業可以在單一網路環境中隔離不同客戶或部門，確保數據和應用程序的安全性。\n\n## 結論\n\nGCP VPC 是 Google Cloud 提供的強大網路基礎設施，允許用戶靈活配置和管理全球範圍內的網路資源。無論是單一區域的部署還是跨區域、跨項目的網路架構，VPC 都能夠提供高性能、安全且可擴展的解決方案。如果您的企業正在尋求一個能夠支持多樣化網路需求的雲端平台，GCP VPC 無疑是一個值得考慮的選擇。\n","tags":["雲端服務","GCP"]},{"title":"GCP - Anthos 混合雲與多雲管理的工具","url":"/2024/08/29/GCP-Anthos-混合雲與多雲管理的工具/","content":"\n# 什麼是 Google Cloud Anthos？\n\n![image](https://hackmd.io/_uploads/BkbFQ3pj0.png)\n>https://cloud.google.com/migrate/anthos?hl=zh-tw\n\nGoogle Cloud Anthos 是 Google 雲端平台（GCP）推出的現代化應用程式管理解決方案。Anthos 不僅僅是一個平台，它提供了一整套工具和服務，讓企業能夠在混合雲與多雲環境中更有效率地管理、部署和運行應用程式。無論應用程式部署在本地數據中心、GCP 還是其他雲端服務提供商，Anthos 都能夠提供一致性的運營和管理。\n\n以下是官方說明影片\nhttps://youtu.be/1t6rHa2icqM\n\n\n這邊是官方的說明文件\n![image](https://hackmd.io/_uploads/rkXFZ2Ts0.png)\n>https://cloud.google.com/anthos/?hl=zh_tw\n\n---\n\n## 簡化翻新作業\n\n![image](https://hackmd.io/_uploads/H1URQnasR.png)\n>https://cloud.google.com/migrate/anthos?hl=zh-tw\n\nMigrate for Anthos and GKE 讓您能夠快速且輕鬆地將傳統應用程式從虛擬機器 (VM) 遷移到原生容器中，進行應用程式翻新。我們獨特的自動化處理方法能夠自動擷取 VM 中的重要應用程式元素，並將這些元素無縫地插入到 Google Kubernetes Engine (GKE) 或 Anthos 叢集中的容器，從而消除容器不需要的 VM 層（例如訪客作業系統）的負擔。\n\n這種方法能大幅降低手動執行應用程式翻新專案所需的成本和人力。完成遷移後，您的團隊可以在新的平台上使用相同的服務、政策和方法，以更高效且更具成本效益的方式部署、操作及維護現有的應用程式。\n\n---\n\n## 規劃理想的遷移過程\n\n![image](https://hackmd.io/_uploads/ByiHU26s0.png)\n>https://cloud.google.com/migrate/anthos?hl=zh-tw\n\n大多數數位轉型都需要運用不同策略的組合。對於可受益於容器的工作負載，Migrate for Anthos 和 GKE 提供了快速順暢的翻新途徑，而其他更適合做為 VM 的工作負載，則只要使用 Migrate for Compute Engine 照原樣遷移，並利用與 GKE 整合的虛擬私人雲端 (VPC) 網路即可。因此，您不必受限於現有的基礎架構或單一遷移路徑。Google 可讓您根據需求，在您偏好的位置執行工作負載。\n\n如要瞭解詳情，請觀看這部短片：[安心遷移至 Google Cloud](https://youtu.be/1t6rHa2icqM)\n\n---\n\n## 輕鬆升級為容器\n\n![image](https://hackmd.io/_uploads/B1MDLh6oA.png)\n>https://cloud.google.com/migrate/anthos?hl=zh-tw\n\n有些工作負載很容易就會被 IT 人員註記為「無法升級」，但 Migrate for Anthos 可免除一道又一道的人工作業，因此即使是小型的 IT 團隊也能將這些工作負載遷移並翻新。您不必重寫或重新建構應用程式，就能將現有應用程式從伺服器和 VM 自動擷取至容器中，以原生方式運行，進而消除過去阻礙企業升級至容器的複雜性和知識差距。\n\n閱讀網誌，深入瞭解使用 [Migrate for Anthos 進行容器化的所有優點](https://cloud.google.com/migrate/anthos?hl=zh_tw)\n\n---\n\n## 迅速發揮現代化的優點\n\n![image](https://hackmd.io/_uploads/H13_836oR.png)\n>https://cloud.google.com/migrate/anthos?hl=zh-tw\n\n\n加速遷移及採用新型平台，可讓企業以更有效率的方式運作，並在現有和新開發的應用程式中使用經過整合的政策、管理方式和技術。此外，您也能重新分配原先須用於維護舊有環境的預算，藉此解決翻新及開發新應用程式所需的額外資金的問題。\n\n---\n\n## 加速採用 Day 2 作業\n\n![image](https://hackmd.io/_uploads/SkOFUnToC.png)\n>https://cloud.google.com/migrate/anthos?hl=zh-tw\n\n針對「第二天作業」(Day-2 Operation)，您可以切換至新型的持續整合 (CI)/持續推送軟體更新 (CD) 管道、以映像檔為基礎的管理方式，以及預期狀態設定，藉此節省與維護、修補及更新 VM 和實體伺服器相關的人力和費用。此外，您也能加速採用新型服務，例如 Anthos 服務網格、Anthos Config Management、角色型存取權控管 (RBAC) 功能和 Cloud Logging 等，藉此輕鬆翻新 IT 藍圖配置，進而整合已遷移和新開發應用程式的政策強制執行作業及管理方式。\n\n---\n\n# Anthos 的主要功能\n![image](https://hackmd.io/_uploads/H1URQnasR.png)\n\n1. **跨雲端管理**：Anthos 允許用戶將應用程式部署在不同的雲端環境中（如 AWS、Azure、On-Premise），同時保持一致的管理界面與運營流程。這樣，企業可以在不同雲端供應商之間靈活移動工作負載，而不會受到平台鎖定的影響。\n\n2. **Kubernetes 的強大支持**：Anthos 建基於 Kubernetes，使其能夠無縫整合現代容器化應用程式管理。透過 Anthos，企業可以更輕鬆地在不同的基礎架構上部署和管理 Kubernetes 集群。\n\n3. **服務網格與安全性**：Anthos Service Mesh 提供了強大的服務間通信管理與監控功能，確保應用程式之間的通信安全且高效。此外，Anthos 亦提供了強大的政策管理功能，讓 IT 管理員能夠制定與強制執行一致的安全政策。\n\n4. **開發者友好**：Anthos 支持 CI/CD 流程，讓開發者能夠快速迭代和部署應用程式。借助於其與 Google Cloud Build、Cloud Run 的整合，開發者可以更快地將新功能推向市場。\n\n# Anthos 的應用場景\n\n![image](https://hackmd.io/_uploads/B1MDLh6oA.png)\n\n1. **混合雲策略**：企業可以使用 Anthos 在本地數據中心和雲端之間實現應用程式的無縫移動，確保數據保護及合規性同時享受雲端靈活性。\n\n2. **多雲管理**：對於運營在多個雲端提供商上的企業，Anthos 能夠提供統一的管理平台，減少複雜性並提升運營效率。\n\n3. **現代化應用程式轉型**：透過將傳統應用程式容器化並部署在 Kubernetes 集群中，Anthos 幫助企業實現應用程式的現代化轉型，提升應用程式的可移植性與可擴展性。\n\n# 結論\n\n![image](https://hackmd.io/_uploads/H13_836oR.png)\nGoogle Cloud Anthos 是一個強大的工具集，能夠為企業提供在混合雲與多雲環境中一致且高效的應用程式管理體驗。無論企業是希望推動數位轉型，還是簡化現有的多雲策略，Anthos 都能夠提供支持，確保企業能夠在不犧牲靈活性或安全性的情況下，快速適應市場需求。\n\nAnthos 的出現標誌著企業雲端管理的新時代，為混合雲與多雲環境提供了無與倫比的靈活性和控制能力。如果您的企業正考慮擴展雲端戰略，或是想要在不同雲端環境中保持一致性，那麼 Google Cloud Anthos 無疑是一個值得考慮的選擇。\n\n","tags":["雲端服務","GCP","Anthis"]},{"title":"TFT聯盟戰棋 - 陣容介紹喚蜜師法師維迦","url":"/2024/08/29/TFT聯盟戰棋-陣容介紹喚蜜師法師維迦/","content":"# TFT聯盟戰旗 - 陣容介紹喚蜜師、法師維迦\n\n![image](https://hackmd.io/_uploads/Hkm2FqpsA.png)\n\n今天要跟大家介紹的陣容是喚蜜師、法師維迦整體下來有輸出有坦有回血，且成長很平緩，偏向賭狗陣容\n\n![TFT_OPGG_Builder](https://hackmd.io/_uploads/rklUTw6i0.png)\n\n![image](https://hackmd.io/_uploads/r1QSn9psR.png)\n\n# 陣容組成\n\n## 布里茲\n![image](https://hackmd.io/_uploads/SkZk9cpo0.png)\n\n![image](https://hackmd.io/_uploads/ry5jjcaoC.png)蜂蜜屏障\n獲得298/401/566(Ability powerHealth)護盾，持續6秒。\n\n## 努努\n![image](https://hackmd.io/_uploads/S1oxq9Ts0.png)\n![image](https://hackmd.io/_uploads/Bknl2c6iR.png)黏黏嚙咬\n嚙咬目標，治療250/300/350(Ability power)生命，造成200/300/450(Ability power)魔法傷害並附加凍骨效果3秒。\n凍骨：降低攻速 20%\n\n## 維迦\n![image](https://hackmd.io/_uploads/rkfAKcpoA.png)\n\n![image](https://hackmd.io/_uploads/Hkev29Tj0.png)蜂王的審判\n被動：每購買一個護符，增加3魔法攻擊。\n主動：對目標造成240/330/475(Ability power)魔法傷害。\n\n## 薇可絲\n![image](https://hackmd.io/_uploads/BkJWTqTiR.png)\n\n![image](https://hackmd.io/_uploads/SyVgpcpiA.png)個人舒適圈\n獲得380/430/480 (Ability power)護盾，持續4秒，每有一名敵軍瞄準薇可絲便增加5%。護盾失效時，對2格內的敵軍造成80/120/200 (Ability power)魔法傷害。\n\n## 希格斯\n![image](https://hackmd.io/_uploads/HJlXq5To0.png)\n\n![image](https://hackmd.io/_uploads/r1pFh96s0.png)彈跳蜜蜂\n朝最遠的敵軍投擲一枚彈跳炸彈。炸彈會在命中第一名敵軍時爆炸，對目標造成200/300/450 (Ability power)魔法傷害，並對附近所有敵軍造成100/150/225 (Ability power)魔法傷害。\n\n## 佳里歐\n![image](https://hackmd.io/_uploads/SyhE5cpjA.png)\n![image](https://hackmd.io/_uploads/SkquicpsR.png)匯聚重擊\n使承受的傷害降低20/25/30 (Ability power)，持續4秒。發射兩發魔法彈，魔法彈會在3格內距離最遠的敵軍處匯集，使其暈眩1.25/1.25/1.5秒。每發魔法彈對路徑上的敵軍造成50/75/115 (Ability power)魔法傷害。\n法師施放會瞄準不同的敵軍。\n\n## 納米\n![image](https://hackmd.io/_uploads/H1Yr99Tj0.png)\n![image](https://hackmd.io/_uploads/Hk1Eiqpi0.png)利維坦\n朝範圍內最多敵軍聚集處發射泡泡，造成240/360/1800(Ability power)魔法傷害。每3次施放後，改為召喚利維坦，使直線上的敵軍暈眩並造成200/300/1200(Ability power)魔法傷害。\n、 \n## 諾拉與悠咪\n![image](https://hackmd.io/_uploads/B1P8qcpoR.png)\n\n![image](https://hackmd.io/_uploads/ryTtc56sA.png)傳送門嘉年華\n朝當前目標射出一顆圓球，爆炸後造成180/270/1000 (Ability power)魔法傷害，使區域染色5/5/15秒，期間造成500/750/3000 (Ability power)魔法傷害。如果圓球落在已染色的區域，它會彈到2格內的新位置，然後爆炸。\n\n## 羈絆\n\n羈絆有 摯友、5喚蜜師、5法師、2先鋒\n\n![image](https://hackmd.io/_uploads/rJBwpcpj0.png)\n![image](https://hackmd.io/_uploads/r1QSn9psR.png)\n![image](https://hackmd.io/_uploads/HJ9BT5pjC.png)\n\n# 增幅裝置\n密蜂摯友、法師之紋、喚蜜師之紋\n\n# 實戰影片\nhttps://youtu.be/xW4SY0UtocM?si=wFvIxt8Y1S9OVCHm\n","tags":["聯盟戰棋"]},{"title":"GCP - Compute Engine 如何優化成本與性能","url":"/2024/08/28/GCP-Compute-Engine-如何優化成本與性能/","content":"\n\n![image](https://hackmd.io/_uploads/Syu03foiA.png)\n\n## 引言\n\n隨著現代企業越來越依賴雲端技術，Google Cloud Platform (GCP) 成為了許多公司首選的雲端解決方案之一。GCP 提供了靈活且強大的計算資源，但如何在不犧牲性能的情況下優化成本，卻是企業面臨的一大挑戰。本文將探討 GCP 中成本優化與性能優化的策略與最佳實踐，幫助企業在滿足業務需求的同時，最大化利用其資源並控制開支。\n\n## 理解 GCP 的成本結構\n\n### 計費模式：按需付費 vs 預留折扣\n\nGCP 的計費模式主要分為按需付費和預留折扣。按需付費適合短期和不確定的工作負載，而預留折扣針對長期穩定的使用情境提供了更具吸引力的價格。舉例來說，對於一年內持續運行的應用，預留折扣能夠節省高達30%的成本。選擇適合的計費模式能幫助企業有效降低雲端成本。\n\n### 了解 Compute Engine 的成本組成\n\nCompute Engine 的成本不僅包括運算時間，還涉及到與其相關的儲存、網路以及 IP 地址等費用。例如，標準型虛擬機器的每月運行成本中，儲存和網路的費用可能佔到30%以上。因此，深入理解這些組成部分，並根據需求進行配置，有助於避免不必要的支出。\n\n## 選擇合適的 Compute Engine 類型\n\n### 標準型 vs 高 CPU vs 高記憶體 vs GPU vs TPU\n\nGCP 提供多種 Compute Engine 類型，如標準型、高 CPU、高記憶體、GPU 和 TPU。選擇哪一種資源取決於您的應用程式需求。比如，針對需要大量數據處理的應用，高記憶體型可能是最佳選擇，而對於機器學習模型訓練，GPU 或 TPU 能顯著提升計算性能，進而降低訓練時間和成本。\n\n### 預計用途 vs 實際需求的匹配\n\n在選擇資源時，預計用途與實際需求的匹配至關重要。例如，如果應用程式的高峰期較短暫，那麼過度配置高規格的 VM 可能會導致資源浪費。相反，若選擇過低的配置，可能會導致性能瓶頸。因此，精確評估應用的負載模式，有助於找到最適合的資源配置。\n\n### 彈性機制與自動縮放 (Autoscaling)\n\n利用 GCP 的自動縮放功能，您可以根據實際負載自動調整資源。這樣可以確保在需求高峰時具備足夠的計算能力，同時在負載減少時降低成本。例如，某線上零售平台在促銷活動期間使用自動縮放功能，成功避免了因過度配置資源導致的成本浪費。\n\n## 利用 Sustained Use Discounts 和 Committed Use Contracts\n\n### Sustained Use Discounts 的自動折扣機制\n\nGCP 提供 Sustained Use Discounts（SUDs），當虛擬機器長時間持續運行時，會自動應用折扣。這種機制非常適合需要長期運行的工作負載，如數據庫或後端服務。在某些情境下，SUDs 甚至可以將成本降低達到20%。\n\n### Committed Use Contracts 的長期成本優勢\n\n對於長期穩定的工作負載，您可以選擇 Committed Use Contracts，以較低的價格預留一定量的資源。這種合約可以顯著降低長期成本。例如，某家金融科技公司預留了三年的計算資源，成功將成本削減了近 25%。\n\n### 如何判斷選擇哪一種折扣策略最合適\n\n根據工作負載的特性和穩定性，決定是採用 Sustained Use Discounts 還是 Committed Use Contracts。前者更適合變動性較大的工作負載，後者則適合可預測的長期需求。例如，對於每天持續運行的線上交易平台，Committed Use Contracts 可能是更經濟的選擇。\n\n## 透過機器規模優化性能\n\n### 調整虛擬機器 (VM) 的規模來提升效能\n\n根據工作負載需求調整虛擬機器的規模，無論是垂直擴展（增加單一 VM 的資源）還是水平擴展（增加多個 VM），都可以顯著提升效能。對於單一計算密集型任務，增加 VM 的 CPU 和記憶體有助於縮短處理時間，提升應用性能。\n\n### 垂直擴展與水平擴展的選擇\n\n垂直擴展適合單一工作負載對 CPU 或記憶體有較高需求的情況，而水平擴展則更適合需要高可用性或分散式運算的情境。例如，一家遊戲公司在應對玩家人數驟增時，選擇了水平擴展多個 VM，以確保伺服器穩定運行。\n\n### 適當配置資源以避免過度配置或資源不足\n\n適當配置資源可以避免不必要的支出，並確保系統在高負載下能夠正常運行。這一點在虛擬機器的選型和調整上尤為重要。例如，一個日常負載較低的應用可能只需要最低配置的 VM，但在某些關鍵時刻則需要快速垂直擴展以應對突發需求。\n\n## 利用 Preemptible VMs 節省成本\n\n### 什麼是 Preemptible VMs 及其特點\n\nPreemptible VMs 是一種低成本的計算選項，適合短期且可中斷的工作負載。這類 VM 的價格比標準 VM 低 70% 以上，但 GCP 可能會在任意時間收回資源。這類 VM 特別適合批次作業或大型資料分析。\n\n### 適用場景與風險管理\n\nPreemptible VMs 適合處理批次作業、資料分析等可中斷的工作負載。例如，一家研究機構在進行大規模基因數據分析時使用了 Preemptible VMs，節省了大量計算成本。在使用這類 VM 時，必須制定應急方案，以應對 VM 被收回的情況，如定期保存進度或使用自動重啟策略。\n\n### 節省成本的實際案例\n\n在處理大規模資料分析時，使用 Preemptible VMs 可以顯著降低成本。例如，某數據處理公司在大規模資料處理項目中，使用 Preemptible VMs 將計算成本降低了 60%，這是一個成功的實踐案例。\n\n## 定期監控與調整\n\n### 使用 Stackdriver 和其他工具進行監控\n\n透過 GCP 的 Stackdriver 和其他監控工具，可以實時追蹤系統效能和成本。利用這些工具，企業可以在系統負載變化時即時調整資源配置，避免資源浪費或性能不足的問題。例如，設置自動告警機制，當資源利用率超過預定閾值時，系統會自動通知管理員進行調整。\n\n### 自動化與自適應調整策略\n\n借助自動化工具，您可以實現資源配置的自適應調整，確保系統在不同負載下始終運行在最佳狀態。例如，配置自動縮放策略，使系統根據流量自動擴展或縮減資源，從而有效控制成本。\n\n### 經常審查與優化設定\n\n定期審查並優化設定，能夠及時識別並修正不必要的資源浪費。例如，每季度對現有配置進行一次全面檢查，確保所有資源都得到充分利用，並調整不再適用的配置。\n\n## 使用 Google Kubernetes Engine (GKE) 進行成本與性能優化\n\n### 探討 GKE 的彈性和自動擴展能力\n\nGKE 提供高度彈性與自動擴展功能，特別適合容器化應用的成本與\n\n性能優化。通過設置自動擴展策略，您可以根據實際負載動態調整資源，確保在流量高峰時提供足夠的計算能力，而在流量低谷時減少資源使用。例如，一家 SaaS 公司利用 GKE 的自動擴展功能，成功在流量高峰期間保持服務穩定性，同時控制了成本。\n\n### 實踐中的 GKE 最佳實踐\n\nGKE 的最佳實踐包括合理的節點池配置、正確使用標籤與命名空間管理資源、以及充分利用自動縮放功能等。例如，為了降低管理成本，您可以將相似的工作負載分配到同一節點池中，並設置適當的資源限額，以防止單個應用佔用過多資源。\n\n### 透過標籤與命名空間管理資源\n\n標籤與命名空間是管理 GKE 資源的有效工具。通過正確地應用這些工具，您可以實現對資源的精細控制與成本分配。例如，為不同的應用程式和部門分配唯一的標籤，並基於這些標籤進行成本審計與分析，從而提高資源利用效率。\n\n## 結論\n\n在 GCP 上進行成本與性能優化是一個持續的過程，需要定期的審視與調整。通過深入理解 GCP 的計費模式、正確選擇和配置 Compute Engine 類型、利用折扣策略、監控與自動化工具、以及充分利用 GKE 的功能，企業可以在不犧牲性能的情況下顯著降低雲端支出。隨著雲端技術的不斷發展，企業應該持續學習與應用最新的技術，以保持競爭力並最大化投資回報。\n\n","tags":["雲端服務","GCP"]},{"title":"GCP - Google Cloud Skills Boost 的 Qwiklabs課程紀錄 : Google Kubernetes Engine: Qwik Start","url":"/2024/08/28/GCP-Google-Cloud-Skills-Boost-的-Qwiklabs課程紀錄-Google-Kubernetes-Engine-Qwik-Start/","content":"\n![image](https://hackmd.io/_uploads/rJ7NUf3sA.png)\n\n\n今天這篇文章是在記錄我練習Google Cloud Skills Boost 官方學習資源平台的過程，今天練習的課程是 Google Kubernetes Engine: Qwik Start，這個 實踐實驗室（Qwiklabs） 主題是在介紹 Google 雲端平台上面的Kubernetes 功能。\n\n![image](https://hackmd.io/_uploads/rkNv8G3jA.png)\n\n我會記錄題目的內容跟翻譯成中文的意思，還有我操作的結果畫面，方便之後複習時可以縮短學習時間。\n\n# 什麼是Google Cloud Learning Courses and Certifications ? \n\n![image](https://hackmd.io/_uploads/Hk4NWznjR.png)\n>https://cloud.google.com/learn?hl=zh_tw\n\nGoogle Cloud Learning Courses and Certifications是 Google Cloud 的學習資源平台。這個網站提供了一系列的學習資源，幫助使用者學習和掌握 Google Cloud 技術。內容包括教學課程、實驗室練習、學習路徑、認證準備資源，以及其他可以幫助使用者提升技能的教育材料。無論是初學者還是有經驗的專業人員，都可以在這裡找到適合的學習內容，進一步了解如何有效地使用 Google Cloud 服務和技術。\n\n![image](https://hackmd.io/_uploads/Hk_fEz2i0.png)\n\n這邊點擊 訓練 -> 開始訓練 就可以進入 Google Cloud Skills Boost\n\n# 什麼是 Google Cloud Skills Boost ?\n![image](https://hackmd.io/_uploads/SyTOXGno0.png)\n>https://www.cloudskillsboost.google/\n\n是 Google Cloud 提供的學習平台，專門用來幫助使用者提升雲端技能。該平台包含各種實踐實驗室（Qwiklabs）、學習路徑、課程和其他學習資源，旨在幫助使用者掌握 Google Cloud 的技術和服務。平台上的內容涵蓋了從基礎到進階的各種主題，適合不同經驗水平的學習者。此外，它還提供認證準備資源，幫助學習者準備 Google Cloud 的官方認證考試。\n\n\n# GSP100\n![image](https://hackmd.io/_uploads/HJao_DYoC.png)\n\n# 教學影片 \n[Manage Containerized Apps with Kubernetes Engine | Google Cloud Labs](https://www.youtube.com/watch?v=u9nsngvmMK4&feature=youtu.be)\n\n# Overview - 概述\n\n[Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine) (GKE) provides a managed environment for deploying, managing, and scaling your containerized applications using Google infrastructure. The GKE environment consists of multiple machines (specifically [Compute Engine](https://cloud.google.com/compute) instances) grouped to form a [container cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).\n\nIn this lab, you get hands-on practice with container creation and application deployment with GKE.\n\n\nGoogle Kubernetes Engine (GKE) 提供了一個受管理的環境，用於在 Google 基礎架構上部署、管理和擴展您的容器化應用程式。GKE 環境由多台機器（具體來說是 Compute Engine 實例）組成，這些機器被分組形成一個 容器集群。\n\n在本次實驗中，您將進行實際操作，練習使用 GKE 進行容器創建和應用程式部署。\n\n# Objectives - 目標\n\nIn this lab you will learn how to:\n\n* Create a GKE cluster\n* Deploy an application to the cluster\n* Delete the cluster\n\n以上內容是在本次實驗中，您將學習如何：\n\n* 建立一個 GKE cluster (集群)\n* 將應用程式部署到該 cluster (集群)\n* 刪除該 cluster (集群)\n\n## Cluster orchestration with Google Kubernetes Engine - 使用 Google Kubernetes Engine 進行叢集編排\n\nGoogle Kubernetes Engine (GKE) clusters are powered by the [Kubernetes](https://kubernetes.io/) open source cluster management system. Kubernetes provides the mechanisms through which you interact with your container cluster. You use Kubernetes commands and resources to deploy and manage your applications, perform administrative tasks, set policies, and monitor the health of your deployed workloads.\n\nKubernetes draws on the same design principles that run popular Google services and provides the same benefits: automatic management, monitoring and liveness probes for application containers, automatic scaling, rolling updates, and more. When you run your applications on a container cluster, you're using technology based on Google's 10+ years of experience with running production workloads in containers.\n\n以上內容是在描述 GKE 如何可以編輯 Cluster 的原理跟功能介紹\n\nGoogle Kubernetes Engine (GKE) 的叢集是由 [Kubernetes](https://kubernetes.io/) 開源叢集管理系統提供支持的。Kubernetes 提供了與容器叢集進行互動的機制。您可以使用 Kubernetes 的指令和資源來部署和管理應用程式、執行管理任務、設定政策以及監控已部署工作負載的健康狀況。\n\nKubernetes 借鑑了運行 Google 眾多熱門服務的相同設計原則，並提供了相同的優勢：自動管理、應用程式容器的監控和存活探針、自動縮放、滾動更新等功能。當您在容器叢集上運行應用程式時，您正在使用基於 Google 超過十年運行生產環境工作負載經驗的技術。\n\n## Kubernetes on Google Cloud - 在 Google Cloud 上使用 Kubernetes\n\nWhen you run a GKE cluster, you also gain the benefit of advanced cluster management features that Google Cloud provides. These include:\n\n* [Load balancing](https://cloud.google.com/compute/docs/load-balancing-and-autoscaling) for Compute Engine instances\n* [Node pools](https://cloud.google.com/kubernetes-engine/docs/node-pools) to designate subsets of nodes within a cluster for additional flexibility\n* [Automatic scaling](https://cloud.google.com/kubernetes-engine/docs/cluster-autoscaler) of your cluster's node instance count\n* [Automatic upgrades](https://cloud.google.com/kubernetes-engine/docs/node-auto-upgrade) for your cluster's node software\n* [Node auto-repair](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair) to maintain node health and availability\n* [Logging and Monitoring](https://cloud.google.com/kubernetes-engine/docs/how-to/logging) with Cloud Monitoring for visibility into your cluster\n\nNow that you have a basic understanding of Kubernetes, you will learn how to deploy a containerized application with GKE in less than 30 minutes. Follow the steps below to set up your lab environment.\n\n以上內容是進階介紹 Kubernetes 的功能細節\n\n當您運行 GKE 叢集時，還可以享受 Google Cloud 提供的進階叢集管理功能。這些功能包括：\n\n- 為 Compute Engine 實例提供的[負載平衡](https://cloud.google.com/compute/docs/load-balancing-and-autoscaling)\n- 使用[節點池](https://cloud.google.com/kubernetes-engine/docs/node-pools)來指定叢集內的節點子集，以增加彈性\n- 自動調整叢集節點實例數量的[自動縮放](https://cloud.google.com/kubernetes-engine/docs/cluster-autoscaler)\n- 為叢集節點軟體提供的[自動升級](https://cloud.google.com/kubernetes-engine/docs/node-auto-upgrade)\n- 維護節點健康與可用性的[節點自動修復](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair)\n- 使用 Cloud Monitoring 進行叢集的[日誌記錄與監控](https://cloud.google.com/kubernetes-engine/docs/how-to/logging)，以提升叢集的可視性\n\n現在您已經對 Kubernetes 有了基本的了解，接下來將學習如何在不到 30 分鐘內使用 GKE 部署容器化應用程式。請按照以下步驟來設置您的實驗環境。\n\n# Task 1. Set a default compute zone - 設定預設的計算區域\n\nYour [compute zone](https://cloud.google.com/compute/docs/regions-zones/#available) is an approximate regional location in which your clusters and their resources live. For example, us-central1-a is a zone in the us-central1 region.\n\nIn your Cloud Shell session, run the following commands.\n\n你的 [計算區域](https://cloud.google.com/compute/docs/regions-zones/#available) 是叢集及其資源所在的近似區域位置。例如，us-central1-a 是 us-central1 區域中的一個區域。\n\n在你的 Cloud Shell 會話中，運行以下命令。\n\n1. Set the default compute region:\n\n```\ngcloud config set compute/region \"REGION\"\n```\n\nExpected output:\n\n```\nUpdated property [compute/region].\n```\n\n![image](https://hackmd.io/_uploads/ryZ5gdKo0.png)\n\n2. Set the default compute zone:\n\n```\ngcloud config set compute/zone \"ZONE\"\n```\n\nExpected output:\n\n```\nUpdated property [compute/zone].\n```\n\n![image](https://hackmd.io/_uploads/S1psguFjC.png)\n\n# Task 2. Create a GKE cluster - 建立一個 GKE 叢集\n\nA [cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture) consists of at least one cluster master machine and multiple worker machines called nodes. Nodes are [Compute Engine virtual machine (VM) instances](https://cloud.google.com/compute/docs/instances/) that run the Kubernetes processes necessary to make them part of the cluster.\n\n{% note info simple %}\nNote: Cluster names must start with a letter and end with an alphanumeric, and cannot be longer than 40 characters.\n{% endnote %}\n\nRun the following command:\n\n一個 [叢集](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture) 由至少一個叢集主控機器和多個稱為節點的工作機器組成。節點是運行 Kubernetes 所需進程的 [Compute Engine 虛擬機器 (VM) 實例](https://cloud.google.com/compute/docs/instances/)，使它們成為叢集的一部分。\n\n{% note info simple %}\n注意：叢集名稱必須以字母開頭並以字母或數字結尾，且名稱長度不得超過 40 個字元。\n{% endnote %}\n\n執行以下指令：\n\nCreate a cluster:\n\n```\ngcloud container clusters create --machine-type=e2-medium --zone=ZONE lab-cluster\n```\n\nYou can ignore any warnings in the output. It might take several minutes to finish creating the cluster.\n\nExpected output:\n```\nNAME: lab-cluster\nLOCATION: ZONE\nMASTER_VERSION: 1.22.8-gke.202\nMASTER_IP: 34.67.240.12\nMACHINE_TYPE: e2-medium\nNODE_VERSION: 1.22.8-gke.202\nNUM_NODES: 3\nSTATUS: RUNNING\n```\n\nClick Check my progress to verify the objective.\n![image](https://hackmd.io/_uploads/SJs0cDYj0.png)\n\n![image](https://hackmd.io/_uploads/Hy-eGdFoR.png)\n>這一步執行會花一段時間\n\n![image](https://hackmd.io/_uploads/SJuDG_KiC.png)\n\n\n# Task 3. Get authentication credentials for the cluster - 獲取叢集的身份驗證憑證\n\nAfter creating your cluster, you need authentication credentials to interact with it.\n\n* Authenticate with the cluster:\n\n在建立叢集後，你需要身份驗證憑證來與叢集互動。\n\n* 與叢集進行身份驗證：\n\n```\ngcloud container clusters get-credentials lab-cluster\n```\n\nExpected output:\n```\nFetching cluster endpoint and auth data.\nkubeconfig entry generated for my-cluster.\n```\n\n![image](https://hackmd.io/_uploads/S1weX_FiC.png)\n\n\n# Task 4. Deploy an application to the cluster - 部署應用程式到叢集\n\nYou can now deploy a containerized application to the cluster. For this lab, you'll run hello-app in your cluster.\n\nGKE uses Kubernetes objects to create and manage your cluster's resources. Kubernetes provides the [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) object for deploying stateless applications like web servers. [Service](https://kubernetes.io/docs/concepts/services-networking/service/) objects define rules and load balancing for accessing your application from the internet.\n\n1.To **create a new Deployment** `hello-server` from the `hello-app` container image, run the following `kubectl create` command:\n\n你現在可以將容器化的應用程式部署到叢集。在這個實驗中，你將在叢集中運行 `hello-app`。\n\nGKE 使用 Kubernetes 物件來創建和管理叢集的資源。Kubernetes 提供了 [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) 物件來部署無狀態應用程式，如網頁伺服器。[Service](https://kubernetes.io/docs/concepts/services-networking/service/) 物件則定義了從互聯網訪問你的應用程式的規則和負載均衡。\n\n1.要從 `hello-app` 容器映像中**創建一個新的 Deployment** `hello-server`，請運行以下 `kubectl create` 指令：\n\n```\nkubectl create deployment hello-server --image=gcr.io/google-samples/hello-app:1.0\n```\n\nExpected output:\n```\ndeployment.apps/hello-server created\n```\n\n![image](https://hackmd.io/_uploads/H1dPXdtj0.png)\n\n\nThis Kubernetes command creates a deployment object that represents `hello-server`. In this case, `--image` specifies a container image to deploy. The command pulls the example image from a [Container Registry](https://cloud.google.com/container-registry/docs) bucket. `gcr.io/google-samples/hello-app:1.0` indicates the specific image version to pull. If a version is not specified, the latest version is used.\n\n這個 Kubernetes 指令會創建一個代表 `hello-server` 的 Deployment 物件。在這個例子中，`--image` 指定了要部署的容器映像。該指令會從 [Container Registry](https://cloud.google.com/container-registry/docs) 儲存區中提取範例映像。`gcr.io/google-samples/hello-app:1.0` 表示要提取的特定映像版本。如果未指定版本，則會使用最新版本。\n\nClick **Check my progress** to verify the objective.\n![image](https://hackmd.io/_uploads/SJNx2vFsA.png)\n\n2. To create a Kubernetes Service, which is a Kubernetes resource that lets you expose your application to external traffic, run the following kubectl expose command:\n\n要建立一個 Kubernetes Service，它是一種 Kubernetes 資源，允許你將應用程式公開給外部流量，請執行以下 `kubectl expose` 指令：\n\n```\nkubectl expose deployment hello-server --type=LoadBalancer --port 8080\n```\n\nIn this command:\n* `--port` specifies the port that the container exposes.\n* `type=\"LoadBalancer\"` creates a Compute Engine load balancer for your container.\n\nExpected output:\n\n在這個指令中：\n* `--port` 指定容器所開放的端口。\n* `type=\"LoadBalancer\"` 為你的容器建立一個 Compute Engine 負載平衡器。\n\n預期輸出：\n\n```\nservice/hello-server exposed\n```\n\n![image](https://hackmd.io/_uploads/B1FqQOtjR.png)\n\n\n3. To inspect the `hello-server` Service, run `kubectl get`:\n\n要檢查 `hello-server` 服務，請執行 `kubectl get`：\n\n```\nkubectl get service\n```\n\nExpected output:\n```\nNAME             TYPE            CLUSTER-IP      EXTERNAL-IP     PORT(S)           AGE\nhello-server     loadBalancer    10.39.244.36    35.202.234.26   8080:31991/TCP    65s\nkubernetes       ClusterIP       10.39.240.1               433/TCP           5m13s\n```\n\n{% note info simple %}\n**Note**: It might take a minute for an external IP address to be generated. Run the previous command again if the EXTERNAL-IP column status is **pending**.\n\n**注意**：生成外部 IP 地址可能需要一分鐘。如果 EXTERNAL-IP 欄位狀態為 **pending**，請再次執行之前的指令。\n{% endnote %}\n\n![image](https://hackmd.io/_uploads/HkT2X_FiA.png)\n\n\n4. To view the application from your web browser, open a new tab and enter the following address, replacing `[EXTERNAL IP]` with the `EXTERNAL-IP` for `hello-server`.\n\n要在網頁瀏覽器中查看應用程式，開啟一個新標籤頁並輸入以下地址，將 `[EXTERNAL IP]` 替換為 `hello-server` 的 `EXTERNAL-IP`。\n\n```\nhttp://[EXTERNAL-IP]:8080\n```\n\n**Expected output**: The browser tab displays the message **Hello, world!** as well as the version and hostname.\n\n**預期輸出**：瀏覽器標籤頁顯示消息 **Hello, world!** 以及版本和主機名稱。\n\n這邊實作產生的 EXTERNAL-IP 是 34.85.205.6 測試瀏覽的畫面如下\n\n![image](https://hackmd.io/_uploads/HkjG4OtsR.png)\n>http://34.85.205.6:8080/\n\n\nClick **Check my progress** to verify the objective.\n![image](https://hackmd.io/_uploads/BJOVpwYjR.png)\n\n# Task 5. Deleting the cluster - 刪除叢集\n\n1. To delete the cluster, run the following command:\n 要刪除叢集，請運行以下命令：\n```\ngcloud container clusters delete lab-cluster\n```\n2. When prompted, type Y to confirm.\n\nDeleting the cluster can take a few minutes. For more information on deleted GKE clusters from the Google Kubernetes Engine (GKE) article, [Deleting a cluster](https://cloud.google.com/kubernetes-engine/docs/how-to/deleting-a-cluster).\n\n當系統提示時，輸入 Y 以確認。\n\n刪除叢集可能需要幾分鐘。欲了解更多有關從 Google Kubernetes Engine (GKE) 刪除叢集的資訊，請參閱文章 [刪除叢集](https://cloud.google.com/kubernetes-engine/docs/how-to/deleting-a-cluster)。\n\n![image](https://hackmd.io/_uploads/SymdEuYjC.png)\n\n![image](https://hackmd.io/_uploads/r1zjr_YsC.png)\n> 這邊也可以直接在介面上操作\n\nClick **Check my progress** to verify the objective.\n\n![image](https://hackmd.io/_uploads/Bkl3aDtsC.png)\n\n# Congratulations! - 恭喜！\nYou have just deployed a containerized application to Google Kubernetes Engine! In this lab, you created a GKE cluster, deployed a containerized application to the cluster, and deleted the cluster. You can now apply this knowledge to deploy your own applications with GKE.\n\n您剛剛成功將容器化應用程式部署到 Google Kubernetes Engine！在這個實驗中，您建立了一個 GKE 叢集，將容器化應用程式部署到叢集，並刪除了該叢集。現在，您可以將這些知識應用到部署您自己的應用程式上。\n\n## Next steps / Learn more - 下一步 / 了解更多\n\nThis lab is part of a series of labs called Qwik Starts. These labs are designed to give you some experience with the many features available with Google Cloud. Search for \"Qwik Starts\" in the [Google Cloud Skill Boost catalog](http://google.qwiklabs.com/catalog) to find the next lab you'd like to take!\n\n這個實驗是 Qwik Starts 系列實驗的一部分。這些實驗旨在讓您體驗 Google Cloud 提供的眾多功能。您可以在 [Google Cloud Skill Boost 目錄](http://google.qwiklabs.com/catalog) 中搜尋 \"Qwik Starts\" 來找到您想參加的下一個實驗！\n\n## Google Cloud training and certification - Google Cloud 培訓與認證\n\n...helps you make the most of Google Cloud technologies. [Our classes](https://cloud.google.com/training/courses) include technical skills and best practices to help you get up to speed quickly and continue your learning journey. We offer fundamental to advanced level training, with on-demand, live, and virtual options to suit your busy schedule. [Certifications](https://cloud.google.com/certification/) help you validate and prove your skill and expertise in Google Cloud technologies.\n\n...幫助您充分利用 Google Cloud 技術。我們的[課程](https://cloud.google.com/training/courses)涵蓋了技術技能和最佳實踐，能夠幫助您快速上手並持續學習。我們提供從基礎到高級的培訓課程，並有隨選、現場和虛擬選項以適應您的繁忙日程。[認證](https://cloud.google.com/certification/)能幫助您驗證和證明您在 Google Cloud 技術方面的技能和專業知識。\n\n\n# 總結\n今天跟大家分享 Google Cloud Skills Boost 中 Google Kubernetes Engine: Qwik Start 課程的操作過程，包括設置計算區域、創建 GKE 叢集、部署應用程式到叢集、獲取身份驗證憑證以及刪除叢集的步驟。\n\n之後我還會持續練習 Qwiklabs 的內容並記錄分享給大家，如果有問題歡迎在部落格文章留言詢問。\n","tags":["雲端服務","GCP","Kubernetes","Google Cloud Skills Boost"]},{"title":"使用ATOM 和 RSS 格式把Hexo內容搬到 Wordpress 上的流程","url":"/2024/08/27/使用ATOM-和-RSS-格式把Hexo內容搬到-Wordpress-上的流程/","content":"\n# ATOM 和 RSS 的簡介\n\n**RSS（Really Simple Syndication）** 和 **ATOM** 都是用來分發網路內容的標準格式。它們的主要目的是幫助使用者訂閱和自動獲取網站更新，無需手動訪問網頁。這對於部落格或新聞網站非常有用，因為它能讓讀者即時接收新文章的通知。\n\n## RSS\n\n![image](https://hackmd.io/_uploads/SyJICyojR.png)\n\nRSS 是一種 XML 格式，常見的版本為 RSS 2.0。使用 RSS，網站可以將最新的內容發布到訂閱者的 RSS 閱讀器中。讀者可以使用 RSS 閱讀器訂閱 RSS Feed，當網站更新時，內容會自動推送到他們的裝置上。\n\n## ATOM\n\n![image](https://hackmd.io/_uploads/r15501oiR.png)\n\nATOM 是另一種 XML 格式，功能類似於 RSS，但有更多可自定義的元素。ATOM 被認為是 RSS 的改進版，因為它具有更好的格式和結構，適合用於更複雜的內容發佈需求。\n\n## 如何使用\n用戶只需將網站提供的 RSS 或 ATOM 連結添加到他們的 RSS 閱讀器中即可。對於網站管理員來說，提供 RSS 或 ATOM Feed 是吸引讀者的重要方式之一，能有效提升內容曝光率。\n\n# 產出 Hexo 的 RSS 摘要格式文章檔案\nRSS 摘要格式可以方便 WordPress 導入，在 _config.yml 檔案中調整設定\n\n在 Hexo 中，如果要生成 RSS 摘要（也稱為 RSS Feed），你需要安裝一個 RSS 插件並進行相應設定。以下是詳細步驟：\n\n## 安裝 RSS 插件\n\n### 方法一 : `hexo-generator-feed`\n首先，你需要安裝 `hexo-generator-feed` 插件。打開終端機並在你的 Hexo 專案目錄下執行以下命令：\n\n```bash\nnpm install hexo-generator-feed --save\n```\n\n![image](https://hackmd.io/_uploads/H13fgKHjR.png)\n\n### 方法二 : `hexo-migrator-rss`\n後來有看到這一篇hexo官方說明文件\nhttps://hexo.io/zh-tw/docs/migration\n\n裡面有提到使用 `hexo-migrator-rss` 這個工具來進行轉移\n\n首先，安裝 hexo-migrator-rss 外掛。\n```\n$ npm install hexo-migrator-rss --save\n```\n\n一旦外掛安裝完成，執行下列指令，從 RSS 轉移所有文章。 source 可以是檔案路徑或網址。\n\n```\n$ hexo migrate rss <source>\n```\n這邊我最終是使用 hexo-generator-feed 產生的\n\n## 配置 `_config.yml`\n\n安裝完成後，你需要在 Hexo 的主配置檔 `_config.yml` 中添加 RSS 的相關設定。以下是我設定的配置：\n\n```yaml\nfeed: \n\ttype:\n    - atom\n    - rss2\n  path:\n    - atom.xml\n    - rss2.xml\n\tlimit: 0\n\thub:\t\n\tcontent: true\n```\n\n{% note info simple %}\n變數內容說明\n\n- **enable**：啟用或停用此插件。預設為啟用。\n- **type**：Feed 的類型。可以是 `atom` 或 `rss2`。指定為 `['atom', 'rss2']` 以輸出這兩種類型。（預設：`atom`）\n- **path**：Feed 的路徑。如果指定了多種類型，路徑必須按照類型的順序排列。（預設：`atom.xml/rss2.xml`）\n- **limit**：Feed 中顯示的最大文章數量。（設為 `0` 或 `false` 以顯示所有文章）\n- **hub**：PubSubHubbub hub 的 URL。（如果不使用，請保持空白）\n- **content**：（可選）設為 `true` 時，會在 Feed 中包含整篇文章的內容。\n- **content_limit**：（可選）摘要內容的字數上限。僅在 `content` 設為 `false` 且沒有自訂文章描述時使用。\n- **content_limit_delim**：（可選）如果使用 `content_limit` 來縮短文章內容，僅在達到字數上限前的最後一個指定分隔符處截斷內容。預設不使用。\n- **order_by**：Feed 的排序方式。（預設：`-date`，即按日期倒序）\n- **icon**：（可選）自訂 Feed 圖示。預設使用主設定中的 email 對應的 Gravatar。\n- **autodiscovery**：自動發現 Feed 的設定。（預設：`true`）許多主題已提供此功能，如果需要停用，可能需要調整主題設定。\n- **template**：自訂模板路徑。這個檔案將用來生成 Feed 的 XML 檔案，預設模板為 `atom.xml` 和 `rss2.xml`。即使插件設定為輸出多種 Feed 類型，也可以只指定一個自訂模板。\n\n{% endnote %}\n\n依照這樣以上設定執行產生時，會生成下面兩種內容的網址:\nhttps://gahgah147.github.io/atom.xml\nhttps://gahgah147.github.io/rss2.xml\n\n\n## 生成靜態文件\n\n設定完成後，執行以下命令生成靜態文件：\n\n```bash\nhexo generate\n```\n或是\n\n```bash\nhexo g\n```\n\n生成後，RSS 文件會自動保存在你的 public 資料夾中，路徑是 `public/rss.xml`（或者你在配置中設定的路徑）。\n\n實際上我平常部屬到github.io網頁上的流程是這樣，一樣可以更新到RSS 或是ATOM\n```\nhexo clean && hexo deploy\n```\n\n## 驗證 RSS\n\n在瀏覽器中打開 `http://你的網站域名/atom.xml` 或是 `http://你的網站域名/rss2.xml`（或你設定的路徑）檢查 RSS 是否正確生成。\n\n例如我這邊產生的是\n`https://gahgah147.github.io/atom.xml`和`https://gahgah147.github.io/rss2.xml`\n\n我這邊成功產生的RSS畫面\n![image](https://hackmd.io/_uploads/rysfWFSsC.png)\n>https://gahgah147.github.io/atom.xml\n\n\n# 將文章導入 WordPress\n\n我後來是使用 FeedWordPress 這個套件來匯入\n\n![image](https://hackmd.io/_uploads/BknKO6YjA.png)\n\n安裝完成之後在 New source 這邊輸入生成的  `http://你的網站域名/atom.xml`\n![image](https://hackmd.io/_uploads/H1uou6FsA.png)\n\n\n然後在這邊點選 Update Now\n![image](https://hackmd.io/_uploads/S1j1YatiA.png)\n\n以下是我成功匯入的Hexo 部落格文章\n![image](https://hackmd.io/_uploads/rJWAOpqi0.png)\n\n# 為什麼這邊Wordpress 的標題點進去之後都會導引到hexo的文章連結?\n\n當使用 RSS 將 Hexo 的文章同步到 WordPress 時，如果標題點進去後會導引到 Hexo 的文章連結，這通常是因為 RSS Feed 中的文章連結 (link 標籤) 指向的是原始網站（即 Hexo 部署的站點）。\n\n原因分析： RSS Feed 的結構中，每篇文章都有一個 link 標籤，這個標籤是用來指定該文章的原始連結。在你將 RSS Feed 匯入到 WordPress 時，這些連結會保留原本的目標（即 Hexo 部落格的 URL），因此在 WordPress 中點擊標題後會導向原始的 Hexo 網頁。\n\n使用 FeedWordPress 套件時，默認情況下匯入的文章會保留 RSS Feed 中的原始連結，因此點擊標題時會跳轉到 Hexo 的文章連結。然而，FeedWordPress 提供了一些選項，可以讓你調整這種行為。\n\n你可以按照以下步驟來修改：\n\n1. **設定 FeedWordPress 將文章匯入為 WordPress 本地內容：**\n\n   - 在 WordPress 後台，進入「FeedWordPress」的設定頁面。\n   - 在「Feeds & Updates」中，找到並點選你已經設定的 RSS Feed。\n   - 在該 Feed 的詳細設定中，找到「Posts & Links」部分。\n![image](https://hackmd.io/_uploads/B1Nz31os0.png)\n   - 會看到一個選項「Permalinks point to:」，將此選項設置為「The local copy on this website」而不是「The original source of the syndicated item」。\n\n![image](https://hackmd.io/_uploads/HJFUhyoj0.png)\n>這邊應該要改為The local copy on this website\n\n   這樣設置後，FeedWordPress 會將匯入的文章設置為本地的 WordPress 文章，並且點擊標題後將導向 WordPress 上的文章頁面，而非 Hexo 原始連結。\n\n2. **手動修改匯入的文章：**\n\n   如果希望更加自定義某些文章的行為，也可以在文章匯入後手動編輯文章中的連結。\n\n透過這些設定，就可以讓 FeedWordPress 將 RSS Feed 的文章匯入為 WordPress 本地內容，避免跳轉到 Hexo 的文章頁面。\n\n\n# 總結 \n\n這樣就可以成功同步 Hexo 的文章到 WordPress 部落格文章上，有些細節還是要花點時間測試調整之後才知道如何改動，這些功能實際大約花了我3天時間，大家如果之後有需要把hexo部落格搬家可以參考看看，同時也可以考慮保留兩邊的部落格，因為自動化導入RSS的功能我覺得其實蠻方便的，另外Hexo加上github的架設其實不用額外花錢維護。\n\n","tags":["Wordpress","Hexo","ATOM","RSS"],"categories":["架站記錄"]},{"title":"Harbor：Docker的港口 - 容器映像檔管理工具","url":"/2024/08/23/Harbor：Docker的港口-容器映像檔管理工具/","content":"\n\n![image](https://hackmd.io/_uploads/SJByrurj0.png)\n\n隨著容器技術的普及，企業在部署和管理容器應用時面臨越來越多的挑戰。如何有效地管理和保護大量的容器映像檔成為企業的重要課題。Harbor 作為一個企業級的容器映像檔管理解決方案，應運而生，提供了全面的功能來解決這些問題。\n\n## 什麼是 Harbor？\n\nHarbor 是一個開源的容器映像檔倉庫，最初由 VMware 開發，後來捐贈給 CNCF（Cloud Native Computing Foundation）。Harbor 的設計目標是提供一個安全、可靠且高效的容器映像檔管理平台。它不僅僅是一個映像檔倉庫，更是一個具備多種企業級功能的管理解決方案。\n\n## Harbor 的主要功能\n\n1. **多租戶支持與角色管理**\n   - Harbor 提供了完善的多租戶支持，可以為不同的團隊或項目設置獨立的命名空間，並基於角色的權限管理來控制對映像檔的訪問權限。這樣可以確保不同團隊的數據隔離和訪問控制，提升了企業級應用的安全性。\n\n2. **映像檔簽名與漏洞掃描**\n   - Harbor 集成了映像檔簽名和漏洞掃描功能。使用者可以在推送映像檔之前，對其進行簽名，保證映像檔的完整性和可信度。同時，Harbor 會自動掃描映像檔中的漏洞，並生成詳細的報告，幫助開發者及時修復安全問題。\n\n3. **鏡像複製**\n   - 在全球部署應用時，映像檔的高效傳輸至關重要。Harbor 提供了跨數據中心和雲環境的鏡像複製功能，確保映像檔能夠快速部署到全球各地的數據中心，減少了部署延遲並提升了應用的可用性。\n\n4. **細粒度的訪問控制**\n   - 透過集成 OAuth 及 LDAP，Harbor 支持基於用戶、組別、命名空間的細粒度訪問控制，從而保證了敏感數據的安全性。管理者可以根據需要靈活設置用戶和組別的訪問權限，確保只有授權用戶才能夠訪問特定的映像檔。\n\n5. **審計日誌**\n   - Harbor 提供了全面的審計日誌功能，記錄所有用戶的操作行為，幫助企業進行安全審計和問題追踪。這在合規性要求高的環境中特別重要，確保企業能夠符合各種法規和內部安全政策。\n\n6. **Web UI 及 RESTful API**\n   - Harbor 提供了直觀的 Web UI，方便用戶管理和瀏覽映像檔，同時還提供了功能強大的 RESTful API，供開發者進行二次開發或集成。這使得 Harbor 能夠靈活地融入企業現有的開發和運維流程中。\n\n## 為什麼選擇 Harbor？\n\nHarbor 的多功能性和可擴展性使其成為企業管理容器映像檔的理想選擇。它不僅能夠幫助企業提高容器應用的安全性，還能夠簡化映像檔的管理和部署流程，讓企業可以更專注於核心業務的開發和創新。\n\nHarbor 的開源性意味著企業可以根據自己的需求進行定制，並且擁有活躍的社區支持，保證了持續的更新和改進。無論是大型企業還是初創公司，Harbor 都能為其容器映像檔管理提供有力的支持。\n\n# 結論\n\n隨著容器技術的日益普及，選擇一個合適的容器映像檔管理工具至關重要。Harbor 作為一個功能豐富、安全性強、易於擴展的解決方案，能夠滿足企業在多租戶管理、漏洞掃描、鏡像複製等方面的需求，是企業級應用的不二之選。\n\nHarbor 為企業提供了強大的工具來應對容器管理中的各種挑戰，從而讓企業能夠在雲原生應用的開發和運營中更加從容。","tags":["Docker","Harbor"]},{"title":"Velero: Kubernetes 中的帆船備份與災難復原工具","url":"/2024/08/23/Velero-Kubernetes-中的帆船備份與災難復原工具/","content":"\n![image](https://hackmd.io/_uploads/rJS0m_SoC.png)\n\n隨著 Kubernetes (K8s) 在全球企業中的接受度不斷上升，越來越多的企業選擇使用 K8s 來部署服務。K8s 的靈活性和可擴展性使得它成為現代企業基礎設施的重要組成部分。然而，隨著應用程式的日益複雜，備份與災難復原成為了運營過程中不可忽視的課題。這篇文章將介紹 Velero，一款強大的開源工具，專為 Kubernetes 集群的備份、還原、災難復原以及資料遷移設計。\n\n## 為什麼需要備份？\n\n在生產環境中，難免會遇到一些不可控的因素或意外操作，甚至是程式錯誤，這些都可能導致服務停擺。如果集群龐大或部署的服務繁多，快速找出問題來源並不容易。在某些情況下，集群設定可能已被改動，而我們也記不得原本的配置。此時，如果有備份，便能夠迅速將集群恢復至正常狀態。\n\n## 需要備份的內容\n\nK8s 使用 Controller pattern 來管理集群狀態，透過與 API Server 的協作，確保集群達到預期狀態。因此，我們需要備份的是儲存對象狀態的資料。\n\n最少需要備份以下兩個部分：\n1. **etcd**：etcd 是 K8s 中非常重要的元件，用於儲存集群的網路配置以及對象的狀態訊息。還原 etcd 等同於還原 K8s 集群狀態。\n2. **Persistent Volume (PV)**：雖然 etcd 還原了 K8s 集群狀態，但 PV 的內容不屬於 K8s 集群狀態的一部分，如資料庫中的資料。因此，除了 etcd 外，還需要備份 PV 的內容。\n\n## Velero 的功能介紹\n\nVelero 是一款開源工具，專為安全地備份與還原 Kubernetes 集群資源和持久性卷（Persistent Volumes）而設計。它的三大主要功能包括：\n1. **災難復原**：當 K8s 集群發生問題時，能夠快速恢復。\n2. **資料遷移**：在不同的 K8s 集群之間遷移應用程式。\n3. **資料保護**：對 Persistent Volume 進行備份，確保資料的完整性。\n\n## Velero 的架構\n\nVelero 通過實作 Custom Resource Definition (CRD)，並由 Velero Controller 執行備份與還原操作。備份過程大致如下：\n1. 使用者透過 velero CLI 建立 Backup object。\n2. BackupController 監聽並驗證此事件。\n3. BackupController 查詢 API Server，並備份目標資源。\n4. 最後，BackupController 將備份的資源上傳至指定的 Object Storage Service。\n\n## 備份過程中的注意事項\n\nVelero 支援兩種主要的 PV 備份方式：\n1. **Volume Snapshot**：利用 storage provider 的 snapshot 功能對資料進行快照。適合需要確保資料一致性的場景，如公有雲提供的 block storage（如 EBS、Google Compute Engine Disks、Azure Managed Disks）。\n2. **Restic**：一個支援多系統的備份還原工具，適用於沒有 snapshot 支援的場景。Restic 可以透過 Velero 備份 PV 的資料，但對於有資料一致性要求的應用，建議在備份前凍結資料。\n\n## 還原操作\n\n在還原過程中，Velero 支援一些特殊操作，如：\n- 復原到指定的 namespace。\n- 保存 service 的 NodePort。\n- 改變 PV/PVC 的 StorageClass。\n\n此外，Velero 也支援多種 hooks 來控制還原行為。\n\n## 使用範例\n\n假設我們部署了一個 nginx server 並使用 PV 儲存 log 檔案。透過 Velero，我們可以輕鬆地將整個 K8s 集群進行備份，然後在需要時進行還原。具體操作步驟如下：\n1. 安裝 CSI Driver，並配置 hostpath storage class。\n2. 部署 nginx server 並掛載 PV。\n3. 使用 Velero 進行備份。\n4. 刪除 nginx 部署，模擬災難場景。\n5. 使用 Velero 還原 nginx server，並檢查資料恢復情況。\n\n## 心得\n\nVelero 操作簡單，且輕量化的設計使其能夠支援多種平台。雖然本文演示了如何進行備份與還原，但 Velero 也支援跨集群遷移，只需在新 K8s 集群上安裝 Velero，便可輕鬆進行還原操作。然而，使用 Velero 前需仔細閱讀官方文件，了解其功能與限制，以確保能滿足自身需求。\n\n","tags":["Kubernetes","Velero","備份","災難還原"]},{"title":"GCP - Google Compute Engine (GCE) 簡介與操作實例","url":"/2024/08/23/GCP-Google-Compute-Engine-GCE-簡介與操作實例/","content":"\n# Google Compute Engine 是什麼?\n\n![image](https://hackmd.io/_uploads/BkfHy_rjA.png)\n\nGoogle Compute Engine 是 GCP 的核心運算服務，專門提供可擴展的虛擬機器，讓企業能夠運行各種工作負載。Compute Engine 支援多種作業系統、機器類型與區域選擇，並能夠與其他 GCP 服務如 Cloud Storage 和 BigQuery 無縫整合，提供靈活且高效的雲端運算解決方案。\n\nGoogle Compute Engine 的主要優勢包括：\n\n1. **可擴展性**：無論是單一 VM 還是成千上萬的 VM，Compute Engine 都能夠快速部署並靈活應對工作負載的變化。\n2. **自動化管理**：自動縮放、快照、備份和恢復等功能讓企業輕鬆管理和維護基礎架構。\n3. **高效運行**：Compute Engine 提供多種機器類型，從一般用途到高性能運算，適應不同的計算需求。\n\n![image](https://hackmd.io/_uploads/r1QhkdSoC.png)\n>https://cloud.google.com/products/compute\n\n# 如何在 GCP 中將 VM 複製到另一個專案並保留相同固定 IP?\n\n![image](https://hackmd.io/_uploads/BJpQkdBoR.png)\n在企業的業務連續性和災難恢復計畫中，維持關鍵系統的高可用性至關重要。GCP 平台提供了靈活的虛擬機（VM）管理功能，允許用戶將 VM 複製到其他專案，同時保留相同的固定 IP，從而確保網路配置的穩定性與一致性。本文將介紹如何在 GCP 中完成這一操作，並適用於備援環境的準備。\n\n## 準備工作\n\n在開始複製 VM 之前，請確保以下幾點：\n\n- **權限檢查**：確認你在源專案和目標專案中擁有足夠的權限，尤其是跨專案操作的權限。\n- **資源準備**：目標專案中是否已配置好必要的網路、子網和防火牆規則，以適應複製後的 VM。\n- **IP 地址確認**：確保目標專案中沒有其他資源占用你打算保留的固定 IP。\n\n# 跨專案複製 VM 的步驟\n\n## 創建 VM 映像\n首先，我們需要將源 VM 打包成映像，以便在目標專案中創建新的 VM。\n\n```bash\ngcloud compute images create my-vm-image \\\n  --source-disk=my-source-vm \\\n  --source-disk-zone=us-central1-a \\\n  --family=my-vm-family\n```\n\n## 將映像複製到目標專案\n接下來，我們需要將映像共享給目標專案，然後在目標專案中使用該映像創建 VM。\n\n```bash\ngcloud compute images add-iam-policy-binding my-vm-image \\\n  --member='user:target-project-user@example.com' \\\n  --role='roles/compute.imageUser'\n```\n\n## 在目標專案中創建新的 VM\n使用複製的映像在目標專案中創建 VM：\n\n```bash\ngcloud compute instances create my-new-vm \\\n  --image=my-vm-image \\\n  --zone=us-central1-b \\\n  --project=target-project-id\n```\n\n# 保留與配置相同的固定 IP\n\n## 釋放原專案中的固定 IP\n在源專案中釋放該固定 IP，並將其設置為共享狀態，這樣在目標專案中可以重新綁定。\n\n```bash\ngcloud compute addresses delete my-vm-ip \\\n  --region=us-central1 \\\n  --project=source-project-id\n```\n\n## 在目標專案中重新分配固定 IP\n將相同的 IP 地址分配給目標專案中的新 VM：\n\n```bash\ngcloud compute addresses create my-vm-ip \\\n  --addresses=EXTERNAL_IP_ADDRESS \\\n  --region=us-central1 \\\n  --project=target-project-id\n```\n\n# 測試與驗證\n\n當所有配置完成後，務必進行測試以確保 VM 能夠正常運行並成功使用所保留的固定 IP。可以進行以下測試：\n\n- **Ping 測試**：檢查新 VM 是否可以通過固定 IP 回應請求。\n- **連線測試**：驗證服務端口是否能正常連接。\n\n# 最佳實踐與注意事項\n\n- **定期演練**：為了確保備援環境的有效性，建議定期演練整個流程並進行必要的調整。\n- **監控和日誌**：利用 GCP 的監控和日誌工具，實時監控系統健康狀況並快速應對問題。\n\n# 結語\n\n通過在 GCP 中將 VM 複製到不同專案並保留相同的固定 IP，企業能夠更有效地管理備援環境，提升系統的容錯能力和業務連續性。這一流程不僅簡化了災難恢復的操作，還確保了網路配置的一致性，是確保高可用性的最佳選擇之一。\n","tags":["雲端服務","GCP"]},{"title":"GCP - Google SecOps 雲端資訊安全運營工具","url":"/2024/08/22/GCP-Google-SecOps-雲端資訊安全運營工具/","content":"\n以下圖片是我今天看到線上 APAC Security Digital Summit 2024影片分享的片段\n![image](https://hackmd.io/_uploads/ryj-X4Vj0.png)\n\n今天主要有講了四個大主題  \nGoogle Cloud：Google 的雲端服務平台，提供運算、存儲、數據分析等各種雲端解決方案。\n\nGoogle SecOps：Google 提供的安全運營解決方案，整合了威脅檢測、響應、合規性管理等功能，幫助企業保護其雲端環境的安全。\n\nMandiant：Mandiant 是一家網路安全公司，專注於威脅情報和事件響應。Mandiant 被 Google Cloud 收購後，與 Google 的安全服務整合，提升整體安全能力。\n\nMarketplace：Google Cloud Marketplace 提供各種第三方的工具和服務，幫助企業擴展其雲端功能，涵蓋安全、數據分析、開發等多個領域。\n\n這一篇文章主要想要分享我新看到的Google SecOps。\n\n隨著數位化轉型的加速，企業在雲端環境中面臨的安全威脅日益增加。為了有效應對這些挑戰，Google Cloud 提供了一套強大的安全運營（Security Operations，SecOps）解決方案，幫助企業構建更加安全和穩定的雲端環境。這篇文章將介紹 Google SecOps 的核心功能及其如何幫助企業保護其數據和基礎設施。\n\n\n# 什麼是 Google SecOps？\n\n![image](https://hackmd.io/_uploads/S1PgyDNj0.png)\n>https://cloud.google.com/security\n\nGoogle SecOps 是一套由 Google Cloud 提供的安全解決方案，旨在整合安全運營的各個方面，幫助企業快速檢測、分析和應對安全威脅。SecOps 是由 Security（安全）和 Operations（運營）結合而成的概念，強調安全與運營之間的協作，以保障雲端環境的整體安全性。\n\n## Google SecOps 的核心功能\n\n### 威脅檢測與響應\n   - Google SecOps 利用先進的威脅檢測技術，實時監控雲端環境，識別潛在的安全威脅。透過整合 Google 的威脅情報和機器學習技術，SecOps 可以快速偵測到異常行為並自動啟動響應措施。\n\n### 整合的安全分析\n   - Google 提供的 Security Command Center 是 SecOps 的核心組件之一，它能夠集中管理和分析來自各種 Google Cloud 服務的安全訊號。這種集中式的管理能讓安全團隊更快發現威脅並采取相應行動。\n\n### 合規性管理與監控\n   - Google SecOps 幫助企業確保其雲端環境符合各類合規標準，無論是全球的 GDPR 還是區域性的數據保護規範。透過自動化的合規性檢查，SecOps 能夠持續監控合規狀況，並在發現違規時及時通知相關團隊。\n\n### 自動化與協作\n   - Google SecOps 強調自動化和團隊協作，減少人為錯誤並提高回應速度。自動化的威脅響應流程能夠快速封鎖惡意活動，防止損害擴大。同時，SecOps 平台支持跨團隊協作，確保安全事件的有效處理。\n\n# 使用 Google SecOps 的好處\n\n## 強化威脅防禦\n得益於 Google 的全球安全情報網絡和強大的機器學習能力，SecOps 能夠提前預測並防禦各類網路攻擊，有效降低企業遭受攻擊的風險。\n\n## 提升運營效率\n自動化工具和集中化管理平台使得安全團隊能更有效率地處理大量安全事件，減少了人工操作的時間和錯誤率。\n\n## 合規性無縫管理\nSecOps 能夠輕鬆管理和檢查合規性，確保企業在全球不同地區都能遵守相關法律法規，降低因不合規帶來的風險。\n\n## 快速響應能力\n在發生安全事件時，SecOps 可以自動調動資源、封鎖威脅並進行恢復，確保業務不中斷，將損失降到最低。\n\n# 總結\n\n在當今快速變化的數位世界中，安全運營已成為企業成功的關鍵因素之一。Google SecOps 透過先進的技術與強大的分析能力，幫助企業應對日益複雜的安全挑戰，保障數據與業務的安全性。對於希望在雲端環境中建立堅固防線的企業來說，Google SecOps 是不可或缺的合作夥伴。\n","tags":["雲端服務","GCP","資訊安全"]},{"title":"GCP - Google Cloud Platform 的地區(Regions) 和區域(Zones)","url":"/2024/08/21/GCP-Google-Cloud-Platform-的地區-Regions-和區域-Zones/","content":"\n![image](https://hackmd.io/_uploads/HJxggfmoC.png)\n\n# 什麼是 GCP 的 Regions 和 Zones？\n\n![image](https://hackmd.io/_uploads/S1F_oWms0.png)\n   >官方說明文件鏈接：[Regions and Zones | Google Cloud](https://cloud.google.com/about/locations)\n\n在 Google Cloud Platform (GCP) 中，**Regions** 和 **Zones** 是雲端基礎設施的核心概念。Region 是分佈在全球各地的地理區域，每個 Region 由多個獨立的 Zones 組成。這些 Zones 是實際承載應用程式和資料的物理資料中心。正確選擇 Region 和 Zone 不僅影響應用的性能，還涉及數據主權、法律合規性等多方面考量。\n# 為什麼 Regions 和 Zones 很重要？\n\n讓我們透過一個具體的情境來理解 Regions 和 Zones 的重要性：\n\n**情境 1：單一資料中心**\n\n想像您的應用程式部署在倫敦的一個資料中心。如果僅依賴這個單一的資料中心，您將面臨以下挑戰：\n\n![image](https://hackmd.io/_uploads/ry9FnbQi0.png)\n\n- **挑戰 1：全球用戶訪問速度慢（高延遲）**  \n  來自世界其他地區的用戶可能會因為距離而感受到較高的延遲，影響用戶體驗。\n\n- **挑戰 2：資料中心崩潰的風險（低可用性）**  \n  如果倫敦的資料中心發生故障，您的應用程式將無法使用，導致業務中斷。\n\n**情境 2：多資料中心（單一 Region）**\n\n現在假設您在倫敦增加了一個新的資料中心。這能解決某些問題，但還是會有一些挑戰：\n![image](https://hackmd.io/_uploads/ByknnW7o0.png)\n\n\n- **挑戰 1：全球用戶訪問速度慢**  \n  雖然有多個資料中心，但它們都位於倫敦，全球用戶的訪問速度仍然會受到影響。\n\n- **挑戰 2（已解決）：單一資料中心崩潰**  \n  如果其中一個資料中心崩潰，另一個資料中心可以接手，確保應用程式的可用性。\n\n- **挑戰 3：整個倫敦地區不可用**  \n  如果整個倫敦地區發生大範圍的問題（如自然災害），所有資料中心都可能無法運行，您的應用程式將再次面臨中斷風險。\n\n**情境 3：多 Region 部署**\n\n為了進一步提升應用的可用性，我們可以在另一個 Region（例如孟買）部署資料中心：\n\n![image](https://hackmd.io/_uploads/HJ6Thb7jA.png)\n\n- **挑戰 1（部分解決）：全球用戶訪問速度慢**  \n  通過在多個 Regions 部署應用程式，您可以降低全球用戶的延遲。\n\n- **挑戰 2（已解決）：單一資料中心崩潰**  \n  如果某個資料中心崩潰，應用程式仍然可以從其他資料中心運行。\n\n- **挑戰 3（已解決）：整個 Region 不可用**  \n  如果倫敦的所有資料中心都無法使用，您的應用程式仍然可以從孟買的資料中心提供服務。\n\n透過這些情境，我們可以看到選擇多個 Regions 和 Zones 部署應用程式的重要性。Google Cloud 提供了超過 20 個 Regions，並且每年都在不斷擴展，讓您可以在全球範圍內擴展業務。\n\n# GCP Regions 和 Zones 的用途\n\n\n![image](https://hackmd.io/_uploads/rkf6jZ7jR.png)\n>官方說明文件鏈接：[Choosing Compute Engine Regions and Zones | Google Cloud](https://cloud.google.com/compute/docs/regions-zones)\n\nGCP 的 Regions 和 Zones 為您提供靈活的部署選項，讓您可以根據業務需求來優化應用程式的性能和可靠性。\n\n- **數據存儲與處理**：選擇距離最近的 Region 來降低延遲，提升用戶體驗。分散數據存儲於多個 Zones 也能減少單點故障風險。\n- **高可用性與容災**：利用多 Zone 部署，確保應用的高可用性。如果某個 Zone 出現故障，其他 Zones 可以即時接手，保持應用運行。\n\n# GCP 在亞太地區的 Regions 概況\n\n針對台灣的使用者，GCP 提供了多個在亞太地區的 Regions，這些 Regions 可以有效降低延遲並提供良好的網路連接性。以下是對台灣使用者最具吸引力的幾個 Regions：\n\n- **台灣（asia-east1）**：這是距離台灣最近的 Region，可以提供最低的延遲。\n- **香港（asia-east2）**：在亞洲其他地區擁有業務的台灣公司可以考慮香港 Region。\n- **新加坡（asia-southeast1）**：對於東南亞業務需求較大的公司，新加坡 Region 是不錯的選擇。\n\n在選擇 Region 時，台灣的使用者應該根據業務需求、數據主權考量、法律合規性以及成本來做出決定。\n\n# 如何選擇適合的 Region 和 Zone\n\n選擇適合的 Region 和 Zone 是確保應用高效運行的重要步驟。以下是幾個關鍵考量：\n\n- **性能與延遲**：GCP 提供工具來測量不同 Regions 和 Zones 的延遲。使用者可以利用這些工具來選擇延遲最低的 Region。\n- **成本考量**：不同的 Regions 可能會有不同的費用結構。在選擇 Region 時，除了性能，也需要考量運營成本。\n\n![image](https://hackmd.io/_uploads/Skgm0WXoC.png)\n> 各據點的產品供應情形：[Regions and Zones | Google Cloud](https://cloud.google.com/about/locations)\n\n在選擇地區時可以先查看一下，你會使用到的服務在那個地區有沒有支援\n\n# 如何在同一 Region 內實現高可用性？\n\n為了在同一 Region 內達到高可用性，GCP 提供了 **Zones** 概念。每個 Region 內有三個或更多的 Zones，這些 Zones 透過低延遲的網路連接在一起。這樣的設計可以提高應用的可用性和故障容忍度。\n\n- **增加可用性與容錯性**：多 Zone 部署可以確保即使某個 Zone 出現故障，應用仍然能夠正常運行。\n\n# GCP Regions 和 Zones 的最佳實踐\n\n- **多 Zone 部署**：為了提高應用的高可用性，建議在多個 Zones 部署應用，這樣即使某個 Zone 出現故障，其他 Zones 也可以接手。\n- **跨 Region 備份與容災**：設定跨 Region 的備份計劃有助於保障數據安全，防止在單一 Region 失效時數據丟失。\n\n# 總結\n選擇適當的 GCP Region 和 Zone 是確保雲端應用高效、可靠運行的關鍵。對於台灣的使用者，應根據具體業務需求選擇最合適的 Region 和 Zone，並採取最佳實踐來優化部署策略。\n\n今天介紹了 Regions 和 Zones，其實目前感覺最簡單是從最接近的點，然後如果是預算沒有上限最好是所有地區都部屬資料中心，這樣可用性最高，但最終還是要考量成本跟預算來做最好的配置，\n\n","tags":["雲端服務","GCP"]},{"title":"GCP - Google 的雲端服務 Google Cloud Platform 介紹","url":"/2024/08/21/GCP-Google-的雲端服務-Google-Cloud-Platform-介紹/","content":"\n![image](https://hackmd.io/_uploads/rkfsA6zo0.png)\n\n在這個數位化轉型的時代，雲端運算已成為企業快速發展和應對市場變化的關鍵。Google Cloud Platform (GCP) 作為領先的雲端服務提供商之一，為各種規模的企業提供了豐富的工具和服務，助力他們實現創新、優化運營並提高效率。本篇文章將深入探討 GCP 的核心功能、使用案例以及為什麼它是現代企業的理想選擇。\n\n![image](https://hackmd.io/_uploads/S1dCpTfiC.png)\n>https://cloud.google.com\n\n# 什麼是 Google Cloud Platform？\n\nGoogle Cloud Platform 是由 Google 提供的綜合雲端服務套件，涵蓋了運算、存儲、數據分析、人工智慧、機器學習、網路等多個領域。GCP 的產品組合多樣化，無論是初創公司還是大型企業，都能在 GCP 上找到適合自己的解決方案。\n\n## 核心功能\n\n1. **彈性運算能力**：GCP 提供多種運算選項，如 Compute Engine 的虛擬機、Kubernetes Engine 的容器編排，以及 Cloud Run 的無伺服器運算，滿足不同工作負載的需求。\n2. **強大的存儲和數據管理**：從 Cloud Storage 的物件存儲，到 BigQuery 的數據分析，GCP 為各類數據提供高可用性、可擴展性和安全性。\n3. **先進的人工智慧和機器學習**：GCP 擁有強大的 AI/ML 工具，如 Vertex AI，助力企業構建、訓練和部署機器學習模型，輕鬆實現 AI 驅動的業務創新。\n4. **全球網路基礎設施**：依託於 Google 的全球網路，GCP 提供快速、安全、可靠的網路服務，確保應用和服務在全球範圍內的穩定運行。\n\n\n# 目前主流的雲端服務\n\n目前市面上最主要的雲端服務有三家，Google 提供的Google Cloud Platform (GCP)、Amazon提供的Amazon Web Services (AWS)、微軟提供的Microsoft Azure \n\n## **Google Cloud Platform (GCP)**\n   - 由 Google 提供的綜合雲端服務平台，涵蓋運算、存儲、數據分析、機器學習等多領域，擁有強大的全球網路基礎設施。\n\n## **Amazon Web Services (AWS)**\n   - 亞馬遜提供的雲端平台，是目前全球市場份額最大的雲服務提供商。AWS 提供超過 200 種服務，包括運算、存儲、數據庫、機器學習、物聯網等。\n\n## **Microsoft Azure**\n   - 微軟的雲端服務平台，擁有廣泛的產品和解決方案，涵蓋運算、人工智慧、數據分析、混合雲、物聯網等領域，並且與 Windows Server 和 SQL Server 等微軟產品高度整合。\n   \n\n# 為什麼選擇 Google Cloud Platform？\n\n## 安全性和合規性\n\nGCP 在安全性上設置了多層保護機制，包括資料加密、自動防禦 DDoS 攻擊、身份驗證管理等，並且符合多項全球和區域的合規標準，讓企業無需擔心數據安全問題。\n\n## 可擴展性和彈性\n\n無論是小規模的試驗項目還是全球範圍的大型應用，GCP 都能隨時隨需擴展，確保系統始終保持最佳性能。這使得企業能夠靈活應對業務增長和市場變化。過去，企業需要購買足夠的基礎設施來應對高峰期的流量需求，但這導致了在低負載時期的資源浪費。使用 GCP 等雲端服務，企業可以按需彈性擴展或縮減資源，確保資源利用率最大化，並降低前期成本。\n\n## 降低前期成本與風險\n\n傳統上，企業需要提前購買大量基礎設施來應對潛在的業務增長，這不僅成本高昂，風險也相對較大。如果這些預期未能實現，投資便成為沉沒成本。GCP 的按需付費模式幫助企業減少了這種風險，使他們能夠更靈活地管理資本支出，將更多資源投入到核心業務中。\n\n## 高資源利用率與自動化運維\n\n在傳統的基礎設施模式下，企業常因應對高峰負載而購買過多的資源，導致大部分時間基礎設施處於閒置狀態。使用 GCP，企業只需為實際使用的資源付費，並且無需專門的維護團隊來管理和維護硬體資源，這對初創公司和中小型企業尤為有利。此外，GCP 提供了自動化的資源管理功能，企業可以將更多精力專注於創新和業務增長。\n\n## 整合性與生態系統\n\nGCP 與許多流行的開源工具、第三方應用以及其他 Google 產品無縫整合，如 Firebase、Google Workspace 等，形成了一個強大且多樣化的生態系統，支持企業構建現代化應用。這樣的整合性讓企業能夠輕鬆地運用多種工具與服務，快速響應市場需求，並持續優化其業務流程。\n\n# GCP 的常見使用案例\n\n1. **現代應用開發**：利用 GKE、Cloud Functions、App Engine 等服務，快速構建和部署可擴展的雲端應用。\n2. **大數據和分析**：結合 BigQuery、Dataflow 和 Looker，實現大數據的高效存儲、處理和分析。\n3. **人工智慧與機器學習**：透過 Vertex AI、TensorFlow 等工具，為產品和服務引入智能化功能。\n\n# 如何開始試用GCP?\n\n這邊看到可以取得$300的抵免額，能夠在未來 90 天內試用 Google Cloud。\n免費試用期結束後不會自動收費，所以大家有興趣可以申請試用3個月看看\n\n![image](https://hackmd.io/_uploads/HJpzl0MsA.png)\n>https://cloud.google.com\n\n這邊可以點選右上角的免費試用開始註冊\n\n![image](https://hackmd.io/_uploads/H1o7eCzjA.png)\n\n選擇完地區後點選同意並繼續\n\n接下來是填寫付款資訊，填寫完成後就可以開始試用GCP了\n![image](https://hackmd.io/_uploads/rJOEx0fjC.png)\n\n\n# 結語\n\nGoogle Cloud Platform 以其廣泛的服務、強大的功能和卓越的性能，成為了眾多企業數位化轉型的首選平台。無論您是希望優化現有系統，還是構建新一代應用，GCP 都能提供無與倫比的支援和保障。如果您還未開始使用 GCP，現在正是踏上雲端之旅的最佳時機。\n","tags":["雲端服務","GCP"]},{"title":"GCP：使用 Google Cloud Storage Transfer Service 管理資料轉移","url":"/2024/08/20/GCP：使用-Google-Cloud-Storage-Transfer-Service-管理資料轉移/","content":"\n![image](https://hackmd.io/_uploads/ByI180-jR.png)\n\n在當今數據驅動的世界中，資料管理和遷移對企業來說至關重要。無論是從本地環境到雲端，還是跨雲平台間的資料轉移，選擇合適的工具是成功的關鍵。這篇文章將介紹 Google Cloud 的 Storage Transfer Service（STS），並探討其核心功能、使用案例以及如何輕鬆管理大規模資料轉移。\n\n# 什麼是 Storage Transfer Service？\n\n以下是官方說明文件\n![image](https://hackmd.io/_uploads/SJEewRbsA.png)\n>https://cloud.google.com/storage-transfer/docs/overview\n\nGoogle Cloud Storage Transfer Service (STS) 是一個功能強大的工具，專為在各種來源之間自動化大規模資料轉移而設計。無論您需要從本地環境、其他雲端存儲提供者，或在 Google Cloud 的不同存儲桶之間進行資料遷移，STS 都能提供靈活且高效的解決方案。\n\n## 核心功能\n\n- **多源支援**：STS 支援多種資料來源，如 Amazon S3、Microsoft Azure、Hadoop 分布式文件系統（HDFS）等，讓您能輕鬆整合來自不同平台的資料。\n- **定時和增量傳輸**：您可以設定定時任務以自動化資料轉移，並支援增量傳輸，確保只轉移新數據，節省時間和資源。\n- **資料驗證和容錯**：在資料轉移過程中，STS 會自動執行資料完整性驗證，並具有錯誤重試機制，以確保資料轉移的可靠性。\n- **無縫整合**：與 Google Cloud Storage、BigQuery 等其他 GCP 服務無縫整合，簡化數據流程。\n\n## Storage Transfer Service 的使用案例\n\n1. **雲端資料遷移**：將資料從本地資料中心遷移至 Google Cloud Storage，提升可用性和擴展性。\n2. **跨平台資料整合**：從其他雲端平台轉移資料至 GCP，以統一管理和分析。\n3. **資料備份與恢復**：定期將資料備份到不同的 GCP 存儲桶，以增強資料安全性和恢復能力。\n\n# 如何使用 Storage Transfer Service？\n\n使用 Storage Transfer Service 進行資料轉移的流程相當簡單：\n\n1. **設定來源和目標**：選擇資料來源（如本地檔案系統或其他雲端平台）和目標（GCS 存儲桶）。\n2. **定義轉移規則**：設定轉移的時間表、範圍（全量或增量），以及是否進行資料壓縮或解壓縮。\n3. **啟動轉移**：開始資料轉移並監控過程，您可以查看傳輸進度、錯誤報告等。\n\n以下是開始移轉的官方文件\n![image](https://hackmd.io/_uploads/H1yhDRWoC.png)\n>https://cloud.google.com/storage-transfer/docs/create-transfers#create_a_transfer\n\n這邊可以看到有多種方式，也可以選擇多種資源，依照實際需求來使用\n![image](https://hackmd.io/_uploads/SJGz_RWo0.png)\n\n# 總結\n\nGoogle Cloud Storage Transfer Service 是一個功能強大且靈活的工具，能幫助企業有效地管理和遷移大量資料。不論是從本地環境、其他雲端平台，還是 GCP 內部的資料轉移，STS 都能提供可靠的解決方案，滿足多樣化的業務需求。如果您正考慮進行資料遷移，不妨嘗試使用 Storage Transfer Service 來簡化流程並提升效能。","tags":["GCP","資料轉移"]},{"title":"GCP - 雲端證照課程 GCP Associate Cloud Engineer 準備","url":"/2024/08/20/GCP-雲端證照課程-GCP-Associate-Cloud-Engineer-準備/","content":"\n# 什麼是 GCP Associate Cloud Engineer？\n\n這邊是Google 的 Associate Cloud Engineer 官方文件\n\n![image](https://hackmd.io/_uploads/ryCkm3WjC.png)\n>https://cloud.google.com/learn/certification/cloud-engineer\n\n![image](https://hackmd.io/_uploads/S1iVmhbjC.png)\n>https://cloud.google.com/blog/topics/training-certifications/which-google-cloud-certification-exam-should-you-take\n\n   Google Certified Associate Cloud Engineer 認證表示您能夠部署應用程式、監控運營和管理企業解決方案。此認證證明您具備使用 Google Cloud Console 和命令行介面執行常見基於平台任務的能力，以維護部署在 Google Cloud 上的解決方案。\n   \n\n# GCP 官方有哪些認證?\n\n以下是Google Cloud 認證官方說明文件\n![image](https://hackmd.io/_uploads/SJmSM2ZoA.png)\n>https://cloud.google.com/learn/certification?hl=zh_tw#why-get-google-cloud-certified\n\n**Cloud Digital Leader (雲端數位領袖課程)** - 此認證適合任何希望展示其雲端運算基礎知識的人，並展示如何使用 Google Cloud 產品和服務來實現組織目標。\n\n**Associate Cloud Engineer (雲端工程師)** - 此認證適合具有 Google Cloud 基礎知識和經驗的候選人，這些人需具備部署雲端應用、監控運作、以及管理雲端企業解決方案的能力。\n\n**Professional Google Cloud Certifications (專業 Google Cloud 認證)** - 這些認證適合具備深入經驗，能夠根據組織業務需求，為其設置雲端環境，並有服務和解決方案部署經驗的候選人。\n\n- **Professional Cloud Architect (雲端架構師)**\n- **Professional Cloud Developer (雲端開發人員)**\n- **Professional Data Engineer (資料工程師)**\n- **Professional Cloud Database Engineer (雲端資料庫工程師)**\n- **Professional DevOps Engineer (雲端開發運作工程師)**\n- **Professional Machine Learning Engineer (機器學習工程師)**\n- **Professional Network Engineer (雲端網路工程師)**\n- **Professional Security Engineer (雲端資安工程師)**\n- **Professional Workspace Administrator (Google Workspace 管理員)**\n\n這邊可以看到Associate Cloud Engineer 是在第二階段的認證\n\n# Associate Cloud Engineer 認證驗證的能力\n\n* 設置雲解決方案環境\n* 規劃和配置雲解決方案\n* 部署和實施雲解決方案\n* 確保雲解決方案的成功運行\n* 配置訪問和安全性\n\n# Associate Cloud Engineer 認證學習路徑\n根據恆逸的建議，完成以下三個課程後，能更有效地準備 GCP Associate Cloud Engineer 認證考試：\n![image](https://hackmd.io/_uploads/SyYjNKbo0.png)\n\n1. **GCPFU (Google Cloud基礎知識之核心基礎架構)** \n   - 課程名: Google Cloud Fundamentals: Core Infrastructure\n\n2. **GCPAR (使用Google Compute Engine進行架構設計)** \n   - 課程名: Architecting with Google Compute Engine\n\n3. **GCPK8S (使用Google Kubernetes Engine進行架構設計)** \n   - 課程名: Architecting with Google Kubernetes Engine\n\n# 考試內容\n* 時長：2小時\n* 註冊費：125美元\n* 考試形式：Multiple choice and multiple select，遠端或親自在Kryterion考試中心進行。\n* 先決條件：無\n* 推薦經驗：6個月以上Google Cloud實務經驗。\n* 認證更新/重新認證：考生必須重新認證以保持其認證狀態。除非在詳細的考試說明中明確說明，否則所有Google Cloud認證的有效期為自認證之日起兩年。您可以在認證到期日期前60天開始嘗試重新認證。\n\n\n# 考試準備資源與建議\n   \n## 恆逸的課程\n\n| 課程名稱                                    | 課程簡稱 | 時數  | 費用       | 點數  | 連結 |\n| ------------------------------------------- | ------ | ----- | ---------- | ----- | ----- |\n| Google Cloud基礎知識之核心基礎架構          | GCPFU  | 7小時 | NT$ 14,000 | 3.5   | [課程連結](https://www.uuu.com.tw/Course/Show/1771/Google-Cloud%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E4%B9%8B%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A4%8E%E6%9E%B6%E6%A7%8B) |\n| 使用Google Compute Engine進行架構設計       | GCPAR  | 21小時| NT$ 42,000 | 11.0  | [課程連結](https://www.uuu.com.tw/Course/Show/1772/%E4%BD%BF%E7%94%A8Google-Compute-Engine%E9%80%B2%E8%A1%8C%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88) |\n| 使用Google Kubernetes Engine進行架構設計    | GCPK8S | 21小時| NT$ 42,000 | 11.0  | [課程連結](https://www.uuu.com.tw/Course/Show/1889/%E4%BD%BF%E7%94%A8Google-Kubernetes-Engine%E9%80%B2%E8%A1%8C%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88) |\n\n\n\n## Udemy 課程\nGCP Associate Cloud Engineer - Google Cloud Certification\n![image](https://hackmd.io/_uploads/r1yyhFbiA.png)\n>https://www.udemy.com/course/google-cloud-certification-associate-cloud-engineer/?couponCode=SKILLS4SALEB\n\n# 參考文章\n\n[恆逸 - Google Cloud 認證考試介紹](https://www.uuu.com.tw/Course/Partner/Google/section=exam/title=Google%20Cloud%20%E8%AA%8D%E8%AD%89%E8%80%83%E8%A9%A6%E4%BB%8B%E7%B4%B9)\n\n[Udemy : GCP Associate Cloud Engineer - Google Cloud Certification](https://www.udemy.com/course/google-cloud-certification-associate-cloud-engineer/?couponCode=SKILLS4SALEA)\n\n# 總結\n\n以上是我目前得知關於GCP Associate Cloud Engineer 認證的資訊，我準備是想要先從Udemy這邊的課程來進行準備，因為課程價格目前看來是最低的，另外之後可能也要定期進行證照的更新。\n","tags":["GCP","雲端證照"]},{"title":"GCP - Google Cloud Storage (GCS) Google 雲端儲存服務介紹","url":"/2024/08/19/GCP-Google-Cloud-Storage-GCS-Google-雲端儲存服務介紹/","content":"![image](https://hackmd.io/_uploads/Hyk8cFhcC.png)\n\n在現今的雲端計算時代，儲存和管理大量數據變得比以往任何時候都更加重要。Google Cloud Storage (GCS) 作為 Google Cloud Platform (GCP) 的核心服務之一，提供了一個可靠且可擴展的物件儲存解決方案，適用於各種應用場景。\n\n簡單來說 Google Cloud Storage 就是在 Google 雲端平台上用來儲存東西的工具。\n\n\n## 什麼是 Google Cloud Storage?\n\n有使用 Google cloud plateform(GCP) 的話可以在介面中查詢到cloud storage像是以下這邊的圖案\n![image](https://hackmd.io/_uploads/H1tLYq3cC.png)\n\n且在右方可以看到一系列的官方教學說明，其實建議詳細操作之後就會對這個功能比較熟悉\n![image](https://hackmd.io/_uploads/HJnpYq29R.png)\n\n\n另外以下是Google Cloud Storage 的官方介紹文章\n![image](https://hackmd.io/_uploads/SJodtt35C.png)\n>https://cloud.google.com/storage?hl=zh-TW\n\nGoogle Cloud Storage 是一個物件儲存服務，它允許使用者在雲端中存儲任意大小的數據，包括結構化和非結構化數據。GCS 提供了高可用性和耐久性，並支持全球範圍內的數據存取，這使得它成為企業和開發者的理想選擇。\n\n以下是官方的教學介紹影片\nhttps://youtu.be/wNOs3LlsH6k\n\n## Google Cloud Storage 的主要功能有哪些?\n\n### 1. **一流的數據分析和機器學習/AI 工具**：當資料存入 Cloud Storage 後，即可輕鬆運用 Google Cloud 的強大工具，包括使用 BigQuery 建立資料倉儲，使用 Dataproc 執行開放原始碼數據分析，或使用 Vertex AI 建構及部署機器學習 (ML) 模型。。\n  \n![image](https://hackmd.io/_uploads/HJLESc3cA.png)\n>https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes\n\n### 2. **自動轉換儲存空間級別**：透過物件生命週期管理 (OLM)、自動調整級別等功能，您可以輕鬆利用不同儲存空間級別來存放物件，獲得最佳成本效益。您可以在值區層級設定政策，按照上次存取時間自動將物件移至存取頻率較低的儲存空間級別。在存取頻率較低的儲存空間級別中，提前刪除資料或擷取資料都不會產生費用，也沒有級別轉換費用。\n\n![image](https://hackmd.io/_uploads/rkp5H9n9C.png)\n\n\n### 3. **有服務水準協議保證的洲際規模複製機制**：領先業界的雙區域值區支援大量區域。單一的洲際規模值區提供橫跨三大洲的九個區域，復原時間目標 (RTO) 為零。即便服務發生中斷，應用程式也能順暢存取備用區域中的資料，沒有容錯移轉和容錯回復過程。如果機構的可用性需求極高，搭配使用強化型複製功能與雙區域值區可以提供 15 分鐘的復原點目標 (RPO) 服務水準協議。\n\n### 4. **使用 Cloud Storage 做為本機檔案系統**：使用者經常選用 Cloud Storage 儲存訓練資料、模型和查核點，以供 Cloud Storage 值區中的機器學習專案中的機器學習專案使用。Cloud Storage FUSE 不僅能讓您充分發揮 Cloud Storage 可擴充、價格實惠、高處理量和簡單易用的特性，同時更支援使用或需要檔案系統語意的應用程式。 Cloud Storage FUSE 現在也提供快取功能，與原生機器學習架構資料載入器相比，訓練時間縮短為 2.2 倍，訓練處理量也提升達到 2.9 倍。\n\n![image](https://hackmd.io/_uploads/BkY0SqhqR.png)\n\n### 5. **利用檔案目錄報告管理物件儲存空間**:目錄報告包含與物件相關的中繼資料資訊，例如物件的儲存空間級別、ETag 和內容類型。這些資訊可協助您分析儲存成本、稽核及驗證物件，並確保資料安全無虞且符合法規。您可以將目錄報告匯出為半形逗號分隔值 (CSV) 檔案或 Apache Parquet 檔案，進一步使用 BigQuery 等工具進行分析。進一步瞭解儲存空間分析目錄報告。\n\n![image](https://hackmd.io/_uploads/ryXz89n5R.png)\n>以上內容都是來自Google cloud storage官方說明文件，還有更多功能可以展開查看https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes\n\n## GCS 的應用場景\n\n### 1. **數據備份和災難恢復**：GCS 是數據備份的理想選擇，並能夠與全球各地的資料中心協同工作來進行災難恢復。\n\n![image](https://hackmd.io/_uploads/BkD0Uq35C.png)\n>以上圖片是來自Google cloud storage官方說明文件https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes\n\n運作原理:Cloud Storage 的 [Nearline Storage](https://cloud.google.com/storage/docs/storage-classes#nearline) 提供快速、低成本且高度耐用的儲存服務，可用來存放每月存取不到一次的資料，能降低備份和封存成本，並保留即時存取資料的能力。所有儲存空間級別的延遲時間皆為毫秒等級，且透過同一個 API 來存取，所以除了復原作業之外，Cloud Storage 中的備份資料也可以用於其他用途\n\n[關於Nearline Storage 的詳細介紹可以參考這個官方文件](https://cloud.google.com/storage/docs/storage-classes#nearline)\n\n### 2. **內容存放與傳遞**：GCS 可以作為靜態網站或應用程式資源的存儲位置，並能與 CDN（內容分發網絡）配合，提升內容傳遞速度。\n\n![image](https://hackmd.io/_uploads/BkX0Pqn5A.png)\n>以上圖片是來自Google cloud storage官方說明文件https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes\n\n運作原理:利用 Cloud Storage 的異地備援功能，將音訊或視訊直接串流至應用程式或網站。異地備援儲存空間具備最高級別的可用性與效能，因此非常適合以低延遲而高 QPS 的方式，將內容提供給位於不同地理區域的使用者。\n\n\n3. **大數據分析**：GCS 與 BigQuery 等工具整合，方便儲存並分析大量結構化和非結構化數據。\n\n![image](https://hackmd.io/_uploads/rywxu539R.png)\n>以上圖片是來自Google cloud storage官方說明文件https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes\n\n運作原理:建立用於數據分析的資料湖泊\n開發及部署資料管道和儲存空間，以便分析大量資料。Cloud Storage 具備高可用性、效能和同步一致性，可讓您安心地準確處理數據分析工作負載。\n\n[關於使用cloud storage建立的資料湖泊(BigLake tables)可以參考這篇官方介紹文件](https://cloud.google.com/bigquery/docs/create-cloud-storage-table-biglake#cloud-storage-as-data-lake)\n\n4. **機器學習與 AI**:GCS 可以啟動 Google 推薦的預先設定解決方案，透過生成式 AI 快速擷取文字，並為儲存在 Cloud Storage 中的大量文件產生摘要。\n\n![image](https://hackmd.io/_uploads/Sk8kiqnqC.png)\n>以上圖片是來自Google cloud storage官方說明文件https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes\n\n5. **託管網站**：可以使用 Google Cloud 控制台中建構、託管及經營動態網站。\n\n![image](https://hackmd.io/_uploads/rkWcs525R.png)\n>以上圖片是來自Google cloud storage官方說明文件https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes\n\n運作原理:使用 Python 和 JavaScript，推出可公開存取及自訂的直接出貨零售產品範例網站。\n\n## 如何使用 Google Cloud Storage\n\n### 1. **建立 Bucket**：在 GCS 中，所有數據都儲存在 Bucket 中。首先，創建一個 Bucket，並選擇適合的存儲類別與區域。\n\n![image](https://hackmd.io/_uploads/r17mp535C.png)\n>可以先點擊畫面中的Create\n\n![image](https://hackmd.io/_uploads/HyaXG7giC.png)\n>這邊設定bucket的名字，例如 test-bucket-2024-08-19 \n\n![image](https://hackmd.io/_uploads/S1YcfXxsR.png)\n>設定地點\n\n![image](https://hackmd.io/_uploads/SJqnM7lsA.png)\n>選擇儲存類型\n\n![image](https://hackmd.io/_uploads/BkVeX7eiC.png)\n>選擇如何控制對物件的存取權限\n\n![image](https://hackmd.io/_uploads/B15JEQgoR.png)\n>這部份是在解釋如何保護 Google Cloud Storage (GCS) 中的物件數據，以及可用的額外數據保護選項。\n\n**選擇如何保護物件數據**  \n您的數據在 Cloud Storage 中始終受到保護，但您還可以選擇以下額外的數據保護選項，以增加安全層級。\n\n**數據保護選項**\n\n**自定義軟刪除策略（用於數據恢復）**  \n   啟用後，將覆蓋預設的保留期。刪除的物件將在指定的時間內被保留，在此期間可以恢復。如果設置為 0 天，則刪除的物件無法恢復。了解更多\n\n**物件版本控制（用於版本管理）**  \n   用於恢復被刪除或覆蓋的物件。為了最小化存儲版本的成本，建議限制每個物件的非當前版本數量，並設定它們在若干天後過期。了解更多\n\n**保留（用於合規性）**  \n   用於在指定的時間內防止刪除或修改存儲桶中的物件。\n\n接下來按下 Create 之後會顯示以下畫面\n![image](https://hackmd.io/_uploads/SJ3VVQgoR.png)\n\n這邊可以選擇是否要公開開放存取這個Bucket\n\n![image](https://hackmd.io/_uploads/rkSkLXeoC.png)\n>這邊可以看到我們剛剛創建的Bucket\n\n### 2. 上傳與管理數據：使用 GCP 提供的工具或 API，將文件上傳至 Bucket，並設定存取控制與生命周期管理。\n\n\n![image](https://hackmd.io/_uploads/rkSkLXeoC.png)\n>這邊可以點選我們剛剛創建的Bucket進入查看細節\n\n![image](https://hackmd.io/_uploads/B1iPIQgoA.png)\n>這邊可以看到Bucket的細節\n\n![image](https://hackmd.io/_uploads/BJ9mP7loR.png)\n>這邊可以看到上傳檔案的按紐\n\n![image](https://hackmd.io/_uploads/S1kYP7xoC.png)\n>可以測試上傳檔案\n\n### 3. 訪問與整合：透過網址或整合至其他 GCP 服務中訪問存儲在 GCS 的數據，並根據需求設定許可權。\n\n具體來說，可以查看以下兩份文件來實作：\n\n**[公開訪問和連結的官方指南](https://cloud.google.com/storage/docs/access-public-data)** - 這份文件描述如何設定物件的公開連結以及使用不同的 URL 格式來存取 GCS 中的數據。\n   \n![image](https://hackmd.io/_uploads/H1Mkt7gjA.png)\n> 使用URL的方式\n\n![image](https://hackmd.io/_uploads/SkXMt7xsA.png)\n>還有使用程式語言的方式存取，可以依照你的需求來選擇\n\n**[使用客戶端程式庫來存取](https://cloud.google.com/storage/docs/reference/libraries)** - 此文件涵蓋了如何將 GCS 與 BigQuery、Compute Engine 以及其他 GCP 服務整合。\n\n![image](https://hackmd.io/_uploads/ByaOK7esA.png)\n>這邊可以看到各種程式語言的客戶端程式庫(client library)，這邊可以依照你的環境需求做使用。\n\n## 結論\n\n今天跟大家介紹的Google Cloud Storage的簡單概念跟使用情境，Google Cloud Storage 是一個靈活且強大的物件存儲解決方案，適合各種規模的企業和開發者使用。無論是備份數據、內容傳遞、還是大數據分析，GCS 都能提供高效且經濟的存儲選擇。隨著企業對數據管理需求的不斷增長，GCS 為其提供了穩定且可靠的雲端儲存支持。\n\n如果您有興趣了解更多細節，歡迎在下方留言跟我討論。\n","tags":["GCP","GCS","雲端","Google"]},{"title":"Honeygain 蜜蜂幣 - 使用手機掛網輕鬆賺取被動收入的好工具","url":"/2024/08/16/Honeygain-蜜蜂幣-使用手機掛網輕鬆賺取被動收入的好工具/","content":"\n哈囉，大家好，我是 Nalson 今天要跟大家分享一個輕鬆賺取被動收入的工具——[Honeygain](https://r.honeygain.me/GAHGA2FC21)。這個平台支援手機和電腦，只要安裝 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 的 APP 或電腦程式，然後像平常一樣使用設備，就能輕鬆透過掛機網路來賺取額外收入。\n\n不需要額外的操作或投入，只要保持設備連網，你就能開始積累收益，讓被動收入變得簡單又實在。\n\n![image](https://hackmd.io/_uploads/ryiG3zic0.png)\n\n# Honeygain 是什麼?\n\n[Honeygain](https://r.honeygain.me/GAHGA2FC21) 是一個可以讓使用者賺取被動收入的應用程式和平台。透過 [Honeygain](https://r.honeygain.me/GAHGA2FC21)，用戶可以分享自己設備（如手機或電腦）的閒置網路頻寬，來幫助企業進行各種網路相關的任務，如網路研究、廣告驗證和內容交付等。作為回報，用戶會根據分享的網路流量量獲得相應的報酬。\n\n![image](https://hackmd.io/_uploads/H1UESBjcA.png)\n\n使用 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 非常簡單，只需要下載並安裝應用程式，註冊帳號後啟動應用即可開始賺錢。該應用在背景運行，不會影響設備的日常使用。隨著網路流量的累積，用戶可以將賺取的積分兌換成現金或其他獎勵。[Honeygain](https://r.honeygain.me/GAHGA2FC21) 特別適合不常使用全部網路頻寬的用戶，因為它能夠將閒置的資源轉化為收益。\n\n\n![image](https://hackmd.io/_uploads/S1Qkifo9C.png)\n>https://r.honeygain.me/GAHGA2FC21\n\n# 為什麼 Honeygain 掛網可以賺錢?\n\n![image](https://hackmd.io/_uploads/SkkVVSi9C.png)\n\n\n[Honeygain](https://r.honeygain.me/GAHGA2FC21) 掛網可以賺錢的原因是它將用戶設備的閒置網路頻寬出租給第三方企業，用來進行各種合法的網路相關任務。這些企業可能需要大量分散式的網路流量來進行以下活動：\n\n1. **市場研究**：企業利用全球各地的網路流量來進行價格比較、趨勢分析或競爭對手調查。\n2. **廣告驗證**：用來檢查廣告在不同地區的顯示情況，以確保其準確性和合規性。\n3. **內容交付**：企業可能需要透過多個節點來分發內容，以確保穩定和快速的傳輸。\n\n當你在設備上安裝並啟用 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 後，它會在背景中將閒置的網路頻寬出租給這些企業，並根據你所分享的網路流量給予報酬。因為這些任務需要遍佈全球的多個網路節點，[Honeygain](https://r.honeygain.me/GAHGA2FC21) 提供了企業所需的分佈式網路資源，而你則可以輕鬆獲得一筆被動收入。\n\n更多詳細資訊可以參考以下官方介紹影片。\nhttps://youtu.be/6RDNT-f8Pv4?si=Blic3oABWI9EvGa7\n\n# 如何開始註冊使用 Honeygain?\n\n點擊這裡註冊，透過[我的Honeygain推薦連結註冊](https://r.honeygain.me/GAHGA2FC21)可獲得 3 美元獎勵。以下是註冊流程：\n\n點擊連結：進入 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 網站。\n註冊帳號：輸入你的資料並完成註冊。\n驗證信箱：收取並確認驗證郵件。\n開始賺錢：登入後即可開始使用 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 賺取收入。\n\n![image](https://hackmd.io/_uploads/HyPy_rsqA.png)\n\n\n透過我的連結進入可以看到我的邀請代碼\n![image](https://hackmd.io/_uploads/H19h_Hs5A.png)\n\n註冊成功會發驗證信到你的信箱，點選確認驗證信箱，然後會跳轉到主頁面，\n![image](https://hackmd.io/_uploads/ryShtrjc0.png)\n\n\n# 主頁面畫面\n主頁面畫面很簡單容易理解\n![image](https://hackmd.io/_uploads/ryShtrjc0.png)\n\n## honeygain 檔案下載方式\n![image](https://hackmd.io/_uploads/rJOHEr35C.png)\n\n目前支援 [Windows](https://download.honeygain.com/windows-app/Honeygain_install.exe?_gl=1*1ty5rzq*_gcl_au*OTg0MzI2MzgzLjE3MTc2MzQ2OTA.*_ga*NTA5NjE0NTgzLjE3MTc2MzQ2OTA.*_ga_3LNFBDTH6H*MTcyMzc3Mzc0MS4zLjEuMTcyMzc3ODEzNS4wLjAuMA..)、[Android](https://download.honeygain.com/android-app/honeygain_app.apk?_gl=1*13rc0ah*_gcl_au*OTg0MzI2MzgzLjE3MTc2MzQ2OTA.*_ga*NTA5NjE0NTgzLjE3MTc2MzQ2OTA.*_ga_3LNFBDTH6H*MTcyMzc3Mzc0MS4zLjEuMTcyMzc3ODEzNS4wLjAuMA..)、[For macOS](https://resources.honeygain.com/macos-app/Honeygain_1.5.1.dmg?_gl=1*13rc0ah*_gcl_au*OTg0MzI2MzgzLjE3MTc2MzQ2OTA.*_ga*NTA5NjE0NTgzLjE3MTc2MzQ2OTA.*_ga_3LNFBDTH6H*MTcyMzc3Mzc0MS4zLjEuMTcyMzc3ODEzNS4wLjAuMA..)、[For Linux](https://hub.docker.com/r/honeygain/honeygain)\n\n可以依照你自己的使用狀況下載\n\n## 蜜蜂收集畫面\n其中有蜜蜂收集條，搜集滿之後就可以換取20美元出來\n![image](https://hackmd.io/_uploads/HJjEqSsqC.png)\n\n## 收集紀錄報表\n這邊是30天內的蒐集量狀況\n![image](https://hackmd.io/_uploads/SkbnqHo5R.png)\n\n## Honeygain 掛網裝置顯示\n以下這張圖是目前有啟用 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 掛網的裝置\n![image](https://hackmd.io/_uploads/HkwCqHsqC.png)\n\n## Honeygain 額外賺錢方式\n除了網路掛機，你還可以透過以下方式賺取額外收益：\n\n1. 打開蜂蜜罐抽獎：每天收集 15 MB 就可以參加抽獎。\n2. 成就系統：完成成就後可獲得額外積分。\n3. 邀請好友：透過推薦連結，好友每賺取 10GB，你可獲得 25% 的積分分成。\n\n### 打開蜂蜜罐抽獎\n這邊是一個每天可以打開蜂蜜罐的機會\n![image](https://hackmd.io/_uploads/rynkjSj5C.png)\n\n一般每天會像這樣，收集滿 15 MB 之後就可以打開蜂蜜抽獎\n![image](https://hackmd.io/_uploads/By7QlrnqC.png)\n\n每天分享每 15 MB就可以，打開蜂蜜罐的畫面\n![image](https://hackmd.io/_uploads/BJq8hMjcC.png)\n\n### 成就系統\n這邊是成就系統，完成成就之後也可以獲得額外的積分\n![image](https://hackmd.io/_uploads/BkxhxrncR.png)\n\n### 邀請好友\n這邊是邀請好友獲得的機制，這邊也可以產生你自己的邀請碼，有人透過這個邀請碼使用[Honeygain](https://r.honeygain.me/GAHGA2FC21)來取得積分時你也可以分享到25%的積分\n![image](https://hackmd.io/_uploads/HJF-bHn9A.png)\n\n其實如果朋友數量夠多的話應該會是一筆不錯的被動收入。趕快試試看吧！\n\n# 進階賺錢攻略：啟用Jumptask賺取額外的10%積分\n\n## Jumptask是什麼?\nJumpTask 是一個去中心化的自由工作（gig economy）平台，透過區塊鏈技術連接企業和自由工作者。該平台允許用戶完成各種微型任務（如填寫問卷、測試應用程式、參與市場調查等），並以加密貨幣（通常是其原生代幣 JT）來獲取報酬。\n\nJumpTask 的目標是透過去中心化的方式為企業提供靈活的勞動力，同時為全球的自由工作者提供賺取收入的機會。這種模式消除了傳統平台的中介費用，讓企業和工作者都能享受更高的收益和效率。\n\n## 如何在 Honeygain 上面使用 JumpTask\n![image](https://hackmd.io/_uploads/SJYlDB35A.png)\n\n這邊可以在官方網站看到 JumpTask 與 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 合作，允許 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 用戶將他們的收益直接兌換成 JumpTask 的加密貨幣，並在 JumpTask 平台上使用這些代幣進行更多任務或提取到加密貨幣錢包。\n\n使用 Jumptask 的話可以獲取額外的10% 收入，但是這邊要注意Jumptask 是加密貨幣，加密貨幣的價值是會上下浮動的，且出金方式要改為加密貨幣出金。\n\n![image](https://hackmd.io/_uploads/SJ0iLBh90.png)\n\n\n# 總結\n\n總的來說，[Honeygain](https://r.honeygain.me/GAHGA2FC21) 是一個不需要投入額外時間和精力就能賺取被動收入的好工具。只要安裝應用程式並保持設備連網，你就能輕鬆將閒置的網路頻寬轉化為現金收入。對於那些擁有穩定網路連線的用戶來說，這是一個非常實用的賺錢方法。\n\n此外，透過完成成就、打開蜂蜜罐、邀請好友等多種方式，你還可以進一步增加收益。如果你正在尋找一個輕鬆無壓力的被動收入來源，那麼 [Honeygain](https://r.honeygain.me/GAHGA2FC21) 絕對值得一試。立即透過我的推薦連結註冊，開始體驗簡單又有趣的賺錢方式吧！，如果有嘗試也歡迎跟我討論賺取蜜蜂的結果。\n","tags":["被動收入","區塊鏈","Honeygain","JumpTask"],"categories":["被動收入"]},{"title":"蝦皮分潤計畫介紹：如何賺取額外被動收入","url":"/2024/08/14/蝦皮分潤計畫介紹：如何賺取額外被動收入/","content":"\n![image](https://hackmd.io/_uploads/H1mzKpYqC.png)\n\n在數位時代，線上購物成為了我們生活中不可或缺的一部分。隨著電商平台的迅速發展，蝦皮（Shopee）作為其中的領導者，提供了多種創造收入的方式。其中，蝦皮分潤計畫（Shopee Affiliate Program）是一個非常吸引人的選擇。如果你對賺取額外收入感興趣，這個計畫或許正是你所需要的！\n\n# 什麼是蝦皮分潤計畫？\n\n蝦皮分潤計畫是一個聯盟行銷計畫，讓網站擁有者、部落客、社交媒體影響者等，通過推廣蝦皮平台上的商品來賺取佣金。參加這個計畫的會員可以獲得獨特的聯盟鏈接，並將這些鏈接放置在自己的網站、部落格或社交媒體上，當有用戶通過這些鏈接進行購買時，會員便能夠獲得一定比例的佣金。\n\n![image](https://hackmd.io/_uploads/HyLGOpt90.png)\n>https://help.shopee.tw/portal/10/article/123888-%E8%9D%A6%E7%9A%AE%E5%88%86%E6%BD%A4%E8%A8%88%E7%95%AB%E4%BB%8B%E7%B4%B9?previousPage=secondary%20category\n\n# 如何參加蝦皮分潤計畫？\n\n1. **註冊成為聯盟會員**\n   - 訪問蝦皮分潤計畫申請網站，註冊成為聯盟會員。填寫必要的個人資訊和銀行帳戶資料以便於未來的佣金發放。\n\n![image](https://hackmd.io/_uploads/H1mzKpYqC.png)\n>https://affiliate.shopee.tw/?previousPage=other%20articles\n\n點選立刻加入後會需要登入蝦皮帳號\n![image](https://hackmd.io/_uploads/SJKAYaK5R.png)\n\n填寫完資料之後會顯示以下畫面\n![image](https://hackmd.io/_uploads/B1QX5aF50.png)\n\n\n2. **選擇推廣商品**\n   - 登入聯盟平台後，你可以選擇你想要推廣的商品或店鋪。蝦皮提供了豐富的商品類別，你可以根據你的受眾選擇最合適的商品進行推廣。\n\n3. **獲取聯盟鏈接**\n   - 生成推廣鏈接或廣告素材，將其放置在你的網站、部落格或社交媒體上。這些鏈接將追蹤所有經由你推廣所產生的交易。\n\n4. **推廣與賺取佣金**\n   - 當用戶通過你的聯盟鏈接進行購買時，你將會獲得相應的佣金。蝦皮分潤計畫的佣金比例根據不同的商品類別和銷售量會有所不同。\n\n# 蝦皮分潤計畫的優勢\n\n- **高佣金比例**：蝦皮提供具有競爭力的佣金比例，幫助你獲得可觀的收入。\n- **豐富的商品選擇**：從電子產品到生活用品，蝦皮擁有廣泛的商品種類，適合各種不同的推廣策略。\n- **簡單的操作**：註冊和使用過程簡單明瞭，適合各種程度的推廣者。\n- **詳細的報告功能**：提供詳細的銷售報告和數據分析，幫助你了解推廣效果並調整策略。\n\n# 如何提高分潤收入？\n\n1. **選擇熱門商品**：推廣市場上需求量大的商品，提高轉換率和銷售量。\n2. **優化推廣內容**：撰寫吸引人的商品評測和介紹，增加用戶的點擊和購買意願。\n3. **利用社交媒體**：在社交媒體上積極推廣，擴大你的影響力和受眾範圍。\n4. **定期更新內容**：保持網站和部落格內容的更新，吸引更多的流量和訪問。\n\n# 總結\n\n蝦皮分潤計畫是一個既簡單又有效的賺錢方式，無論你是部落客、網紅還是網站擁有者，都可以通過參加這個計畫來獲得額外的收入。只要你善用推廣技巧，選擇合適的商品並持續優化你的推廣策略，相信你一定能在蝦皮分潤計畫中獲得滿意的收益！\n","tags":["聯盟行銷","被動收入","蝦皮分潤計畫"]},{"title":"探索 Gizzmo AI ：用AI撰寫Amazon聯盟行銷推廣文章賺取被動收入，WordPress 內容創建和聯盟行銷的完美結合","url":"/2024/08/14/探索-Gizzmo-AI-：用AI撰寫Amazon聯盟行銷推廣文章賺取被動收入，WordPress-內容創建和聯盟行銷的完美結合/","content":"\n# Gizzmo AI 是什麼 ?\n![image](https://hackmd.io/_uploads/BkWnyBvcR.png)\n>https://gizzmo.ai/\n\nGizzmo AI 是一款專為 WordPress 使用者設計的 AI 工具，主要用於快速生成高質量且經過 SEO 優化的內容。\n\n這款工具特別適合於希望通過聯盟行銷來賺取收入的網站擁有者。\n\nGizzmo AI 可以自動生成與 Amazon 產品相關的內容，幫助使用者找到合適的關鍵詞並分析文章的語法與拼寫錯誤，還能自動插入 Amazon 的聯盟連結，增加收入潛力。\n\n![image](https://hackmd.io/_uploads/r11sksF5A.png)\n\n---\n\n# Gizzmo 收費方式\n![image](https://hackmd.io/_uploads/S1-qnBwcC.png)\n>https://gizzmo.ai/#Pricing\n\n![image](https://hackmd.io/_uploads/HJivb5F50.png)\n\n這裡提供了一個清晰的 Gizzmo AI 收費方案比較表格，包括 Lite、Builder、Pro 和 Unlimited 四種版本的功能和費用差異。\n\n| **功能 / 版本**         | **Lite (免費)**  | **Builder ($19.99/月)** | **Pro ($49.99/月)** | **Unlimited ($99.99/月)** |\n|------------------------|-----------------|-------------------------|--------------------|--------------------------|\n| **每月文章數**         | 不限             | 25 篇                   | 150 篇              | 1000 篇                   |\n| **產品評測文章**       | ✅                | ✅                        | ✅                   | ✅                         |\n| **產品推薦文章**       | ✅                | ✅                        | ✅                   | ✅                         |\n| **一般內容文章**       | ✅                | ✅                        | ✅                   | ✅                         |\n| **完整的 SEO 工具箱**  | ❌                | ✅                        | ✅                   | ✅                         |\n| **聯盟行銷套件**       | ❌                | ✅                        | ✅                   | ✅                         |\n| **自動化後期製作**     | ❌                | ✅                        | ✅                   | ✅                         |\n| **Amazon 圖片建議**    | ✅                | ✅                        | ✅                   | ✅                         |\n| **專屬帳號限制**       | 1 個              | 1 個                     | 1 個                | 1 個                      \n| **退款保證**           | ❌                | ✅                        | ✅                   | ✅                         |\n| **隨時取消**           | ❌                | ✅                        | ✅                   | ✅                         |\n\n\n值得注意的是，Gizzmo AI 的免費版（Lite）已經能夠生成高品質的產品評測和推薦文章，這對於剛起步或資金有限的內容創作者來說是一個非常實用的工具。這意味著你可以利用免費版來產生專業的開箱測試文章，而不需要立刻投入成本。\n\n因此，如果你需要一個強大的內容生成工具，但又不確定是否要購買高階版本，那麼免費版將是一個很好的起點。隨著需求的增長，你可以隨時升級到更高版本，以獲得更多的功能和服務。\n\n---\n\n# 安裝 Gizzmo AI 插件步驟\n\n**登入 WordPress 後台**，點選 **外掛**  \n   ![image](https://hackmd.io/_uploads/rJwEiHDqA.png)\n\n點選 **安裝外掛**  \n   ![image](https://hackmd.io/_uploads/HkyvoSvcR.png)\n\n查詢 **Gizzmo**  \n   ![image](https://hackmd.io/_uploads/SyucjBPqC.png)\n\n點選 **立即安裝**  \n   ![image](https://hackmd.io/_uploads/Hyo2jrD5R.png)\n\n點選 **啟用**  \n   ![image](https://hackmd.io/_uploads/r1YCiSP50.png)\n\nGizzmo 插件已成功安裝，會出現在後台選單中  \n   ![image](https://hackmd.io/_uploads/rkFB3rwqC.png)\n\n---\n\n# 設定 Gizzmo 後台\n\n首先填寫一些基本資料，例如名稱、Email 和密碼  \n   ![image](https://hackmd.io/_uploads/Sk8oTSP5R.png)\n\n設定 Gizzmo Chrome 插件  \n   ![image](https://hackmd.io/_uploads/SJqgCrDcA.png)\n\n   點選這個按鈕  \n   ![image](https://hackmd.io/_uploads/SkL8ABwqR.png)  \n   前往 Gizzmo Chrome 插件安裝頁面。\n\n   點選 **加到 Chrome**  \n   ![image](https://hackmd.io/_uploads/r1Y90Swq0.png)\n\n   前往 Amazon 的產品頁面，例如：https://www.amazon.com/dp/B09B8V1LZ3  \n   在跳出的 Gizzmo 視窗中填入後台顯示的 token  \n   ![image](https://hackmd.io/_uploads/SJ54xIv5R.png)\n\n   點選 + 把產品加入後台  \n   ![image](https://hackmd.io/_uploads/SyBAxLDcC.png)  \n   成功加入的畫面如下：  \n   ![image](https://hackmd.io/_uploads/SkYeWLvqR.png)\n\n   點擊 ![image](https://hackmd.io/_uploads/BJDEbID9A.png) 進入下一步\n\n   顯示設定成功的畫面  \n   ![image](https://hackmd.io/_uploads/BkmLZUDcA.png)\n\n---\n\n# 開始產生文章\n\n一開始會顯示的公告畫面  \n![image](https://hackmd.io/_uploads/HksibIwcC.png)  \n內容是 Gizzmo AI 2.0.7 的更新公告和使用指引。Gizzmo AI 是一個利用人工智慧幫助創建內容的平台。這裡是內容的重點：\n\n- **歡迎詞**：歡迎使用 Gizzmo AI 2.0.7，平台的使命是幫助你根據真實產品事實和經過驗證的用戶評論創建有價值的內容。\n\n- **注意事項**：\n  1. **AI 驅動的內容生成**：使用 AI 生成的內容後，請檢查並調整以符合你的個人風格和語調。\n  2. **AI 生成的圖片**：在發佈前，請檢查所有 AI 生成的圖片。\n  3. **免責聲明**：不要忘記添加有關亞馬遜佣金和 AI 使用的免責聲明。\n\n- **Gizzmo AI 2.0.7 的新功能**：\n  - 支援比較文章和清單文章。\n  - 增強的自訂選項。\n  - 改進的 UI/UX，提供更流暢的工作流程。\n  - 支援更多亞馬遜商店。\n  - 支援 44 種語言。\n\n- **支援**：如果需要幫助，支援團隊隨時提供協助。\n\n接下來點選畫面上的 **Pepare** 讓 AI 幫你產生文章  \n![image](https://hackmd.io/_uploads/SkFMzIw5R.png)\n\n產生中的畫面  \n![image](https://hackmd.io/_uploads/BkJvMIwq0.png)\n\n產生完成  \n![image](https://hackmd.io/_uploads/S189fUDcR.png)\n\n因為免費版所以有些功能不能選擇，但可以將語言調整為繁體中文  \n![image](https://hackmd.io/_uploads/SklCzLPc0.png)\n\n接下來 AI 會開始撰寫文章  \n![image](https://hackmd.io/_uploads/ByUHmLDcR.png)\n\n這邊可以看到 Gizzmo AI 幫我產生的文章草稿  \n![image](https://hackmd.io/_uploads/r1CdmIw90.png)\n\n下面的連結是成功產生的文章，發佈在[我的wordpress版本部落格](https://www.catchorange.com)上\nhttps://www.catchorange.com/2024/08/12/amazon-echo-dot-5th-gen-review/\n\n---\n\n# 使用 Gizzmo AI 寫比較文章\n\n這邊上方可以看到Compare 來撰寫比較文章\n\n![image](https://hackmd.io/_uploads/HklwDqKcC.png)\n\n點選加入\n![image](https://hackmd.io/_uploads/SyEyKctqA.png)\n\n點選 ![image](https://hackmd.io/_uploads/ry3gYqFq0.png) \n\n接下來可以看到  Gizzmo AI 生成的比較\n![image](https://hackmd.io/_uploads/r1WQY9YqC.png)\n\n這邊可以產生文章\n![image](https://hackmd.io/_uploads/HkOFK9FqR.png)\n\n這邊可以點擊Save as Draft 存成草稿\n![image](https://hackmd.io/_uploads/BkYG59t5A.png)\n\n下面的連結是成功產生的文章，發佈在[我的wordpress版本部落格](https://www.catchorange.com)上\n\nhttps://www.catchorange.com/2024/08/14/ultimate-showdown-raymylo-vs-iron-flask-insulated-water-bottles/\n\n![image](https://hackmd.io/_uploads/HJPyaqK5R.png)\n\n這邊可以看到比較文章還有一些表格跟評分，文章的內容也感覺很不錯。\n\n---\n# 總結\n\n文章的質量其實不錯，Gizzmo AI 在內容生成上表現良好。但由於亞馬遜聯盟行銷目前不支援台灣，我建議如果要撰寫推廣文章，還是選擇撰寫英文版本比較合適，這樣能夠更好地利用聯盟行銷的優勢。\n","tags":["被動收入","Wordpress","Gizzmo AI","網站架設"],"categories":["架站記錄"]},{"title":"Amazon Associates 亞馬遜聯盟行銷 - 從網路賺取被動收入","url":"/2024/08/12/Amazon-Associates-亞馬遜聯盟行銷-從網路賺取被動收入/","content":"\n# 什麼是聯盟行銷？\n聯盟行銷最簡單的概念，就是推薦行銷。你可以將亞馬遜上的產品推薦給其他人，只要有人透過你的推薦連結購買商品，你就能獲取一部分佣金。這種方式不僅簡單，而且可以持續賺取被動收入，特別適合想要在家工作的朋友們。\n\n# 什麼是 Amazon Associates？\n![image](https://hackmd.io/_uploads/SkRDCmD9R.png)\n\n亞馬遜是全球最大的電商平台，擁有無數的商品種類，從日常用品到高端電子產品應有盡有。加入 Amazon Associates 計劃意味著你可以選擇大量的產品進行推薦，並且亞馬遜的名氣和信譽也有助於提高你的銷售機會。此外，亞馬遜的聯盟行銷平台也相對容易上手，適合新手。\n\n# 如何申請 Amazon Associates？\n\n**註冊 Amazon Associates**\n首先，你需要免費註冊一個 Amazon Associates 帳號。你可以通過以下連結立即加入：\n![image](https://hackmd.io/_uploads/SkRDCmD9R.png)\n>https://affiliate-program.amazon.com/\n\n\n**點選 Sign Up**\n\n你需要填寫一些基本資料，包括你的姓名、email和密碼。\n![image](https://hackmd.io/_uploads/HyQ1gVPqR.png)\n\n**收驗證信**\n這邊會需要進入信箱收驗證碼\n![image](https://hackmd.io/_uploads/SkZdeEvqR.png)\n\n**填寫一些基本資料**\n![image](https://hackmd.io/_uploads/BkTBWNv5A.png)\n\n**輸入你的網頁或社交平台**\n![image](https://hackmd.io/_uploads/SJRsMEv9A.png)\n\n接下來，你需要提供你會使用來推廣亞馬遜產品的網站或社交平台，如個人網站、Facebook 粉絲專頁、Instagram 或 YouTube 頻道等。如果你還沒有這些平台，可以先填寫現有的，之後再補充其他的。\n\n**填寫網站的一些內容**\n![image](https://hackmd.io/_uploads/r1dzm4P90.png)\n\n在亞馬遜聯盟營銷中，你可以選擇一個「Associates Store ID」來追蹤從你的聯盟連結進入亞馬遜網站的流量和銷售。這個 ID 是你在亞馬遜聯盟計畫中的唯一識別碼。\n\n還有網站的內容大致上是什麼?等等的問題之後\n\n**接下來就成功取得 Associate ID 了**\n![image](https://hackmd.io/_uploads/rku3IEw9A.png)\n\n# 付款方式與週期\n\nAmazon Associates 提供兩種收款方式，包括 Pay by gift card 和支票。建議選擇 Pay by gift card，因為只要達到 $10 就可以提款，而支票則有更高的提款門檻。\n\n每個月底會進行結算，但實際上你可能需要等待約兩個月的時間才能收到款項。\n\n![image](https://hackmd.io/_uploads/r1_adNv9R.png)\n我在這邊選擇 Pay by gift card\n\n# 如何推薦商品並獲取佣金？\n\n申請完成後，你就可以開始推薦商品了。你可以通過登入 Amazon Associates 帳戶，使用 SiteStripe 工具來獲取你想要推薦的商品連結。這個工具會顯示在亞馬遜網站的頂部，方便你隨時生成推薦連結。\n\n1. **找到商品**：登入 Amazon 並找到你想推薦的商品。\n2. **生成連結**：使用 SiteStripe 工具生成連結。你可以選擇純文字連結、圖片連結或文字+圖片的混合連結。\n3. **嵌入你的網站或社交平台**：將生成的推薦連結嵌入到你的網站、博客文章或社交平台帖子中。\n\n# 注意事項\n\n在使用 Amazon Associates 時，有一些注意事項需要遵守：\n\n- **使用正確的圖片**：不要隨意擷取亞馬遜的商品圖片，而是使用 SiteStripe 工具提供的圖片連結。\n- **避免自我購買**：你不能通過自己的推薦連結購買商品，這樣的交易無法獲取佣金。\n- **標示聯盟身份**：在你使用推薦連結的頁面上，務必清楚地標示你參加了 Amazon Associates Program，這樣可以讓讀者知道你會從中獲取佣金。\n- **不要在 Email 中發布推薦連結**：亞馬遜不允許你在電子郵件中發布推薦連結，只能在網站或社交平台上使用。\n\n\n\n# 經驗分享與總結\n\n亞馬遜聯盟行銷是一個值得新手嘗試的被動收入來源。雖然初期可能需要花一些時間來建立內容和推廣商品，但一旦設置完成，隨著時間的推移，你可以不斷地從推薦的商品中獲得收益。\n\n如果你對聯盟行銷有興趣，不妨立刻開始嘗試，並持續學習和優化你的推廣策略，逐步提升你的被動收入。\n\n","tags":["聯盟行銷","Amazon","被動收入"]},{"title":"讓孩子愛上閱讀！探索米奇翻翻書的奇妙世界，現在立刻免費索取！","url":"/2024/08/09/讓孩子愛上閱讀！探索米奇翻翻書的奇妙世界，現在立刻免費索取！/","content":"![image](https://hackmd.io/_uploads/BkkN4S7qR.png)\n\n在現今這個數位時代，找到讓孩子沉浸於閱讀的方式並不容易。然而，這款【米奇翻翻書】讓這個挑戰變得有趣且充滿互動性。這本書不僅僅是一部童書，它還是一個充滿驚喜的閱讀體驗，讓孩子在翻閱每一頁的同時，都能發現新奇的故事情節和生動的圖畫。\n\n\n---\n\n# **米奇翻翻書的特色**\n![image](https://hackmd.io/_uploads/SJbKVHXqA.png)\n取材自迪士尼美語世界《Fun and Games》系列的改編內容，一起認識米奇與他的好朋友，在遊玩中，其實寶貝正在進行人際關係上的美語互動呦！\n\n- **互動式設計**：每一頁都設計了不同的翻頁機關，讓孩子能夠在閱讀的過程中親自參與，增加了學習的樂趣。\n\n- **色彩繽紛的插畫**：充滿活力的迪士尼角色，像是米奇、米妮和唐老鴨，讓孩子愛不釋手。\n- **培養閱讀習慣**：這本書專為啟發孩子的閱讀興趣而設計，適合不同年齡段的孩子閱讀。\n\n![image](https://hackmd.io/_uploads/B1ts4H7cR.png)\n>翻開被遮蓋的卡片，看看藏起來的是哪位迪士尼大明星！\n\n![image](https://hackmd.io/_uploads/rkwRNrXqC.png)\n>掃描翻翻書上的QR code進入網頁 ，認識美式美語的打招呼方式再透過主題歌曲，讓寶貝開心學美語！\n\n---\n\n# **為什麼選擇米奇翻翻書？**\n米奇翻翻書不僅能夠吸引孩子的注意力，更能啟發他們的想像力。每一頁的設計都精心製作，讓孩子在探索的過程中，發現隱藏的驚喜，從而增加對閱讀的興趣。\n\n---\n\n# **限時優惠活動體驗組，免費申請**\n現在透過我的專屬連結免費申請式用【米奇翻翻書】，還有其他體驗組。立即行動，讓孩子踏上閱讀的奇幻旅程！\n\n![image](https://hackmd.io/_uploads/SJBxLB7cC.png)\n\n\n[**點擊這裡米奇美語體驗組免費申請**](https://vbtrax.com/track/clicks/7093/c627c2bc990927defb8dec35dc2e9753743940c172e5eff1113ff408600456ed)\n\n![image](https://hackmd.io/_uploads/rkzFvrmcR.png)\n\n\n---\n\n# **總結**\n別讓您的孩子錯過這個探索書本世界的好機會！透過米奇翻翻書，讓他們在互動中學習，在閱讀中成長。趕快行動吧，透過以下連結購買，讓孩子的閱讀旅程更豐富多彩！\n\n[**點擊這裡米奇美語體驗組免費申請**](https://vbtrax.com/track/clicks/7093/c627c2bc990927defb8dec35dc2e9753743940c172e5eff1113ff408600456ed)\n\n","tags":["聯盟行銷","迪士尼美語"]},{"title":"Hexo部落格 - Butterfly 主題調整 第三天","url":"/2024/08/07/Hexo部落格-Butterfly-主題調整-第三天/","content":"# 設計Logo\n![logo](https://hackmd.io/_uploads/HJF2tD1c0.png)\n\n# 今天設定了 Nav Bar\n![image](https://hackmd.io/_uploads/S11M3wkcA.png)\n\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n```\nnav:\n  logo: #image\n  display_title: true\n  fixed: false # fixed navigation bar\n  \n  \n```\n\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n```\nmenu:\n  首頁: / || fas fa-home\n  時間軸: /archives/ || fas fa-archive\n  標籤: /tags/ || fas fa-tags\n  分類: /categories/ || fas fa-folder-open\n  # 清單||fas fa-list:\n  #   音樂: /music/ || fas fa-music\n  #   電影: /movies/ || fas fa-video\n  友情連結: /link/ || fas fa-link\n  關於: /about/ || fas fa-heart\n```\n\n這邊設定成了中文\n\n# 頭像\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n```\navatar:\n  img: /img/logo.png\n  effect: true # 頭像會一直轉圈\n```\n\n這邊換成我設計的Logo了\n\n![image](https://hackmd.io/_uploads/HJWfAvJ9A.png)\n\n# 社交圖標 (Social Settings)\n\nButterfly支持 font-awesome v6 圖標.\n\n書寫格式 圖標名：url || 描述性文字 || color\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n\n```\nsocial:\n  fab fa-github: https://github.com/xxxxx || Github || \"#hdhfbb\"\n  fas fa-envelope: mailto:xxxxxx@gmail.com || Email || \"#000000\"\n```\n\n這邊我設定了 github的社交連結\n\n![image](https://hackmd.io/_uploads/HySttceqR.png)\n\n\n# 頂部圖\n\n\n| 配置 | 解釋 |\n| -------- | -------- | \n| index_img     | 主頁的 top_img     | \n| default_top_img     | 默認的 top_img，當頁面的 top_img 沒有配置時，會顯示 default_top_img    |\n archive_img     | 歸檔頁面的 top_img  | \n tag_img     | tag 子頁面 的 默認 top_img | \n tag_per_img     | tag 子頁面的 top_img，可配置每個 tag 的 top_img | \n category_img     | category 子頁面 的 默認 top_img | \n category_per_img     | category 子頁面的 top_img，可配置每個 category 的 top_img | \n\n# 運行時間\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n\n```\nruntimeshow:\n  enable: true\n  publish_date: 6/7/2018 00:00:00  \n  ##網頁開通時間\n  #格式: 月/日/年 時間\n  #也可以寫成 年/月/日 時間\n```\n\n![image](https://hackmd.io/_uploads/SyQSl2xqA.png)\n\n這樣可以顯示已執行時間\n\n# 最新評論\n修改 主題配置文件  `themes/butterfly/_config.yml`\n\n```\n# Aside widget - Newest Comments\nnewest_comments:\n  enable: true\n  sort_order: # Don't modify the setting unless you know how it works\n  limit: 6\n  storage: 10 # unit: mins, save data to localStorage\n  avatar: true\n\n\n```\n\n這邊我依設定啟動就會顯示空白，我想可能是因為目前還沒有任何評論，所以暫時還是先設定成 false\n\n# 總結\n\n今天設定了Logo、Nav Bar、頂部圖、運行時間、最新評論等等的設定，發現官方文件還有更多詳細內容，超級多設定今天先暫時這樣好了，接下來的設定等改天再找時間來做\n","tags":["Hexo","Butterfly"],"categories":["架站記錄"]},{"title":"區塊鏈 - Gala Film: Web3版本的Netflix平台，影音產業的區塊鏈革命","url":"/2024/08/06/區塊鏈-Gala-Film-Web3版本的Netflix平台，影音產業的區塊鏈革命/","content":"# 區塊鏈 - Gala Film: Web3版本的Netflix平台，影音產業的區塊鏈革命\n\n# Gala Film 是什麼？\n![image](https://hackmd.io/_uploads/BJrrZZyq0.png)\n>[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed)\n\n[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 是一個基於區塊鏈技術的影音平台，致力於革新電影和電視節目產業。透過區塊鏈技術，Gala Film 為創作者提供更多的控制權和收益，並為觀眾帶來全新的觀看體驗。\n\n# Gala Film 的特色\n\n## 1. 真正的作品所有權\n![image](https://hackmd.io/_uploads/Bk8Cm-kc0.png)\n\n在傳統影音產業中，作品的所有權通常掌握在大型製作公司手中，而創作者獲得的收益有限。在 [Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 上，影音作品以 NFT 的形式存在於區塊鏈上，這意味著創作者可以完全擁有他們的作品並直接從中獲益。\n\n## 2. 去中心化的影音生態系統\n![image](https://hackmd.io/_uploads/S1fqNZy5C.png)\n\n[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 採用了去中心化的架構，消除了中間人的干預。這不僅確保了影音作品的透明度和安全性，還讓創作者和觀眾之間的互動更加直接和公平。\n\n## 3. Gala Nodes 支持的網絡\n![image](https://hackmd.io/_uploads/Bk6aE-J9A.png)\n\n[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 依賴於 Gala Nodes 來支持其網絡運營。這些節點由社區成員運行，確保了平台的穩定性和安全性，並讓運行節點的成員能夠賺取 GALA 代幣。\n\n## 4. 豐富多樣的影音內容\n\n[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 平台上有豐富多樣的影音內容，涵蓋各種電影和電視節目類型。無論你是動作片愛好者，還是喜歡浪漫劇，[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 都能滿足你的需求。\n\n![image](https://hackmd.io/_uploads/rySeSZyqR.png)\n![image](https://hackmd.io/_uploads/By3-Bbk9R.png)\n![image](https://hackmd.io/_uploads/B1mIr-1cC.png)\n\n目前看來 [Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 上總共有9個電影。\n\n# 如何開始？\n\n加入 [Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 的方式非常簡單：\n\n1. 註冊 Gala Film 帳戶。\n![image](https://hackmd.io/_uploads/H1H1UZJcC.png)\n> 可以點選[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 畫面右上角的註冊\n\n![image](https://hackmd.io/_uploads/ByOU8WycC.png)\n\n2. 瀏覽平台上的影音作品，選擇你喜歡的內容，開始觀看。\n\n點擊這裡 [Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 註冊並開始你的影音之旅！\n\n# 總結\n\n[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 不僅僅是一個影音平台，更是一個讓創作者和觀眾能夠真正掌控影音命運的生態系統。無論你是影片創作者還是觀影愛好者，[Gala Film](https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed) 都能為你帶來全新的體驗。趕快加入我們，探索這個令人興奮的影音世界吧！\n","tags":["Web3","Block Chain","Gala","Film"]},{"title":"區塊鏈 - Gala Music : Web3版本的Spotify平台，音樂產業的區塊鏈革命","url":"/2024/08/05/區塊鏈-Gala-Music-Web3版本的Spotify平台，音樂產業的區塊鏈革命/","content":"# 什麼是 Gala Music?\n![image](https://hackmd.io/_uploads/rJKaoWCt0.png)\n>[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec)\n\n[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 是一個基於區塊鏈技術的音樂平台，旨在革新音樂產業。通過區塊鏈技術，Gala Music 不僅讓藝術家擁有他們的作品，還為聽眾提供了一種全新的互動方式，讓音樂創作變得更加公平和透明。\n\n# Gala Music 的特色\n\n## 1. 真正的音樂作品所有權\n\n![image](https://hackmd.io/_uploads/BJcvlGCKR.png)\n\n在傳統音樂產業中，音樂作品的所有權通常掌握在唱片公司手中，藝術家獲得的收益有限。而在 [Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 上，音樂作品以 NFT 的形式存在於區塊鏈上，這意味著藝術家可以完全擁有他們的作品並直接從中獲益。\n\n\n## 2. 去中心化的音樂生態系統\n\n![image](https://hackmd.io/_uploads/SyFngzCtC.png)\n\n[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 採用了去中心化的架構，消除了中間人的干預。這不僅確保了音樂作品的透明度和安全性，還讓藝術家和聽眾之間的互動更加直接和公平。\n\n\n## 3. Gala Nodes 支持的網絡\n\n![image](https://hackmd.io/_uploads/rkzJWM0YA.png)\n\n[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 依賴於 Gala Nodes 來支持其網絡運營。這些節點由社區成員運行，確保了平台的穩定性和安全性，並讓運行節點的成員能夠賺取 GALA 代幣。\n\n\n## 4. 豐富多樣的音樂內容\n\n![image](https://hackmd.io/_uploads/S1ry6ZAKR.png)\n[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 平台上有豐富多樣的音樂內容，涵蓋各種音樂風格和流派。無論你是流行音樂愛好者，還是喜歡古典音樂，[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 都能滿足你的需求。\n\n# 如何開始？\n\n加入 [Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 的方式非常簡單：\n\n1. 註冊 Gala Music 帳戶。\n\n![image](https://hackmd.io/_uploads/BJu7WG0K0.png)\n> 可以點選[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 畫面右上角的註冊\n\n![image](https://hackmd.io/_uploads/S19rbzCK0.png)\n> 這邊可以選擇綁定Google、 Apple或 Facebook也可以設定帳號密碼登入\n\n2. 瀏覽平台上的音樂作品，選擇你喜歡的作品，開始享受音樂。\n\n點擊這裡 [Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 註冊並開始你的音樂之旅！\n\n## 結語\n\n[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 不僅僅是一個音樂平台，更是一個讓藝術家和聽眾能夠真正掌控音樂命運的生態系統。無論你是音樂創作者還是音樂愛好者，[Gala Music](https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec) 都能為你帶來全新的體驗。趕快加入我們，探索這個令人興奮的音樂世界吧！","tags":["Web3","Block Chain","Gala","Music"]},{"title":"區塊鏈 - Gala Games : WEB3版本的Steam 遊戲平台","url":"/2024/08/05/區塊鏈-Gala-Games-WEB3版本的Steam-遊戲平台/","content":"\n# Gala Games 是什麼?\n\n![image](https://hackmd.io/_uploads/ByOs2hTY0.png)\n>[Gala Games ](https://tinyurl.com/24ke97we)\n\n[Gala Games](https://tinyurl.com/24ke97we) 是一個基於區塊鏈技術的遊戲平台，致力於讓玩家掌控他們的遊戲體驗。[Gala Games](https://tinyurl.com/24ke97we) 的願景是將權力交還給玩家，讓他們不僅僅是遊戲的參與者，更是遊戲世界的創造者和擁有者。從 [Gala Games 連結](https://tinyurl.com/24ke97we)進去可以看到畫面很像 Steam 一樣有很多款遊戲，但這些遊戲的特點就是都是跟Gala區塊鏈有關的區塊鏈遊戲。\n\n\n# Gala Games 的特色\n\n## 1. 真正的資產所有權\n\n在傳統遊戲中，玩家購買的物品和角色屬於遊戲公司，一旦遊戲關閉或玩家停止遊戲，這些資產就會消失。而在 [Gala Games](https://tinyurl.com/24ke97we)，所有的遊戲內資產都是以 NFT（非同質化代幣）的形式存在於區塊鏈上，這意味著玩家真正擁有這些資產，並且可以在市場上自由交易。\n\n![image](https://hackmd.io/_uploads/SJjzfa6KC.png)\n>[其中一個遊戲 Town Star販賣中的道具](https://tinyurl.com/24ke97we)  \n\n## 2. 去中心化的遊戲生態系統\n\n[Gala Games](https://tinyurl.com/24ke97we) 採用了去中心化的架構，遊戲世界由玩家共同維護。這樣的設計不僅確保了遊戲的公平性，還能讓玩家參與到遊戲的開發和決策中。\n\n![image](https://hackmd.io/_uploads/ryWfmTaKR.png)\n\n\n## 3. Gala Node 網絡\n\n[Gala Games](https://tinyurl.com/24ke97we) 依賴於一個去中心化的伺服器網絡，由玩家運行的 Gala Nodes 支持。這些節點確保了遊戲的運行穩定性，同時也讓玩家可以通過運行節點賺取 GALA 代幣。\n\n![image](https://hackmd.io/_uploads/ByERl66Y0.png)\n\n## 4. 多樣化的遊戲\n\n[Gala Games](https://tinyurl.com/24ke97we) 平台上有多款遊戲，涵蓋不同類型和風格，從策略遊戲到角色扮演遊戲應有盡有。無論你是喜歡建設自己的帝國，還是想要體驗冒險，[Gala Games](https://tinyurl.com/24ke97we) 都能滿足你的需求。\n\n![image](https://hackmd.io/_uploads/SJnnN6TK0.png)\n\n![image](https://hackmd.io/_uploads/Bk6p4apYA.png)\n\n![image](https://hackmd.io/_uploads/S1a0E6Tt0.png)\n\n![image](https://hackmd.io/_uploads/SJ21BpaFR.png)\n\n![image](https://hackmd.io/_uploads/SJAgBpaK0.png)\n\n![image](https://hackmd.io/_uploads/SylGS6Tt0.png)\n\n目前看來 [Gala Games](https://tinyurl.com/24ke97we) 上總共有18款遊戲，另外其中有3款式準備要推出的遊戲。\n\n# 如何開始？\n\n加入 [Gala Games](https://tinyurl.com/24ke97we) 的方式非常簡單：\n\n1. 註冊 Gala Games 帳戶。\n\n![image](https://hackmd.io/_uploads/r1OKQ6aKA.png)\n> 可以點選[Gala Games](https://tinyurl.com/24ke97we) 畫面右上角的註冊\n\n![image](https://hackmd.io/_uploads/r1bnQ66tR.png)\n> 這邊可以選擇綁定Google、 Apple或 Facebook也可以設定帳號密碼登入\n\n2. 選擇你感興趣的遊戲，開始遊玩並賺取資產。\n\n點擊這裡 [Gala Games ](https://tinyurl.com/24ke97we) 註冊並開始你的遊戲之旅！\n\n## 總結\n\n[Gala Games](https://tinyurl.com/24ke97we) 不僅僅是一個遊戲平台，更是一個玩家可以真正掌控自己遊戲命運的生態系統。無論你是遊戲愛好者還是區塊鏈技術的愛好者，[Gala Games](https://tinyurl.com/24ke97we) 都能為你帶來全新的體驗。趕快加入我們，探索這個令人興奮的世界吧！\n\n\n","tags":["Web3","Block Chain","Gala","Games"]},{"title":"毛好多：讓您的寵物享受極致呵護的最佳選擇","url":"/2024/08/02/毛好多：讓您的寵物享受極致呵護的最佳選擇/","content":"作為一名寵物主人，我們家養的瑪爾濟斯也常常會想吃一些零食，而且牠又那麼可愛，我們總是希望能夠為心愛的毛孩提供最好的生活品質。無論是食品、玩具，還是護理用品，每一樣都馬虎不得。今天，我們要為您推薦一個專門為毛孩設計的線上選物店——[毛好多 - 毛比你多的毛孩選物店](https://tinyurl.com/22l4rfwv)。\n\n![image](https://hackmd.io/_uploads/SkCsLZ5KR.png)\n\n立刻點選以下連結去逛逛^^\nhttps://tinyurl.com/22l4rfwv\n\n# 毛好多是什麼？\n\n毛好多是一個專門為寵物主人打造的線上選物店，提供多種優質的寵物用品。無論您的寵物是狗狗、貓咪，還是其他小動物，毛好多都能夠滿足牠們的各種需求。平台上的所有產品均經過嚴格篩選，保證品質和安全，讓您的毛孩享受最好的照顧。\n\n因為我們家養的是可愛馬爾濟斯，所以會想要常常去逛他們的狗狗專區\n![image](https://hackmd.io/_uploads/H1g4Db9F0.png)\n\n# 平台特色\n\n## 1. 多樣化的寵物用品\n毛好多提供豐富的寵物用品，包括高品質的食品、趣味玩具、健康護理產品等，讓您一站式購齊所有所需。\n\n![image](https://hackmd.io/_uploads/SJ70wW5F0.png)\n\n## 2. 優質品牌保障\n平台上所有商品均來自知名品牌，品質有保障。無論是食品還是護理用品，都經過專業檢驗，讓您購物無憂。\n\n## 3. 專業養護建議\n毛好多不僅僅是一個購物平台，還提供豐富的寵物養護資訊和建議，幫助您更好地了解和照顧您的毛孩。\n\n![image](https://hackmd.io/_uploads/S19kub9FR.png)\n\n\n## 4. 便捷的購物體驗\n毛好多的線上平台設計簡潔，操作方便，讓您輕鬆找到所需產品，快速完成購買，享受無憂的購物體驗。\n\n# 總結\n\n現在就訪問 [毛好多線上選物店](https://tinyurl.com/22l4rfwv)，探索更多優質產品，讓您的毛孩享受最好的生活品質。毛好多，毛比你多的毛孩選物店，為您的寵物提供最貼心的服務和最優質的產品。\n\n![image](https://hackmd.io/_uploads/SyUyK-5F0.png)\n\n可以常常去挑我們家波比愛吃的零食","tags":["聯盟行銷","毛好多","寵物購物"]},{"title":"Hexo部落格 - Butterfly 主題調整 第二天","url":"/2024/08/01/Hexo部落格-Butterfly-主題調整-第二天/","content":"\n# 設定語言\n\n修改網站配置文件 `_config.yml`\n\n調整以下變數\n```\nlanguage:\n```\n\n默認語言是 en\n\n主題支持三種語言\n\ndefault(en)\nzh-CN (簡體中文)\nzh-TW (繁體中文)\n\n我們這邊改為 zh-TW (繁體中文)\n\n# 網站資料\n修改網站各種資料，例如標題、副標題和電子信箱等個人資料，請修改部落格根目錄的`_config.yml`\n\n```\n# Site\ntitle: <部落格名稱>\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: <作者名稱>\nlanguage: zh-TW\ntimezone: ''\n\n```\n\n這邊需要仔細想想keywords 要設定成什麼\n\n# 導航欄設置 (Navigation bar settings)\n\n主題配置文件`_config.yml`中\n\n```\nnav:\n  logo: #image\n  display_title: true\n  fixed: false # fixed navigation bar\n```\n\n\nlogo:網站的 logo，支持圖片，直接填入圖片鏈接\ndisplay_title:是否顯示網站標題，填寫 true 或者 false\nfixed:是否固定狀態欄，填寫 true 或者 false\n\n# 菜單/目錄\n修改 主題配置文件\n```\nHome: / || fas fa-home\nArchives: /archives/ || fas fa-archive\nTags: /tags/ || fas fa-tags\nCategories: /categories/ || fas fa-folder-open\nList||fas fa-list:\n  Music: /music/ || fas fa-music\n  Movie: /movies/ || fas fa-video\nLink: /link/ || fas fa-link\nAbout: /about/ || fas fa-heart\n\n```\n\n例如：\n```\nmenu:\n  首頁: / || fas fa-home\n  時間軸: /archives/ || fas fa-archive\n  標籤: /tags/ || fas fa-tags\n  分類: /categories/ || fas fa-folder-open\n  清單||fa fa-heartbeat:\n    音樂: /music/ || fas fa-music\n    照片: /Gallery/ || fas fa-images\n    電影: /movies/ || fas fa-video\n  友鏈: /link/ || fas fa-link\n  關於: /about/ || fas fa-heart\n\n```\n\n# 代碼 (Code Blocks)\nButterfly 支持6種代碼高亮樣式：\n\ndarker\npale night\nlight\nocean\nmac\nmac light\n修改 主題配置文件\n\n```\nhighlight_theme: light\n```\n\n# 設定搜尋功能\n\n採用本地搜尋功能，這邊我選用hexo-generator-search來實作搜尋功能\n![image](https://hackmd.io/_uploads/H1qeGFutA.png)\n>https://github.com/wzpan/hexo-generator-search\n\n## 安裝 hexo-generator-search\n```\nnpm install hexo-generator-search --save\n```\n\n## 修改 主題配置文件  `themes/butterfly/_config.yml`\n```\n# Local search\nlocal_search:\n  enable: false\n  # Preload the search data when the page loads.\n  preload: false\n  # Show top n results per article, show all results by setting to -1\n  top_n_per_article: 1\n  # Unescape html strings to the readable one.\n  unescape: false\n  CDN:\n\n```\n\n\n\n| 參數 | 解釋 |\n| -------- | -------- |\n| enable    | 是否開啟本地搜索     | \n| preload    | 預加載，開啟後，進入網頁後會自動加載搜索文件。關閉時，只有點擊搜索按鈕後，才會加載搜索文件     |\n| top_n_per_article    | \t匹配的文章結果，默認顯示最開始的 1段結果     |\n| unescape    | \t將 html 字符串解碼為可讀字符串   |\n| CDN    | \t搜索文件的 CDN 地址（默認使用的本地鏈接）   |\n\n這邊實測設定後右上角會出現這個搜尋的圖案\n![image](https://hackmd.io/_uploads/HJnYm2OFC.png)\n\n然後點擊就可以進行搜尋\n![image](https://hackmd.io/_uploads/SJE2Q2dY0.png)\n\n測試真的可以搜尋到文章\n![image](https://hackmd.io/_uploads/rkJb42dYC.png)\n\n\n# 評論功能設定\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n```\ncomments:\n  # Up to two comments system, the first will be shown as default\n  # Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo\n  use: Valine,Disqus\n  text: true # Display the comment name next to the button\n  # lazyload: The comment system will be load when comment element enters the browser's viewport.\n  # If you set it to true, the comment count will be invalid\n  lazyload: true\n  count: true # Display comment count in top_img\n  card_post_count: false # Display comment count in Home Page\n```\n\t\n\n| 參數 | 解釋 |\n| -------- | -------- | \n| use     | 使用的評論（請注意，最多支持兩個，如果不需要請留空）注意：雙評論不能是 Disqus 和 Disqusjs 一起，由於其共用同一個 ID，會出錯     | \n| text     | 是否顯示評論服務商的名字   | \n| lazyload     | 是否為評論開啟lazyload，開啟後，只有滾動到評論位置時才會加載評論所需要的資源（開啟 lazyload 後，評論數將不顯示） | \n| count     | 是否在文章頂部顯示評論數\nlivere、Giscus 和 utterances 不支持評論數顯示 | \n| card_post_count     | 是否在首頁文章卡片顯示評論數\ngitalk、livere 、Giscus 和 utterances 不支持評論數顯示 | \n\n以上變數是在 2024-08-01 參考 Butterfly 官方配置說明文件設定的，最新內容建議可以參考官方網站https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96\n\n\n這邊修改過後實測真的有評論區可以留言了^^\n![image](https://hackmd.io/_uploads/SyEFBn_t0.png)\n\n# 分享\n\n## 通用設置\n這邊Butterfly設定內建是使用 sharejs\n![image](https://hackmd.io/_uploads/HynyBhdKA.png)\n>https://github.com/overtrue/share.js/\n\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n\n```\nsharejs:\n  enable: true\n  sites: facebook  #想要顯示的內容  ,twitter,wechat,weibo,qq\n```\n\n這邊因為我只有facebook 所以這樣更改\n\n目前暫時先設定通用設置，官網還有其他留言板設定像是Disqus、livere (來必力)、gitalk、 Valine、Waline、Utterances、Facebook Comments、Twikoo、Giscus、remark42、artalk 可以參考，有很多的選擇。\n\n# 在線聊天\n\n## 通用設置\n\n修改 主題配置文件  `themes/butterfly/_config.yml`\n\n```\n# Chat Button [recommend]\n# It will create a button in the bottom right corner of website, and hide the origin button\nchat_btn: true\n```\n\n為了不影響訪客的體驗，主題提供一個`chat_hide_show`配置\n設為`true`後，使用工具提供的按鈕時，只有向上滾動才會顯示聊天按鈕，向下滾動時會隱藏按鈕。\n\n修改 `主題配置文件`\n\n```\n# The origin chat button is displayed when scrolling up, and the button is hidden when scrolling down\nchat_hide_show: true\n```\n\n{% note info simple %}\n如果使用工具自帶的聊天按鈕，按鈕位置可能會遮擋右下角圖標，請配置`rightside_bottom`調正右下角圖標位置\n{% endnote %}\n\n設定之後在這邊會顯示有聊天功能\n![image](https://hackmd.io/_uploads/r1zpTnOKC.png)\n\n## 設定crisp\n![image](https://hackmd.io/_uploads/HyWykput0.png)\n>https://crisp.chat/en/\n\n註冊 crisp 帳號\n![image](https://hackmd.io/_uploads/Sk1zJauKA.png)\n\n設定樣式\n![image](https://hackmd.io/_uploads/B1Xc1pdK0.png)\n\n註冊完成後可以取得這個資料\n![image](https://hackmd.io/_uploads/SkxRJ6_KC.png)\n\n找到需要的網站ID 進行設定\n```\n# crisp\n# https://crisp.chat/en/\ncrisp:\n  enable: true\n  website_id: xxxxxxxx\n```\n\n實測設定完可以成功留言\n![image](https://hackmd.io/_uploads/Sk-fMa_YR.png)\n\n也可以成功在後台看到這邊的訊息，也可以回應。\n![image](https://hackmd.io/_uploads/HkC8fTOYA.png)\n\n# 總結\n\n今天設定了Butterfly 主題的代碼樣式、搜尋功能、評論功能、分享、跟在線聊天設定，官方網站還有好幾項，這部分我覺得之後再來找時間設定好了","tags":["Hexo","Butterfly"],"categories":["架站記錄"]},{"title":"發現家樂福的驚喜優惠：讓您的購物體驗更加美好","url":"/2024/08/01/發現家樂福的驚喜優惠：讓您的購物體驗更加美好/","content":"\n大家好，今天要跟大家分享家樂福的線上購物平台，其實之前有空都會跟家人一起去逛家樂福，都會看到很多特價商品而且有時候，不知不覺就會買很多東西導致每次都會都非常的重，辛辛苦苦搬回家之後要在一個一個塞進冰箱，這邊建議可以在家輕鬆地在家吹冷氣線上逛價樂福\n\n這邊是家樂福的線上購物平台\n![image](https://hackmd.io/_uploads/HJ3qGwdF0.png)\n>https://abzcoupon.com/track/clicks/4459/c627c2bc990927defa8aec35dc2e9753743940c172e5eff1113ff40863005ae7\n\n\n## 超讚的優惠券專區\n![image](https://hackmd.io/_uploads/SJP14vut0.png)\n>https://tinyurl.com/2633nl84\n\n這邊的優惠券專區，就算是已經在現場逛了也可以看看有優惠哦。\n\n## 限時優惠區\n![image](https://hackmd.io/_uploads/SJOnNv_FC.png)\n\n\n## 精選活動區\n![image](https://hackmd.io/_uploads/Sk5-rwdKC.png)\n\n這邊也有很多的精選活動，比如周四固定會有7-11取貨299免運的活動\n\n## 銀行優惠活動\n![image](https://hackmd.io/_uploads/H10LSPuF0.png)\n\n這邊有玉山銀行的優惠活動哦\n\n![image](https://hackmd.io/_uploads/SJD5LwuK0.png)\nhttps://tinyurl.com/228rp6u2\n\n這邊是國泰世華銀行跟聯邦銀行的優惠\n![image](https://hackmd.io/_uploads/r1aTLvutC.png)\n\n玉山銀行分期0利率的優惠還有樂天信用卡的優惠\n![image](https://hackmd.io/_uploads/r18ZvvdYC.png)\n\n玉山銀新客新客家加碼200元優惠\n![image](https://hackmd.io/_uploads/HJLqPvOt0.png)\n\n\n![image](https://hackmd.io/_uploads/ryFivPuKA.png)\n>https://tinyurl.com/2aan4abw\n\n# 特價商品推薦\n\n## 廠商直送優惠\n![image](https://hackmd.io/_uploads/SknUuPdY0.png)\n\n## 中元普渡優惠\n中元普渡拜拜用品\n![image](https://hackmd.io/_uploads/HkEYuvdtR.png)\n\n中元普渡零食飲料\n![image](https://hackmd.io/_uploads/BJhlcD_KR.png)\n\n可以使用[家樂福線上購物網址](https://tinyurl.com/286v4vyj)進行挑選\n\n## 保健養生優惠\n\n保健食品\n![image](https://hackmd.io/_uploads/rJDcqvdYR.png)\n\n運動用品\n![image](https://hackmd.io/_uploads/SJ96cv_t0.png)\n\n## 冰鎮美食優惠\n冰品\n![image](https://hackmd.io/_uploads/HkrkovdKR.png)\n\n## 出國旅遊優惠\n旅行用品\n![image](https://hackmd.io/_uploads/Bkoxiv_FA.png)\n\n## 出行防蟲利器\n防蚊液\n![image](https://hackmd.io/_uploads/SyCbiDOF0.png)\n\n## 夏日樂趣優惠\n戶外用品\n![image](https://hackmd.io/_uploads/SkJQjD_F0.png)\n\n水上活動用品\n![image](https://hackmd.io/_uploads/r1bNjPuFA.png)\n\n防曬用品\n![image](https://hackmd.io/_uploads/ByQBiPOtC.png)\n\n## 寵愛毛孩優惠\n寵物用品\n![image](https://hackmd.io/_uploads/BkY8ow_FA.png)\n\n## 消暑對策\n防曬用品\n![image](https://hackmd.io/_uploads/BJ2PovdKC.png)\n\n電扇\n![image](https://hackmd.io/_uploads/H1gKovdY0.png)\n\n飲料\n![image](https://hackmd.io/_uploads/ryNqovuF0.png)\n\n\n## 開學準備\n文具用品\n![image](https://hackmd.io/_uploads/BkIjjDdFR.png)\n\n服飾配件\n![image](https://hackmd.io/_uploads/BJt3jv_FA.png)\n\n電子產品\n![image](https://hackmd.io/_uploads/Sy26iDdtC.png)\n\n## 飲食新選擇\n\n素食食品\n![image](https://hackmd.io/_uploads/rJFlhv_YR.png)\n\n\n# 節省購物的小技巧\n為了讓大家能夠在家樂福購物時獲得更多優惠，我想分享一些小技巧：\n\n* 關注家樂福的官網和社群媒體：家樂福經常在官網和社群媒體上發布最新的優惠訊息，記得多多關注。\n* 利用會員卡：辦理家樂福的會員卡，可以享受更多會員專屬的優惠和累積點數兌換好禮。\n* 選擇特價時段購物：有些商品在特定時段會有額外折扣，可以根據這些時段來安排購物。\n\n\n# 總結\n家樂福的優惠活動總是充滿驚喜，這次的活動更是物超所值。希望這篇文章能夠幫助大家在購物時節省更多，享受更愉快的購物體驗。快去家樂福看看，發現更多超值優惠吧！\n\n如果您有任何問題或購物心得，歡迎在下方留言與我們分享。期待您的回饋！\n祝大家購物愉快！\n\n有興趣可以到以下家樂福線上購物查看\n\nhttps://abzcoupon.com/track/clicks/4459/c627c2bc990927defa8aec35dc2e9753743940c172e5eff1113ff40863005ae7\n\n","tags":["聯盟行銷","家樂福優惠"]},{"title":"Flutter 學習紀錄 - Day 3 – Dart Language 學習","url":"/2024/07/30/Flutter-學習紀錄-Day-3-–-Dart-Language-學習/","content":"# Flutter 學習紀錄 - Day 3 – Dart Language 學習\n\n# Dart 官方說明教學文件\n![image](https://hackmd.io/_uploads/Hy_5_z8K0.png)\n>https://dart.dev.org.tw/overview\n\n## Dart：語言\n\nDart 是一種類型安全的程式語言，設計用於確保變數的值始終與其靜態類型相符。這種方式稱為健全類型檢查。雖然 Dart 的類型是強制性的，但類型註解是可選的，因為 Dart 支援類型推論。這意味著即使你不明確指定類型，Dart 也能自動推斷出變數的類型。\n\nDart 的類型系統非常靈活，允許使用 `dynamic` 類型來結合執行時期檢查。這在需要編寫特別動態的程式碼或進行實驗時非常有用。\n\n### 健全的空安全\n\nDart 內建了健全的空安全機制。這表示除非你明確允許變數為空，否則它們的值不能為空。這種空安全機制能夠透過靜態程式碼分析在執行時期保護你免於空例外。\n\n與其他一些空安全語言不同的是，當 Dart 確定變數為非空時，該變數在執行時期將始終保持非空。如果你在偵錯器中檢查程式碼的執行情況，你會看到非空性在執行時期得到保留，這就是所謂的健全空安全。\n\n這些特性使得 Dart 成為一個非常可靠和強大的語言，特別適合用於構建高效能且穩定的應用程式。\n\n\n## Dart：函式庫\n\nDart 有一個 豐富的核心函式庫集，提供許多日常程式設計任務的基本要素\n\n* 每個 Dart 程式（dart:core）的內建類型、集合和其他核心功能\n* 更豐富的集合類型，例如佇列、連結串列、雜湊映射和二元樹（dart:collection）\n* 用於在不同資料表示法之間轉換的編碼器和解碼器，包括 JSON 和 UTF-8（dart:convert）\n* 數學常數和函數，以及隨機數字產生（dart:math）\n* 支援非同步程式設計，使用 Future 和 Stream 等類別（dart:async）\n* 有效處理固定大小資料（例如，未簽署的 8 位元組整數）和 SIMD 數值類型的清單（dart:typed_data）\n* 檔案、socket、HTTP 和其他 I/O 支援，適用於非網路應用程式（dart:io）\n* 外國函數介面，用於與呈現 C 風格介面的其他程式碼進行互操作（dart:ffi）\n* 使用隔離進行並行程式設計，獨立的工作人員類似於執行緒，但不會共用記憶體，僅透過訊息進行通訊（dart:isolate）\n* HTML 元素和其他資源，適用於需要與瀏覽器和文件物件模型 (DOM) 互動的基於網路的應用程式（dart:html）\n\n\n除了核心函式庫之外，許多 API 都透過全面的套件集提供。Dart 團隊發布許多有用的補充套件，例如\n\n* 字元\n* intl\n* http\n* 加密\n* 標記語言\n\n\n此外，第三方發行商和更廣大的社群會發布數千個套件，支援下列功能\n\n* XML\n* Windows 整合\n* SQLite\n* 壓縮\n\n若要查看一系列使用 Dart 核心函式庫的範例，請閱讀 [核心函式庫文件](https://dart.dev.org.tw/libraries)。若要尋找其他 API，請參閱 [常用套件頁面](https://dart.dev.org.tw/guides/libraries/useful-libraries)。\n\n\n## Dart：平台\n\nDart 的編譯器技術非常靈活，能夠讓您以不同的方式執行程式碼，適用於多種平台。\n\n### 原生平台\n\n針對行動裝置和桌上型電腦應用程式，Dart 提供了兩種編譯方式：\n\n- **即時編譯 (JIT)**：在開發期間，Dart VM 可以即時編譯程式碼，讓開發者能夠快速測試和調整程式碼。\n- **提前編譯 (AOT)**：在發佈應用程式時，Dart 編譯器會將程式碼轉換為機器碼，確保應用程式在裝置上能夠高效執行。\n\n### 網頁平台\n\n針對網頁應用程式，Dart 可以編譯為 JavaScript，方便在各種瀏覽器上運行。這種編譯可以用於開發和生產環境，確保網頁應用的兼容性和效能。\n\n\n![image](https://hackmd.io/_uploads/HkzO5f8KR.png)\n>https://dart.dev.org.tw/overview#platform\n\n\n# DartPad - 練習平台\n\n![image](https://hackmd.io/_uploads/H1oGjGUF0.png)\n>https://dartpad.dev/\n\nDartPad 是一個線上工具，能在瀏覽器中撰寫、執行和分享 Dart 程式碼，無需安裝任何軟體。\n\n以下是一些 DartPad 的主要功能：\n\n* 即時編輯和執行：可以即時撰寫和執行 Dart 程式碼，立即看到結果，這對於學習和測試程式碼片段非常有用。\n\n* 範例程式碼：DartPad 提供了豐富的範例程式碼，可以快速瞭解 Dart 語言和 Flutter 框架的各種功能和特性。\n\n* 分享程式碼：可以輕鬆地分享您的程式碼片段和結果，方便與他人協作和討論。\n使用 DartPad，您可以快速開始學習和探索 Dart 和 Flutter，而不需要進行任何設定或安裝。\n\n這邊可以參考Dart 官方簡介文件說明做完整的一個練習。\n\n![image](https://hackmd.io/_uploads/r1M0iMIKR.png)\n>https://dart.dev.org.tw/language\n\n# 資料型態\n\n\n| 資料型態    | 說明                                                                 | 範例                                                         |\n|-------------|--------------------------------------------------------------------|--------------------------------------------------------------|\n| **var**     | 類似於 JavaScript 的變數宣告，根據初始化的值自動推斷型別，但一旦賦值後型別不可更改 | `var myVar = 42;`                                             |\n| **Object**  | 所有型別的根基礎類別。每個 Dart 型別都繼承自 `Object`                   | `Object myObject = \"Hello, Dart!\";`                           |\n| **dynamic** | 允許在編譯時期跳過型別檢查，明確表示可以在執行時期變更型別                  | `dynamic myDynamic = 10; myDynamic = \"Now I'm a string!\";` |\n| **num**     | `int` 和 `double` 的父類別，表示數值型資料的抽象                           | `num myNum = 3.14;`                                           |\n| **int**     | 表示整數型別                                                             | `int myInt = 123;`                                            |\n| **double**  | 表示雙精度浮點數型別                                                        | `double myDouble = 456.78;`                                   |\n| **bool**    | 表示布林值型別，只有 `true` 和 `false` 兩個值                               | `bool myBool = true;`                                         |\n| **String**  | 表示字串型別                                                             | `String myString = \"Dart is great!\";`                         |\n| **Symbol**  | 表示 Dart 程式中的符號，用於反射（reflection）                                | `Symbol mySymbol = #mySymbol;`                                |\n| **List<T>** | 類似於 Python 的列表，支持泛型，用於表示有序集合                               | `List<int> myList = [1, 2, 3];`                               |\n| **Map<K, V>** | 類似於 Python 的字典，支持泛型，用於表示鍵值對集合                           | `Map<String, int> myMap = {'one': 1, 'two': 2, 'three': 3};`  |\n\n\n    \nDart擁有int、double、String、bool等常見的變數型態\n    \n在定義變數的時候可以選擇給他明確的型態或是用「var」讓Dart來幫忙決定\n\n```\nvoid main() {\n  var a = 1; //int 整數\n  var b = \"1\"; // String 字串\n  var c = 1.1; // double 浮點數\n  \n  if (a is int) {\n    print('a is int'); // Output： a is int\n  }\n  if (b is String) {\n    print('b is String'); // Output： b is String\n  }\n  if (c is double) {\n    print('c is double'); // Output： c is double\n  }\n} \n```\n![image](https://hackmd.io/_uploads/BkkmafUtR.png)\n\n    \n需要注意的是假如用的是var在宣告賦值後就不能再賦予它其他型態的值了。\n    \n```\nvoid main() {\n  var a = 1;\n  a = \"123\"; // Error: A value of type 'String' can't be assigned to a variable of type 'int'.\n}\n```\n![image](https://hackmd.io/_uploads/BJbw6GLt0.png)\n\n如上圖所示會發生錯誤\n    \n也可以使用dynamic來做宣告，dynamic是所有物件的基礎類型，也就是說它可以代表任何物件。\n換句話來說，Dart的「dynamic」和JavaScript的「var」非常相似，可以隨時替換不同型態的值給變數。\n    \n```\nvoid main() {\n  dynamic a = 1;\n  a = '123';  // no error\n\n}\n```\n![image](https://hackmd.io/_uploads/r1diaGItA.png)\n\n雖然這次也是使用var來宣告，但卻可以替換成不同型態的值，這是由於一開始並未給變數a初始值，因此var會給予變數a dynamic型態，所以就算替換了不同型態的值也不會報錯。\n```\nvoid main() {\n  var a;\n  a = 1;\n  print(a); // Output：1\n  a = \"123\";\n  print(a); // Output： 123\n}\n```\n![image](https://hackmd.io/_uploads/Sk5JRM8t0.png)\n\n## List \n\n定義 List 需要使用方括號 []。可以在宣告時定義儲存值的型態，或者使用 dynamic 來接受所有型態。如果希望 List 內的值不被更動，在宣告時可以使用 const 關鍵字來把值固定，這樣之後就無法對 List 做新增、修改、刪除操作。\n    \nList 可以儲存任意型態的資料。\n使用 const 宣告的 List 是不可變的，無法修改其內容。\n支持泛型，可以在宣告時指定儲存的值的型態。\n透過這些特性，Dart 的 List 能夠提供靈活且強大的資料結構來管理和操作集合數據。\n\n```\nvoid main() {\n  List<dynamic> a = const [1, '123', true];\n  print(a[1]); // Output：123\n  a.add(123); // error\n}\n```\n![image](https://hackmd.io/_uploads/ByxgMQ8tC.png)\n\n## Map\n    \n最後要介紹的是Map，Map是使用key-value的方式來儲存的資料型態，Map是使用大括號{}，以Key:Value的方式定義。\n之後在實作專案裡面會使用到Map來儲存從Youtube Api回傳過來的JSON Data，大家可以先去看一下JSON是怎麼樣的資料格式喔~\n\n```\nvoid main() {\n  var map = {\n    'key1': 'value1',\n    'key2': 'value2',\n    'key3': 'value3'\n  };\n \n  print(map['key1']);    // Output: value1\n  print(map['test']);    // Output: null\n \n  map['key4'] = 'value4';\n  \n  //Length  \n  print(map.length); //Output： 4\n \n  print(map.containsKey('value1')); // Output： false\n \n\n  print(map.entries); // Output： (MapEntry(key1: value1), MapEntry(key2: value2), MapEntry(key3: value3), MapEntry(key4: value4))\n  print(map.values); // Output： (value1, value2, value3, value4)\n}\n```\n\n![image](https://hackmd.io/_uploads/Sy-a77LFC.png)\n\n# 總結\n    \n今天整理了 Dart 語言的基本概念和特性，包括其類型系統、函式庫、平台支援以及一些常用的資料型態，還有Dart 語言特性跟DartPad 的練習平台。","tags":["Flutter"]},{"title":"Flutter 學習紀錄 - Day 2 基礎概念","url":"/2024/07/30/Flutter-學習紀錄-Day-2-基礎概念/","content":"# Flutter 學習紀錄 - Day 2 基礎概念\n\n# Flutter的架構\n\nFlutter 是一個跨平台 UI 工具組，設計用於允許在作業系統（例如 iOS 和 Android）之間重複使用程式碼，同時也允許應用程式直接與底層平台服務介接。目標是讓開發人員能夠提供在不同平台上感覺自然的高效能應用程式，在它們存在差異的地方採用差異，同時盡可能共用程式碼。\n\n在開發期間，Flutter 應用程式會在 VM 中執行，該 VM 提供狀態熱重載變更，而不需要完全重新編譯。對於發行，Flutter 應用程式會直接編譯成機器碼，無論是 Intel x64 或 ARM 指令，還是針對網路的 JavaScript。此架構是開放原始碼的，採用寬鬆的 BSD 授權，並擁有蓬勃發展的第三方套件生態系統，補充核心程式庫功能。\n\n此概觀分為多個區段\n\n* 圖層模型：建構 Flutter 的部分。\n* 反應式使用者介面：Flutter 使用者介面開發的核心概念。\n* 小工具簡介：Flutter 使用者介面的基本建構區塊。\n* 渲染處理：Flutter 如何將 UI 程式碼轉換成像素。\n* 平台嵌入器概觀：讓行動和桌上型作業系統執行 Flutter 應用程式的程式碼。\n* 將 Flutter 與其他程式碼整合：關於 Flutter 應用程式可用的不同技術的資訊。\n* 支援網路：關於瀏覽器環境中 Flutter 特性的結論性說明。\n\n## 架構圖層\nFlutter 被設計為可擴充的圖層系統。它以一系列獨立的程式庫存在，每個程式庫都依賴於底層圖層。沒有任何圖層具有對下方圖層的特權存取權，而且架構層的每個部分都設計為可選和可替換的。\n![image](https://hackmd.io/_uploads/S1WdXASF0.png)\n>https://flutter.dev.org.tw/resources/architectural-overview\n\nFlutter的架構分成三層：\n\n### Framework\nFramework 層是 Flutter 的高層部分，主要是由 Dart 語言撰寫。這一層提供了構建應用程式的基本結構和工具。它包含了以下幾個子層：\n\n* Widgets：Flutter 提供了豐富的 Widget 集合，用於構建複雜的 UI 元件。這些 Widget 是 Flutter 應用程式的核心，所有的視圖和互動都由這些 Widget 組成。\n\n* Rendering：這個子層負責將 Widget 渲染到螢幕上。它處理佈局、繪製和動畫等操作，確保 Widget 能夠正確顯示和互動。\n\n* Animation and Gestures：提供了動畫和手勢的支援，讓開發者能夠輕鬆地添加豐富的動畫效果和處理用戶的手勢輸入。\n### Engine\n\nEngine 層是 Flutter 的核心，它由 C++ 編寫，並且負責低層次的渲染和輸入處理。這一層提供了跨平台的渲染和執行環境，使得 Flutter 應用能夠在不同的平台上運行。Engine 包含以下主要組件：\n\n* Skia：一個開源的 2D 圖形庫，用於繪製所有的圖形元素。Skia 提供了高效的繪圖性能，確保 Flutter 應用能夠流暢運行。\n\n* Dart Runtime：運行 Dart 程式碼的執行環境，負責 Dart 程式碼的編譯和執行。\n\n* Text：提供了文字渲染的支援，包括複雜的文字佈局和渲染。\n\n### Embedder\n\nEmbedder 層負責將 Flutter 應用嵌入到特定的操作系統中。這一層提供了與底層平台互動的介面，使得 Flutter 可以在不同的操作系統上運行。Embedder 包含以下功能：\n\n* Platform Channels：用於 Dart 和原生平台代碼之間的通信。這使得 Flutter 應用能夠調用原生平台的 API，並且讓原生平台能夠調用 Dart 程式碼。\n\n* Event Loop：處理操作系統的事件，如輸入事件和畫面更新，並將這些事件傳遞給 Flutter 應用。\n\n* Window Management：管理應用的窗口和視窗，使得 Flutter 應用能夠在不同平台上以正確的大小和位置顯示。\n\n\n# 跨平台開發工具比較\n\n與 APP 開發相關的主要跨平台開發框架和工具包括以下幾個：\n\n### 1. **Flutter**\n\n![image](https://hackmd.io/_uploads/SkF5LCBKA.png)\n>https://docs.flutter.dev/\n- **語言**：Dart\n- **描述**：由 Google 開發的框架，可以構建高效能的原生應用。其特點包括豐富的 widget 庫和優秀的 Hot Reload 功能。\n- **特點**：\n  - 高效能，直接編譯成原生代碼。\n  - 擁有豐富的預設元件和插件。\n  - 支援 iOS、Android、Web 和桌面應用。\n\n### 2. **React Native**\n![image](https://hackmd.io/_uploads/SJ7i_CHtA.png)\n>https://reactnative.dev/\n- **語言**：JavaScript\n- **描述**：由 Facebook 開發，使用 JavaScript 和 React 來構建原生應用。具有廣大的社群和豐富的第三方資源。\n- **特點**：\n  - 使用 JavaScript 和 React 來開發。\n  - 可以共享大部分代碼於 iOS 和 Android 平台。\n  - 需要透過 JavaScript Bridge 與平台溝通。\n\n### 3. **Ionic**\n![image](https://hackmd.io/_uploads/SysxFArYR.png)\n>https://ionicframework.com/\n- **語言**：JavaScript (Angular, React, Vue)\n- **描述**：基於 web 技術的框架，使用 HTML、CSS 和 JavaScript 來構建跨平台應用。依賴於 Cordova 和 Capacitor。\n- **特點**：\n  - 使用流行的 web 框架（如 Angular、React、Vue）。\n  - 可以通過 WebView 將應用包裝成原生應用。\n  - 支援廣泛的插件和原生功能訪問。\n\n### 4. **Apache Cordova (PhoneGap)**\n![image](https://hackmd.io/_uploads/B1oXtRSK0.png)\n>https://cordova.apache.org/\n- **語言**：HTML, CSS, JavaScript\n- **描述**：使用 web 技術來構建移動應用，並包裝成原生應用在各種平台上運行。\n- **特點**：\n  - 通過 WebView 渲染應用內容。\n  - 支援多種平台（iOS、Android 等）。\n  - 插件系統豐富，能訪問各種原生功能。\n\n### 5. **Kotlin Multiplatform Mobile (KMM)**\n![image](https://hackmd.io/_uploads/Byt8tRrY0.png)\n>https://www.jetbrains.com/kotlin-multiplatform/\n- **語言**：Kotlin\n- **描述**：由 JetBrains 提供，允許使用 Kotlin 來共享業務邏輯代碼，同時在 Android 和 iOS 上運行。\n- **特點**：\n  - 專注於共享邏輯層，UI 層使用平台原生方式實現。\n  - 提供 Kotlin 語言的所有優勢和功能。\n  - 與 Android 原生開發無縫整合。\n\n### 6. **Unity**\n![image](https://hackmd.io/_uploads/SkSYYCBt0.png)\n>https://unity.com/cn \n\n- **語言**：C#\n- **描述**：主要用於遊戲開發，但也能用於構建各種跨平台的應用。\n- **特點**：\n  - 支援多種平台，包括 iOS、Android、Windows、macOS。\n  - 強大的 2D 和 3D 渲染能力。\n  - 擁有廣泛的插件和資源庫。\n\n### 8. **NativeScript**\n![image](https://hackmd.io/_uploads/Sk1vcCHKA.png)\n>https://nativescript.org/\n- **語言**：JavaScript, TypeScript\n- **描述**：允許使用 JavaScript 或 TypeScript 來構建原生移動應用。\n- **特點**：\n  - 提供對原生 API 的直接訪問。\n  - 可以使用 Angular 或 Vue.js 來構建應用。\n  - 支援 iOS 和 Android。\n\n當然可以，以下是調整後的比較表：\n\n| 框架/工具                         | **Flutter**                                             | **React Native**                                        | **.NET MAUI**                                            | **Ionic**                                                | **Apache Cordova (PhoneGap)**                            | **Kotlin Multiplatform Mobile (KMM)**                    | **Unity**                                                | **NativeScript**                                         |\n|-----------------------------------|---------------------------------------------------------|---------------------------------------------------------|----------------------------------------------------------|----------------------------------------------------------|----------------------------------------------------------|----------------------------------------------------------|----------------------------------------------------------|----------------------------------------------------------|\n| **語言**                          | Dart                                                    | JavaScript                                              | C#                                                       | JavaScript (Angular, React, Vue)                         | HTML, CSS, JavaScript                                    | Kotlin                                                   | C#                                                       | JavaScript, TypeScript                                   |\n| **Hot Reload 支援**               | 支援                                                    | 支援                                                    | 支援                                                     | 支援                                                     | 支援                                                     | 不支援                                                   | 支援                                                     | 支援                                                     |\n| **發展時間**                      | 2017年                                                  | 2015年                                                  | 2021年                                                   | 2013年                                                   | 2009年                                                   | 2019年                                                   | 2005年                                                   | 2014年                                                   |\n| **Component 支援**                | 由 Google 開發，預設豐富                                | 需要第三方支援                                          | 由 Microsoft 支持，與 .NET 生態系統整合                  | 需要第三方支援                                           | 需要第三方支援                                           | 需自行開發                                               | 豐富，針對遊戲開發                                       | 需要第三方支援                                           |\n| **文件品質**                      | 詳細易讀                                                | 第三方 Library 文件品質不一                             | 詳細易讀                                                 | 第三方 Library 文件品質不一                              | 第三方 Library 文件品質不一                              | 詳細易讀                                                 | 詳細易讀                                                 | 詳細易讀                                                 |\n| **社群成熟度**                    | 發展中                                                  | 成熟                                                    | 發展中                                                   | 成熟                                                     | 成熟                                                     | 發展中                                                   | 成熟                                                     | 發展中                                                   |\n| **效能**                          | 直接轉成 native code                                    | 需透過 Bridge 與平台溝通                                | 直接訪問原生 API                                         | 基於 WebView                                            | 基於 WebView                                            | 直接訪問原生 API                                         | 高效能 2D 和 3D 渲染                                     | 直接訪問原生 API                                         |\n| **App 大小**                      | 較小                                                    | 較大                                                    | 中等                                                     | 中等                                                     | 中等                                                     | 中等                                                     | 較大                                                     | 中等                                                     |\n| **特色與備註**                    | 高效能，豐富的 widget 庫和 Hot Reload 功能              | 使用 JavaScript 和 React 開發，廣大的社群與資源         | 繼承自 Xamarin，與 Visual Studio 緊密整合               | 使用 web 技術構建應用，依賴於 Cordova 和 Capacitor       | 使用 web 技術構建應用，廣泛的平台支持                   | 共享邏輯層，UI 層使用平台原生方式實現                   | 遊戲開發為主，但可構建各種應用，支持多平台               | 使用 Angular 或 Vue.js 構建應用，支援 iOS 和 Android    |\n\n# 總結\n\n- **Flutter** 是一個強大且高效的框架，適合構建高性能、原生體驗的跨平台應用。\n- **React Native** 具有廣大的社群和資源，使用 JavaScript 和 React，是許多開發者的首選。\n- **.NET MAUI** 繼承自 Xamarin，與 .NET 和 Visual Studio 緊密結合，適合已有 C# 技能的開發者。\n- **Ionic** 和 **Cordova** 適合使用 web 技術開發應用的團隊，具有較好的跨平台支持。\n- **Kotlin Multiplatform Mobile (KMM)** 提供共享業務邏輯的能力，適合 Android 和 iOS 原生開發者。\n- **Unity** 適合需要高效能 2D/3D 渲染的應用，尤其是遊戲開發。\n- **NativeScript** 允許使用 Angular 或 Vue.js 構建應用，提供直接訪問原生 API 的能力。\n\n這些框架各有優勢和適用場景，選擇哪一個取決於你的具體需求和技術背景。希望這些比較能對你有所幫助。\n","tags":["Flutter"]},{"title":"Flutter 學習紀錄 - Day 1 安裝與介紹","url":"/2024/07/30/Flutter-學習紀錄-Day-1-安裝與介紹/","content":"# Flutter 學習紀錄 - Day 1 安裝與介紹\n\n# 什麼是Flutter\n![image](https://hackmd.io/_uploads/SJY_aRlKA.png)\n>https://flutter.dev/\n\nFlutter 是由 Google 開發的一個開源框架，使用 Dart 程式語言寫一份Code可以同時讓iOS與Android平台使用，也支援Web以及桌面應用程式。\n\n主要特點如下：\n\n## 主要特點\n### 跨平台：\nFlutter 允許開發者使用單一代碼庫同時構建 Android 和 iOS 應用，甚至可以用於網頁和桌面應用的開發。\n\n### 高性能：\n由於 Flutter 直接編譯成原生代碼，因此性能優越，可以達到原生應用的流暢度。\n\n### 豐富的組件庫：\n提供了大量的預製組件（Widgets），這些組件可以高度定制，滿足不同設計需求。\n\n### 熱重載：\nFlutter 支持熱重載（Hot Reload），使得開發者可以快速查看代碼修改結果，大幅提升開發效率。\n\n### 單一代碼語言：\n使用 Dart 編程語言，簡化了開發過程，特別是對於那些需要同時支持多個平台的應用。\n\n## 優點 \n### 快速開發：\n由於熱重載功能和豐富的組件庫，開發者可以更快更新和測試應用。\n\n### 一致的 UI 表現:\nFlutter 的組件是基於自己繪製的，因此無論在什麼平台上，UI 表現都一致。\n\n### 強大的社群支持：\nFlutter 擁有一個活躍且不斷增長的社群，提供了大量的資源和插件，幫助開發者解決各種問題。\n\n## Fltter檔案構造\n\n\n```\nflutter_project/\n│\n├── lib/\n├── test/\n│   └── widget_test.dart\n├── android/\n├── ios/\n├── assets/\n└── pubspec.yaml\n```\n\n### lib\n主要的 Dart 代碼存放處，包含應用程式的主要邏輯和功能。\n\n### test\n用於存放測試代碼的地方。在這個資料夾中，你可以編寫單元測試和集成測試。\n\n### android\nAndroid 平台的原生代碼存放處。通常你不太需要直接操作這個資料夾，除非你有特定的 Android 平台需求。\n### ios\niOS 平台的原生代碼存放處。與 android 資料夾一樣，大多數情況下你不需要直接處理這個資料夾。\n\n### assets\n存放應用程式資源檔案的地方，如圖片、字體文件等。在 Dart 代碼中，你可以使用 AssetImage 或類似的類來訪問這些資源。\n### test中的 widget_test.dart 文件（可選）\n默認的測試文件，用於測試應用程式的 Widget。你可以在這裡添加和擴展測試。\n\n# Fltter教學資源\n\n以下是網路上參考的學習資源\n\n## HKT 線上教室 Flutter 程式設計入門實戰 30 天\n![image](https://hackmd.io/_uploads/ByjVuYEFA.png)\n>https://ithelp.ithome.com.tw/users/20096484/ironman/2699\n\n## 猫哥 — Flutter 零基础入门中文教学\n![image](https://hackmd.io/_uploads/ry2zdKEFA.png)\n>https://www.youtube.com/watch?v=C1emOeteMmc&list=PL274L1n86T839P6Bqd3M2knHhLjU0wRMG\n\n## Flutter中文网\n![image](https://hackmd.io/_uploads/HJBy_tNF0.png)\n>https://doc.flutterchina.club/tutorials/\n\n## Flutter---Google推出的跨平台框架，Android、iOS一起搞定\n![image](https://hackmd.io/_uploads/Skp73p4tA.png)\n>https://ithelp.ithome.com.tw/users/20119550/ironman/2221\n\n# 下載 Flutter\n\n## 方法一 (推薦)\n### 安裝Git for Windows(https://git-scm.com/download/win)\n### 下載Flutter SDK\n在C槽點滑鼠右鍵「Git bash here」，便會開啟git bash，你就可以在裡面下git command。\n![image](https://hackmd.io/_uploads/rJhvkyZFC.png)\n\n\n接著輸入git clone -b stable https://github.com/flutter/flutter.git\n電腦就會自己去找Flutter官方發布的最新穩定版本並下載到當前資料夾。\n\n# 安裝Flutter\n## 進到flutter資料夾，執行flutter_console.bat\n\n![image](https://hackmd.io/_uploads/HJ7XeJbF0.png)\n\n執行後會跳出以下畫面\n![image](https://hackmd.io/_uploads/B1V8lkWtR.png)\n\n輸入以下指令 檢查電腦環境，並下載Dart的SDK\n```\nflutter doctor\n```\n![image](https://hackmd.io/_uploads/BkojgJ-FC.png)\n\n\n![image](https://hackmd.io/_uploads/rkY1Q1WK0.png)\n\n{% note warning simple %}\n最後會產生一個簡易的報表，這時會看到一些錯誤或警告。\n別緊張，後面的步驟會一步一步處理它們。\n\n先看一下有哪些錯誤\n\n[X] Android toolchain - develop for Android devices\n    X Unable to locate Android SDK.\n    \n[X] Visual Studio - develop Windows apps\n    X Visual Studio not installed; this is necessary to develop Windows apps.\n    \n[!] Android Studio (not installed) \n{% endnote %}\n\n## 設定安裝 \n```\nbin/sdkmanager --sdk_root=\"C:\\Android\\Sdk\" --install \"cmdline-tools;latest\"\n```\n## 接受 Android SDK 授權協議\n\n```\nflutter doctor --android-licenses\n```\n\n## 設定環境變數\n\n搜尋環境變數\n![image](https://hackmd.io/_uploads/HkflEkWYR.png)\n\n點選環境變數\n![image](https://hackmd.io/_uploads/HyqNE1-FC.png)\n\n在使用者變數區域找到「path」變數\n![image](https://hackmd.io/_uploads/HyVIVy-FC.png)\n\n新增一個路徑到C:\\flutter\\bin\n![image](https://hackmd.io/_uploads/H1ytVybYR.png)\n\n\n完成這個步驟之後就可以直接在cmd或powershell使用flutter commands，\n\n## 下載安裝Android Studio\n\n![image](https://hackmd.io/_uploads/ByVdrk-FC.png)\n>https://developer.android.com/studio?hl=zh-tw#get-android-studio\n\n這邊發現好像改版成 Android Studio Koala了\n\n![image](https://hackmd.io/_uploads/ryySFFNY0.png)\n\n![image](https://hackmd.io/_uploads/SJ3UFF4YC.png)\n\n![image](https://hackmd.io/_uploads/rJYutYEFC.png)\n\n![image](https://hackmd.io/_uploads/HJO5tKEYA.png)\n\n![image](https://hackmd.io/_uploads/r15Q9FVFC.png)\n\n![image](https://hackmd.io/_uploads/HJPV5FEYC.png)\n\n![image](https://hackmd.io/_uploads/BkIDctNFC.png)\n\n![image](https://hackmd.io/_uploads/Sk7FcY4tA.png)\n\n![image](https://hackmd.io/_uploads/H1ljqYEY0.png)\n\n![image](https://hackmd.io/_uploads/SJLC5FNKR.png)\n\n### 設定模擬器\n\n\n### 設定 C/C++ for Visual Studio Code\n參考文件:https://code.visualstudio.com/docs/languages/cpp\n\n![image](https://hackmd.io/_uploads/S1jkS9NY0.png)\n\n![image](https://hackmd.io/_uploads/ryMWr9EYR.png)\n\n後來發現這個操作沒有效，還是要直接安裝 Visual Studio\n\n## 安裝visual studio\n選擇 Desktop development with C++\n![image](https://hackmd.io/_uploads/BySy66VK0.png)\n因為以上這個問題，所以需要安裝visual studio 的 C++  workload\n\n\n![image](https://hackmd.io/_uploads/SJkcYarYC.png)\n>目前遇到這個問題，不知道如何處理，暫時忽略\n\n## 安裝 cmdline-tools 組件\n\n1.使用 SDK Manager 安裝 cmdline-tools\n打開命令提示符或 PowerShell。\n\n2.導航到你的 Android SDK 安裝目錄下的 cmdline-tools/bin 目錄。例如，如果你的 SDK 安裝在 C:\\Users\\<你的用戶名>\\AppData\\Local\\Android\\Sdk，那麼命令應該是：\n\n```\ncd C:\\Users\\<你的用戶名>\\AppData\\Local\\Android\\Sdk\\cmdline-tools\\latest\\bin\n\n```\n\n3.執行以下命令來安裝最新的 cmdline-tools：\n```\nsdkmanager --install \"cmdline-tools;latest\"\n```\n\n接受 Android SDK 許可\n在命令提示符中輸入以下命令來接受所有 Android SDK 許可：\n```\nflutter doctor --android-licenses\n```\n\n![image](https://hackmd.io/_uploads/SJGTw5EtC.png)\n\n\n### 安裝Flutter和dart plugin\n![image](https://hackmd.io/_uploads/HyYgAKEKR.png)\n\n\n## 目前實測操作結果如下\n![image](https://hackmd.io/_uploads/r1oEYpBtC.png)\n\n\n## 結尾\n今天實際操作了 Flutter 的安裝，後續的Java 需要設定環境變數跟 android studio 安裝都花了比較多的時間，另外 安裝 Visual Studio 也是花了很久的時間特別麻煩，而且很佔空間，另外遇到以下錯誤\n\n錯誤碼 1310: 拒絕存取\nWindow Installer 服務要安裝 Visual Studio 所需封裝時，無法存取這部電腦的登錄或檔案系統。如果 Windows Defender 或其他防毒軟體會限制存取，就可能發生這種情況。\n\n修正方式: 請檢查您的防毒設定，並確認 Windows Installer 服務對登錄和檔案系統有不受限制的存取權。\n\n這部分目前打算暫時先略過，之後再來處理。","tags":["Flutter"]},{"title":"我想要再去當救生員","url":"/2024/07/26/我想要再去當救生員/","content":"# 我想要再去當救生員\n\n# 前言\n\n我之前大學的時候有當過救生員，那時候是因為學校有救生員社團，所以那時候去參加就有跟著社團訓練有拿到水協的救生員證，也有在一段時間課間時間去學校泳池站救生，那時候覺得救生訓練很有趣，除了每周二跟周四晚上的泳池訓練以外，周末還有海訓、溪訓跟深水泳池，我記得海訓的時候是在白沙灣太陽很大超好玩，溪訓的時候是在坪林親水公園溪水超冰的很涼快而且要記得防曬，深水泳池是在松山運動中心跳水很刺激不過那時候很怕猶豫很久不敢跳，這週六去白沙灣玩sup的時候覺得周末如果我自己有時間可以安排來站救生感覺也不錯，所以想再來去考一下體委的救生證。\n\n# 怎麼報名?\n\n現在報名要到[i運動資訊平台](https://isports.sa.gov.tw/apps/LGM/LGM09/LGM0967Q_01V1.aspx?MENU_PRG_CD=4&ITEM_PRG_CD=2)查詢離自己比較近的訓練泳池訓練單位跟日期，因為要完成50個小時的新訓，且其中包含8小時的基本救命術訓練，才能取得體育署救生員執照的「報考」資格。\n\n![image](https://hackmd.io/_uploads/ryUZmlYIA.png)\n>i運動資訊平台\n\n今天是 2024年7月4號，我在這邊找到了離我比較近的士林前港泳池有辦新訓，所以就有報名7月份的新訓了，希望一切順利。","tags":["救生員"]},{"title":"GCP 學習 - Moniter 官方教學課程紀錄","url":"/2024/06/17/GCP-學習-Moniter-官方教學課程紀錄/","content":"# GCP 學習 - Moniter 官方教學課程紀錄\n\n這邊是 Google Cloud Platform (GCP) 的 Moniter介面\n![image](https://hackmd.io/_uploads/HkY6NvtSC.png)\n>https://console.cloud.google.com/logs/query\n\nGCP 這邊在使用上都會有一個這樣的了解詳情按紐\n![image](https://hackmd.io/_uploads/ry_1rmar0.png)\n\n點擊下去之後就會有詳細的教學文件，我覺得很實用，但是這邊有個問題就是界面都會一直隨著時間改動，可能我現在紀錄的內容過了一年之後就更新了需要重新學習，不過我覺得還是可以做一個參考使用。\n\n# 教學項目\n一開始右邊可以看到教學項目，有以下內容\n\n## 說明文件: 使用記錄檔探索工具\n\n您可以使用 Cloud Logging，有效率地擷取、檢視及分析查詢的記錄檔。\n\n![image](https://hackmd.io/_uploads/SyfQsz6HA.png)\n>https://cloud.google.com/logging/docs/view/logs-explorer-interface\n\n## 教學課程: 快速入門導覽課程：Cloud Logging 導覽與簡介\n\n課程時間: 20 分鐘\n開始使用 Cloud Logging，追蹤應用程式中的問題。\n![image](https://hackmd.io/_uploads/SyUa3f6H0.png)\n\n\n## 教學課程:快速入門導覽課程：運用作業套件代理程式，從 Apache 網路伺服器收集記錄檔\n\n使用作業套件代理程式，從 Apache 網路伺服器收集記錄檔，再透過記錄檔探索工具查看這些檔案。\n\n![image](https://hackmd.io/_uploads/BJDCnGpBR.png)\n\n\n## 說明文件: Logging 用途\n\n瞭解用途、最佳做法和產業解決方案。\n監控與記錄的架構指南\n\n探索監控與記錄的最佳做法和參考架構。\n\n![image](https://hackmd.io/_uploads/B1mOjG6r0.png)\n\n\n\n## 說明文件: 透過記錄檔探索工具建構查詢\n\n在記錄檔探索工具中建構查詢，以便擷取、修正及分析記錄檔。\n\n![image](https://hackmd.io/_uploads/BkohsMaBR.png)\n>https://cloud.google.com/logging/docs/view/building-queries\n\n## 說明文件: Logging 查詢語言\n\n瞭解用來查詢記錄檔資料及建立記錄檔接收器的 Logging 查詢語言。\n\n![image](https://hackmd.io/_uploads/rJMghzTHC.png)\n>https://cloud.google.com/logging/docs/view/logging-query-language\n\n## 說明文件: 使用記錄檔探索工具的查詢範例\n\n查看建議的查詢，讓您輕鬆使用記錄檔探索工具找出重要記錄檔。\n\n![image](https://hackmd.io/_uploads/SJlr3z6BA.png)\n>https://cloud.google.com/logging/docs/view/query-library\n\n\n## 說明文件: 使用 gcloud CLI 寫入及查詢記錄項目\n\n運用記錄工具試用一些 Cloud Logging 的基本功能。\n\n![image](https://hackmd.io/_uploads/HJQ_3G6SC.png)\n>https://cloud.google.com/logging/docs/write-query-log-entries-gcloud\n\n以下是個別細項的介紹\n\n## 使用記錄檔探索工具 - View logs by using the Logs Explorer\n使用記錄檔探索工具\n\n![image](https://hackmd.io/_uploads/S1DiUPYHC.png)\n>https://cloud.google.com/logging/docs/view/logs-explorer-interface\n\n可以使用 Cloud Logging，有效率地擷取、檢視及分析查詢的記錄檔。\n這邊的文件寫得非常的詳細\n\n## 快速入門導覽課程：Cloud Logging 導覽與簡介 \n\n這邊是一個教學課程20 分鐘，是有關 Cloud Logging，追蹤應用程式中的問題。\n\n![image](https://hackmd.io/_uploads/rJAlKDKr0.png)\n\n![image](https://hackmd.io/_uploads/Bk0MtvYBR.png)\n\n### 步驟1. 專案設定\n![image](https://hackmd.io/_uploads/HJXBYDtSR.png)\n\n### 步驟2. 探索 Cloud Logging 介面\n![image](https://hackmd.io/_uploads/SJx_tvFSC.png)\n\n如要輸入篩選條件來限制顯示的記錄檔，請使用「Query Builder」(查詢建立工具) 窗格。\n\n![image](https://hackmd.io/_uploads/B1RIqDYBR.png)\n\n如要查看查詢結果，請使用「Query Results」(查詢結果) 窗格。\n\n![image](https://hackmd.io/_uploads/ByENZuKBC.png)\n\n\n![image](https://hackmd.io/_uploads/BkdY5DtBC.png)\n\n如要查看不同欄位對應的記錄項目數量，請使用「Log Fields」(記錄檔欄位) 窗格。\n\n舉例來說，這個窗格會列出嚴重性為 Critical 的記錄檔數量。這個窗格中的資料可做為欄位參考清單，撰寫查詢時可派上用場。\n\n![image](https://hackmd.io/_uploads/r1Yp5DtSR.png)\n\n如要查看錯誤率，請使用「Histogram」(直方圖) 圖表。這張圖表不僅可協助您找出值得關注的事件發生的時間點，還可用來做為依時間和日期篩選記錄結果的介面。\n\n![image](https://hackmd.io/_uploads/HyOgjDKSA.png)\n\n如要取得查詢的連結，點選「Share Link」(共用連結) 按鈕，即可針對目前顯示的這組記錄檔複製安全的深層連結。\n\n![image](https://hackmd.io/_uploads/BkLDjvYSC.png)\n\n![image](https://hackmd.io/_uploads/BJ7KivKB0.png)\n\n如要針對顯示或查詢的記錄檔設定時間範圍，請使用時間範圍選取器按鈕。\n\n![image](https://hackmd.io/_uploads/B1hnjDFH0.png)\n\n![image](https://hackmd.io/_uploads/SkupguFB0.png)\n\n### 步驟3. 建立 GKE 叢集\n![image](https://hackmd.io/_uploads/Skw7MdKBC.png)\n\n在工具列中按一下  ![image](https://hackmd.io/_uploads/HyzvfuFrR.png)\n\n![image](https://hackmd.io/_uploads/rJS_fuKH0.png)\n>這邊會開始佈建 Cloud Shell 機器\n\n在下列指令中，將 PROJECT_ID 替換成您的專案 ID，然後在 Cloud Shell 中執行指令：\n\n```\ngcloud container clusters create \\\n    \"logcluster\" --project PROJECT_ID \\\n    --zone us-central1-c --scopes \\\n    \"gke-default\" --num-nodes \"3\" \\\n    --enable-stackdriver-kubernetes\n```\n![image](https://hackmd.io/_uploads/Sk0dm_trA.png)\n\n這邊系統題式要啟用 Kubernetese Engine API\n![image](https://hackmd.io/_uploads/HJ514_Yr0.png)\n>點選啟用\n\n花了一點時間後就成功了\n![image](https://hackmd.io/_uploads/Hyt6EdtHA.png)\n\n\n執行上一個指令後，系統就會建立名為 logcluster 的叢集。這項作業會在幾分鐘內完成。建立叢集時，GKE 會佈建虛擬機器、載入機器映像檔，並設定要執行的 GKE 叢集。\n\n如要安裝會產生記錄的應用程式，請按「Next」(下一步)。\n\n\n### 步驟4. 安裝應用程式\n![image](https://hackmd.io/_uploads/SyT9LOtrC.png)\n\n\n執行下列指令，連線至 GKE 叢集：\n\n```\ngcloud container clusters \\\n    get-credentials logcluster \\\n    --zone us-central1-c --project \\\n    PROJECT_ID\n```\n    \n![image](https://hackmd.io/_uploads/HymbwOYHC.png)\n\n提取 Container Registry 中的應用程式，並部署至叢集：\n```\nkubectl run chatty \\\n    --image=gcr.io/cloud-logging-generator/cloud-logging-log-creator\n```\n\n![image](https://hackmd.io/_uploads/Hy-wPOtB0.png)\n\n部署應用程式需要一些時間。部署完成後，應用程式就會產生記錄檔。\n\n如要查看應用程式，請參考 GitHub 中的 [cloud-logging-log-creator](https://github.com/GoogleCloudPlatform/cloud-logging-log-creator?hl=zh-TW) 應用程式。\n\n如要瞭解如何查看 GKE 記錄檔，請按「Next」(下一步)。\n\n### 步驟5. 查看 GKE 記錄檔\n![image](https://hackmd.io/_uploads/rkLi_OYS0.png)\n\n在「Logs Explorer」(記錄檔探索工具) 頁面中，前往「Log Fields」(記錄檔欄位) 專區。\n\n![image](https://hackmd.io/_uploads/B1JNKOYBA.png)\n\n「Resource Type」(資源類型)\n\n![image](https://hackmd.io/_uploads/SyA3KuKH0.png)\n 專區中應該會列出幾個不同的實體，例如「Kubernetes Node」(Kubernetes 節點) 或「Kubernetes Pod」。\n\n按一下「Kubernetes Cluster」(Kubernetes 叢集)。\n\n選取「Kubernetes Cluster」(Kubernetes 叢集) 資源類型後，會發生以下情況：\n\n![image](https://hackmd.io/_uploads/r1hRquKHA.png)\n\n\n「Query results」(查詢結果) 窗格中顯示的所有記錄，資源類型都設為「Kubernetes Cluster」(Kubernetes 叢集)。\n「Query builder」(查詢建立工具) 窗格中的查詢會變更為 resource.type=\"k8s_cluster\"\n新類別會出現在「Log fields」(記錄欄位) 窗格中。這些類別包括：\n* 記錄檔名稱\n* 專案 ID\n* 位置\n\n在「Query builder」(查詢建立工具) 工具列中，按一下「Clear Query」(清除查詢)。\n![image](https://hackmd.io/_uploads/BkqfjOtSA.png)\n\n### 步驟6. 尋找含有 chattylogs 的記錄檔\n\n1.在「Query Builder」(查詢建立工具) 中輸入 chattylogs。\n\n![image](https://hackmd.io/_uploads/rkh76OtS0.png)\n\n在「Query Builder」(查詢建立工具) 中輸入單一字詞時，該查詢會搜尋各個記錄檔的所有欄位，確認是否有相符項目。這類查詢的效率較低。\n\n在先前的範例中，查詢只會搜尋每個記錄項目的 resource.type 這個欄位。\n\n2.按一下 [執行查詢]。\n\n結果會列出您安裝的應用程式產生的所有記錄檔。\n\n3.請花幾分鐘的時間探索資料。舉例來說，只要前往「Query」(查詢) 窗格中的某個記錄檔，然後按下「Expand」(展開)按鈕，即可探索該記錄檔的各個欄位。\n![image](https://hackmd.io/_uploads/ByMLadYSC.png)\n\n4.在「Query builder」(查詢建立工具) 工具列中，按一下「Clear Query」(清除查詢)。\n![image](https://hackmd.io/_uploads/HJYup_YS0.png)\n\n### 步驟7. 依嚴重性和記錄檔名稱篩選\n\n1.依嚴重性等級篩選：\n\n按一下「Severity」(嚴重性)。\n![image](https://hackmd.io/_uploads/HyxiTOYBR.png)\n\n選取「Critical」(重要)。\n![image](https://hackmd.io/_uploads/S1X2adYSR.png)\n\n「Query results」(查詢結果) 窗格會顯示嚴重性等級為 Critical 的記錄。\n\n2.依記錄檔名稱篩選：\n\n* 找到任一項目，然後按一下展開符號。\n* 找出 logName 項目，在記錄檔名稱上按一下，然後點選「Show matching items」(顯示相符的項目)。\n\n![image](https://hackmd.io/_uploads/HyXbkYYHC.png)\n\n查詢傳回的結果如下：\n\n```\nseverity=CRITICAL\nlogName=\"projects/PROJECT_ID/logs/chattylogs\"\n```\n\n系統只會顯示符合 severity 和 logName 篩選條件的記錄檔。\n\n3.探索錯誤直方圖：\n\n* 從查詢建立工具中移除 severity=Critical 這一行，然後按一下「Run Query」(執行查詢)。\n\n![image](https://hackmd.io/_uploads/B1aAlFKSR.png)\n\n\n* 前往「Histogram」(直方圖) 窗格，找出直方圖顯示紅色長條的時間範圍，然後透過滑桿將時間範圍限縮到該直方圖項目附近。\n![image](https://hackmd.io/_uploads/rycyGYKSC.png)\n\n* 移動滑桿後，按一下「Run Query」(執行查詢)。\n![image](https://hackmd.io/_uploads/BkQDMKYHC.png)\n\n\n直方圖會顯示，嚴重性為 Critical 的各個記錄項目前面，會有狀態為 Informational 或 Warning 的其他記錄檔。這些時間較早的記錄檔提供的資訊為，在系統寫入嚴重性為 Critical 的記錄項目前，應用程式處於何種狀態。\n\n### 步驟8. 串流記錄\n根據預設，系統會停用記錄檔串流功能，記錄檔探索工具不會直接顯示這些內容。\n\n如要即時查看記錄檔，請按一下「Stream logs」(串流記錄)。\n\n![image](https://hackmd.io/_uploads/BJ_pMFYBC.png)\n\n查看完畢之後，請按一下「Stop streaming」(停止串流)。\n![image](https://hackmd.io/_uploads/H16RGtFHA.png)\n\n如要進一步瞭解 Logging，請按「Next」(下一步)。\n\n### 步驟9. 進一步瞭解 Cloud Logging\n\n「Log-based metrics」(記錄指標) 頁面可讓您從記錄項目的內容中取得指標資料。舉例來說，您可以建立指標來計算專案中的 Compute Engine VM 發生了多少 Warning 事件。詳情請參閱「[記錄指標總覽](https://cloud.google.com/logging/docs/logs-based-metrics)」的說明。\n\n「Logs Router」(記錄檔路由器) 頁面可讓您將記錄檔導向不同的目的地，包括 Cloud Logging 記錄檔值區、Cloud Storage 值區、Pub/Sub 主題和 BigQuery 資料集。您可以使用這項功能設定要將哪些記錄檔轉送至特定目的地。詳情請參閱「[轉送和儲存空間總覽](https://cloud.google.com/logging/docs/routing/overview)」的說明。\n\n本快速入門導覽課程需使用資源，如要瞭解如何避免系統向您的 Google Cloud 帳戶收取相關費用，請按「Next」(下一步)。\n\n### 步驟10. 後續步驟 避免產生帳單費用\n保留已建立的資源並運用 Logging 執行更多工作，或是清除所用資源來避免產生帳單費用。\n\n運用 Logging 執行更多工作\n* 進一步瞭解 Logging 查詢語言：\n    * 常見查詢。\n    * 建構查詢。\n* 瞭解如何查詢及查看記錄檔。\n清除所用資源\n此逐步操作說明需使用資源，如要避免系統向您的 Google Cloud 帳戶收取相關費用，請按照下列步驟操作。\n\n執行下列指令：\n```\ngcloud container clusters delete \\\n    logcluster --zone \\\n    us-central1-c --project PROJECT_ID \\\n    -q\n```\n\n\n## 快速入門導覽課程：運用作業套件代理程式，從 Apache 網路伺服器收集記錄檔\n\n使用作業套件代理程式，從 Apache 網路伺服器收集記錄檔，再透過記錄檔探索工具查看這些檔案。\n\n### 步驟1. 運用作業套件代理程式收集來自 Apache 的記錄檔\n![image](https://hackmd.io/_uploads/Bk9O9ttBC.png)\n瞭解如何使用作業套件代理程式，收集及查看 `syslog` 記錄檔。這些記錄檔是由安裝在 Compute Engine 虛擬機器 (VM) 執行個體上的 Apache 網路伺服器所收集。您可以使用類似本快速入門導覽課程中的程序，[監控其他第三方應用程式](https://cloud.google.com/logging/docs/agent/ops-agent/third-party)。\n\n\n在本快速入門導覽課程中，執行以下操作：\n1. 建立 Compute Engine VM 執行個體，並安裝[作業套件代理程式](https://cloud.google.com/logging/docs/agent/ops-agent)。\n1. 安裝 Apache 網路伺服器。\n1. 針對 Apache 網路伺服器設定作業套件代理程式。\n1. 在記錄檔探索工具中查看記錄檔。\n1. 建立記錄式快訊。\n1. 測試快訊。\n1. 清除所用資源。\n\n預計時間：\n15 分鐘\n\n\n### 步驟2.  建立 VM 執行個體\n\n![image](https://hackmd.io/_uploads/SyCtcFtSR.png)\n\n1.前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：\n\n前往「VM instances」(VM 執行個體) 頁面\n![image](https://hackmd.io/_uploads/HJneotKHR.png)\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。\n\n2.點選「Create instance」(建立執行個體) 建立 VM。\n![image](https://hackmd.io/_uploads/r13bsYYr0.png)\n\n如要查看位置，請點選下列按鈕：顯示\n![image](https://hackmd.io/_uploads/HJgVitFBC.png)\n\n3.在`「Name」(名稱)` 欄位中，輸入描述性名稱。\n\n![image](https://hackmd.io/_uploads/HkwujFtB0.png)\n\n4.在`「Machine type」(機器類型)` 欄位中，選取「e2-small」。\n![image](https://hackmd.io/_uploads/B11ssYtS0.png)\n\n![image](https://hackmd.io/_uploads/SkRToFtHR.png)\n\n5.在`「Boot disk」(開機磁碟)` 區段中，保留預設設定「Debian GNU/Linux」。\n![image](https://hackmd.io/_uploads/HJtAoKtSA.png)\n\n6.在`「Firewall」(防火牆)` 區段中，選取「Allow HTTP traffic」(允許 HTTP 流量) 和「Allow HTTPS traffic」(允許 HTTPS 流量)。\n![image](https://hackmd.io/_uploads/rynehFKHA.png)\n\n![image](https://hackmd.io/_uploads/Byst2tKr0.png)\n\n7.在「Observability - Ops Agent」(觀測能力 - 作業套件代理程式)區段中，選取「Install Ops Agent for Monitoring and Logging」(安裝作業套件代理程式來處理監控和記錄工作)。\n\n![image](https://hackmd.io/_uploads/B18shKFBR.png)\n\n8.按一下「Create」(建立)。\n![image](https://hackmd.io/_uploads/Hks32FtBR.png)\n\n![image](https://hackmd.io/_uploads/H1VEpKtHA.png)\n\n### 步驟3.  安裝 Apache 網路伺服器\n\n1.在「VM instances」(VM 執行個體) 頁面上找到新的 VM，前往「Connect」(連線) 欄，然後點選「SSH」。\n\n![image](https://hackmd.io/_uploads/HkdgCttHR.png)\n\n![image](https://hackmd.io/_uploads/SkOWCKKr0.png)\n\n點選授權\n![image](https://hackmd.io/_uploads/ByCmAttS0.png)\n\n2.如要更新套件清單，請將下列指令複製到剪貼簿，貼到 SSH 終端機，然後按下 Enter 鍵：\n\n```\nsudo apt-get update\n```\n\n![image](https://hackmd.io/_uploads/HyBIAFYHA.png)\n\n3.看到「Reading package lists... Done」(正在讀取套件清單... 完成) 訊息後，請在 SSH 終端機中執行下列指令，安裝 Apache2 網路伺服器：\n\n```\nsudo apt-get install apache2 php7.0\n```\n\n![image](https://hackmd.io/_uploads/r1nuAFYrC.png)\n\n系統詢問是否繼續安裝時，請輸入 Y。如果安裝指令失敗，請使用 sudo apt-get install apache2 php。\n\n4.命令提示字元傳回後，請前往「VM instances」(VM 執行個體) 頁面，然後將 VM 的外部 IP 位址複製到下列網址：\n\n```\nhttp://EXTERNAL_IP\n```\n\n![image](https://hackmd.io/_uploads/B1w5O-6HC.png)\n>這邊說的 外部IP 就是這個\n\n5.如要連線至 Apache 網路伺服器，請開啟新的瀏覽器分頁，然後輸入上一步中的網址。\n\n網路伺服器安裝成功後，瀏覽器分頁就會顯示 Apache2 Debian 預設頁面。\n\n![image](https://hackmd.io/_uploads/H1NTdZpS0.png)\n>http://34.69.206.231/\n\n如要瞭解如何透過作業套件代理程式收集 Apache 記錄檔和指標，請點選「Next」(下一步)。\n\n### 步驟4.  收集 Apache 網路伺服器記錄檔和指標\n![image](https://hackmd.io/_uploads/B14OYZaS0.png)\n\n1. 前往 VM 執行個體的 SSH 終端機。如果尚未開啟終端機，請執行下列步驟：\n\na. 前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：\n\n前往「VM instances」(VM 執行個體) 頁面\n![image](https://hackmd.io/_uploads/Byneqbar0.png)\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。\n\nb. 找到新的 VM，然後點選「SSH」。\n\n2. 複製下列指令，貼到執行個體的終端機，然後按下 Enter 鍵：\n```\n# Configures Ops Agent to collect telemetry from the app and restart Ops Agent.\n\nset -e\n\n# Create a back up of the existing file so existing configurations are not lost.\nsudo cp /etc/google-cloud-ops-agent/config.yaml /etc/google-cloud-ops-agent/config.yaml.bak\n\n# Configure the Ops Agent.\nsudo tee /etc/google-cloud-ops-agent/config.yaml > /dev/null << EOF\nmetrics:\n  receivers:\n    apache:\n      type: apache\n  service:\n    pipelines:\n      apache:\n        receivers:\n          - apache\nlogging:\n  receivers:\n    apache_access:\n      type: apache_access\n    apache_error:\n      type: apache_error\n  service:\n    pipelines:\n      apache:\n        receivers:\n          - apache_access\n          - apache_error\nEOF\n\nsudo service google-cloud-ops-agent restart\nsleep 60\n```\n\n![image](https://hackmd.io/_uploads/SysGi-aS0.png)\n\n\n先前的指令會建立設定，收集和擷取 Apache 網路伺服器中的記錄檔和指標。詳情請參閱「[針對 Apache 網路伺服器設定作業套件代理程式](https://cloud.google.com/monitoring/agent/ops-agent/third-party/apache?hl=zh-TW)」一節。\n\n3. 等候命令提示字元顯示，這至少需要 60 秒。\n\n如要瞭解如何查看 Apache 網路伺服器的 syslog 記錄檔，請點選「Next」(下一步)。\n\n### 步驟5. 查看 Apache 網路伺服器記錄檔\n\n![image](https://hackmd.io/_uploads/rk12AbTBA.png)\n\n1. 前往 Google Cloud 控制台的「Logs Explorer」(記錄檔探索工具) 頁面：\n\n前往「Logs Explorer」(記錄檔探索工具)\n\n![image](https://hackmd.io/_uploads/Syh_sZpSC.png)\n\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Logging」的結果。\n\n「Query results」(查詢結果) 窗格會顯示最近的記錄檔。\n\n2. 確認工具列中的「Show query」(顯示查詢) 已啟用。\n\n![image](https://hackmd.io/_uploads/SJkCs-6SC.png)\n\n3. 如要查看 Apache 網路伺服器記錄檔，請建立並執行查詢：\n\na. 從「Google Cloud project」(Google Cloud 專案) 選取器展開 Google Cloud 專案清單，然後將 Google Cloud 專案 ID 複製到剪貼簿。\n\n在下列運算式中，將複製的 ID 貼到 PROJECT_ID 欄位中，然後將運算式複製到查詢編輯器中：\n\n```\nresource.type=\"gce_instance\"\nlogName=(\"projects/PROJECT_ID/logs/apache_access\" OR \"projects/PROJECT_ID/logs/apache_error\")\n```\n\n![image](https://hackmd.io/_uploads/BkHNT-6B0.png)\n\n執行先前的查詢時，只會顯示 apache_access 和 apache_error 記錄項目。\n\nc.點選「Run query」(執行查詢)。\n![image](https://hackmd.io/_uploads/BJNS0WpSR.png)\n「Query results」(查詢結果) 窗格會顯示查詢結果。\n\n![image](https://hackmd.io/_uploads/r1YORWTHC.png)\n\n如要在記錄檔中出現特定模式時收到通知，請建立快訊政策。\n\n如要瞭解如何建立快訊政策要使用的通知管道，請點選「Next」(下一步)。\n\n### 步驟6. 建立電子郵件通知管道\n![image](https://hackmd.io/_uploads/Hyt0RbaBA.png)\n\n1. 前往 Google Cloud 控制台的「Alerting」(快訊) 頁面notifications：\n\n前往「Alerting」(快訊)\n\n![image](https://hackmd.io/_uploads/BJFMyMaB0.png)\n\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Monitoring」的結果。\n\n2. 點選工具列中的「Edit Notification Channels」(編輯通知管道)。\n\n\n3. 在「Notification channels」(通知管道) 頁面中，捲動至「Email」(電子郵件)，然後點選「Add new」(新增)。\n\n\n![image](https://hackmd.io/_uploads/BJ_L1zar0.png)\n\n4. 輸入您的電子郵件地址和顯示名稱 (例如 My email)，然後點選「Save」(儲存)。\n\n![image](https://hackmd.io/_uploads/rJsOeM6rC.png)\n\n\n如要瞭解如何在記錄檔中出現特定模式時收到通知，請點選「Next」(下一步)。\n\n### 步驟7. 建立記錄式快訊\n![image](https://hackmd.io/_uploads/BJscxzaBA.png)\n\n1. 前往 Google Cloud 控制台的「Logs Explorer」(記錄檔探索工具) 頁面：\n\n前往「Logs Explorer」(記錄檔探索工具)\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Logging」的結果。\n\n![image](https://hackmd.io/_uploads/Syn1ZMTrA.png)\n\n2. 在「Query results」(查詢結果) 工具列中，點選「Create alert」(建立快訊) add_alert。記錄檔快訊政策窗格會隨即開啟。\n\n![image](https://hackmd.io/_uploads/ByJ4-GpBR.png)\n\n\n3. 在「Alert details」(快訊詳細資料) 的「Alert Policy Name」(快訊政策名稱) 欄位中，輸入 404 Not Found。\n\n![image](https://hackmd.io/_uploads/rJTL-zTHC.png)\n\n4. 在「Choose logs to include in this alert」(選擇要包含在這則快訊中的記錄檔)中，執行下列操作：\n\na. 移除記錄檔篩選器文字方塊中的任何內容。\nb. 複製下列查詢並貼到記錄檔篩選器文字方塊中：\n```\nseverity>=DEFAULT /help httpRequest.status=404\n```\n先前的記錄檔篩選器會搜尋 severity 等級至少為 DEFAULT 的記錄項目，包含 /help 文字且 httpRequest 狀態為 404。\n\n![image](https://hackmd.io/_uploads/BJ20ffTSR.png)\n\n5. 在「Set notification frequency and autoclose duration」(設定通知頻率和自動關閉期限) 區段中，執行下列操作：\n\na. 將「Time between notifications」(通知傳送間隔時間) 欄位設為「5 min」(5 分鐘)。\n\nb. 將「Incident autoclose duration」(事件自動關閉期限) 欄位設為「30 min」(30 分鐘)。\n\n![image](https://hackmd.io/_uploads/BJecQMaH0.png)\n\n6. 在「Who should be notified?」(應該通知誰？) 中，從「Notification Channels」(通知管道) 選單中選取您的電子郵件，然後點選「Save」(儲存)。\n\n![image](https://hackmd.io/_uploads/HkfAmG6HA.png)\n\n![image](https://hackmd.io/_uploads/HkEk4fTHR.png)\n\n![image](https://hackmd.io/_uploads/rJHxNMprC.png)\n\n如要瞭解如何測試快訊政策，請按「Next」(下一步)。\n\n### 步驟8. 測試快訊政策\n\n![image](https://hackmd.io/_uploads/BJh_EMarR.png)\n\n1. 前往 VM 執行個體的 SSH 終端機。如果尚未開啟終端機，請執行下列步驟：\n\na. 前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：\n\n![image](https://hackmd.io/_uploads/Sk5REfaB0.png)\n\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。\n\nb. 找到新的 VM，然後點選「SSH」。\n\n2. 如要在伺服器上搜尋虛構頁面 `localhost/help`，請執行下列指令：\n\n```\ncurl localhost/help\n```\n\n終端機顯示「404 Not Found」訊息後，系統會傳送電子郵件通知。這項程序會在幾分鐘內完成。\n\n![image](https://hackmd.io/_uploads/r12QLz6H0.png)\n\n3. 如要查看新的記錄項目，請執行下列操作：\na. 前往 Google Cloud 控制台的「Logs Explorer」(記錄檔探索工具) 頁面：\n\n前往「Logs Explorer」(記錄檔探索工具)\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Logging」的結果。\n\n![image](https://hackmd.io/_uploads/BJBxPfpHR.png)\n\nb. 點選工具列中的「Jump to now」(跳到現在時間)。\n![image](https://hackmd.io/_uploads/BkSSDGTB0.png)\n\n如要查看後續步驟並避免系統向帳戶收費，請點選「Next」(下一步)。\n\n### 步驟9. 避免系統向帳戶收費\n![image](https://hackmd.io/_uploads/SylMnPGaHC.png)\n\n保留已建立的資源並運用 Monitoring 執行更多工作，或是清除所用資源來避免產生帳單費用。\n\n運用 Monitoring 執行更多工作\n\n#### 教學課程: 透過作業套件代理程式收集 Apache 指標\n瞭解如何透過作業套件代理程式，收集 Apache 網路伺服器指標。\n\n![image](https://hackmd.io/_uploads/Byhx_zTr0.png)\n\n\n#### 說明文件: 使用記錄檔探索工具查看記錄檔\n\n進一步瞭解 Cloud Monitoring。\n![image](https://hackmd.io/_uploads/ByJv_G6BC.png)\n\n>https://cloud.google.com/logging/docs/view/logs-explorer-interface\n\n#### 說明文件: 透過記錄檔探索工具建構查詢\n\n進一步瞭解 Cloud Monitoring。\n\n![image](https://hackmd.io/_uploads/HJOoOM6HA.png)\n>https://cloud.google.com/logging/docs/view/building-queries\n\n#### 清除所用資源\n此逐步操作說明需使用資源，如要避免系統向您的 Google Cloud 帳戶收取相關費用，請按照下列步驟操作。\n\n1. 如果您已建立 VM，請刪除該 VM：\n\na. 前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：\n\n前往「VM instances」(VM 執行個體) 頁面\n\n![image](https://hackmd.io/_uploads/HkXqtzTrR.png)\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。\n\nb. 針對您建立的 VM，點選 \n「Actions」(動作)，然後選取「Delete」(刪除)。\n![image](https://hackmd.io/_uploads/BklTYMprC.png)\n\n![image](https://hackmd.io/_uploads/HyKpYMTrC.png)\n\n2. 刪除您建立的快訊政策：\n\na. 前往 Google Cloud 控制台的「Alerting」(快訊) 頁面notifications：\n\n前往「Alerting」(快訊)\n\n如果您是使用搜尋列尋找這個頁面，請選取子標題為「Monitoring」的結果。\n\nb. 選取您建立的快訊政策，然後點選「Delete」(刪除)。\n![image](https://hackmd.io/_uploads/SyIm9zTB0.png)\n\n# 結尾\n以上就是設定Google Cloud Platform (GCP) 的 Moniter介面官方教學課程操作的步驟紀錄，官方的教學介紹課程內容蠻多的，希望能幫助到你，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。","tags":["GCP","Google","GCP Moniter"]},{"title":"Google 帳號預設語言改為中文","url":"/2024/06/14/Google-帳號預設語言改為中文/","content":"\n# Google 帳號預設語言改為中文\n\n在工作時候，常常會需要使用公司的Google 帳號，新的Google 帳號常常預設會是英文，這時候會需要更改預設語言可以參考以下官方頁面\n![image](https://hackmd.io/_uploads/SkacXDKBC.png)\n\n>https://support.google.com/accounts/answer/32047?hl=zh-Hant&co=GENIE.Platform%3DDesktop\n\n\n# 操作步驟\n\n## 進入 google 管理介面\n點擊 https://myaccount.google.com/\n\n畫面如下\n![image](https://hackmd.io/_uploads/HkszgwFHR.png)\n\n\n## 進入語言設定\n切換到Personal Info -> 點選 Language\n![image](https://hackmd.io/_uploads/B1bngwYBA.png)\n\n查詢中文-> 點選繁體中文\n![image](https://hackmd.io/_uploads/rkzybPKBA.png)\n\n選擇台灣\n![image](https://hackmd.io/_uploads/rkozbPFBR.png)\n\n這樣就成功設定了\n![image](https://hackmd.io/_uploads/r10UWvtSC.png)\n\n# 結尾\n以上就是設定 Google 帳號預設語言的步驟，希望能幫助到你，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。\n","tags":["Google","辦公小技巧"],"categories":["辦公小技巧"]},{"title":"Docker 學習筆記 Day3 - 建立自己的Docker 映像檔","url":"/2024/06/14/Docker-學習筆記-Day3-建立自己的Docker-映像檔/","content":"# Docker 學習筆記 Day3 - 建立自己的Docker 映像檔\n\n# Docker Hub 是什麼？\n\n![image](https://hackmd.io/_uploads/rJL5dXYHC.png)\n> https://hub.docker.com/\n\nDocker Hub 是一個線上託管服務，專門用來存儲和分發 Docker 映像檔。它提供了一個集中式平台，讓開發者能夠輕鬆分享、搜尋和下載各種應用程式的 Docker 映像檔。Docker Hub 提供了多種功能，例如公共和私有儲存庫、自動建置、Webhooks 及其他整合服務。以下是 Docker Hub 的一些主要功能：\n\n1. **公共和私有儲存庫**：你可以選擇將映像檔設為公共或私有。公共儲存庫可供所有人自由訪問，而私有儲存庫則只有你指定的用戶才能存取。\n\n2. **自動建置**：你可以將 Docker Hub 與 GitHub 或 Bitbucket 等原始碼儲存庫連接，當你的程式碼有變動時，Docker Hub 可以自動建置映像檔。\n\n3. **Webhooks**：當映像檔有更新時，Webhooks 可以通知你指定的應用程式或服務，方便進行自動化流程。\n\n4. **團隊和組織管理**：你可以創建和管理團隊，設定不同成員的訪問權限，適合協作開發和大型專案管理。\n\n像是昨天就有在 Docker Hub 上面查詢到範例的映像檔\n\n## 如何使用 Docker Hub\n\n### 1. 註冊 Docker Hub 帳號\n首先，你需要一個 Docker Hub 帳號，可以到 [Docker Hub 官方網站](https://hub.docker.com/) 註冊。\n\nDocker Hub 註冊頁面\n![image](https://hackmd.io/_uploads/ryd75QYSR.png)\n>https://hub.docker.com/signup\n\n### 2. 登入 Docker Hub\n使用以下命令在終端機中登入 Docker Hub：\n```bash\ndocker login\n```\n輸入你的 Docker Hub 使用者名稱和密碼。\n\n### 3. 上傳映像檔到 Docker Hub\n假設你已經有一個本地的 Docker 映像檔，你可以使用以下命令將映像檔推送到 Docker Hub：\n```bash\ndocker tag your-image-name your-dockerhub-username/your-repository-name:tag\ndocker push your-dockerhub-username/your-repository-name:tag\n```\n\n### 4. 從 Docker Hub 下載映像檔\n你可以使用以下命令從 Docker Hub 下載並運行映像檔：\n```bash\ndocker pull your-dockerhub-username/your-repository-name:tag\ndocker run -d your-dockerhub-username/your-repository-name:tag\n```\n\n\n### 實例：建立並上傳自己的 Docker 映像檔\n\n1. **建立 Dockerfile**\n在專案目錄中建立一個 `Dockerfile`，內容如下：\n```Dockerfile\n# 使用官方的 Node.js 映像檔作為基礎映像檔\nFROM node:14\n\n# 建立應用目錄\nWORKDIR /usr/src/app\n\n# 複製 package.json 和 package-lock.json\nCOPY package*.json ./\n\n# 安裝應用程式依賴\nRUN npm install\n\n# 複製所有檔案到工作目錄\nCOPY . .\n\n# 暴露應用埠\nEXPOSE 8080\n\n# 定義啟動指令\nCMD [\"node\", \"app.js\"]\n```\n\n2. **建置 Docker 映像檔**\n在終端機中執行以下命令來建置映像檔：\n```bash\ndocker build -t your-dockerhub-username/your-repository-name:tag .\n```\n\n3. **推送映像檔到 Docker Hub**\n```bash\ndocker push your-dockerhub-username/your-repository-name:tag\n```\n\n\n## 使用來自 Docker Hub 的映像檔\n\n使用以下指令抓取 web-ping 應用程式的容器映像檔\n```\ndocker image pull diamol/ch03-web-ping\n```\n\n\n像是`diamol/ch03-web-ping`這個映像檔就可以在 Docker Hub 上面看到\n![image](https://hackmd.io/_uploads/HyELj7FB0.png)\n>https://hub.docker.com/r/diamol/ch03-web-ping\n\n執行結果 如下\n![image](https://hackmd.io/_uploads/H1NzsXYS0.png)\n\n依照結果這邊來看，會發現這邊有很多個檔案\n```\nUsing default tag: latest\nlatest: Pulling from diamol/ch03-web-ping\ne7c96db7181b: Pull complete\nbbec46749066: Pull complete\n89e5cf82282d: Pull complete\n5de6895db72f: Pull complete\nf5cca017994f: Pull complete\n78b9b6c949f8: Pull complete\nDigest: sha256:2f2dce710a7f287afc2d7bbd0d68d024bab5ee37a1f658cef46c64b1a69affd2\nStatus: Downloaded newer image for diamol/ch03-web-ping:latest\ndocker.io/diamol/ch03-web-ping:latest\n```\n\n這個機制稱為 映像層(image layers)。 也就是每個image 映像黨都是由很多個映像層組合而成的。\n\n## 利用映像檔執行一個容器\n\n\n當你執行以下命令時：\n\n```bash\ndocker container run -d --name web-ping diamol/ch03-web-ping\n```\n\n這行命令的目的是啟動一個新的 Docker 容器，並且有以下幾個特點：\n\n1. **`docker container run`**：\n   - 這是 Docker 的一個命令，用於運行一個新的容器。\n\n2. **`-d`**：\n   - `-d` 代表 \"detached mode\"，這表示容器會在後台執行，不會鎖定終端機。\n\n3. **`--name web-ping`**：\n   - `--name` 參數用來給容器指定一個名稱。在這個例子中，容器的名稱被設為 `web-ping`。這樣在未來的操作中，你可以通過這個名稱來引用這個容器，而不是使用自動生成的容器 ID。\n\n4. **`diamol/ch03-web-ping`**：\n   - 這是要運行的映像檔的名稱。`diamol` 是映像檔的名稱空間或組織名稱，`ch03-web-ping` 是具體的映像檔名稱。這個映像檔可能已經在你的本地系統上，如果沒有，Docker 會從 Docker Hub 或其他配置的映像檔庫拉取這個映像檔。\n\n總結來說，這行命令會在後台啟動一個名為 `web-ping` 的容器，該容器基於 `diamol/ch03-web-ping` 映像檔。這使得你可以在不影響當前終端機工作的情況下執行並管理這個容器。\n\n\n![image](https://hackmd.io/_uploads/r1dXkNtB0.png)\n>執行結果\n\n這個容器開啟後會反覆不斷的ping 作者的部落格(blog.sixeyed.com)\n![image](https://hackmd.io/_uploads/S1yJe4KrA.png)\n>可以在 Docker desktop 上觀察\n\n另外也可以使用以下指令查看\n```\n docker container logs web-ping\n```\n\n## 刪除現有容器\n使用以下指令刪除剛剛練習的 `web-ping` 容器\n```\ndocker rm -f web-ping\n```\n\n## 設定環境變數: --env\n\n```bash\ndocker container run --env TARGET=google.com diamol/ch03-web-ping\n```\n\n這行命令的目的是啟動一個新的 Docker 容器，並且有以下幾個特點：\n\n1. **`docker container run`**：\n   - 這是 Docker 的一個命令，用於運行一個新的容器。\n\n2. **`--env TARGET=google.com`**：\n   - `--env` 參數用來設置環境變數。在這個例子中，`TARGET` 是環境變數的名稱，而 `google.com` 是這個變數的值。這個環境變數會傳遞給容器內運行的應用程式，應用程式可以根據這個環境變數來決定其行為。例如，這裡假設應用程式會針對 `google.com` 執行一些操作。\n\n3. **`diamol/ch03-web-ping`**：\n   - 這是要運行的映像檔的名稱。`diamol` 是映像檔的名稱空間或組織名稱，`ch03-web-ping` 是具體的映像檔名稱。這個映像檔可能已經在你的本地系統上，如果沒有，Docker 會從 Docker Hub 或其他配置的映像檔庫拉取這個映像檔。\n\n總結來說，這行命令會啟動一個基於 `diamol/ch03-web-ping` 映像檔的容器，並且將 `TARGET` 環境變數設置為 `google.com`。這使得容器內的應用程式可以利用這個環境變數來決定它要針對 `google.com` 執行的操作。\n\n![image](https://hackmd.io/_uploads/BJYQmNtS0.png)\n>執行結果\n\n程式會一直執行，按 `Ctrl` + `C` 可以結束應用程式。\n\n環境變數對於Docker而言來說是一個非常重要的機制，能夠視情況朴整不同的設定值，例如\n在專案開發中的開發環境(DEV)、測試環境(QAT)、正式環境(PRD)\n\n\n![image](https://hackmd.io/_uploads/r1ssNEFrA.png)\n>圖片來源:https://ryanisagoodguy.blogspot.com/2020/02/devteststageprod.html\n\n# Dockerfile\n\n到 `diamol/ch03/exercises/web-ping` 資料夾中\n```\ncd diamol/ch03/exercises/web-ping\ncode .\n```\n\n![image](https://hackmd.io/_uploads/BytkL4YHR.png)\n\n可以看到 `Dockerfile`範例內容如下\n```\nFROM diamol/node\n\nENV TARGET=\"blog.sixeyed.com\"\nENV METHOD=\"HEAD\"\nENV INTERVAL=\"3000\"\n\nWORKDIR /web-ping\nCOPY app.js .\n\nCMD [\"node\", \"/web-ping/app.js\"]\n```\n\n\n這個 Dockerfile 目的是建立一個自訂的 Docker 映像檔，該映像檔基於 `diamol/node` 映像檔，並設定一些環境變數、工作目錄、複製應用程式檔案以及設定容器啟動時的指令\n\n```Dockerfile\nFROM diamol/node\n```\n這行指令指定了基礎映像檔，`diamol/node`。這表示你的自訂映像檔將基於這個映像檔來構建，繼承其所有的內容和設置。\n\n```Dockerfile\nENV TARGET=\"blog.sixeyed.com\"\nENV METHOD=\"HEAD\"\nENV INTERVAL=\"3000\"\n```\n這些指令設置了三個環境變數：\n  - `TARGET`：指定要 Ping 的目標 URL，預設值為 `blog.sixeyed.com`。\n  - `METHOD`：指定 HTTP 請求的方法，預設值為 `HEAD`。\n  - `INTERVAL`：指定 Ping 的間隔時間，單位為毫秒，預設值為 `3000` (3秒)。\n  這些環境變數可以在容器內的應用程式中使用，允許你在不修改程式碼的情況下更改這些設置。\n\n```Dockerfile\nWORKDIR /web-ping\n```\n這行指令設置了容器內的工作目錄為 `/web-ping`。接下來的所有指令（如 `COPY` 和 `CMD`）都會相對於這個目錄進行操作。\n\n```Dockerfile\nCOPY app.js .\n```\n這行指令將本地檔案系統中的 `app.js` 檔案複製到容器內的當前工作目錄 (`/web-ping`) 中。這樣做是為了確保 `app.js` 在容器運行時可以被訪問和執行。\n\n```Dockerfile\nCMD [\"node\", \"/web-ping/app.js\"]\n```\n這行指令指定了當容器啟動時要執行的命令。這裡使用 `node` 命令來運行 `app.js` 檔案。`CMD` 指令會在容器啟動時執行一次，並保持容器運行。\n\n\n# 建立映像檔\n\n使用以下命令來建立一個 Docker 映像檔\n\n```\ndocker image build --tag web-ping .\n```\n\n`docker image build`：這是 Docker 的一個命令，用來建立 Docker 映像檔。\n\n`--tag web-ping`：這個參數用來為建立的映像檔指定一個標籤。在這個例子中，映像檔的標籤被設置為 `web-ping`。這個標籤可以用來識別這個映像檔，後續可以使用這個標籤來運行容器或者上傳到 Docker Hub 等映像檔庫中。\n\n`.`：這表示 Docker 命令應該在當前目錄下查找 Dockerfile。Dockerfile 是一個包含了建立映像檔所需指令的文本文件，通常放在項目的根目錄下。\n\n總結來說，這個命令的目的是在當前目錄下的 Dockerfile 中定義的指令基礎上建立一個名為 web-ping 的 Docker 映像檔。這個映像檔可以通過標籤 web-ping 來識別。\n\n![image](https://hackmd.io/_uploads/Hkzs_VYHC.png)\n>成功建立畫面\n\n# 列出映像檔\n\n使用以下指令來列出所有w字母開頭的映像檔\n\n```\ndocker image ls 'w*'\n```\n\n![image](https://hackmd.io/_uploads/HytGY4KHA.png)\n>執行結果\n\n# Docker 映像層是什麼?\n\n在 Docker 中，映像檔（Image）是一種輕量、可執行的環境打包方式，它可以包含應用程式運行所需的所有資源，如程式碼、執行環境、庫文件、設定檔等。一個 Docker 映像檔由多個層（Layer）組成，每一層都是對映像檔系統的一次修改。\n\n## 分層結構\n\n當你建立一個新的 Docker 映像檔時，每一個指令（如 `RUN`、`COPY`、`ADD`）都會產生一個新的層。這種分層結構有幾個重要的優勢：\n\n1. **節省空間**：如果兩個映像檔共用相同的層，這些層只會在硬碟上存儲一次，因此節省了空間。\n\n2. **容易分享**：每個層都是獨立的，因此可以更容易地共享和重複使用這些層。這也是 Docker 映像檔如此輕量級和易於傳播的原因之一。\n\n3. **快速構建**：當你修改了一個映像檔並重新構建時，Docker 可以快速地重新使用先前建立的層，只重新建立修改過的部分，從而加快了構建速度。\n\n## 實際應用\n\n例如，假設你有一個基於 Ubuntu 的映像檔，並且對其進行了一些自定義配置和安裝，這些操作會生成一個新的層。當你使用這個映像檔建立容器時，Docker 會將這些層堆疊在一起，最終形成一個完整的運行環境。\n\n## 查看看Docker映像檔的metadata\n可以使用以下指令來看 web-ping 的映像檔metadata:\n```\ndocker image history web-ping\n```\n\n可以看到每一個映像層都有輸出\n![image](https://hackmd.io/_uploads/ryPYsEYH0.png)\n\nCREATED BY 這一欄紀錄的是Dockerfile執行的命令\n\n\n# 映像層快取\n\n修改一下 app.js 檔案，例如加入空白後執行以下指令\n```\ndocker image build -t web-ping:v2 .\n```\n\n調整 Dockerfile 內容如下:\n```\nFROM diamol/node\n\nCMD [\"node\", \"/web-ping/app.js\"]    # CMD 往前放了\n\nENV TARGET=\"blog.sixeyed.com\" \\     # 3個 ENV 合併在一起\n    METHOD=\"HEAD\" \\\n    NTERVAL=\"3000\"\n\nWORKDIR /web-ping\nCOPY app.js .\n\n```\n\n```\ncd ..\ncd web-ping-optimized/\ndocker image build -t web-ping:v3 .\n```\n\n![image](https://hackmd.io/_uploads/Hy2cM8FHR.png)\n\n\n這一段其實有點看不太懂書中說到的優化在哪裡，我只看到有調整了寫法\n\n# 結尾\n以上就是第三天的練習內容，今天介紹了Docker Hub、Dockerfile、Docker Image還有Image Layer 相關的知識，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。\n\n\n","tags":["Docker"],"categories":["Docker 學習筆記"]},{"title":"Hexo部落格 - Butterfly 主題調整","url":"/2024/06/13/Hexo部落格-Butterfly-主題調整/","content":"# Hexo部落格 - Butterfly 主題調整\n\n本文介紹如何在 Hexo 部落格中使用 Butterfly 主題，以及如何進行一些常見的調整。包括檔案結構介紹、主題顏色調整、樣式修改、Tags位置調整等。\n\n## 目錄\n- [檔案結構介紹](#檔案結構介紹)\n- [主題顏色調整](#主題顏色調整)\n- [樣式 (css相關的項目)](#樣式-css相關的項目)\n- [Tags：移至文章上方](#tags移至文章上方)\n- [版權框內的字句](#版權框內的字句)\n- [為文章加密](#為文章加密)\n  - [使用方法](#使用方法)\n- [右下角按鈕：改為默認顯示，按才隱藏](#右下角按鈕改為默認顯示按才隱藏)\n- [右下角新增【到最底部】按鈕](#右下角新增到最底部按鈕)\n- [文章網址名稱、文章位置整理](#文章網址名稱文章位置整理)\n- [生成 sitemap - atom.xml](#生成-sitemap---atomxml)\n- [製作 404 page](#製作-404-page)\n\n## 檔案結構介紹\n\n### Hexo 相關檔案\n```\n.\n├── public            // 執行 hexo generate 後，輸出的靜態網頁\n├── scaffolds         // 模板。Hexo會根據scaffold來建立新文章/新頁面\n├── scripts           // 存放自定義 js 文件\n├── source        \n|   ├── _drafts       // 草稿文章\n|   ├── _posts        // 發佈文章\n|   ├── link          // 友情連結\n|   ├── categories    // 分類頁面\n|   └── tags          // 標籤頁面\n├── themes            // Hexo 主題文件，Butterfly 主題的檔案就在裡面\n├── _config.yml       // 整個 Blog 的配置\n└── package.json      // 已下載的插件及其版本 version no.\n```\n\n### Butterfly 主題的檔案\n```\n.\n└──themes\n   └── Butterfly\n       ├── languages    // 主題語言字眼\n       ├── layout       // pug 文件，後會渲染成 html\n       ├── scripts      // js 文件\n       ├── source        \n       |   ├── css      // styl 文件，後會渲染成 css\n       |   ├── img      // 主題配置用到的圖片\n       |   └── js       // js 文件\n       └── _config.yml  // Butterfly 主題配置\n```\n\n## 主題顏色調整\n\n如果想進階修改主題顏色的話，可以修改 `.\\themes\\Butterfly\\source\\css\\var.styl` 文件。\n\n## 樣式 (css相關的項目)\n\n如果想修改特定元素的樣式，例如字體大小、字體顏色、背景顏色、tag 外觀樣式、border style 、button、動畫效果等等，可以修改 layout 檔案 `.\\themes\\Butterfly\\source\\css\\_layout`。\n\n例如想修改黑夜模式的顏色組合，就到這裡修改： `.\\themes\\Butterfly\\source\\css\\_mode\\darkmode.styl`。\n\n## Tags：移至文章上方\n\n在 `.\\themes\\Butterfly\\layout\\post.pug` 這個文件中，搜尋下面這段，把它移到至 `block content` 的下一行插入。\n\n```pug\n.tag_share\n  if (theme.post_meta.tags)\n    .post-meta__tag-list\n      each item, index in page.tags.data\n        a(href=url_for(item.path)).post-meta__tags #[=item.name]\n```\n\n## 版權框內的字句\n\n在 `.\\themes\\Butterfly\\languages` 這裡面的 yml 檔裡進行修改。\n\n## 為文章加密\n\n在 GitBash 中輸入以下命令來安裝插件：\n\n```bash\nnpm install --save hexo-blog-encrypt\n```\n\n### 使用方法\n\n在需要加密的文章頭加上 `password` 和 `message` (可選):\n\n```markdown\ntitle: 測試 - 為文章加密\ndate: 2024-06-13 14:05:02\ntags:\n    - Hexo\n    - 架站\ncategories: [架站記錄, 技巧]\npassword: test123\nmessage: 試試加密，這篇的密碼是 test123\n---\n\n恭喜成功解密！\n\n這裡是文章內容。\n```\n\n## 右下角按鈕：改為默認顯示，按才隱藏\n\n右下角的黑夜模式、繁簡轉換、字體大小按鈕原本是默認隱藏的，需按設定按鈕才會顯示。想要改成默認顯示，按設定按鈕收起來，再按再彈出來。\n\n修改 `.\\themes\\Butterfly\\source\\css\\_layout\\rightside.styl` 文件：\n\n```styl\n#rightside\n  position: fixed\n  right: -38px\n  bottom: 40px\n  opacity: 0\n  transition: all .5s\n\n  #rightside-config-hide\n    transform: translate(0, 0)\n\n  .rightside-in\n    animation: rightsideIn .3s\n\n  .rightside-out\n    animation: rightsideOut .3s\n    transform: translate(30px, 0) !important\n\n  & > div\n    & > i,\n    & > a,\n    & > div\n      display: block\n      margin-bottom: 2px\n      width: 30px\n      height: 30px\n      background-color: $light-blue\n      color: $white\n      text-align: center\n      text-decoration: none\n      font-size: 16px\n      line-height: 29px\n      cursor: pointer\n\n      &:hover\n        background-color: $ruby\n\n  #rightside_config\n    i\n      animation: avatar_turn_around 2s linear infinite\n\n  #mobile-toc-button\n    display: none\n\n@media screen and (max-width: $bg)\n  #rightside\n    #mobile-toc-button\n      display: block\n\n@keyframes rightsideOut\n  0%\n    transform: translate(0, 0)\n\n  100%\n    transform: translate(30px, 0)\n\n@keyframes rightsideIn\n  0%\n    transform: translate(30px, 0)\n\n  100%\n    transform: translate(0, 0)\n```\n\n## 右下角新增【到最底部】按鈕\n\n除了文章 (post) 頁面，其他頁面都加上【到最底部】按鈕在最\n\n右下方。\n\n1. 在 `.\\themes\\Butterfly\\layout\\includes\\rightside.pug` 中，於最底添加這兩行：\n\n```pug\nif !is_post()\n  i.fa.fa-arrow-down#go-down(title=_p(\"rightside.back_to_bottom\") aria-hidden=\"true\")\n```\n\n2. 在 `.\\themes\\Butterfly\\source\\js\\main.js` 中，添加以下代碼：\n\n```js\n// go down smooth scroll\n$('#go-down').on('click', function () {\n  scrollTo('footer')\n})\n```\n\n## 文章網址名稱、文章位置整理\n\n所有發佈的文章自動生成在 `.\\source\\_posts` 這個資料夾。但排序雜亂無章，而且部署到 GitHub 後，所有文章都散佈在第一層，很亂。希望文章原檔案按照日期排序，但不影響文章網址名稱（在網址中不顯示日期），並且在 GitHub 自動生成一個名叫 post 的資料夾裝放所有文章原檔案。\n\n方法是在 `./config.yml` 裡，把這兩選項更改成以下：\n\n```yaml\npermalink: post/:title/  # 在 GitHub 自動生成一個名叫 post 的資料夾裝放所有文章原檔案\nnew_post_name: post/:year-:month-:day-:title/:title.md  # 在你的電腦儲存位置，會達成以上 tree structure 那樣\n```\n\n## 生成 sitemap - atom.xml\n\n在 bash 中輸入以下命令來安裝插件：\n\n```bash\nnpm install hexo-generator-feed --save\n```\n\n在 `./config.yml` 裡，添加以下配置：\n\n```yaml\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 10\n  hub:\n  content:\n  content_limit: 250\n  content_limit_delim: ' '\n  order_by: -date\n  icon: icon.png\n  autodiscovery: true\n  template:\n```\n\n## 製作 404 page\n\n把你想遇到 404 時轉跳的頁面命名為 `404.html`，放在 `.\\source` 資料夾裡。\n\n然後在 `./config.yml` 裡，設定以下內容：\n\n```yaml\nskip_render:\n  - 404.html\n  - README.md\n  - robots.txt\n```\n\n由於還創建了不需渲染的 `README.md` 和 `robots.txt`，所以把它們也設定在 skip_render 底下。\n\n## 結尾\n以上就是進階Butterfly相關設定，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。\n","tags":["Hexo","Butterfly"],"categories":["架站記錄"]},{"title":"測試 - 為文章加密","url":"/2024/06/13/測試-為文章加密/","content":"\n恭喜成功解密！\n\n這裡是文章內容。","tags":["Hexo","部落格","加密","架站"],"categories":["架站記錄"]},{"title":"Docker 學習筆記 Day2 - 操作流程與基礎指令","url":"/2024/06/11/Docker-學習筆記-Day2-操作流程與基礎指令/","content":"# Docker 學習筆記 Day2 - 操作流程與基礎指令\n\n# 執行範例\n\n## 複製練習專案檔案\n\n練習專案程式碼:https://github.com/sixeyed/diamol \n![image](https://hackmd.io/_uploads/BktHImSrA.png)\n\n使用以下指令進行複製檔案\n```\ngit clone https://github.com/sixeyed/diamol.git\n```\n\n## 執行 Hello World Docker 範例\n```\ndocker container run diamol/ch02-hello-diamol\n```\n\n這邊我遇到這個問題\n![image](https://hackmd.io/_uploads/B13mwQBBC.png)\n\n這邊代表要啟用WSL2，要在 Docker desktop 的 Setting -> Resources 把 \nEnable integration with additional distros: 這邊的 Ubuntu 選項打開，\n然後按 Apply & restart\n![image](https://hackmd.io/_uploads/r11KvXSBC.png)\n\n調整過後執行成功的畫面\n![image](https://hackmd.io/_uploads/H1swMVrHR.png)\n\n# 容器是什麼?\n容器（Container）是一種虛擬化技術，用於將應用程式及其依賴環境打包在一起，以確保應用程式可以在任何計算環境中一致地運行。容器利用操作系統的虛擬化功能，提供輕量級、便攜且獨立的運行環境。\n\n## 容器的優點\n\n1. **輕量化**：容器與傳統虛擬機相比，更加輕量，不需要啟動一個完整的操作系統，因此啟動速度快，占用資源少。\n2. **可移植性**：容器打包了應用程式及其所有依賴，確保應用程式在開發、測試和生產環境中運行一致。\n3. **隔離性**：容器之間相互隔離，確保一個容器內的問題不會影響其他容器，提升應用程式的安全性和穩定性。\n4. **高效性**：容器利用操作系統的共享資源功能，比虛擬機更加高效，適合高密度部署。\n\n# 透過 Docker 互動模式執行容器\n\n```\ndocker container run --interactive --tty diamol/base\n```\n\n- `docker container run`: 告訴 Docker 執行一個容器。\n- `--interactive` 或 `-i`: 表示在容器中啟動互動模式，使得可以與容器中的應用進行互動。\n- `--tty` 或 `-t`: 分配一個 pseudo-TTY（虛擬終端），這樣就可以在容器內進行命令行操作。\n- `diamol/base`: 是要運行的 Docker 映像的名稱。在這個例子中，指定了一個名為 `diamol/base` 的映像。\n\n![image](https://hackmd.io/_uploads/ryOskqrSC.png)\n> 執行後對連接到容器中的終端對話視窗\n\n# 在容器中託管 (host) 一個網站\n\n```\ndocker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web\n```\n\n- `--detach` 或 `-d`: 表示在背景運行容器，即使容器啟動後，終端仍然可用。\n- `--publish 8088:80` 或 `-p 8088:80`: 將容器的端口 80 映射到主機的端口 8088。這樣，當您訪問主機的 8088 端口時，流量將被轉發到容器的 80 端口。\n- `diamol/ch02-hello-diamol-web`: 是要運行的 Docker 映像的名稱。在這個例子中，指定了一個名為 `diamol/ch02-hello-diamol-web` 的映像。\n\n若不確定是否有這個映像檔可以到  https://hub.docker.com/ 查詢\n\n![image](https://hackmd.io/_uploads/r18d_9HBA.png)\n>這邊可以發現 diamol/ch02-hello-diamol-web 跟書本範例上的名稱不太一樣\n\n\n![image](https://hackmd.io/_uploads/rkaXF9HBA.png)\n成功執行結果\n\n![image](https://hackmd.io/_uploads/ryMst5rr0.png)\n\n點選畫面中的 8088:80 可以看到網頁結果\n\n![image](https://hackmd.io/_uploads/rkVkc5rrR.png)\n>http://localhost:8088/\n\n\n# Docker 基本指令\n\n**`docker run`**: 執行一個容器。\n**`docker build`**: 使用 Dockerfile 構建一個新的映像。\n**`docker pull`**: 從 Docker 鏡像倉庫下載一個映像。\n**`docker push`**: 將一個映像推送到 Docker 鏡像倉庫。\n**`docker start`**: 啟動一個停止的容器。\n**`docker stop`**: 停止正在運行的容器。\n**`docker restart`**: 重啟一個容器。\n**`docker rm`**: 刪除一個或多個容器。\n**`docker rmi`**: 刪除一個或多個映像。\n**`docker ps`**: 列出正在運行的容器。\n**`docker ps -a`**: 列出所有的容器，包括停止的容器。\n**`docker images`**: 列出本地的所有映像。\n**`docker exec`**: 在正在運行的容器中執行命令。\n**`docker logs`**: 查看容器的日誌。\n**`docker inspect`**: 查看容器或映像的詳細信息。\n**`docker-compose`**: 使用 Docker Compose 管理多容器應用程序。\n\n這些是 Docker 中的一些基本指令，用於管理容器、映像和其他相關資源。\n\n## 結尾\n\n以上就是第二天的練習內容，今天實際執行了Hello World的範例跟host一個網站、另外還有一些Docker 基本指令，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。\n","tags":["Docker"],"categories":["Docker 學習筆記"]},{"title":"區塊鏈學習 - Day 1 區塊鏈錢包介紹與 Metamask小狐狸安裝方式","url":"/2024/06/07/區塊鏈學習-Day-1-區塊鏈錢包介紹與-Metamask小狐狸安裝方式/","content":"# 區塊鏈學習 - Day 1 區塊鏈錢包介紹與 Metamask小狐狸安裝方式\n\n![image](https://hackmd.io/_uploads/SkSeMeeSR.png)\n>https://ethereum.org/zh-tw/\n\n今天想要來學習Web3 區塊鏈相關技術，另外在查詢的時候看到了etherum 這麼完整的教學文件，所以想來整理記錄一下這個學習的過程。\n\n# 什麼是區塊鏈錢包?\n\n區塊鏈錢包（Blockchain Wallet）是一種數位錢包，用於存儲、管理和交易加密貨幣，如比特幣、以太幣等。區塊鏈錢包的核心功能是讓用戶能夠安全地儲存和使用其加密貨幣。\n\n## 區塊鏈錢包的基本特點\n\n### 1. 公鑰與私鑰\n區塊鏈錢包使用公鑰（Public Key）和私鑰（Private Key）來管理資產：\n- **公鑰**：相當於你的銀行賬號，用來接收加密貨幣，可以公開分享。\n- **私鑰**：相當於你的密碼，用來簽署交易和訪問你的資產，必須保密。\n\n### 2. 熱錢包與冷錢包\n區塊鏈錢包分為熱錢包和冷錢包：\n- **熱錢包（Hot Wallet）**：連接互聯網，方便隨時交易，但相對較不安全，易受黑客攻擊。\n- **冷錢包（Cold Wallet）**：不連接互聯網，通常以硬體錢包形式存在，如Trezor或Ledger，更安全但較不便捷。\n\n### 3. 去中心化\n區塊鏈錢包通常是去中心化的，不依賴於單一機構。這意味著用戶擁有對自己資產的完全控制權，無需經由第三方機構進行交易。\n\n### 4. 多幣種支持\n許多現代區塊鏈錢包支持多種加密貨幣，方便用戶管理不同的數位資產。\n\n### 5. 智慧型合約型錢包\n需要多重簽名來授權交易的錢包，若是多人使用的錢包可以用來加強錢包的安全性。\n\n## 使用區塊鏈錢包的好處\n\n### 1. 安全性\n區塊鏈技術本身具有高度的安全性，加上錢包的加密保護，使得資產不易被盜。\n\n### 2. 自主性\n用戶完全掌控自己的資產和交易，不需要依賴銀行或支付平台。\n\n### 3. 全球性\n加密貨幣交易不受地理位置限制，可以在全球範圍內快速進行。\n\n## 區塊鏈錢包的使用案例\n\n### 1. 投資與交易\n投資者使用區塊鏈錢包進行加密貨幣買賣，或長期持有以期望價值增長。\n\n### 2. 支付與轉賬\n使用加密貨幣進行線上購物或轉賬，特別是在國際支付中，可以避開高額手續費和匯率波動。\n\n### 3. DApps互動\n區塊鏈錢包可以用來與去中心化應用（DApps）互動，如去中心化交易所（DEX）、借貸平台等。\n\n# 如何選擇合適的區塊鏈錢包?\n\n其實現在的區塊鏈錢包越來越多了，如果想要選擇合適的區塊鏈錢包可以參考ethereum 官方的區塊鏈錢包選擇參考頁面。\n\n![image](https://hackmd.io/_uploads/ByOJDJgBC.png)\n>https://ethereum.org/zh-tw/wallets/find-wallet/\n\n## 依照使用角色來選擇\n\n![image](https://hackmd.io/_uploads/H1Rd5ylrC.png)\n\n1.加密貨幣新手:初次使用者尋找適合新手的錢包。\n2.非同質化代幣:專注於支援非同質化代幣的錢包。\n3.長期:使用硬體錢包被動持有代幣。\n4.金融:專為頻繁使用去中心化金融應用程式的使用者打造的錢包。\n5.開發者:幫助開發並測試去中心化應用程式的錢包。\n\n## 依照裝置支援性來選擇\n![image](https://hackmd.io/_uploads/SJhPo1gS0.png)\n\n1.行動裝置\n2.桌上型電腦\n3.瀏覽器\n4.硬體\n\n## 依照語言支援來選擇\n![image](https://hackmd.io/_uploads/S1Zl2ylS0.png)\n\n## 依照是否可以兌換加密貨幣/法定貨幣來選擇\n![image](https://hackmd.io/_uploads/BJ4NTkxHA.png)\n\n1.購買加密貨幣:在錢包中直接使用法定貨幣購買加密貨幣 \n2.出售換取法定貨幣:直接在錢包中出售加密貨幣換取法定貨幣 \n\n## 依照功能來選擇\n![image](https://hackmd.io/_uploads/rJ-cpkxSA.png)\n\n1.連結至去中心化應用程式:你可以連接至支援 WalletConnet 或替代協議的應用程式\n2.支援非同質化代幣:支援檢視非同質化代幣並與之互動的錢包\n3.質押:從錢包中直接質押以太幣\n4.二層網路:支援以太坊二層網路的錢包\n5.交換:在錢包中直接交換 ERC-20 代幣\n6.支援硬體錢包:可連結至硬體錢包以增強安全性的錢包\n7.支援以太坊名稱服務:支援以太坊名稱服務 (ENS) 的錢包\n\n這邊開始出現很多新的名詞了像是質押、二層網路看到這些詞一開始看不懂先不用緊張，先從基礎的學習起來，後面會慢慢了解\n\n## 依照安全性來選擇\n![image](https://hackmd.io/_uploads/H1hWlggH0.png)\n\n1.開放原始碼:讓任何人都可以稽核應用程式的完整性和安全性的開源軟體\n2.個人擁有權:不控制使用者私密金鑰的錢包\n\n## 依照是否是智能合約錢包來選擇\n![image](https://hackmd.io/_uploads/SJILgglSA.png)\n1.多簽:需要多重簽名來授權交易的錢包\n2.社交恢復:允許監護人變更智慧型合約錢包簽署金鑰的錢包\n\n## 進階更多條件來選擇\n![image](https://hackmd.io/_uploads/SJmmZgerR.png)\n\n1.遠端程序呼叫協定匯入:支援自訂遠端程序呼叫協定端點，以連結至不同節點或網路的錢包\n2.代幣匯入:匯入任何 ERC-20 代幣以便於錢包內使用\n3.燃料費自訂:自訂你的燃料用量（基本費用、優先費與最高費用）\n\n\n# MetaMask \n![image](https://hackmd.io/_uploads/SkpIQeeSR.png)\n\n這邊建議使用一開始學習的錢包MetaMask也叫做小狐狸錢包，是目前最多人使用的區塊鏈錢包，j最適合新手入門使用。\n\n點選造訪網頁，會到MetaMask 官網\n![image](https://hackmd.io/_uploads/BJ80VxxHC.png)\n>https://metamask.io/\n\n點選![image](https://hackmd.io/_uploads/rJMgBlxHR.png) 進入Chrome插件畫面\n\n再來點選加到Chrome 開始安裝\n![image](https://hackmd.io/_uploads/BkkHregB0.png)\n\n點選新增擴充功能\n![image](https://hackmd.io/_uploads/H12vSxeSA.png)\n\n如果還沒有用過 Metamask 可以直接點選 Create a new Wallet ，若是有用過則可以點選Import an existing wallet 來匯入MetaMask錢包\n![image](https://hackmd.io/_uploads/Hy9crgxr0.png)\n\n接下來會顯示 MetaMask 詢問訊息，確認沒有問題可以點選I agree\n![image](https://hackmd.io/_uploads/SJLwLeeS0.png)\n\n\n>**幫助我們改進 MetaMask**\n>\n>MetaMask 希望收集使用數據，以更好地了解用戶如何使用 MetaMask。這些數據將用於改>進服務，包括基於您的使用情況進行改進。\n>\n>MetaMask 將會...\n>\n>- 永遠允許您通過設置選擇退出\n>- 發送匿名化的點擊和頁面瀏覽事件\n>- **絕不**收集我們不需要提供服務的信息（如密鑰、地址、交易哈希或餘額）\n>- **絕不**收集您的完整 IP 地址\n>- **絕不**出售數據\n>\n>這些數據是匯總的，因此根據《一般數據保護條例（EU）2016/679》對於數據是匿名的。\n>\n>*當您使用 Infura 作為 MetaMask 中的默認 RPC 提供商時，Infura 將會在您發送交易時收集您的 IP 地址和以太坊錢包地址。我們不會以使我們的系統能夠將這兩個數據關聯的方式存儲這些信息。更多關於 MetaMask 和 Infura 如何從數據收集的角度進行互動的信息，請參閱我們的更新。更多關於我們隱私實踐的一般信息，請參閱我們的[隱私政策](https://metamask.io/privacy.html)。*\n>\n>---\n\n>這個窗口有兩個按鈕：\n>- \"I agree\"（我同意）：表示您同意 MetaMask 收集和使用這些數據。\n>- \"No thanks\"（不，謝謝）：表示您不願意參與數據收集。\n\n再來會顯示設定密碼畫面，輸入密碼後點選Create a new wallet\n![image](https://hackmd.io/_uploads/HJ7Fr4lHC.png)\n\n接下來會介紹「助記詞」，並且詢問是否要備份註記詞\n![image](https://hackmd.io/_uploads/SyOxUEgB0.png)\n\n在來會顯示「助記詞」，要記得這個助記詞很重要，因為這些助記詞就代表你的MetaMask錢包，要妥善記錄下來保存在安全的地方。\n![image](https://hackmd.io/_uploads/HJQYUVeSC.png)\n\n再來正確輸入存起來的助記詞後點選下一步就完成創建錢包了\n![image](https://hackmd.io/_uploads/HJKQO4lH0.png)\n\n成功登入畫面\n![image](https://hackmd.io/_uploads/HyS5dEgr0.png)\n\n>以下是該介面的主要內容和功能說明：\n> **帳戶信息**：\n>   - 帳戶名稱：`Account 1`\n>   - 錢包地址：`0x8753...1b2D4`（已部分隱藏）\n>\n> **以太幣餘額**：\n>   - 餘額：`0 ETH`\n>   - 美元價值：`$0.00 USD`\n>\n> **操作選項**：\n>   - **Buy & Sell**（購買和出售）：購買和出售加密貨幣。\n>   - **Swap**（交換）：在錢包中交換 ERC-20 代幣。\n>   - **Bridge**（跨鏈橋）：將資產從一條鏈轉移到另一條鏈。\n>   - **Portfolio**（投資組合）：查看和管理你的加密資產組合。\n>\n> **資金提示**：\n>   - **Fund your wallet**：提示用戶為錢包添加資金，並提供購買以太幣（ETH）的選項。\n>   - 按鈕：`Buy ETH`（購買 ETH）\n>\n> **代幣選項**：\n>   - **ETH**（以太幣）：\n>     - **Stake**（質押）：選項來質押以太幣。\n>   - **Receive tokens**（接收代幣）：提供地址來接收其他人發送的代幣。\n>   - **Import Tokens**（導入代幣）：添加和顯示其他代幣。\n>   - **Refresh list**（刷新列表）：刷新代幣列表以顯示最新的餘額和代幣。\n>\n> **支持和幫助**：\n>   - **MetaMask 支援**：連接到 MetaMask 支援服務，以獲得幫助和解答問題。\n>\n> **切換網域功能**：右上角顯示網域預設是以太坊（Ethereum），點進去可以看到不同的區塊鏈 \n> \n> ![image](https://hackmd.io/_uploads/r1yRtEgS0.png)\n\n# 結語\n這篇文章介紹了區塊鏈錢包的基本功能和分類，並詳細說明了如何安裝和使用最受歡迎的 MetaMask 小狐狸錢包。隨著區塊鏈技術的發展，錢包的種類和功能也越來越多，官方文件也變得越來越詳細和友好。\n\n希望這篇文章能夠幫助大家對區塊鏈錢包有一個初步的了解和掌握。如果有任何問題或需要進一步的幫助，歡迎在留言區提出。未來，我們將繼續探索更多區塊鏈技術的應用和實踐，讓我們一起在這條學習之路上不斷進步吧！\n\n","tags":["區塊鏈","ETH","Metamask","ethereum"]},{"title":"Docker 學習筆記 Day1 - Docker 介紹與安裝步驟","url":"/2024/06/07/Docker-學習筆記-Day1-Docker-介紹與安裝步驟/","content":"# Docker 學習筆記 Day1 - Docker 介紹與安裝步驟\n\nDocker官網\n![image](https://hackmd.io/_uploads/Sk6e3xJrR.png)\n>https://www.docker.com/\n\ndocker官方教學文件\n![image](https://hackmd.io/_uploads/SJwtCgkSA.png)\nhttps://docs.docker.com/\n\n\n## 引言\n\n我是在看這本書 跟著 Docker 隊長，修練 22 天就精通([這邊是購書連結](https://www.books.com.tw/products/0010903691))\n\n來學習Docker 的，另外還有以下資源可以參考\n\n1.書本中提供的練習專案程式碼:https://github.com/sixeyed/diamol \n2.書籍作者提供的Youtube 系列影片: https://www.youtube.com/playlist?list=PLXl_isu8qxvmDOAnUkG5x16LzBzGzY_Ww\n我覺得書的內容很紮實，但是有時候沒有紀錄很快就會忘記了，所以我就練習寫下操作紀錄跟重點，更多詳細的細節可以直接去查看這本書的內容。\n\n\n## 什麼是 Docker？\n\nDocker 是一個開源的應用程式打包和部署工具，它允許您在容器中打包應用程式及其所有相依性，並確保其將在任何環境中都能運行。這使得應用程式的部署變得更加容易且可靠。\n\n簡單來說有了Docker很多專案部屬的步驟就能夠簡化，且在windows、Linux等系統都能夠快速運行。所以現在很多的github 專案都有dockerfile 且部署流程都會很簡單\n\n## Docker 的優點\n\n- **輕量級**：容器共享主機的核心，並運行於一個單獨的進程中，因此比虛擬機更輕量級。\n- **快速啟動**：容器可以快速啟動，因為它們不需要像虛擬機一樣啟動整個作業系統。\n- **跨平台**：Docker 容器可以在任何支援 Docker 的平台上運行，而不用擔心環境的不同。\n\n# Docker 的使用情境\n\n**應用程式開發與測試**：開發人員可以使用 Docker 將應用程式及其相依性打包成容器，在開發環境中運行，確保開發環境與生產環境一致性。同時，測試人員也可以使用相同的容器運行測試，確保程式碼的正常運作。\n\n**微服務架構**：Docker 可以幫助組織實現微服務架構，將應用程式拆分為多個獨立的服務，每個服務運行在自己的容器中。這樣可以提高應用程式的彈性和可擴展性。\n\n**持續集成和持續部署**：Docker 可以與持續集成和持續部署（CI/CD）工具集成，幫助自動化構建、測試和部署流程，加快軟體交付速度。\n\n**多雲端部署**：Docker 可以在不同的雲端平台上運行，並提供一致的運行環境，從而實現跨雲端的應用程式部署和移植。\n\n**快速擴展**：使用 Docker 可以快速擴展應用程式，只需在需要時啟動新的容器即可，無需等待長時間的部署和配置。\n\n## 在 Windows 上安裝 Docker\n\n因為我目前使用的是Windows，所以我這邊示範Windows安裝的流程，另外我嘗試安裝的經驗來看建議最少都要有 Win11 使用docker起來才不會有問題，因為docker 要求要使用到WSL2。 一般來說電腦太老舊不能升級到win11 的跑docker都會容易出錯。\n\n### 安裝Docker Desktop。\n\n![image](https://hackmd.io/_uploads/HydWxZySC.png)\n>https://www.docker.com/products/docker-desktop/\n\n點選Docker Desktop for Windows 開始安裝\n![image](https://hackmd.io/_uploads/BJbEg-JBR.png)\n\n安裝完成後，啟動 Docker Desktop Installer\n![image](https://hackmd.io/_uploads/r1QLWWkrC.png)\n\n點選OK\n![image](https://hackmd.io/_uploads/H1SRZZ1rC.png)\n\n開始安裝\n![image](https://hackmd.io/_uploads/BJTZGbJrR.png)\n\n安裝成功\n![image](https://hackmd.io/_uploads/Hyo97-1HC.png)\n\n接下來會重新開機，開機完成後會看到以下畫面\n![image](https://hackmd.io/_uploads/Bkq8_AkHA.png)\n\n>這是 Docker 的訂閱服務協議。當你選擇接受時，你同意了以下幾個條款：\n>\n>1. **Subscription Service Agreement** (訂閱服務協議): 這是你與 Docker 之間的主要協議，規範了你如何使用 Docker 的訂閱服務。\n>2. **Docker Data Processing Agreement** (數據處理協議): 這個協議涉及 Docker 如何處理和保護你的數據。\n>3. **Data Privacy Policy** (數據隱私政策): 這個政策描述了 Docker 如何收集、使用、分享和保護你的個人數據。\n>\n>另外，這段文字還提到了一些關於 Docker Desktop 使用條件的資訊：\n>\n>- Docker Desktop 對於小型企業（少於 250 名員工且年收入少於 1000 萬美元）、個人使用、教育和非商業的開源項目是免費的。\n>- 對於專業用途，需要付費訂閱。\n>- 政府機構也需要付費訂閱。\n>\n>你可以閱讀 FAQ 以了解更多詳細資訊。\n\n確認沒有問題後按 \"Accept\" 同意訂閱服務協議\n\n接下來是 Docker Desktop 的歡迎畫面，提示你登錄以連接你的 Docker Desktop 訂閱或訪問在線功能。\n![image](https://hackmd.io/_uploads/HJvitAkSC.png)\n\n這裡有三個選項：\n\n1. **Sign up** (註冊): 如果你還沒有帳戶，可以點擊這裡註冊一個新的 Docker 帳戶。\n2. **Sign in** (登入): 如果你已經有帳戶，可以點擊這裡登入。\n3. **Continue without signing in** (繼續無需登入): 如果你不想登入，可以選擇這個選項繼續使用 Docker Desktop。\n\n這個畫面主要是讓你選擇是否要使用 Docker 的訂閱服務和在線功能。\n\n接下來填完相關問卷後會進入Docker desktop 的畫面\n![image](https://hackmd.io/_uploads/rycR5AJHA.png)\n\n這樣就成功安裝並啟動了 Docker Desktop\n\n## 結尾\n\n以上就是第一天學習Docker的內容，今天介紹了Docker還有使用情境跟安裝步驟，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。\n","tags":["Docker","Docker Desktop"],"categories":["Docker 學習筆記"]},{"title":"隱私權條款","url":"/2024/06/06/隱私權條款/","content":"\n# 隱私權條款\n\n歡迎使用「拿樂橙部落格」(以下簡稱本站)。本站尊重並保護所有使用者的隱私權。請在使用本站前仔細閱讀本隱私權條款。\n\n### 收集的個人資訊\n\n1. **訪問資訊**：當您訪問本站時，我們可能會收集您的IP位址、瀏覽器類型、訪問時間和所瀏覽的頁面等資訊，用於統計分析和網站優化。\n\n2. **其他資訊**：在您使用本站的過程中，您還可能會提供其他個人資訊，例如留言、填寫問卷調查等。\n\n### 資訊的使用和分享\n\n1. **個人資訊使用**：我們僅會在提供服務或維護本站運營所必需的範圍內使用您的個人資訊。\n\n2. **資訊分享**：除非經您同意或符合法律規定，否則我們不會向第三方分享您的個人資訊。\n\n### 資訊安全\n\n1. **安全措施**：我們會採取合理的安全措施來保護您的個人資訊，防止未經授權的訪問、使用或泄露。\n\n2. **資料備份**：我們會定期備份資料，以保護您的資訊安全。\n\n### 隱私權政策的修改\n\n1. **政策修改**：我們保留隨時修改本隱私權政策的權利。修改後的政策將在本站上公佈，並生效。請定期查閱本隱私權政策以獲取最新信息。\n\n\n","tags":["部落格","隱私權條款"]},{"title":"免責聲明與使用條款","url":"/2024/06/06/免責聲明與使用條款/","content":"\n# 免責聲明與使用條款\n\n歡迎使用本站。以下條款和條件將規範您對本站的使用，請仔細閱讀：\n\n**合作關係**：根據FTC規定，本站中推薦的商家或產品可能存在合作關係，當使用者透過本站連結到第三方商家並進行消費時，本站可能獲得相應的傭金作為營運維持費用。這不會影響您購買商品的價格，本站也不會多收您任何費用。\n\n**交易責任**：本站不承擔任何讀者與商家之間的交易責任。任何取消、更改訂單或其他交易問題應直接與商家客服聯絡。本站不參與及協助任何消費者與商家之間的糾紛。\n\n**隱私權**：本站尊重並保護讀者的隱私權。您提供給本站的任何個人資訊將僅供本站與您聯繫，不會轉發給其他方或商家。\n\n**免責聲明**：本站的內容僅供參考，不構成專業建議。使用本站所提供的信息時，您必須自行承擔相應的風險。所有來信諮詢的信件我們不會將資料轉發給其他方或商家，信箱及個人資訊僅供本站與讀者聯繫。\n\n**變更條款**：本站保留隨時更改條款的權利，我們建議您定期查看以獲取最新信息。\n","tags":["免責聲明","部落格"]},{"title":"關於我","url":"/2024/06/06/關於我/","content":"\n# 關於我\n\nHello，我是拿樂橙。\n這裡記錄了我在日常生活中的學習記錄，還有程式工作學習上遇到的問題。希望藉由我的分享，能幫助來到這裡的你。而若有任何合作邀約，歡迎在留言區提出。","tags":["部落格","關於我"]},{"title":"DISC 性格模式溝通四部曲","url":"/2024/06/05/DISC-性格模式溝通四部曲/","content":"# DISC 性格模式溝通四部曲\n\n「先識人、再溝通」才能讓溝通產生效果！接下來會介紹近百年歷史的企業人力管理系統「美國DISC性格模式」作為識人工具，後續可以在最短的時間內，摸清對方的性格、特質、想法、行為、需求，再搭配「四套溝通劇本」，在溝通上能對症下藥、順暢無比！\n\n## DISC 性格模式是什麼?\n\nDISC 是一個性格分析工具，用於了解和分類人的行為特徵和性格特質。它由心理學家威廉·馬斯頓（William Marston）於1928年提出，並廣泛應用於企業管理、人際溝通和個人成長等領域。\n\nDISC將人分類成4種不同的性格，包括：掌控型（Dominance）、影響型（Influence）、穩定型（Steadiness）和分析型（Compliance）。\n\n\n1. **D 型（Dominance，支配型）**：\n   - **特徵**：果斷、直接、目標導向、競爭性強\n   - **動機**：結果和成功\n   - **溝通風格**：喜歡簡潔明瞭的溝通，注重效率和成果\n\n2. **I 型（Influence，影響型）**：\n   - **特徵**：外向、樂觀、熱情、善於溝通\n   - **動機**：社交互動和認可\n   - **溝通風格**：喜歡互動和故事，注重情感和氣氛\n\n3. **S 型（Steadiness，穩定型）**：\n   - **特徵**：耐心、可靠、支持性強、重視穩定\n   - **動機**：和諧和合作\n   - **溝通風格**：注重關係和同理心，喜歡和善的交流\n\n4. **C 型（Conscientiousness，謹慎型）**：\n   - **特徵**：分析性強、謹慎、系統化、精確\n   - **動機**：正確性和品質\n   - **溝通風格**：喜歡條理清晰、細節豐富的溝通，注重事實和數據\n\n\n##  DISC 性格測試\n\n您可以通過一系列簡單的問題測試來了解自己的 DISC 性格類型，例如：\n\n| 問題 | A | B | C | D |\n| --- | --- | --- | --- | --- |\n| 你覺得你的特色比較像？ | 大膽果決，接受挑戰 | 幽默風趣，人緣不錯 | 溫和內向，樂於傾聽 | 彬彬有禮，謹慎仔細 |\n| 平常與他人的相處，你比較傾向？ | 工作為主，很少談到個人生活 | 重視氣氛並帶動團體活力 | 常傾聽並對他人態度和善友好 | 較不會主動與人建立關係 |\n| 你希望別人如何與你溝通？ | 直接講重點，不要拐彎抹角 | 輕鬆愉快，不要太嚴肅或一板一眼 | 不要一次說太多，明確指示細節 | 條例式說明，並解釋其原因 |\n| 哪一個是別人最常說你的小缺點？ | 容易沒有耐性 | 容易缺乏細心 | 容易沒有主見 | 容易缺乏幽默 |\n\n透過這些問題，您可以快速了解自己的性格特質，進而選擇適合的溝通和行為策略。\n\n### 分析結果\n\n- **A 選項多 → 支配型 D**\n- **B 選項多 → 影響型 I**\n- **C 選項多 → 穩定型 S**\n- **D 選項多 → 謹慎型 C**\n\n\n## 如何應用 DISC 模型？\n\n在職場和人際交往中，理解和應用 DISC 模型可以幫助我們更好地與不同性格的人相處。以下是一些應用場景：\n\n- **招聘和團隊建設**：根據性格特徵安排合適的崗位和團隊角色，提高工作效率和團隊協作。\n- **個人發展**：了解自己的性格優勢和改進點，制定針對性的成長計劃。\n- **溝通和說服**：根據對方的性格特徵選擇合適的溝通方式，提高溝通效果和說服力。\n\n\n## 溝通對象的關注點\n\n- **D 型人**：最在意的是結果，想獲得的是好處。適合用選擇題溝通法。\n- **I 型人**：最在意的是感覺，想獲得的是肯定與讚美。適合用說故事溝通法。\n- **S 型人**：最在意的是關係，想獲得的是情感。適合用同理心溝通法。\n- **C 型人**：最在意的是合理，想獲得的是策略。適合用表格式溝通法。\n\n\n以下是整理的比較表格\n\n| 型格 | 最在意 | 想獲得 | 溝通方式 |\n| --- | --- | --- | --- |\n| D 型人 | 結果 | 好處 | 選擇題溝通法 |\n| I 型人 | 感覺 | 肯定與讚美 | 說故事溝通法 |\n| S 型人 | 關係 | 情感 | 同理心溝通法 |\n| C 型人 | 合理 | 策略 | 表格式溝通法 |\n\n## 四套溝通劇本\n\n根據對方的性格特質和需求，選擇適合的溝通劇本，可以讓你的溝通更加有效：\n\n1. **選擇題溝通法（D 型人）**\n    - 提供多個選擇，讓對方決定，以滿足他們對結果和好處的需求。\n\n2. **說故事溝通法（I 型人）**\n    - 通過生動有趣的故事引起對方的興趣，並在故事中傳達你的觀點。\n\n3. **同理心溝通法（S 型人）**\n    - 表達對對方情感和關係的重視，讓對方感受到你的關心和理解。\n\n4. **表格式溝通法（C 型人）**\n    - 以條例式的方式，清晰明確地解釋事情的原因和策略，滿足他們對合理性的需求。\n\n\n## 結尾\n\n以上是DISC 性格介紹的內容，得知這個分類後開始思考人的性格來調整溝通方式，但這邊我也認為這類的分析需要避免濫用，像是亂貼標籤或是合理化自身缺點與盲點，或是急於評論他人特質與行為等等的缺點還是要盡量避免，這個方式也可以讓我比較了解自己的性格，還有應對不同個性的人該如何選擇合適的溝通方式。\n\n","tags":["DISC","心理測驗","溝通模式"]},{"title":"如何讓筆電蓋上螢幕後不自動關機或休眠","url":"/2024/06/05/如何讓筆電蓋上螢幕後不自動關機或休眠/","content":"# 如何讓筆電蓋上螢幕後不自動關機或休眠\n\n在工作時，通常會使用到筆電與外接電源。有時候會想要只使用外接螢幕來進行開發工作，但這時候經常會遇到一個問題：筆電蓋上後，外接螢幕的畫面也會跟著休眠。如果希望蓋上筆電後外接螢幕依然可以使用，可以依照以下步驟進行設定。\n\n## 為什麼筆電蓋上螢幕會進入睡眠？\n\n筆電蓋上螢幕後會進入睡眠模式是為了節省電力並保護電腦硬體。以下是一些具體原因：\n\n1. **節省電力**：睡眠模式可以顯著減少電力消耗，這對於延長電池壽命非常重要。當筆電在電池供電時，進入睡眠模式可以最大限度地保留電量。\n\n2. **保護硬體**：筆電在運行時，硬碟和處理器等硬體部件會發熱。如果長時間在蓋上螢幕的狀態下持續運行，可能會導致散熱不良，從而縮短硬體壽命。\n\n3. **安全性**：當筆電進入睡眠模式時，通常會自動鎖屏，這可以防止未經授權的訪問，保護用戶的數據和隱私。\n\n4. **防止意外操作**：當螢幕蓋上時，鍵盤和觸控板仍然可能被無意識地觸發。睡眠模式可以防止這些無意識的操作干擾正在進行的工作。\n\n5. **使用習慣**：大多數筆電預設在蓋上螢幕時進入睡眠模式，以符合大多數用戶的使用習慣和期望。如果用戶希望蓋上螢幕後筆電繼續運行，可以在電源選項中進行相應的設置。\n\n## 設定步驟\n\n### 1. 進入電源選項設定\n首先，在系統搜尋「蓋上」，找到「變更蓋上螢幕時的行為」後打開進入。\n\n![image](https://hackmd.io/_uploads/ryMmE8hER.png)\n\n### 2. 設定蓋上螢幕時的行為\n在「當我關閉筆記電腦螢幕時」的選項中，我們可以看到「一般電源」和「電池使用中」兩個設定。\n\n- **一般電源**：指的是當筆電連接電源時的行為。這裡選擇「不進行動作」。\n\n![image](https://hackmd.io/_uploads/ryta4LhVR.png)\n\n- **電池使用中**：指的是當筆電使用電池時的行為。如果希望拔掉電源時也讓筆電蓋上螢幕不自動關機，這裡也選擇「不進行動作」。\n\n## 測試設定\n設定完成後，可以測試看看蓋上筆電螢幕是否會進入休眠或關機。只需將筆電蓋上，並觀察外接螢幕是否依然顯示畫面。如果一切正常，外接螢幕應該會保持運行。\n\n## 結論\n通過上述簡單的設定，我們可以在蓋上筆電螢幕後依然使用外接螢幕進行工作，這樣既方便又能提高工作效率。希望這篇文章能幫助你解決筆電蓋上螢幕後自動關機或休眠的問題。如果有任何問題或需要進一步的幫助，歡迎在留言區提出。\n\n","tags":["Win11","電腦操作","筆電","Windows"]},{"title":"Node.js 學習筆記 - NVM 版本控制器介紹及其安裝步驟","url":"/2024/06/05/Node-js-學習筆記-NVM-版本控制器介紹及其安裝步驟/","content":"# Node.js 學習筆記 - NVM 版本控制器介紹及其安裝步驟\n\n![image](https://hackmd.io/_uploads/r1jyf86EC.png)\n\n\n## 什麼是 NVM？\nNVM (Node Version Manager) 是一個管理 Node.js 版本的工具。它允許開發者在多個 Node.js 版本之間輕鬆切換，這對於需要同時維護多個專案或測試新版本功能的開發者來說非常方便。\n\n以下是NVM 的官方Github連結\n\n![image](https://hackmd.io/_uploads/SJVyWU640.png)\n>https://github.com/nvm-sh/nvm\n\n\n## NVM 的優點\n1. **輕鬆管理多個 Node.js 版本**：可以隨時切換、安裝或移除不同的 Node.js 版本。\n2. **環境隔離**：不同專案可以使用不同的 Node.js 版本，避免版本衝突。\n3. **簡單易用**：安裝和使用都非常直觀，幾條命令即可完成操作。\n\n## NVM 的安裝步驟\n\n### 1. 安裝 NVM\n要安裝 NVM，請執行以下步驟：\n\n1. 打開終端機 (Terminal)。\n\n![image](https://hackmd.io/_uploads/HyeuY0SaVR.png)\n\n3. 使用 curl 或 wget 下載並安裝 NVM：\n\n    ```sh\n    # 使用 curl\n    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash\n    \n    # 或使用 wget\n    wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash\n    ```\n    \n![image](https://hackmd.io/_uploads/H1woRHTNA.png)\n\n\n3. 安裝完成後，重新啟動終端機或運行以下命令來使 NVM 生效：\n\n    ```sh\n    source ~/.nvm/nvm.sh\n    ```\n\n因為我不想重新開機所以用這個指令\n![image](https://hackmd.io/_uploads/SkECCBp4R.png)\n\n### 2. 驗證安裝\n要確認 NVM 是否安裝成功，可以運行以下命令：\n\n```sh\nnvm --version\n```\n\n如果安裝成功，會顯示 NVM 的版本號。\n\n![image](https://hackmd.io/_uploads/ryAgy86NR.png)\n>這邊成功顯示版本編號為0.39.2\n\n### 3. 安裝 Node.js 版本\n安裝 NVM 後，可以使用 NVM 來安裝和管理不同的 Node.js 版本。\n\n1. 安裝最新的 LTS 版本：\n\n    ```sh\n    nvm install --lts\n    ```\n\n![image](https://hackmd.io/_uploads/BJnrJ8aER.png)\n>目前安裝最新版本為20.14.0\n\n2. 安裝特定版本，例如 14.17.0：\n\n    ```sh\n    nvm install 14.17.0\n    ```\n    \n![image](https://hackmd.io/_uploads/SkEK1Up4R.png)\n>成功安裝畫面\n\n3. 切換到特定版本：\n\n    ```sh\n    nvm use 14.17.0\n    ```\n\n![image](https://hackmd.io/_uploads/B1-ikU6VR.png)\n>成功切換版本畫面\n\n4. 查看已安裝的所有 Node.js 版本：\n\n    ```sh\n    nvm ls\n    ```\n    \n![image](https://hackmd.io/_uploads/HJfpyLa4C.png)\n>成功列出所有版本的畫面\n\n### 4. 設定默認版本\n如果希望某個版本作為默認版本，可以使用以下命令：\n\n```sh\nnvm alias default 14.17.0\n```\n\n![image](https://hackmd.io/_uploads/BJBXeLaEA.png)\n>設定預設版本成功畫面\n\n### 結論\nNVM 是一個非常實用的工具，尤其適合需要同時管理多個 Node.js 版本的開發者。通過簡單的幾條命令，我們可以輕鬆地安裝、移除或切換不同的 Node.js 版本，從而提高開發效率。\n\n建議一開始安裝node.js 就這樣安裝比較簡單，更詳細的操作指令建議去官方的github網址查看(https://github.com/nvm-sh/nvm)。\n\n希望這篇文章能幫助你了解 NVM 並順利安裝和使用它。如果你有任何問題或需要進一步的幫助，歡迎在留言區提出。\n\n","tags":["Node.js","NVM"]},{"title":"區塊鏈 - 區塊鏈節點商","url":"/2024/05/29/區塊鏈-區塊鏈節點商/","content":"# 區塊鏈 - 區塊鏈節點商\n\n由於在開發使用智能合約時，後端程式會需要透過節點連結到智能合約作互動，所以我們會來介紹節點商跟比較，然後簡單介紹如何註冊申請API Key 來使用節點。\n\n# 什麼是區塊鏈節點商\n\n區塊鏈節點商（Blockchain Node Provider）是專門提供區塊鏈節點服務的公司或平台，使開發者和企業能夠輕鬆地連接和使用區塊鏈網絡，而無需自行運行和維護節點。這些節點商提供的服務包括節點托管、API訪問、數據查詢、交易發送和智能合約部署等。\n\n## 區塊鏈節點商的功能\n\n1. **節點托管**：\n   節點商為客戶運行和管理區塊鏈節點，這樣開發者和企業無需自行處理節點的運行和維護，減少了技術負擔和成本。\n\n2. **API 訪問**：\n   節點商提供簡單易用的API，使開發者能夠通過HTTP請求與區塊鏈網絡互動。這些API支持各種區塊鏈操作，如查詢賬戶餘額、發送交易、部署和調用智能合約等。\n\n3. **高可用性**：\n   節點商通常會提供高可用性的服務，確保客戶的應用能夠穩定地連接到區塊鏈網絡。這些服務通常有全球分佈的伺服器和冗餘設計，以提高可靠性。\n\n4. **安全性**：\n   節點商會實施多層次的安全措施來保護客戶的數據和API請求，包括加密通信、API密鑰管理和訪問控制等。\n\n5. **實時數據和監控**：\n   許多節點商提供實時數據訪問和監控工具，使客戶能夠即時了解區塊鏈網絡的狀態和活動。\n   \n也就是不需要再自己架設節點，維護節點了。\n\n## 為什麼選擇區塊鏈節點商\n\n1. **節省成本**：\n   自行運行和維護區塊鏈節點需要高昂的硬體成本和技術資源。使用節點商的服務，可以顯著降低這些成本。\n\n2. **減少技術負擔**：\n   節點商處理節點的運行、維護和升級，讓開發者專注於應用的開發和創新。\n\n3. **提高可靠性**：\n   節點商提供高可用性和冗餘設計，確保區塊鏈網絡連接的穩定性和可靠性。\n\n4. **加快開發進程**：\n   節點商提供簡單易用的API和豐富的開發工具，使開發者能夠更快速地構建和部署區塊鏈應用。\n   \n## 有哪幾種節點?\n區塊鏈節點商（Blockchain Node Provider) 通常包含以下幾種節點：\n\n1. **完整節點（Full Node）**：這些節點儲存區塊鏈的完整歷史紀錄，並參與區塊鏈網路的共識過程。完整節點可以驗證交易和區塊，確保區塊鏈的完整性和安全性。\n\n2. **輕量節點（Light Node）**：這些節點只儲存區塊鏈的一部分數據，通常是最新的區塊和一些必要的數據，用來簡化運行和減少儲存需求。輕量節點不參與完整的共識過程，但可以快速同步和驗證交易。\n\n3. **挖礦節點（Mining Node）**：這些節點專門用於進行挖礦活動，通過計算來驗證交易並創建新區塊。挖礦節點通常需要高效能的硬體設備和大量的電力資源。\n\n4. **驗證節點（Validator Node）**：在某些共識機制（如權益證明（PoS））中，驗證節點負責檢查和驗證交易，並確保區塊的有效性。驗證節點通常需要持有一定數量的代幣以參與共識過程。\n\n這些節點服務可以用來幫助開發者、企業和個人快速且可靠地接入區塊鏈網路，無需自己管理和維護節點，從而節省資源和精力。\n\n## 常見的區塊鏈節點商\n\n1. **Infura**：\n   提供高可用性的API端點，支持以太坊、IPFS和多個測試網。Infura 的服務器分佈在全球，能夠處理大量的API請求，適合需要穩定連接的應用。\n\n![image](https://hackmd.io/_uploads/S1Gesq-EA.png)\n>https://www.infura.io/zh\n\n2. **Alchemy**：\n   Alchemy 提供優化的API性能和豐富的開發工具，支持以太坊、Polygon、Arbitrum等多個區塊鏈網絡。Alchemy 專注於高效和低延遲的服務，適合大型dApp和企業應用。\n   \n![image](https://hackmd.io/_uploads/B1VVoqbER.png)\n>https://www.alchemy.com/\n\n3. **QuickNode**：\n   QuickNode 提供高速且可擴展的API服務，支持以太坊、Polygon、Binance Smart Chain等多個區塊鏈網絡。QuickNode 的服務強調低延遲和高吞吐量。\n\n![image](https://hackmd.io/_uploads/Hk9-o9ZN0.png)\n>https://www.quicknode.com\n\n4. **Chainstack**：\n   Chainstack 提供企業級的區塊鏈基礎設施服務，支持以太坊、Polygon、BSC、Hyperledger Fabric等多個區塊鏈網絡。Chainstack 強調簡單的部署和管理工具，適合企業應用。\n   \n![image](https://hackmd.io/_uploads/SyJ8jc-VA.png)\n>https://chainstack.com/\n\n以下是包含支援的節點類型的表格：\n\n| 特點               | **Infura**                                               | **Alchemy**                                         | **QuickNode**                                        | **Chainstack**                                      |\n|--------------------|----------------------------------------------------------|-----------------------------------------------------|------------------------------------------------------|-----------------------------------------------------|\n| **支持的網絡**     | 以太坊、IPFS、多個測試網                                 | 以太坊、Polygon、Arbitrum、多個測試網               | 以太坊、Polygon、BSC、多個測試網                    | 以太坊、Polygon、BSC、Hyperledger Fabric、多個測試網|\n| **API 性能**       | 高可用性和可靠性                                         | 優化的API性能，高速和低延遲                         | 高速API服務，低延遲                                  | 高效數據處理，企業級性能                            |\n| **開發者工具**     | 支持Web3.js、ethers.js、Python、PHP                       | 全面支持多種語言和框架，豐富的開發工具              | 支持多種語言和框架，實時數據和監控                   | 簡單的部署和管理工具，支持多種協議                  |\n| **安全性**         | 多層次安全措施，API密鑰管理                               | 高級安全功能和數據保護                              | 高安全性，實時監控和告警                             | 高安全性，企業級保護                                |\n| **通知功能**       | 即時交易和事件通知                                       | 即時交易和事件通知，高級分析工具                    | 實時數據通知，API性能分析                            | 實時通知和監控                                      |\n| **免費和付費方案** | 免費層級及多種付費方案                                   | 免費層級及多種付費方案                              | 免費層級及多種付費方案                               | 免費層級及多種付費方案                              |\n| **支持企業級應用** | 是                                                       | 是                                                   | 是                                                    | 是                                                   |\n| **支援的節點類型** | 完整節點、輕量節點、驗證節點                             | 完整節點、輕量節點、驗證節點、挖礦節點              | 完整節點、輕量節點、驗證節點、挖礦節點               | 完整節點、輕量節點、驗證節點、挖礦節點              |\n# 實際操作使用\n\n## 註冊 Alchemy 帳戶 \n\n### 步驟一: 進入 Alchemy 官網，點選 Get your API key\n![image](https://hackmd.io/_uploads/r1navs-ER.png)\n>https://www.alchemy.com/\n\n### 步驟二:填入名字、電子郵件、密碼(也可以選擇連結 Google 或是 SSO)，後，按 Sign Up\n![image](https://hackmd.io/_uploads/ByUGdjWEA.png)\n>https://auth.alchemy.com/signup\n\n若是選擇 連結google帳號，會需要授權\n![image](https://hackmd.io/_uploads/B16nusWEA.png)\n\n### 步驟三: 填寫相關表單\n\n這邊可以選擇團隊或是個人\n\n![image](https://hackmd.io/_uploads/ByR9Fs-NR.png)\n\n![image](https://hackmd.io/_uploads/H17LFsbVA.png)\n\n這邊可以選擇要建立的產品方向\n![image](https://hackmd.io/_uploads/r1nRtsZNR.png)\n\n在來是選擇網域，最多可以選擇4個\n![image](https://hackmd.io/_uploads/rJdXqoW4R.png)\n\n再來是設定收費方案，這邊我選擇免費的方案\n![image](https://hackmd.io/_uploads/Skbqqj-V0.png)\n\n這邊填入付費方式\n![image](https://hackmd.io/_uploads/H1ZejiWE0.png)\n\n是如何知道Alchemy的? (選填)\n![image](https://hackmd.io/_uploads/ByYY3iWEA.png)\n\n看到這個畫面就代表完成註冊了\n![image](https://hackmd.io/_uploads/H1yTajZ4A.png)\n\n\n### 建立 取得 API Key\n\n### 步驟一: 點選後台的Apps畫面，按右上方的 +Create new app \n![image](https://hackmd.io/_uploads/S1S50jZV0.png)\n\n### 步驟二: 輸入名稱跟描述後按 Create app 開始建立\n![image](https://hackmd.io/_uploads/ryoCRsb40.png)\n\n### 步驟三: 建立成功後點選右上方的 API Key\n![image](https://hackmd.io/_uploads/rky4k2ZVC.png)\n\n可以取得API Key、HTTPS連線網址、WebSocket連線網址跟程式範例 \n\n![image](https://hackmd.io/_uploads/ByMGgnWV0.png)\n\n\n## 註冊infura帳戶\n\n### 步驟1 :進入infura 官網，點選 Singn UP 進行註冊\n![image](https://hackmd.io/_uploads/r1zqGFbE0.png)\n>https://www.infura.io/zh\n\n### 步驟二：填入名字、電子郵件、密碼後，按 CREATE A FREE ACCOUNT 按鈕。\n![image](https://hackmd.io/_uploads/HJDaGFZVA.png)\n>https://app.infura.io/register\n\n這邊的密碼要包含大小寫跟特殊符號\n\n### 步驟三: 驗證Email，infura 會寄送一封驗證信到你的email\n\n![image](https://hackmd.io/_uploads/SkvuQYbVR.png)\n\n會收到像這樣一封信件\n![image](https://hackmd.io/_uploads/B1ZYue7E0.png)\n\n\n### 步驟四: 完成驗證後填寫資料\n\n填寫一些資料像是 角色是什麼、是個人還是團隊使用\n![image](https://hackmd.io/_uploads/rJfztl7NA.png)\n\n再來是填寫創造什麼樣的產品\n![image](https://hackmd.io/_uploads/S1eIKlQ4R.png)\n\n選擇網域\n![image](https://hackmd.io/_uploads/ryTdteX4R.png)\n\n選擇收費方案，這邊選擇免費方案\n![image](https://hackmd.io/_uploads/HJ1otemEA.png)\n\n都填寫完成後會進入後台畫面\n![image](https://hackmd.io/_uploads/rJk-cl7EA.png)\n\n### 步驟五: 取得 API Key\n\n這邊點擊 My First Key 就可以看到 API Key \n![image](https://hackmd.io/_uploads/B1S4ngXE0.png)\n\n\n## 註冊 QuickNode 帳戶\n\n### 步驟一: 進入 QuickNode 官網，點選 Get started\n![image](https://hackmd.io/_uploads/B1hstQ7VC.png)\n>https://www.quicknode.com/\n\n### 步驟二: 填入姓名、email、密碼 或是選擇連結Google 帳號按Create a free account\n![image](https://hackmd.io/_uploads/rys25XQNA.png)\n\n![image](https://hackmd.io/_uploads/SkQ0qXmNR.png)\n\n### 步驟三: 驗證Email 信箱\n![image](https://hackmd.io/_uploads/HJRwvz4NA.png)\n\n會收到這樣一封驗證信件，點擊 Verify Your Account 進行驗證\n![image](https://hackmd.io/_uploads/B1mqPz4V0.png)\n\n### 步驟四: 填寫相關資料\n\n想要開發什麼樣的產品? \n![image](https://hackmd.io/_uploads/rJmkuMEER.png)\n\n填寫完成後就可以進入後團管理畫面\n![image](https://hackmd.io/_uploads/BJT-dGV4C.png)\n\n### 步驟五: 取得 API KEY\n點選 Get started\n![image](https://hackmd.io/_uploads/SkV5KfV4R.png)\n\n選擇要使用的網域後按 Continue\n![image](https://hackmd.io/_uploads/rJBnKM4EA.png)\n\n這邊可以選擇 Sepolia 測試鏈\n![image](https://hackmd.io/_uploads/BJ4gcG4EC.png)\n\n選擇方案\n![image](https://hackmd.io/_uploads/rJerqzN4R.png)\n\n這邊我選擇免費的方案\n![image](https://hackmd.io/_uploads/ryxQjfEVA.png)\n\n選擇是個人使用還是商用\n![image](https://hackmd.io/_uploads/HJd4izNVC.png)\n\n商用需要填入公司資訊\n![image](https://hackmd.io/_uploads/ByynozE4C.png)\n\n個人使用需要填入個人姓名地址\n![image](https://hackmd.io/_uploads/H1p12GVER.png)\n\n填入信用卡資料\n![image](https://hackmd.io/_uploads/H1l7pfEE0.png)\n\n完成後按Create endpoint\n![image](https://hackmd.io/_uploads/BkCO6fEVC.png)\n\n完成後就能取得 Api Key\n![image](https://hackmd.io/_uploads/BJbkAfEE0.png)\n\n\n## 註冊 Chainstack 帳戶 \n\n### 步驟一: 進入 Chainstack 官網，點選 Start now for free\n![image](https://hackmd.io/_uploads/B1Qj1XVE0.png)\n>https://chainstack.com/\n\n### 步驟二:填入名字、電子郵件、密碼(也可以選擇連結 Google 或是 github 等等)，後，按 Sign Up\n![image](https://hackmd.io/_uploads/HJmzxQNNC.png)\n\n### 步驟三: 填寫相關資料\n填入開發的產品是什麼\n![image](https://hackmd.io/_uploads/SJ1IxXV4R.png)\n\n填入團隊規模\n![image](https://hackmd.io/_uploads/By9Kx7EEA.png)\n\n填入開發角色\n![image](https://hackmd.io/_uploads/SkWjg7V40.png)\n\n### 步驟四: 取得API Key\n\n點選專案\n![image](https://hackmd.io/_uploads/H1p1WQVEC.png)\n\n點選 Explore all node options\n![image](https://hackmd.io/_uploads/SkYLZXEEA.png)\n\n選擇 Ethereum\n![image](https://hackmd.io/_uploads/Skn9b7E4C.png)\n\n再點選Ethereum Sepolia Testnet 後按Next 創建\n![image](https://hackmd.io/_uploads/BksaWQE4C.png)\n\n可以填入節點名稱，這邊我先使用預設的名稱然後按Next\n![image](https://hackmd.io/_uploads/S1--fQVEA.png)\n\n再來確認後沒問題按 Join network\n![image](https://hackmd.io/_uploads/SyvIfQNV0.png)\n\n成功創建的節點\n![image](https://hackmd.io/_uploads/rJk9fXE40.png)\n\n點選進去可以看到詳細資訊\n![image](https://hackmd.io/_uploads/Bkg2QXE4C.png)\n\n往下滑到 Access and credentials 可以看到 API KEY\n![image](https://hackmd.io/_uploads/Sk5yN7NVA.png)\n\n### 步驟五: 連結到MetaMask小狐狸\n\n點擊 Add to MetaMask 可以連結到小狐狸，小狐狸會挑出來\n![image](https://hackmd.io/_uploads/Sk5yN7NVA.png)\n\n按下一頁\n![image](https://hackmd.io/_uploads/SyGzNXVE0.png)\n\n點選連線\n![image](https://hackmd.io/_uploads/r1im4mEN0.png)\n\n點選批准\n![image](https://hackmd.io/_uploads/B1MUVmNNC.png)\n\n點選切換網路\n![image](https://hackmd.io/_uploads/rkNDNmEVC.png)\n\n# 結尾\n\n以上就是目前較熱門區塊鏈結點商的介紹與比較還有完整的註冊與取得API Key 方式，目前看使用教學都是infura 比較多所以感覺Infura 是最熱門的，有興趣大家也可以自己嘗試註冊使用看看，開發區塊鏈應用時可以使用得到。\n\n\n# 參考資料\n\n- [Infura](https://infura.io/)\n- [Alchemy](https://www.alchemy.com/)\n- [QuickNode](https://www.quicknode.com/)\n- [Chainstack](https://chainstack.com/)","tags":["Web3","Block Chain","區塊鏈節點商","Infura","Alchemy","QuickNode","Chainstack"]},{"title":"區塊鏈 - ERC20 介紹","url":"/2024/05/21/區塊鏈-ERC20-介紹/","content":"# 區塊鏈 - ERC20 介紹\n\n# ERC 20 是什麼?\nERC20 是以太坊區塊鏈上代幣標準的一種協議，為智能合約提供了統一的介面，使得各種代幣能夠在不同的去中心化應用（DApps）中互操作。這個標準包含了一組必要的方法，使得代幣的創建和交易變得一致且容易。\n\n\"ERC\" 的全名是 \"Ethereum Request for Comment\"，中文翻譯是 \"以太坊徵集修正意見書\"。ERC 是以太坊社群用來提出和討論改進提案的標準。這些提案通常涉及智能合約標準、應用程序介面（API）或協議的改進。\n\n其中，ERC20 是最著名的一個標準，定義了在以太坊區塊鏈上實現可互操作的代幣所需的基本介面。這個標準使得各種代幣能夠在不同的去中心化應用中方便地進行交易和互操作。\n\n此外，還有其他一些常見的 ERC 標準，例如：\n\nERC721：非同質化代幣（NFT）的標準，適用於獨特的資產如收藏品、遊戲內物品等。\nERC1155：多代幣標準，允許單一合約中管理多種代幣，包括同質化代幣和非同質化代幣。\n\n## ERC20 標準的關鍵方法\n\n1. **totalSupply**:  在不需要支付 ETH 礦工費的情況下查詢代幣的總供應量。\n   ```solidity\n   function totalSupply() external view returns (uint256);\n   ```\n\n2. **balanceOf**: 查詢指定地址擁有的代幣數量。\n   ```solidity\n   function balanceOf(address account) external view returns (uint256);\n   ```\n\n3. **transfer**: 從調用者的賬戶轉移指定數量的代幣到目標地址。\n   ```solidity\n   function transfer(address recipient, uint256 amount) external returns (bool);\n   ```\n\n4. **allowance**: 查詢代幣所有者允許花費者花費的剩餘代幣數量。\n   ```solidity\n   function allowance(address owner, address spender) external view returns (uint256);\n   ```\n\n5. **approve**: 允許指定的花費者從調用者的賬戶中提取代幣。\n   ```solidity\n   function approve(address spender, uint256 amount) external returns (bool);\n   ```\n\n6. **transferFrom**: 從一個賬戶轉移指定數量的代幣到另一個賬戶，這個操作由有花費權限的賬戶調用。\n   ```solidity\n   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n   ```\n## ERC20 標準的事件\n\n\n1. **Transfer**: 在代幣轉移時觸發。\n   ```solidity\n   event Transfer(address indexed from, address indexed to, uint256 value);\n   ```\n\n2. **Approval**: 在代幣所有者批准花費者可以花費的代幣數量變更時觸發。\n   ```solidity\n   event Approval(address indexed owner, address indexed spender, uint256 value);\n   ```\n\n\n# 實作練習\n\n## 開發 ERC20_Metadata.sol\n\n這個練習是可以讓我們部屬自己的ERC20 代幣，可以自己取代幣名字、跟代幣簡稱\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20Metadata {\n    function name() external view returns (string memory); // 代幣名稱\n    function symbol() external view returns (string memory); // 代幣符號\n    function decimals() external view returns (uint8); // 代幣小數點位置\n}\n\ncontract ERC20 is IERC20Metadata {\n    string _name;\n    string _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    // 查詢代幣名稱\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    // 查詢代幣符號\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    // 代幣小數點位置\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n}\n```\n![image](https://hackmd.io/_uploads/Sy141FFQ0.png)\n\n### 部屬\n\n![image](https://hackmd.io/_uploads/r1yOkFtmC.png)\n\n在部屬的時候填入name、symbol可以進行部屬\n\n![image](https://hackmd.io/_uploads/rkU3ytYmA.png)\n\n成功部屬結果\n\n## 鑄造(Mint)和燒毀(Burn)新代幣\n\n![image](https://hackmd.io/_uploads/SyhpcaKXA.png)\n\n\n\n這個實作例子我們可以鑄造新代幣跟燒毀新代幣，並且有以下功能\n\n* 只有部屬合約的人才可以鑄造/燃燒代幣\n* 轉帳的合約不能是address(0)\n* 鑄造/燃燒代幣時，總發行量也會增加/減少。\n* 指定某帳戶增加/銷毀代幣\n\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function mint(address account, uint256 value) external;\n    function burn(address account, uint256 value) external;\n}\n\ncontract ERC20 is IERC20 {\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    address private _owner;\n\n    constructor() {\n        _totalSupply = 10000;  // 總發行量: 10000 個token\n        _balances[msg.sender] = 10000;  // 將以太幣持有者的賬戶新增10000 顆token\n        _owner = msg.sender;\n    }\n\n    modifier checkOwner() {\n        require(_owner == msg.sender, unicode\"不是合約擁有者\");\n        _;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        require(_balances[msg.sender] >= value, unicode\"餘額不足\");\n        _balances[msg.sender] -= value;\n        _balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\n        require(_balances[from] >= value, unicode\"餘額不足\");\n        require(_allowances[from][msg.sender] >= value, unicode\"許可權不足\");\n        _balances[from] -= value;\n        _balances[to] += value;\n        _allowances[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function mint(address account, uint256 value) external override checkOwner {\n        require(account != address(0), unicode\"address不能是0x0\");  // 檢查帳戶不能是0x0\n        _totalSupply += value;  // 增加總發行量\n        _balances[account] += value;  // 增加目標賬戶餘額\n        emit Transfer(address(0), account, value);  // 無中生有(address(0)=>account): (address(0), 指定帳戶, 多少代幣)\n    }\n\n    function burn(address account, uint256 value) external override checkOwner {\n        uint256 accountBalance = _balances[account];  // 確認賬戶餘額\n        require(account != address(0), unicode\"address不能是0x0\");  // 檢查帳戶不能是0x0\n        require(accountBalance >= value, unicode\"餘額不足\");  // 檢查餘額夠不夠燒毀\n        _balances[account] = accountBalance - value;  // 指定賬戶銷毀代幣\n        _totalSupply = _totalSupply - value;  // 總發行量也會跟著減少\n        emit Transfer(account, address(0), value);  // 回歸虛無(account=>address(0)): (指定賬戶, address(0), 多少代幣)\n    }\n}\n```\n![image](https://hackmd.io/_uploads/rJxuSpt70.png)\n\n![image](https://hackmd.io/_uploads/SyrKSTF7R.png)\n\n### 部屬\n\n測試鑄造 10000\n![image](https://hackmd.io/_uploads/SkZbzpKXC.png)\n\n測試查詢餘額會增加\n![image](https://hackmd.io/_uploads/HJ6hzptQ0.png)\n\n測試燒毀 1000\n![image](https://hackmd.io/_uploads/SkcbHaYmA.png)\n\n測試查詢餘額會減少\n![image](https://hackmd.io/_uploads/r1_QBpK70.png)\n","tags":["ETH","Solidity","ERC20","Web3"]},{"title":"Gnosis Safe 多簽核錢包使用紀錄","url":"/2024/05/17/Gnosis-Safe-多簽核錢包使用紀錄/","content":"\n# Gnosis Safe 多簽核錢包使用紀錄\n\n![image](https://hackmd.io/_uploads/BJLUKwNmA.png)\n\n\n## 什麼是 多簽核錢包 - Multi-sig Wallet\n多簽核錢包（Multi-sig Wallet）是一種加密貨幣錢包，它需要多個簽名（多個人或設備的授權）才能執行交易。\n這樣的設計提高了資金的安全性和管理的靈活性。簡單來說，這種錢包類似於銀行的聯名帳戶，需要多方同意(例如公司老闆、會計同意後)才能使用資金。\n\n\n### 特性\n* 多重簽名：交易需要多個授權（如2個或3個）才能完成，而不是單一的私鑰。\n* 增加安全性：即使某一個私鑰被盜，黑客無法單獨轉移資金。\n* 協作管理：適合團隊或公司共同管理資金，防止單人濫用權力。\n\n### 應用情境\n\n* 家庭理財：夫妻共同管理，避免單方面亂花錢。\n* 公司財務：需要多個主管批准，確保每筆開支都經過審核。\n* 合作投資：投資者共同管理資金，確保透明和安全。\n\n\n## Multi-sig Wallet 的用途\n多簽核錢包（Multi-sig Wallet）的用途主要是提高資金的安全性和管理的靈活性。這種錢包需要多個簽名（多方授權）才能執行交易，確保資金不會被單一個人或設備濫用。\n\n這樣的設計讓資金管理更安全、更透明，同時也降低了單一個人私鑰洩漏的風險。\n\n### 提高安全性\n* 防止盜竊：即使黑客獲得了一個私鑰，也無法單獨轉移資金，因為需要多個簽名。\n* 分散風險：多個私鑰存放在不同地方或由不同人管理，減少單點故障風險。\n\n### 團隊管理\n* 公司財務：公司可以設置多個主管需要共同批准才能執行資金轉移，確保每筆開支都經過審核。\n* 合作投資：投資者可以共同管理投資資金，確保每筆交易都透明且經過多方同意。\n\n### 家庭理財\n* 聯名帳戶：夫妻或家庭成員共同管理家庭資金，防止單方濫用。\n\n### 智能合約\n* 去中心化應用：在區塊鏈上的智能合約可以利用多簽核機制來確保合約執行的安全性和可靠性。\n\n## 什麼是 Gnosis Safe\n\nGnosis Safe 是支援多條 EVM chains，也是目前市佔率最大，最受信任的一款智能合約錢包。\n![image](https://hackmd.io/_uploads/BkgjKwEmR.png)\n\n![image](https://hackmd.io/_uploads/B1KjYDN7A.png)\n>參考來源:https://johnny-chuang.medium.com/gnosis-safe-%E5%A4%9A%E7%B0%BD%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-aeed1b9b36bd\n\nGnosis Safe 是一種多簽錢包，提供高安全性並與多種硬件錢包和熱錢包相容。其核心功能之一是使用多簽名機制，例如常見的 2/3 簽名機制。\n\n這意味著在三個錢包中，至少需要兩個簽名才能執行交易。\n\n這種設置顯著提高了安全性，即使其中一個熱錢包的私鑰被盜，駭客仍需要再取得一個冷錢包的私鑰才能完成交易，增加了攻擊難度。\n\n此外，Gnosis Safe 可以輕鬆與 DeFi 協議交互，支援 ERC-721 和 ERC-1155 標準的 NFT tokens，使用戶在享有高安全性的同時，能順暢地進行鏈上交互和資產儲存。\n\n這樣的設計確保了用戶資產的安全性和靈活性，非常適合需要高安全性的個人和團體使用。\n\n## 實際操作\n\n### 創建 Gnosis Safe Wallet\n\n首先，先到 Gnosis Safe 的網站\n![image](https://hackmd.io/_uploads/HyvpFv4QC.png)\n>https://safe.global/wallet\n\n點選 Launch Wallet\n![image](https://hackmd.io/_uploads/SkKCFP4XR.png)\n\n點選 Connect wallet\n![image](https://hackmd.io/_uploads/B1SJcv4XA.png)\n\n選擇 MetaMask\n![image](https://hackmd.io/_uploads/rJpe9vE7A.png)\n\n接下來小狐狸會跳出來\n![image](https://hackmd.io/_uploads/ryc5qDEQA.png)\n>點選下一頁\n\n\n選擇連線\n![image](https://hackmd.io/_uploads/HkOJjPE70.png)\n\n![image](https://hackmd.io/_uploads/B1BuiDNmR.png)\n\n這邊選擇好錢包名稱後按 Next\n![image](https://hackmd.io/_uploads/HJX2iP4XA.png)\n\n這邊的 Signer 代表多簽核人員\nThreshold 代表設定一筆交易需要多少個 confirmation 才會上到鏈上\n\n![image](https://hackmd.io/_uploads/BkG_hw4m0.png)\n\n\n![image](https://hackmd.io/_uploads/H1y0hP4Q0.png)\n>小狐狸連動確認畫面\n\n![image](https://hackmd.io/_uploads/H1V-avE7C.png)\n> 創建成功的畫面\n\n\n# 這邊就是一個多簽核錢包\n![image](https://hackmd.io/_uploads/SyP8aPEQA.png)\n\n\n# 測試出金\n![image](https://hackmd.io/_uploads/r1DeetEX0.png)\n>點選 Send 發起一筆出金\n\n![image](https://hackmd.io/_uploads/HyGNeYN7R.png)\n>這邊選擇Send Tokens\n\n![image](https://hackmd.io/_uploads/S19PeKVXA.png)\n>輸入地址與金額後點擊Sign發起出金\n\n![image](https://hackmd.io/_uploads/H1XaeKE70.png)\n> 會跳出小狐狸確認畫面，選擇簽屬\n\n![image](https://hackmd.io/_uploads/HkVM-KE7C.png)\n>這邊可以看到簽核過程\n\n![image](https://hackmd.io/_uploads/r1_Bbt4mA.png)\n>滿足簽核條件後會進入交易流程\n\n![image](https://hackmd.io/_uploads/B1BFbFEXA.png)\n>交易成功可以瀏覽當時的交易紀錄\n\n# 參考資料 \n- [Gnosis Safe 多簽錢包使用教學](https://johnny-chuang.medium.com/gnosis-safe-%E5%A4%9A%E7%B0%BD%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-aeed1b9b36bd)\n- [Gnosis Safe 教程](https://nextrope.com/how-to-create-a-multisig-wallet-using-gnosis-safe/)\n- [Gnosis Safe 官方網站](https://safe.global)\n- [CoinGecko 關於 Gnosis Safe 的介紹](https://www.coingecko.com)","tags":["Gnosis Safe","多簽核","區塊鏈","MetaMask"]},{"title":"IPFS介紹 - 星際檔案系統","url":"/2024/05/16/IPFS介紹-星際檔案系統/","content":"\n# IPFS介紹 - 星際檔案系統 \n\n![image](https://hackmd.io/_uploads/rkqS8qbmC.png)\n>https://ipfs.tech/\n\nIPFS（InterPlanetary File System）是一種分佈式的文件系統，旨在建立一個更快、更安全和更開放的互聯網。\n\nhttps://youtu.be/5Uj6uR3fp-U?si=LLShkmZ5JBewmt6Q\n\n## IPFS的主要特點\n### 分佈式存儲\n資料不是儲存在單一的伺服器上，而是分佈在全球許多節點上。這種方法提高了資料的冗餘度和可靠性。\n\n### 內容尋址\nIPFS 使用內容尋址（Content Addressing）來存取資料，而不是傳統的基於位置的尋址方法。每個文件都有一個唯一的哈希值作為其地址。\n\n### 版本控制\n類似於Git，IPFS 支援資料的版本控制，這意味著每個文件的更改都可以被跟蹤和還原。\n\n### 點對點網絡\nIPFS 使用點對點（P2P）技術，允許用戶直接連接並共享資源，而不需要依賴中央伺服器。\n\n### 去中心化\nIPFS 的架構去除了對中心化伺服器的依賴，減少了單點故障的風險，並且提高了資料的可用性和抗審查性。\n\n## IPFS 的主要用途\n### 網站託管\n通過IPFS，網站可以以去中心化的方式託管，不再依賴單一伺服器，從而提高網站的穩定性和安全性。\n\n### 分佈式應用程式（dApps）\nIPFS 常被用於支援去中心化應用程式，這些應用程式需要一個可靠的分佈式存儲解決方案。\n\n### 大文件共享\n由於其高效的分塊和分發機制，IPFS 非常適合用來共享和存儲大文件。\n\n\n## 實際操作\n\n### 設定與啟動\n\n建立一個ipfs_test資料夾，結構如下。\n\n```\nipfs_test\n|_ staging\n|_ data\n```\n![image](https://hackmd.io/_uploads/H18n2qW7A.png)\n\nstaging 是準備要放即將要 export 出去的檔案的地方。\n\n使用 docker 拉go-ipfs image 啟動，並指定檔案 export 的路徑。\n```\nexport ipfs_staging=/absolute/path/to/<staging的資料夾>/\nexport ipfs_data=/absolute/path/to/<data的資料夾>/\ndocker run -d --name ipfs_host -v $ipfs_staging:/export -v $ipfs_data:/data/ipfs -p 4001:4001 -p 4001:4001/udp -p 127.0.0.1:8080:8080 -p 127.0.0.1:5001:5001 ipfs/go-ipfs:latest\n```\n\n{% note warning simple %}\n\n這邊我有遇到錯誤訊息\n![image](https://hackmd.io/_uploads/SJLDPXQ7A.png)\n\n這個錯誤訊息表明在WSL 2中無法找到docker命令，這可能是因為Docker Desktop尚未與WSL 2整合或安裝。\n\n要在WSL 2中使用Docker Desktop，需要先啟用WSL整合。請按照以下步驟操作：\n\n1.打開Docker Desktop。\n![image](https://hackmd.io/_uploads/B1ScPXmQR.png)\n\n2.點擊左上角的Docker圖標，選擇\"Settings\"。\n![image](https://hackmd.io/_uploads/BkxjPXXQ0.png)\n\n3.在\"Resources\"->\"WSL integration\"部分，勾選\"Enable integration with my default WSL distro\" 並且也把\"Ubuntu-20.04\"這邊的開關打開。\n![image](https://hackmd.io/_uploads/r15pPXQ7A.png)\n\n4.點擊\"Apply & Restart\"來應用更改。\n完成這些步驟後，Docker Desktop將啟用WSL 2整合並重啟。然後，你應該能夠在WSL 2中使用docker命令來運行容器。\n\n{% endnote %}\n\n如果要監看 logs，可以下：\n\n```\ndocker logs -f ipfs_host\n```\n\n![image](https://hackmd.io/_uploads/SkKaT7Qm0.png)\n\n\n進入 container 做事：\n```\ndocker exec -it ipfs_host /bin/sh\n\n```\n\n![image](https://hackmd.io/_uploads/r1Yy0Qm70.png)\n\n![image](https://hackmd.io/_uploads/HkqbRXmQR.png)\n這邊可以發現開啟了3個docker\n\n啟動後可以查看介面\n![image](https://hackmd.io/_uploads/BkFO0QQ7R.png)\n> http://localhost:5001/webui\n\n### 將檔案上傳至 IPFS\n\n進入 container 後，把檔案（這裡以 測試檔案 xlsx 為例）丟到本地的 staging 資料夾，下 export指令把它上傳到 ipfs 並取得 hash 值。\n\n```\ndocker exec -it ipfs_host /bin/sh\nipfs add -r /export/\n```\n![image](https://hackmd.io/_uploads/H1GC7Vm7A.png)\n\n上傳完後會取得 ipfs-hash\n\n```\nadded QmaEa7JhzR6qpFZpRNRecKsAsf1tqzAJKktXxQ6tE4iTPf export/test0050.xlsx\nadded QmUELrk81uAbSsEj4r9XHUtUov7GDLMnTyiVXeCSSoK98o export\n```\n\n\n### 用 ipfs-hash 去查看檔案\n查看剛剛丟的檔案：\n```\nipfs cat /ipfs/QmaEa7JhzR6qpFZpRNRecKsAsf1tqzAJKktXxQ6tE4iTPf\n```\n\n也可以從這邊查看 http://127.0.0.1:8080/ipfs/QmaEa7JhzR6qpFZpRNRecKsAsf1tqzAJKktXxQ6tE4iTPf\n>這邊會直接下載下來\n\n### 其他常用指令\n```\n# 查看 log\ndocker logs -f ipfs_host\n\n# 停止容器\ndocker stop ipfs_host\n\n# 查看內容\nipfs cat /ipfs/QmV3LyHokfUH1kp94Nrxn8q1E8p95Kt9kfKfJSUpXsGc6Q\n\n# docker exec ipfs_host [指令]\ndocker exec ipfs_host ipfs add -r /export/\n```\n\n## 把 node 連結到 IPFS network\n\n查詢自己的 id\n```\n ipfs id\n```\n\n![image](https://hackmd.io/_uploads/BJfg84QQC.png)\n\n介面這邊也可以查看到節點ID\n![image](https://hackmd.io/_uploads/rJ0fUVQ7R.png)\n\n\n尋找其他的 peers\n```\nipfs swarm peers\n```\n![image](https://hackmd.io/_uploads/SJO5L4m7R.png)\n\n圖形化介面查看方式:\n![image](https://hackmd.io/_uploads/HynoLV77C.png)\n\n## 查看別人的檔案\n\n可以透過自己的 IPFS 節點造訪別人的檔案內容。我們來看看被 IPFS 團隊放上 IPFS 網絡的土耳其文維基百科 snapshot！\n\n```\nipfs cat Qme2sLfe9ZMdiuWsEtajWMDzx6B7VbjzpSC2VWhtB6GoB1/wiki/Peer-to-peer.html \n```\n\n![image](https://hackmd.io/_uploads/rJp-v47m0.png)\n\n\n查看土耳其文維基百科部分的檔案：\n\n```\nipfs ls Qme2sLfe9ZMdiuWsEtajWMDzx6B7VbjzpSC2VWhtB6GoB1/wiki/Anasayfa.html\n```\n\n## IPFS 操作介面\n\n### 首頁\n![image](https://hackmd.io/_uploads/r1vU_EXmC.png)\n\n### 檔案\n![image](https://hackmd.io/_uploads/H1vDu4m7R.png)\n\n### 瀏覽\n![image](https://hackmd.io/_uploads/ByVddVmX0.png)\n\n### 用戶群\n![image](https://hackmd.io/_uploads/S1wYuV7X0.png)\n\n![image](https://hackmd.io/_uploads/By0q_VXmA.png)\n\n### 設定\n![image](https://hackmd.io/_uploads/Hk53u47mC.png)\n\n\n這邊我發現實際操作已經跟教學文章比較起來有更新很多畫面了。\n\n## 後記\n\n這一篇是我在網路上看到這篇教學文章\nhttps://medium.com/wenchin-rolls-around/%E8%A9%A6%E7%8E%A9-ipfs-a69a52abb954\n\n跟著實際操作的紀錄，這邊有官方介紹文件 https://docs.ipfs.tech/concepts/usage-ideas-examples/ 有興趣可以繼續研究，另外還有其他人開發的 IPFS 相關應用 https://github.com/ipfs/awesome-ipfs\n","tags":["區塊鏈","IPFS","星際檔案系統","Filecoin"]},{"title":"Amazon Lightsail + Wordpress自架站教學","url":"/2024/05/10/Amazon-Lightsail-Wordpress自架站教學/","content":"\n# Amazon Lightsail + Wordpress自架站教學\n\n這篇是我看到youtube 毛巾的教學影片跟著操作的紀錄\nhttps://youtu.be/ufmCi7pMgKU?si=DG0bd_pwWzb20Lj5\n\n# Amazon \n\n註冊AWS 帳號\n\n# Amazon Lightsail\n\n![image](https://hackmd.io/_uploads/rJDljZsfR.png)\n> 點選Create Instance 創建 instance\n\n![image](https://hackmd.io/_uploads/rkvLoZszA.png)\n>伺服器地區選擇比較近的東京\n\n![image](https://hackmd.io/_uploads/SkrjobiGA.png)\n>選擇Wordpress\n\n![image](https://hackmd.io/_uploads/SylBn-ozC.png)\n>這邊選擇最便宜的5塊錢方案\n\n![image](https://hackmd.io/_uploads/S1FdnZofC.png)\n>取名 這邊我取NalsonBlog\n\n大概等個兩分鐘就建置好了\n\n![image](https://hackmd.io/_uploads/Bk2anbizR.png)\n>建置完成的畫面\n\n\n![image](https://hackmd.io/_uploads/rywaTZifC.png)\n>這邊可以看到我們成功建立好的WordPress 網頁模板\n\n# 進入WordPress 更改後台設定\n\nhttps://docs.aws.amazon.com/zh_tw/lightsail/latest/userguide/log-in-to-your-bitnami-application-running-on-amazon-lightsail.html\n\n上面這篇文章教學很詳細\n\n![image](https://hackmd.io/_uploads/SkaRezozR.png)\n點選 連結圖示 SSH 用戶端視窗會開啟，如以下範例所示。\n\n![image](https://hackmd.io/_uploads/H1xmWfiGA.png)\n\n請輸入如下命令以擷取預設應用程式密碼：\n```\ncat bitnami_application_password\n```\n\n## 登入WordPress後台管理\n![image](https://hackmd.io/_uploads/ryNaWMsM0.png)\n\n可以先將語言改成中文\n![image](https://hackmd.io/_uploads/By9mzMoGR.png)\n\n再來可以選擇喜歡的佈景主題\n![image](https://hackmd.io/_uploads/HkfvfMiz0.png)\n","tags":["AWS","AWS Lightsail","Wordpress"]},{"title":"Docker-compose 問題排除: version is obsolete ","url":"/2024/04/19/Docker-compose-問題排除-is-obsolete/","content":"\n# Docker-compose 問題排除:  `version` is obsolete \n\n我在使用 docker-compose build 時遇到以下問題\n\nWARN[0000] /home/docker-compose.yml: `version` is obsolete \n\n# 問題原因:\n\n從提供的錯誤訊息來看，表示使用的 docker-compose.yml 文件中的 version 字段已經過時。\n\n這通常表示您正在使用的 Docker Compose CLI (Command Line Interface) 已經升級到更高版本，而該版本可能不再需要或不支持 version 字段。\n\n# 解決方法:\n移除 version 行\n編輯您的 docker-compose.yml 文件，刪除或註釋掉 version: '3' 這一行。\n\n```\n# version: '3'\n```","tags":["Docker-compose","version is obsolete"]},{"title":"如何在Windows 10上將Ubuntu從WSL1升級到WSL2","url":"/2024/04/10/如何在Windows-10上將Ubuntu從WSL1升級到WSL2/","content":"# 如何在Windows 10上將Ubuntu從WSL1升級到WSL2\n\n我是使用 win10 的 ubuntu  出現這個問題 \n```\nsudo systemctl status docker\nSystem has not been booted with systemd as init system (PID 1). Can't operate.\nFailed to connect to bus: Host is down\n```\n\nwin 10 舊版本電腦在使用WSL 上會遇到比較多問題需要排除\n\n# 原因\n在Windows 10上，Windows Subsystem for Linux (WSL) 提供了一個運行Linux二進制執行檔案的兼容層，無需使用傳統的虛擬機或雙重啟動設置。WSL有兩個版本：WSL1和WSL2。WSL2相較於WSL1提供了更完整的Linux內核支持和改進的性能。本教程將指導您如何將Ubuntu從WSL1升級到WSL2。\n\n# 前提條件\n\n* 確保您的Windows 10版本至少是2004（組建號19041）或更高版本。\n* 確保您已安裝了Windows Subsystem for Linux (WSL)。\n\n# 操作步驟\n\n## 步驟1：檢查您的WSL版本\n\n1.打開Windows的命令提示符或PowerShell。\n2.輸入以下命令，然後按下Enter鍵：\n```\nwsl -l -v\n```\n\n3.檢查您的Ubuntu發行版旁邊的版本號。如果它顯示的是1，那麼您需要進行升級。\n\n## 步驟2：啟用WSL2功能\n\n1.打開PowerShell作為管理員。\n2.執行以下命令來啟用WSL2功能：\n```\nwsl --set-version Ubuntu 2\n```\n請確保將Ubuntu替換成您的實際發行版名稱，如果它與顯示的不同。\n\n等待升級過程完成。這可能需要一些時間，具體取決於您的系統配置和存儲的文件量。\n\n## 步驟3：驗證升級\n再次執行步驟1中的命令來檢查WSL版本：\n```\nwsl -l -v\n```\n\n","tags":["Docker","Windows 10","WSL","Ubuntu"]},{"title":"RTSP 透過OBS直播到 youtube","url":"/2024/04/09/RTSP-透過OBS直播到-youtube/","content":"# RTSP 透過OBS直播到 youtube\n\n我一開始是看到這篇教學\nhttps://www.jinwei.tw/youtube-obs-rtsp/\n\n但是來源一直吃不到rtsp\n\n後來看到這一篇\nhttps://www.mylumens.com/Download/OBS%20Plugin%20and%20Dockable%20Controller-User%20Manual-Chinese-2021-0823.pdf\n\n的設定可以選擇VLC\n\n但是我的OBS　沒有VLC選項，找到這一篇\nhttps://youtu.be/Gr3XIo7exSg?si=Oe9xsCckZhZtYqn2\n\n提到 OBS 跟VLC 要安裝同樣bit版本 (64 或是 32)\n\n![image](https://hackmd.io/_uploads/Skwrv8zlR.png)\n像這樣就能夠成功選擇了\n\n\n# 參考資料:\n\nhttps://www.jinwei.tw/youtube-obs-rtsp/\nhttps://www.mylumens.com/Download/OBS%20Plugin%20and%20Dockable%20Controller-User%20Manual-Chinese-2021-0823.pdf\nhttps://youtu.be/Gr3XIo7exSg?si=Oe9xsCckZhZtYqn2","tags":["RTSP","影像串流","OBS"]},{"title":"使用Go與Gin框架串接Modbus TCP的完整指南","url":"/2024/04/02/使用Go與Gin框架串接Modbus-TCP的完整指南/","content":"# 使用Go與Gin框架串接Modbus TCP的完整指南\n\n最近在著手開發一個跟漁農業相關的專案，需要透過 Modbus TCP 協定來取得設備上的資訊，這篇文章會紀錄一下 Modbus TCP 的基本概念及協定規格。\n\n我們將探討如何使用Go語言和Gin框架來實現與Modbus TCP裝置的通信。這個主題對於需要在網頁應用中集成實時裝置控制和監控的開發者特別有用。我們會從基本原理開始，介紹測試工具，提供程式碼示例，並探討如何以MVC架構進行切分，以實現更好的代碼組織和維護性。\n\n# 什麼是Modbus TCP?\n\n![image](https://hackmd.io/_uploads/SJcatxFyR.png)\n\nModbus 是在工業領域中廣泛使用的訊息交換規範，而 Modbus TCP 則是 Modbus 的一種實現，它使用 TCP/IP 作為傳輸層協定，因此可以透過網路傳輸。\n\nModbus是一種廣泛使用的串行通信協議，被用於連接工業電子裝置。Modbus TCP則是其基於TCP/IP的變種，允許這些裝置通過網路進行通信。Go語言擁有出色的網路處理能力，配合Gin框架的高效率和簡潔性，可以輕鬆搭建出一個用於與Modbus裝置通信的後端服務。\n\n# 關於 Modbus\nModbus 本身就是一種訊息交換的規範，而 Modbus TCP 則是透過 TCP/IP 來實現 Modbus 的一種方式，因此所有的訊息都是透過 TCP/IP 來傳輸。\n\nModbus 屬於 Client/Server 架構，在工業上會有一個 Server 來存放所有要被讀取的工業設備數據，如溫度、濕度、距離等資料；而 Client 則會傳送一定的訊息格式當做指令，來讀取設備資料（讀），或是叫設備去做些什麼事情（寫）。\n\n無論是對 Modbus Server 發送讀或寫的指令，Server 都會回傳一個確認訊息，讓 Client 知道指令是否成功。整個 Modbus 的溝通就是建構在這個一來一回的訊息交換上。\n\n![image](https://hackmd.io/_uploads/SJi89etyR.png)\n>https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/\n\n在傳輸過程中，Client 與 Server 的訊息最少會有「Function Code」與「Data」兩個部分：\n\nFunction Code：代表要執行的動作代碼，如讀取或寫入。\nData：代表執行動作代碼的相關參數，例如讀取某個位址上的資料，或是回傳某個位址上的資料作為結果。\nFunction Code 和 Data 是整個 Modbus 溝通最基本的單元，也稱為 Protocol Data Unit (PDU)。\n\n除此之外，根據傳輸方式不同可能還會再頭尾加上一些附加資訊，附加後的整個訊息稱為 Application Data Unit (ADU)。\n\n![image](https://hackmd.io/_uploads/ByEFqlF1C.png)\n>https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/\n\nModbus 定義了許多的內建的 Function Code，每個 Function Code 伴隨著特定規則的 Data，在閱讀文件時，可以跟具我們要處理的 Function Code 找到對應的 Data 規則。\n\n![image](https://hackmd.io/_uploads/H1V59etJA.png)\n>https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/\n\n\n# 測試工具\n在開發和測試Modbus TCP通信過程中，你可能會需要以下工具：\n\n* Modbus模擬器（如Modsim）：模擬Modbus服務器（Slave），方便開發和測試。\n* Modbus客戶端測試工具（如Modscan或QModMaster）：用於測試和調試與Modbus裝置的通信。\n\n\n這些工具可以幫助你模擬實際的Modbus環境，進行開發和測試，無需實際的硬件裝置。\n\n## Modbus Slave模擬器\n![image](https://hackmd.io/_uploads/Sy0LoxF1C.png)\n>https://www.azofreeware.com/2019/12/modbus-slave.html\n\n## MODSCAN\n![image](https://hackmd.io/_uploads/H1w6sxF1C.png)\n>https://kknews.cc/zh-tw/news/ga4b86l.html\n\n## QModMaster\n![image](https://hackmd.io/_uploads/SyyGngYkA.png)\n>https://sourceforge.net/projects/qmodmaster/\n\n## Modbus/TCP Master\n![image](https://hackmd.io/_uploads/H1zUheYkC.png)\n\n\n# 程式實作\n以下是使用Go語言和Gin框架來實現Modbus TCP通信的簡單示例。首先，我們需要安裝必要的Go包：\n```\ngo get github.com/gin-gonic/gin\ngo get github.com/goburrow/modbus\n```\n\n然後，我們可以創建一個簡單的Gin後端服務，用於處理Modbus TCP請求：\n```\npackage main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/goburrow/modbus\"\n)\n\nfunc main() {\n    r := gin.Default()\n    \n    r.GET(\"/read\", func(c *gin.Context) {\n        handler := modbus.NewTCPClientHandler(\"192.168.1.1:502\")\n        defer handler.Close()\n        client := modbus.NewClient(handler)\n        \n        results, err := client.ReadHoldingRegisters(1, 1)\n        if err != nil {\n            c.JSON(500, gin.H{\"error\": err.Error()})\n            return\n        }\n        c.JSON(200, gin.H{\"data\": results})\n    })\n\n    r.Run() // listen and serve on 0.0.0.0:8080\n}\n\n```\n\n# 進階MVC架構切分\n\n在一個較大的項目中，為了保持代碼的清晰和可維護性，我們可以將應用劃分為模型（Model）、視圖（View）和控制器（Controller）三個部分，即所謂的MVC架構。\n\n模型（Model）：與Modbus裝置的通信邏輯，例如讀寫寄存器的功能。\n視圖（View）：在這個上下文中，視圖可以是返回給客戶端的JSON數據格式。\n控制器（Controller）：處理HTTP請求，調用模型執行操作，並決定返回哪個視圖。\n這樣的結構使得代碼更加模組化，易於測試和維護。控制器負責路由和請求處理，模型實現具體的業務邏輯，視圖則是數據的表示。\n\n## 模型 (Model)\n模型層封裝了與Modbus裝置通信的邏輯。這裡，我們定義一個ModbusService來處理與Modbus裝置的通信：\n\n```\n// modbusService.go\npackage service\n\nimport (\n    \"github.com/goburrow/modbus\"\n)\n\ntype ModbusService struct {\n    Client modbus.Client\n}\n\nfunc NewModbusService(address string) *ModbusService {\n    handler := modbus.NewTCPClientHandler(address)\n    handler.Connect()\n    return &ModbusService{\n        Client: modbus.NewClient(handler),\n    }\n}\n\nfunc (m *ModbusService) ReadRegister(address, quantity uint16) ([]byte, error) {\n    return m.Client.ReadHoldingRegisters(address-1, quantity)\n}\n\n```\n\n## 控制器 (Controller)\n控制器層負責處理HTTP請求，調用模型來執行操作，並返回視圖。在這個例子中，我們創建一個控制器來處理讀取請求：\n\n```\n// modbusController.go\npackage controller\n\nimport (\n    \"net/http\"\n    \"strconv\"\n\n    \"github.com/gin-gonic/gin\"\n    \"your_project/service\" // 替換成你的專案名稱\n)\n\ntype ModbusController struct {\n    Service *service.ModbusService\n}\n\nfunc NewModbusController(service *service.ModbusService) *ModbusController {\n    return &ModbusController{\n        Service: service,\n    }\n}\n\nfunc (mc *ModbusController) ReadRegister(c *gin.Context) {\n    address, _ := strconv.ParseUint(c.Query(\"address\"), 10, 16)\n    quantity, _ := strconv.ParseUint(c.Query(\"quantity\"), 10, 16)\n\n    data, err := mc.Service.ReadRegister(uint16(address), uint16(quantity))\n    if err != nil {\n        c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n        return\n    }\n\n    c.JSON(http.StatusOK, gin.H{\"data\": data})\n}\n\n```\n\n## 路由設定 (Routing)\n最後，在main.go中設定路由並初始化控制器和模型。這裡我們將路由、控制器和模型結合起來：\n\n```\n// main.go\npackage main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"your_project/controller\" // 替換成你的專案名稱\n    \"your_project/service\"    // 替換成你的專案名稱\n)\n\nfunc main() {\n    r := gin.Default()\n    modbusService := service.NewModbusService(\"192.168.1.1:502\")\n    modbusController := controller.NewModbusController(modbusService)\n\n    r.GET(\"/read\", modbusController.ReadRegister)\n\n    r.Run() // listen and serve on 0.0.0.0:8080\n}\n```\n\n這樣，我們就完成了一個基於MVC架構的應用，這個應用可以通過Gin框架處理HTTP請求，並通過Modbus TCP與裝置進行通信。這個架構使得代碼更加清晰且易於維護，特別適合於較大型的項目。\n\n# 結論\n通過使用Go語言和Gin框架，我們可以構建一個強大的後端應用，用於實現與Modbus TCP裝置的通信。這篇指南僅僅是一個起點，Modbus TCP的實際應用場景非常廣泛，從簡單的數據讀取到復雜的自動化控制系統都有可能。希望這篇文章能夠幫助你開始這樣的項目，並為你提供一些有用的工具和概念。","tags":["Go","Modbus TCP"]},{"title":"Go 接收 RTSP 即時影像","url":"/2024/03/29/Go-接收-RTSP-即時影像/","content":"\n# Go 接收 RTSP 即時影像\n\n# 前言\n目前因為工作需求要接收RTSP即時影像，並且顯示在前端網頁\n\n# 使用工具\nRTSPtoWebRTC:\nhttps://github.com/deepch/RTSPtoWebRTC\n\n# RTSP 測試地址\n\n| 來源 | RTSP | 延遲 |\n| -------- | -------- | -------- |\n| Nordland     | rtsp://77.110.228.219/axis-media/media.amp     | 200ms     |\n| Norwich     | rtsp://37.157.51.30/axis-media/media.amp     | 250ms     |\n| Orlando     | rtsp://97.68.104.34/axis-media/media.amp     | 350ms     |\n| PriceCenterPlaza     | rtsp://132.239.12.145:554/axis-media/media.amp     | 280ms |\n| Vaison-La-Romaine | rtsp://176.139.87.16/axis-media/media.amp   | 差 |\n| VyhladJazero | rtsp://stream.strba.sk:1935/strba/VYHLAD_JAZERO.stream   | 160ms |\n| Western Cape | rtsp://196.21.92.82/axis-media/media.amp   | 450ms |\n| Zeeland | rtsp://213.34.225.97/axis-media/media.amp  | 270ms |\n| Allendale | rtsp://71.83.5.156/axis-media/media.amp  | 270ms |\n| Bedford Hills | rtsp://73.114.177.111/axis-media/media.amp  | 340ms |\n\t\t\n> 也可以參考 https://timetickme.com/stream-a-video-over-rtsp-using-live555mediaserver 本地搭建RTSP服務器進行測試\n\n# 測試流程\n\n## 下載程式碼\n```\ngit clone https://github.com/deepch/RTSPtoWebRTC  \n```\n\n## 到資料夾底下\n```\ncd RTSPtoWebRTC/\n```\n\n# 調整config.json\n```\n{\n  \"server\": {\n    \"http_port\": \":8083\",\n    \"ice_servers\": [\"stun:stun.l.google.com:19302\"]\n  },\n  \"streams\": {\n      \"01\": {\n        \"on_demand\" : false,\n        \"disable_audio\": true,\n        \"url\": \"rtsp://77.110.228.219/axis-media/media.amp\"\n      },\n      \"02\": {\n        \"on_demand\" : true,\n        \"disable_audio\": true,\n        \"url\": \"rtsp://37.157.51.30/axis-media/media.amp\"\n      },\n      \"03\": {\n        \"on_demand\" : false,\n        \"disable_audio\": true,\n        \"url\": \"rtsp://97.68.104.34/axis-media/media.amp\"\n      },\n      \"04\": {\n        \"on_demand\" : false,\n        \"disable_audio\": true,\n        \"url\": \"rtsp://132.239.12.145:554/axis-media/media.amp\"\n      },\n      \"05\": {\n        \"on_demand\" : false,\n        \"disable_audio\": true,\n        \"url\": \"rtsp://176.139.87.16/axis-media/media.amp\"\n      },\n      \"06\": {\n        \"on_demand\" : false,\n        \"disable_audio\": true,\n        \"url\": \"rtsp://stream.strba.sk:1935/strba/VYHLAD_JAZERO.stream\"\n      }\n  }\n}\n\n```\n\n## 測試部屬\n```\nGO111MODULE=on go run *.go\n```\n\n# 透過瀏覽器打開網頁\n```\nhttp://127.0.0.1:8083\n```\n\n![image](https://hackmd.io/_uploads/ByLZznQk0.png)\n> 這邊找到測試用RTSP 就可以看到攝影機畫面\n\n\n參考資料:https://timetickme.com/rtsp%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80/\n\n","tags":["GO","RTSP","即時影像"]},{"title":"GVM：Go 版本管理器的基本介紹","url":"/2024/03/27/GVM：Go-版本管理器的基本介紹/","content":"\n# GVM：Go 版本管理器的基本介紹\n\n# GVM 是什麼?\n![image](https://hackmd.io/_uploads/B1I3TIZJR.png)\n>https://github.com/moovweb/gvm\nGVM 是 Go 版本管理器，是一個用於管理多個 Go 版本的命令行工具。允許開發者輕鬆切換、安裝和使用不同版本的 Go，從而提高了開發效率並幫助保持項目環境的一致性。\n\n# GVM 的特點\n版本切換：GVM 允許您在不同版本的 Go 之間快速切換，方便您在多個項目間工作，每個可能需要不同版本的 Go。\n易於安裝：通過 GVM，安裝新版本的 Go 變得非常容易，只需一條簡單的命令。\n版本隔離：GVM 為每個版本的 Go 提供了隔離的環境，確保了不同項目的依賴和配置不會互相干擾。\n\n# 如何安裝 GVM\n在大多數 Unix-like 系統（如 Linux 和 macOS）上，可以使用以下命令安裝 GVM：\n```\nbash < <(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)\n```\n安裝完成後，可能需要重啟您的終端或者重新加載配置檔案（例如 .bashrc 或 .bash_profile）來使 GVM 的設定生效。\n\n# 使用 GVM 管理 Go 版本\n以下是使用 GVM 的一些基本命令：\n\n列出可用的 Go 版本：\n```\ngvm listall\n```\n\n安裝特定版本的 Go：\n```\ngvm install go1.18.1 -B\n```\n\n使用特定版本的 Go：\n```\ngvm use go1.18.1\n```\n\n設定預設使用的 Go 版本：\n```\ngvm use go1.18.1 --default\n```\n\n# 總結\n\nGVM 是一個強大的工具，對於需要在多個 Go 項目中工作的開發者來說，它提供了極大的便利。通過使用 GVM，開發者可以輕鬆切換 Go 版本，保持項目間的環境一致性，從而提升開發效率。無論您是 Go 語言的新手還是有經驗的開發者，GVM 都是您工具箱中不可或缺的一部分。","tags":["GO","GVM"]},{"title":"Termius: 跨平台SSH客戶端的終極指南","url":"/2024/03/14/Termius-跨平台SSH客戶端的終極指南/","content":"# 前言\n在當今快速變化的技術環境中，遠程管理伺服器變得越來越重要。無論你是一名系統管理員、開發人員還是IT專業人士，都需要一款強大且可靠的工具來管理你的遠程伺服器。這就是Termius發揮作用的地方。\n\n# 什麼是Termius？\n![image](https://hackmd.io/_uploads/ryq9YZg0T.png)\n>https://termius.com/\n\nTermius是一款現代化的SSH客戶端，支持跨平台操作，允許用戶從任何地方安全地訪問和管理遠程系統。它不僅支持SSH，還支持Telnet、Mosh和SFTP協定，提供了一個統一的平台來管理所有的遠程任務。\n\n# 主要特點\n\n* 跨平台支持：Termius提供了Windows、macOS、Linux以及iOS和Android的客戶端。\n* 多標籤界面：輕鬆管理多個同時連接。\n* 密鑰管理：內建密鑰生成和管理功能，提高安全性。\n* 數據同步：通過Termius雲服務在多個設備間同步配置。\n* 端口轉發：支援本地和遠程端口轉發，保障數據傳輸的安全。\n* 自動化腳本：使用SNIPPETS自動化重複的任務。\n\n![image](https://hackmd.io/_uploads/r1KWp-xRp.png)\n>多標籤界面\n\n![image](https://hackmd.io/_uploads/HkYzpWgRa.png)\n>自動化腳本\n\n![image](https://hackmd.io/_uploads/HJrIpZlAT.png)\n>Termius提供了Windows、macOS、Linux以及iOS和Android的客戶端。\n\n# 如何開始使用Termius\n\n##  下載並安裝Termius\n首先，前往Termius官網下載適合你操作系統的Termius版本，然後按照指示完成安裝。\n![image](https://hackmd.io/_uploads/rkKls-xA6.png)\n\n## 創建和配置連接\n打開Termius，你需要創建新的SSH連接。\n\n點擊左側菜單的\"New Host\"。\n![image](https://hackmd.io/_uploads/rkcFibgCp.png)\n\n輸入主機名稱、地址和你的SSH登錄憑證。\n![image](https://hackmd.io/_uploads/Skrx3bx0p.png)\n\n\n(可選)配置高級設置，如端口轉發規則。\n![image](https://hackmd.io/_uploads/rJRW2bxC6.png)\n\n點擊\"Save\"保存配置。\n\n## 開始遠程連線\n![image](https://hackmd.io/_uploads/Byc43WgCT.png)\n選擇你剛才創建的連接，點擊\"Connect\"開始你的遠程SSH會話。就這麼簡單！\n\n\n# 使用技巧\n* 同步你的設置：通過註冊Termius賬戶，你可以同步你的設置到雲端，從任何設備訪問你的連接。\n* 利用SNIPPETS：為常見任務創建SNIPPETS，如更新軟件包或檢查系統狀態，以提高效率。\n\n希望這篇文章能夠幫助你瞭解Termius的基本功能和如何開始使用它來管理你的遠程系統。隨著技術的發展，保持靈活和高效的遠程管理變得越來越重要，而Termius正是這樣一款適合現代IT專業人士的工具。\n","tags":["SSH","Termius"]},{"title":"Next JS 和開放式 AI / GPT：下一代 Next JS 和 AI 應用程式","url":"/2024/02/27/Next-JS-和開放式-AI-GPT：下一代-Next-JS-和-AI-應用程式/","content":"\n# [Next JS 和開放式 AI / GPT：下一代 Next JS 和 AI 應用程式](https://softnshare.com/next-js-ai/?fbclid=IwAR2pwxtLQNCUgwpeKvYi23Ge1N7Svcmi7h_mgp-jJhs41r4znT9m4Ctq1yg)\n\n# 這篇是學習Next JS 和開放式 AI / GPT：下一代 Next JS 和 AI 應用程式 課程的紀錄，\n課程上有使用到以下工具\n\n1. OpenAI 的 GPT 在應用程式中實現 AI 生成的內容\n2. Auth0 驗證 Next JS 應用程式\n3. Tailwind CSS 設計 Next JS 應用程式\n4. MongoDB 儲存 Next JS 應用程式的資料\n5. Stripe 向客戶收費\n\n其中發現台灣沒辦法使用 Stripe 收費這邊比較困擾一點，另外其他功能都有成功設定。\n\n## 第一堂課程\n\n課程教學Github: https://github.com/tomphill/blog-standard-course\nReact基礎課程: https://youtu.be/HVFSgIVXcD4\n第一堂Github連結: https://github.com/tomphill/nextjs-openai-starter \n課程連結: https://www.udemy.com/course/next-js-ai/learn/lecture/36192386?LSNPUBID=BoHFIyu6APU&components=add_to_cart%2Cavailable_coupons%2Cbase_purchase_section%2Cbuy_button%2Cbuy_for_team%2Ccacheable_buy_button%2Ccacheable_deal_badge%2Ccacheable_discount_expiration%2Ccacheable_price_text%2Ccacheable_purchase_text%2Ccurated_for_ufb_notice_context%2Ccurriculum_context%2Cdeal_badge%2Cdiscount_expiration%2Cgift_this_course%2Cincentives%2Cinstructor_links%2Clifetime_access_context%2Cmoney_back_guarantee%2Cprice_text%2Cpurchase_tabs_context%2Cpurchase%2Crecommendation%2Credeem_coupon%2Csidebar_container%2Cpurchase_body_container&ranEAID=BoHFIyu6APU&ranMID=39197&ranSiteID=BoHFIyu6APU-xOeQldV1zZ53.eDHqBvJfQ&utm_medium=udemyads&utm_source=aff-campaign#reviews\n\n# auth0 設定\n![image](https://hackmd.io/_uploads/ByWTukRo6.png)\n\n\n![image](https://hackmd.io/_uploads/rkHSYyRs6.png)\n>設定 auth0 API\n\n## 產生 AUTH0_SECRET 方式\n```\n openssl rand -hex 32\n```\n\n## 調整.env.local 設定檔案如下\n```\nAUTH0_SECRET=<AUTH0_SECRET>\nAUTH0_BASE_URL=<AUTH0_BASE_URL>\nAUTH0_ISSUER_BASE_URL=<AUTH0_ISSUER_BASE_URL>\nAUTH0_CLIENT_ID=<AUTH0_CLIENT_ID>\nAUTH0_CLIENT_SECRET=<AUTH0_CLIENT_SECRET>\n```\n\n## 新增 Application URI 設定\n![image](https://hackmd.io/_uploads/Hko7ATxja.png)\n\n## 設定auth0 登入身分驗證頁面\n新增 pages/api/auth/[...auth0].js\n\n```\nimport { handleAuth } from '@auth0/nextjs-auth0';\n\nexport default handleAuth();\n\n```\n\n## 調整 pages/index.js 檔案\n```\nimport Link from 'next/link'\nexport default function Home() {\n  return (\n    <div>\n      <h1>this is the homepage</h1>\n      <div>\n        <Link href=\"/api/auth/login\">Login</Link>\n      </div>\n    </div>\n  );\n}\n```\n\n執行 npm run dev 後打開  http://localhost:3001/\n![image](https://hackmd.io/_uploads/SyitcyAjp.png)\n\n點擊login 後可以看到身分驗證畫面\n![image](https://hackmd.io/_uploads/Syt1okAsa.png)\n\n註冊頁面\n![image](https://hackmd.io/_uploads/r1lIokCi6.png)\n\n詢問授權\n![image](https://hackmd.io/_uploads/ryWvqJRia.png)\n\n## 設定頁面必須要登入才能瀏覽\n\n舉例來說 pages/post/new.js 檔案內容:\n```\nimport { withPageAuthRequired } from \"@auth0/nextjs-auth0\";\n\nexport default function NewPost(props){\n    console.log('New Post Props:',props);\n    return (\n        <div>\n            <h1>\n                this is the new post page\n            </h1>\n        </div>\n    );\n}\n\nexport const getServerSideProps = withPageAuthRequired(() => {\n    return {\n        props:{},\n    };\n});\n```\n\n這邊的 withPageAuthRequired 就是限定使用者一定要登入才能看到這一頁的內容\n\nrepo紀錄: https://github.com/gahgah147/nextjs-openai-starter/tree/Day1-Auth0%E7%99%BB%E5%85%A5%E9%A9%97%E8%AD%89\n\n# 透過Tailwind CSS設定外觀\n\n![image](https://hackmd.io/_uploads/r1OLCBx2T.png)\n>https://tailwindcss.com/\n\n[Tailwind CSS 新手上路：概念、安裝與工具推薦](https://medium.com/@Kelly_CHI/tailwind-css-introduction-and-tools-68e770b2bf7f)\n\nTailwind CSS 是一個採用了「Utility First」理念的 CSS 框架。\n\n練習Repo: https://github.com/gahgah147/nextjs-openai-starter/tree/Day2-%E9%80%8F%E9%81%8ETailwind-CSS%E8%A8%AD%E5%AE%9A%E5%A4%96%E8%A7%80\n\n# 透過 OpenAI's GPT API 自動產生Blog 文章\n\n首先到 Openai 平台\n![image](https://hackmd.io/_uploads/SyjwaFg36.png)\n>https://platform.openai.com/\n\n登入後可以點選 Usage 查看用量\n![image](https://hackmd.io/_uploads/Sk9aRtgh6.png)\n> 像是這樣就是用完了\n\n![image](https://hackmd.io/_uploads/BJufJcln6.png)\n>這樣是還有用量可以使用\n\n## 產生 API Keys\n點選 API keys 後點擊 Create new secret key 按鈕\n![image](https://hackmd.io/_uploads/HyRHeclhT.png)\n\n這邊可以設定API key的名稱\n![image](https://hackmd.io/_uploads/ryfn-5ehT.png)\n\n成功產生API KEY\n![image](https://hackmd.io/_uploads/BkPdzqxnp.png)\n\n## 設定環境變數\n修改 .env.local 檔新增以下內容\n```\nOPENAI_API_KEY=<剛剛產生的 API KEY>\n```\n\n## 安裝 react-markdown套件\n```\nnpm i react-markdown\n```\n\n在程式碼中引用\n例如:postContent 是 markdown 的內容\n```\n\nimport Markdown from \"react-markdown\";\n\n...\n<Markdown>\n    {postContent}\n</Markdown>\n...\n```\n\n## 設定MongoDB\n\n![image](https://hackmd.io/_uploads/H1-poJ72p.png)\n>https://www.mongodb.com/atlas/database\n\n註冊後登入\n![image](https://hackmd.io/_uploads/BkfW3ymhT.png)\n>https://cloud.mongodb.com/v2/64a3c968e3797d3fc1796726#/clusters\n\n### 設定IP ADDRESS\n因為一開始如果沒有設定IP Address會無法連線到\n點選 Network Access\n\n![image](https://hackmd.io/_uploads/ByVPmx7nT.png)\n\n點選 ADD IP ADDRESS\n\n![image](https://hackmd.io/_uploads/SJk37gX2T.png)\n\n選擇 ALLOW ACCESS FROM ANYWHERE\n\n### 創建資料庫\n點選DataBase \n\n![image](https://hackmd.io/_uploads/HylDVxQn6.png)\n\n![image](https://hackmd.io/_uploads/B1hq0Zmh6.png)\n\n建立新的資料庫\n![image](https://hackmd.io/_uploads/BJRGyfQha.png)\n\n再新增一個posts table\n![image](https://hackmd.io/_uploads/SyNU1z7ha.png)\n\n點選 Connect\n![image](https://hackmd.io/_uploads/SJRcJf72T.png)\n\n產生使用者\n![image](https://hackmd.io/_uploads/Bk1beGm2T.png)\n\n設定選擇 Connect to your application\n![image](https://hackmd.io/_uploads/H1xHxMX3p.png)\n\n複製這段程式碼\n![image](https://hackmd.io/_uploads/rylnefm2p.png)\n\n修改 .env.local 檔案新增以下這一行\n```\nMONGODB_URI=mongodb+srv://user:<password>@cluster0.biiwahu.mongodb.net/?retryWrites=true&w=majority\n```\n\n這樣就能成功建立連線\n\n# 設定 Stripe 收費功能\n\n{% note warning simple %}\n這邊我發現一個問題 Stripe並不支援在台灣開立商戶帳戶 \n{% endnote %}\n\n![image](https://hackmd.io/_uploads/ryq1DtV26.png)\n>https://stripe.com/\n\n登入後創建帳號\n![image](https://hackmd.io/_uploads/ry7kYtEha.png)\n\n點選開發人員 > API 密鑰 複製 Secret key\n![image](https://hackmd.io/_uploads/SkQ4KK4np.png)\n\n修改 .env.local 檔案\n```\nSTRIPE_SECRET_KEY=<剛剛的Secret key>\n```\n\n點選添加產品\n\n![image](https://hackmd.io/_uploads/H1gkTKNnT.png)\n\n新增一個 10 tokens 的產品\n![image](https://hackmd.io/_uploads/SJghz6K43p.png)\n\n複製這邊的 API ID\n![image](https://hackmd.io/_uploads/BJMvaFNhT.png)\n\n修改 .env.local 檔案\n```\nSTRIPE_PRODUCT_PRICE_ID=<API ID>\n```\n\n## 設定Webhooks\n\n點選 Webhooks\n![image](https://hackmd.io/_uploads/SJyIOFS3p.png)\n\n點擊 在本地環境中測試\n![image](https://hackmd.io/_uploads/SJq__FB2T.png)\n\n![image](https://hackmd.io/_uploads/HkifYFrhp.png)\n\n下載CLI\n這邊後來是選擇用apt 下載\nAdd Stripe CLI’s GPG key to the apt sources keyring:\n```\ncurl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg\n```\nAdd CLI’s apt repository to the apt sources list:\n```\necho \"deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main\" | sudo tee -a /etc/apt/sources.list.d/stripe.list\n```\nUpdate the package list:\n```\nsudo apt update\n```\nInstall the CLI:\n```\nsudo apt install stripe\n```\n\n這邊會需要登入 stripe\n![image](https://hackmd.io/_uploads/HkRfW5r26.png)\n\n```\nstripe listen --forward-to localhost:3000/api/webhooks/stripe\n```\n![image](https://hackmd.io/_uploads/HJrgr9B2T.png)\n\n這樣可以取得 webhook signing secret \n\n修改 .env.local 檔案 新增 STRIPE_WEBHOOK_SECRET 內容\n```\nSTRIPE_WEBHOOK_SECRET=<webhook signing secret >\n```\n\nrepo紀錄: https://github.com/gahgah147/nextjs-openai-starter/tree/Day4-%E8%A8%AD%E5%AE%9AStripe%E6%94%B6%E8%B2%BB%E5%8A%9F%E8%83%BD\n\n# 部屬\n\n## 建立新的repository\n點選新增\n![image](https://hackmd.io/_uploads/rkLKtsK36.png)\n\n![image](https://hackmd.io/_uploads/ryJ0YiKha.png)\n\n![image](https://hackmd.io/_uploads/BkPJ5jKnp.png)\n\n## 設定 digitalocean\n\n![image](https://hackmd.io/_uploads/rJCHqoKnp.png)\n>https://www.digitalocean.com/\n\n註冊好後選擇部屬到APPs 上\n![image](https://hackmd.io/_uploads/BkfHTjKhT.png)\n\n設定連結到github \n![image](https://hackmd.io/_uploads/rJVCTjK2T.png)\n\n這邊可以選擇想要的方案，這邊選擇Edit plan\n![image](https://hackmd.io/_uploads/H1_W0iY36.png)\n\n這邊選擇最便宜的 每月5美元方案\n![image](https://hackmd.io/_uploads/B1R6-hF2a.png)\n\n## 接下來可以設定環境變數\n![image](https://hackmd.io/_uploads/HkiGM3t26.png)\n\n選擇 Bulk Editor\n![image](https://hackmd.io/_uploads/rJtVMnFha.png)\n\n複製 env.local 的所有內容\n\n![image](https://hackmd.io/_uploads/Syesf2F3T.png)\n\n![image](https://hackmd.io/_uploads/Hy2oMhYn6.png)\n\n這邊點擊後會需要等待一段時間\n![image](https://hackmd.io/_uploads/B1imR3K3p.png)\n\n成功後可以看到網站連結\n![image](https://hackmd.io/_uploads/HkXxe6tnp.png)\n\n修改環境變數 AUTH0_BASE_URL 為https://squid-app-zu4dz.ondigitalocean.app/\n![image](https://hackmd.io/_uploads/HJR9bpFha.png)\n\n修改 auth0 的環境變數\n![image](https://hackmd.io/_uploads/HkKLzTY36.png)\n>https://manage.auth0.com/\n\n\n","tags":["Next JS","AUTH0","Tailwind CSS","Stripe","MongoDB","OpenAI","GPT API"]},{"title":"GO 使用Gin和Swagger設定自動產生文件檔案","url":"/2024/02/01/GO-使用Gin和Swagger設定自動產生文件檔案/","content":"\n# 前言\n\n當開發RESTful API時，有效的文檔是極其重要的，它可以幫助開發者快速理解和使用API。Swagger是一個強大的工具，用於自動生成和維護API文檔。\n\n本文將指導你如何使用Swagger在Gin框架中自動生成API文檔，並提供一些維護的最佳實踐。\n\n# 為什麼選擇Swagger？\n\n1.標準化: Swagger遵循OpenAPI規範，這是一個業界標準。\n2.交互性: Swagger UI允許用戶直接從文檔中測試API，無需其他工具。\n\n# 安裝流程\n\n安裝必要的套件\n首先，我們需要安裝swag CLI工具和Gin的Swagger中間件。\n\nswagger cmd: 用於生成介面文件的命令列工具。\n\n```\ngo get -u github.com/swaggo/swag/cmd/swag\n```\nStarting in Go 1.17, installing executables with go get is deprecated. go install may be used instead:\n\n```\ngo install github.com/swaggo/swag/cmd/swag@latest\n```\n\ngin-swagger: gin與swagger的中介軟體。\nfiles: 幫助建立檔案\n```\ngo get -u github.com/swaggo/gin-swagger\ngo get -u github.com/swaggo/files\n```\n\n在你的主要應用文件中執行以下命令：\n```\nswag init\n```\n\n{% note warning simple %}\n![image](https://hackmd.io/_uploads/S1QZb_O5T.png)\n這邊實作遇到這個問題，後來看這篇文章\n[[Golang] “swag: command not found”error handling](https://peggy-tsai.medium.com/golang-swag-command-not-found-error-handling-52e2cbc5240e)\n\n[參考這個解法](https://github.com/swaggo/swag/issues/197?source=post_page-----52e2cbc5240e--------------------------------#issuecomment-585102353)\n\n輸入以下指令以獲得 Go 的工作路徑\ngo env GOPATH\n\n![image](https://hackmd.io/_uploads/BJ_ZV__9T.png)\n\n找路徑後到 go/bin資料夾中，輸入下方command\n```\nPATH=$(go env GOPATH)/bin:$PATH\n```\n回到專案資料夾，即可正常使用\n![image](https://hackmd.io/_uploads/BJ7PNdd5T.png)\n\n{% endnote %}\n\n這將生成docs目錄，其中包含Swagger的文檔資料。\n\n將Swagger UI加入Gin\n在你的Gin應用中，導入必要的包並將Swagger中間件添加到路由。\n```\nimport (\n    swaggerFiles \"github.com/swaggo/files\"\n\tginSwagger \"github.com/swaggo/gin-swagger\"\n    \"message/docs\"\n)\n\nfunc main() {\n    r := gin.Default()\n    docs.SwaggerInfo.BasePath = \"/api/v1\"\n    r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n    // other routes...\n    r.Run()\n}\n```\n\n這一步實作發現還要引入專案 docs 文件才行\n\n# Swagger 註解\n\n## 一般說明\n```\n// @title Gin swagger\n// @version 1.0\n// @description Gin swagger\n\n// @contact.name nathan.lu\n// @contact.url https://tedmax100.github.io/\n\n// @license.name Apache 2.0\n// @license.url http://www.apache.org/licenses/LICENSE-2.0.html\n\n// @host localhost:8080\n// schemes http\nfunc main() { ... }\n```\n\nAPI Info\n\n| 註解 | 描述 | \n| -------- | -------- | \n| title     | 必須簡單API專案的標題或主要的業務功能     | \n| version   | 必須目前這專案/API的版本     | \n| description     | 簡單描述     | \n| tersOfService     | 服務條款     | \n| contact.name     | 作者名稱     | \n| contact.url\t     | 作者blog     | \n| contact.email     | 作者email    | \n| license.name     | 必須許可證名稱     | \n| license.url    | 許可證網址     | \n| host     | 服務名稱或者是ip     | \n| BasePath     | 基本URL路徑, (/api/v1, /v2...)     | \n| schemes     | 提供的協定, (http, https)     | \n\n## API 功能註解\nAPI Operation\n\n```\nhelloHandler.go\n\n// @Summary 說Hello\n// @Id 1\n// @Tags Hello\n// @version 1.0\n// @produce text/plain\n// @Success 200 string string 成功後返回的值\n// @Router /hello [get]\nfunc GetHello(ctx *gin.Context) {...}\n\n// @Summary Delete Hello\n// @Id 1\n// @Tags Hello\n// @version 1.0\n// @produce text/plain\n// @param id path int true \"id\"\n// @Success 200 string string 成功後返回的值\n// @Router /hello/{id} [delete]\nfunc DeleteHello(ctx *gin.Context) { ... }\n```\n\n\n| 註解 | 描述 | \n| -------- | -------- | \n| summary     | 描述該API     |\n| tags     | 歸屬同一類的API的tag     |\n| accept     | request的context-type     |\n| produce     | response的context-type     |\n| param     | 參數按照 參數名 參數類型 參數的資料類型 是否必須 註解 (中間都要空一格) |\n| header     | response header return code 參數類型 資料類型 註解 |\n| router     | path httpMethod    |\n\n#  最佳作法\n\n1.保持文檔最新: 每次更新API時，確保運行swag init以更新文檔。\n2.描述和詳細: 使用Swagger註釋提供充分的API描述和範例。\n3.版本控制: 如果你的API有多個版本，確保在Swagger文檔中明確指出。\n\n# 結論\n利用Swagger與Gin結合，不僅可以自動生成API文檔，還可以提供一個交互式的界面，使其他開發者更容易理解和使用你的API。\n\n但這邊目前看來還是要人工撰寫，感覺不夠自動化，我認為需要再進一找看看有沒有自動化工具\n\n# swagger 註解自動化\n\n# 參考資料:\n\nhttps://peggy-tsai.medium.com/golang-swag-command-not-found-error-handling-52e2cbc5240e\nhttps://vocus.cc/article/650d7ee8fd89780001aa431a\nhttps://github.com/swaggo/swag/issues/197?source=post_page-----52e2cbc5240e--------------------------------#issuecomment-585102353\n\nhttps://ithelp.ithome.com.tw/articles/10224472?sc=rss.iron","tags":["go","Gin","Swagger","OpenAPI"]},{"title":"Docker -  MySql 資料庫 Container 內容持久化","url":"/2024/01/29/Docker-MySql-資料庫-Container-內容持久化/","content":"\n# 前言\n\n這篇是我看到 [[Docker] 如何讓 MySql 資料保存，不會隨著容器而消失](https://blog.mewo.com.tw/docker/docker-%E5%A6%82%E4%BD%95%E8%AE%93-mysql-%E4%BF%9D%E5%AD%98%EF%BC%8C%E4%B8%8D%E6%9C%83%E9%9A%A8%E8%91%97%E5%AE%B9%E5%99%A8%E8%80%8C%E6%B6%88%E5%A4%B1/?fbclid=IwAR29_1eWXWRUYc8w_pUzs0b8oK_1XACRTVlcqPiz60QJipYG-etzRzvJCpU)\n跟著實作的紀錄\n\n# Container 內容持久化\n\n開發的時候 Docker 扮演一個重要的角色，我們能透過 docker-compose 快速的啟用一些需要使用到 App服務. 此篇就是要來介紹，如果透過 Volume 的方式，將 MySql Container 內容持久化。\n\n\n# Docker 指令介紹\n\n根據 dokcer-compose .yaml 啟動\n```\ndocker-compose up\n```\n停止 contanier\n```\ndocker-compose stop\n```\n\n移除 container\n```\ndocker-compose down\n```\n\n使用 docker 指令的時候，很會透過 docker-compose down 來關閉 container，這時候就會發現存放在 mysql 中的 資料，在下一次啟動 container 的時候就會全部消失。\n\n# 如何解決 docker-compose down 資料也不會消失\n在 yaml 中新增 Volumes，Volumes 會將資料存放於 Container 之外，範例中就是會把資料存放於 db_data 這個資料夾\n\n```\nvolumes:\n      - ./db_data:/var/lib/mysql\n```\n\n此時使用 docker-compose down 關閉 container\n\n再透過 docker-compose up 就會發現 mysql 的資料還存在\n\n# Yaml 設定檔內容\n```\nversion: \"3.9\"\n\nservices:\n  mydb:\n    image: mysql:5.7\n    volumes:\n      - ./db_data:/var/lib/mysql\n    restart: always\n    ports:\n      - 3306:3306\n    environment:\n      MYSQL_ROOT_PASSWORD: somewordpress\n      MYSQL_DATABASE: mydatebae\n      MYSQL_USER: root\n      MYSQL_PASSWORD: password\nnetworks:\n    LAN:\n        driver: bridge\n        name: mysql_LAN\n```","tags":["Docker","MySql","Docker compose"]},{"title":"使用 Go 來寫一個 Repository Restful API 的留言板","url":"/2024/01/29/使用-Go-來寫一個-Repository-Restful-API-的留言板/","content":"\n\n# 前言\n這篇是我看到這篇文章\nhttps://github.com/880831ian/go-restful-api-repository-messageboard?tab=readme-ov-file\n跟著實作練習的紀錄，是使用 Go 來寫一個 Repository Restful API 的留言板，並且會使用 gin 以及 gorm (使用 Mysql)套件。\n另外有加入 docker-compose設定跟mysql 連線調整。\n\n# 開發環境\n## Go\n![image](https://hackmd.io/_uploads/Hy_t7sx5a.png)\n>https://go.dev/\n\n## GIN框架\n![image](https://hackmd.io/_uploads/B1ZiXjl5p.png)\n>https://gin-gonic.com/\n\n## Mysql \n![image](https://hackmd.io/_uploads/Sks3mogcT.png)\n![image](https://hackmd.io/_uploads/SJXmVogc6.png)\n\n## Docker\n![image](https://hackmd.io/_uploads/SyXkVjl56.png)\n\n# 檔案結構\n```\n.\n├── controller\n│   └── controller.go\n├── go.mod\n├── go.sum\n├── main.go\n├── model\n│   └── model.go\n├── repository\n│   └── repository.go\n├── router\n│   └── router.go\n└── sql\n    ├── connect.yaml\n    └── sql.go\n```\n\n資料夾個別功能與作用:\nsql：放置連線資料庫檔案。\ncontroller：商用邏輯控制。\nmodel：定義資料表資料型態。\nrepository：處理與資料庫進行交握。\nrouter：設定網站網址路由。\n\n## 設定 go.mod\n到開發資料夾底下\n```\ncd message_board\n```\n初始化設定 go.mod 的 module\n```\ngo mod init message\n```\n\n接著使用 go get 來引入 gin、gorm、mysql、yaml 套件\n\n```\n$ go get -u github.com/gin-gonic/gin\n$ go get -u gorm.io/gorm\n$ go get -u gorm.io/driver/mysql\n$ go get -u gopkg.in/yaml.v2\n```\n\n## main.go\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"message/model\"\n\t\"message/router\"\n\t\"message/sql\"\n)\n\nfunc main() {\n\t//連線資料庫\n\tif err := sql.InitMySql(); err != nil {\n\t\tpanic(err)\n\t}\n\t\n\t//連結模型\n\tsql.Connect.AutoMigrate(&model.Message{})\n\t//sql.Connect.Table(\"message\") //也可以使用連線已有資料表方式\n\t\n\t//註冊路由\n\tr := router.SetRouter()\n\t\n\t//啟動埠為8082的專案\n\tfmt.Println(\"開啟127.0.0.0.1:8082...\")\n\tr.Run(\"127.0.0.1:8082\")\n}\n```\n\n引入我們 Repository 架構，將 config、model、router 導入，先測試是否可以連線資料庫，使用 AutoMigrate 來新增資料表(如果沒有才新增)，或是使用 Table 來連線已有資料表，註冊網址路由，最後啟動專案，我們將 Port 設定成 8082。\n\n## sql 設定\nconnect.yaml\n```\nhost: 127.0.0.1\nusername: root\npassword: \"密碼\"\ndbname: \"資料庫名稱\"\nport: 3306\n```\n我們把 mysql 連線的資訊寫在此處。  (專案正式環境可能要加入gitignore 比較安全)\n\nsql.go (下面為一個檔案，但長度有點長，分開說明)\n```\npackage sql\n\nimport (\n\t\"io/ioutil\"\n\t\"fmt\"\n\t\"gopkg.in/yaml.v2\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/driver/mysql\"\n)\n\n```\n\nimport 會使用到的套件。\n```\nvar Connect *gorm.DB\n\ntype conf struct {\n\tHost     string `yaml:\"host\"`\n\tUserName string `yaml:\"username\"`\n\tPassword string `yaml:\"password\"`\n\tDbName   string `yaml:\"dbname\"`\n\tPort     string `yaml:\"port\"`\n}\n\nfunc (c *conf) getConf() *conf {\n\t//讀取config/connect.yaml檔案\n\tyamlFile, err := ioutil.ReadFile(\"sql/connect.yaml\")\n\t\n\t//若出現錯誤，列印錯誤訊息\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n\t\n\t//將讀取的字串轉換成結構體conf\n\terr = yaml.Unmarshal(yamlFile, c)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n\treturn c\n}\n```\n設定資料庫連線的 conf 來讀取 yaml 檔案。\n\n```\n//初始化連線資料庫\nfunc InitMySql() (err error) {\n\tvar c conf\n\t\n\t//獲取yaml配置引數\n\tconf := c.getConf()\n\t\n\t//將yaml配置引數拼接成連線資料庫的url\n\tdsn := fmt.Sprintf(\"%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local\",\n\t\tconf.UserName,\n\t\tconf.Password,\n\t\tconf.Host,\n\t\tconf.Port,\n\t\tconf.DbName,\n\t)\n\t\n\t//連線資料庫\n\tConnect, err = gorm.Open(mysql.New(mysql.Config{DSN: dsn}), &gorm.Config{})\n\treturn\n}\n```\n \n初始化資料庫，會把剛剛讀取 yaml 的 conf 串接成可以連接資料庫的 url ，最後連線資料庫。\n\n## 路由設定\nrouter.go\n```\npackage router\n\nimport (\n\t\"message/controller\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc SetRouter() *gin.Engine {\n\t//顯示 debug 模式\n\tgin.SetMode(gin.ReleaseMode)\n\tr := gin.Default()\n\n\tv1 := r.Group(\"api/v1\")\n\t{\n\t\t//新增留言\n\t\tv1.POST(\"/message\", controller.Create)\n\t\t//查詢全部留言\n\t\tv1.GET(\"/message\", controller.GetAll)\n\t\t//查詢 {id} 留言\n\t\tv1.GET(\"/message/:id\", controller.Get)\n\t\t//修改 {id} 留言\n\t\tv1.PATCH(\"/message/:id\", controller.Update)\n\t\t//刪除 {id} 留言\n\t\tv1.DELETE(\"/message/:id\", controller.Delete)\n\t}\n\treturn r\n}\n```\n設定路由，版本 v1 網址是 api/v1 ，分別是新增留言、查詢全部留言、查詢 {id} 留言、修改 {id} 留言、刪除 {id} 留言，連接到不同的 controller function 。\n\n## 資料表設定\nmodel.go\n```\npackage model\n\nimport \t\"gorm.io/gorm\"\n\nfunc (Message) TableName() string {\n\treturn \"message\"\n}\n\ntype Message struct {\n\tId        int    `gorm:\"primary_key,type:INT;not null;AUTO_INCREMENT\"`\n\tUser_Id   int    `json:\"User_Id\"  binding:\"required\"`\n\tContent   string `json:\"Content\"  binding:\"required\"`\n\tVersion   int    `gorm:\"default:0\"`\n\t// 包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位\n    gorm.Model\n}\n```\n設定資料表的結構，使用 gorm.Model 預設裡面會包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位。\n\n## controller 設定\ncontroller.go\n(下面為一個檔案，但長度有點長，分開說明)\n\n```\npackage controller\n\nimport (\n\t\"message/model\"\n\t\"message/repository\"\n\t\"net/http\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n```\nimport 會使用到的套件。\n\n查詢留言功能\n```\nfunc GetAll(c *gin.Context) {\n\tmessage, err := repository.GetAllMessage()\n\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": err.Error()})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"message\": message})\n}\n\nfunc Get(c *gin.Context) {\n\tvar message model.Message\n\n\tif err := repository.GetMessage(&message, c.Param(\"id\")); err != nil {\n\t\tc.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"message\": message})\n}\n```\n\nGetAll() 會使用到 repository.GetAllMessage() 查詢並回傳顯示查詢的資料。\n\nc.Param(\"id\") 是網址讀入後的 id，網址是http://127.0.0.1:8081/api/v1/message/{id} ，將輸入的 id 透過 repository.GetMessage() 查詢並回傳顯示查詢的資料。\n\n新增留言功能\n```\nfunc Create(c *gin.Context) {\n\tvar message model.Message\n\n\tif c.PostForm(\"Content\") == \"\" || utf8.RuneCountInString(c.PostForm(\"Content\")) >= 20 {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"沒有輸入內容或長度超過20個字元\"})\n\t\treturn\n\t}\n\n\tc.Bind(&message)\n\trepository.CreateMessage(&message)\n\tc.JSON(http.StatusCreated, gin.H{\"message\": message})\n}\n```\n使用 Gin 框架中的 Bind 函數，可以將 url 的查詢參數 query parameter，http 的 Header、body 中提交的數據給取出，透過 repository.CreateMessage() 將要新增的資料帶入，如果失敗就顯示 http.StatusBadRequest，如果成功就顯示 http.StatusCreated 以及新增的資料。\n\n修改留言功能\n```\nfunc Update(c *gin.Context) {\n\tvar message model.Message\n\n\tif c.PostForm(\"Content\") == \"\" || utf8.RuneCountInString(c.PostForm(\"Content\")) >= 20 {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"沒有輸入內容或長度超過20個字元\"})\n\t\treturn\n\t}\n\n\tif err := repository.UpdateMessage(&message, c.PostForm(\"Content\"), c.Param(\"id\")); err != nil {\n\t\tc.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, gin.H{\"message\": message})\n}\n```\n先使用 repository.GetMessage() 以及 c.Param(\"id\") 來查詢此 id 是否存在，再帶入要修改的 Content ，透過 repository.UpdateMessage() 將資料修改，，如果失敗就顯示 http.StatusNotFound 以及找不到留言，如果成功就顯示 http.StatusOK 以及修改的資料。\n\n刪除留言功能\n```\nfunc Delete(c *gin.Context) {\n\tvar message model.Message\n\n\tif err := repository.DeleteMessage(&message, c.Param(\"id\")); err != nil {\n\t\tc.JSON(http.StatusNotFound, gin.H{\"message\": \"找不到留言\"})\n\t\treturn\n\t}\n\tc.JSON(http.StatusNoContent, gin.H{\"message\": \"刪除留言成功\"})\n}\n```\n透過 repository.DeleteMessage() 將資料刪除，如果失敗就顯示 http.StatusNotFound  以及找不到留言，如果成功就顯示 http.StatusNoContent。\n\n\n## repository.go\n(下面為一個檔案，但長度有點長，分開說明)\n\n所有的邏輯判斷都要在 controller 處理，所以 repository.go 就單純對資料庫就 CRUD：\n```\npackage repository\n\nimport (\n\t\"message/model\"\n\t\"message/sql\"\n)\n```\nimport 會使用到的套件。\n\n查詢留言資料讀取\n```\n//查詢全部留言\nfunc GetAllMessage() (message []*model.Message, err error) {\n\terr = sql.Connect.Find(&message).Error\n\treturn\n}\n\n//查詢 {id} 留言\nfunc GetMessage(message *model.Message, id string) (err error) {\n\terr = sql.Connect.Where(\"id=?\", id).First(&message).Error\n\treturn\n}\n```\n\n新增留言資料讀取\n\n```\n//新增留言\nfunc CreateMessage(message *model.Message) (err error) {\n\terr = sql.Connect.Create(&message).Error\n\treturn\n}\n```\n修改留言資料讀取\n\n```\n//更新 {id} 留言\nfunc UpdateMessage(message *model.Message, content, id string) (err error) {\n\terr = sql.Connect.Where(\"id=?\", id).First(&message).Update(\"content\", content).Error\n\treturn\n}\n```\n\n刪除留言資料讀取\n```\n//刪除 {id} 留言\nfunc DeleteMessage(message *model.Message, id string) (err error) {\n\terr = sql.Connect.Where(\"id=?\", id).First(&message).Delete(&message).Error\n\treturn\n}\n```\n\n# Mysql docker-compose 設定\n因為我在實作時發現沒有做 mysql server的設定，我這邊作了以下調整\n\n## Dockerfile\n```\n# 使用 Go 官方映像作為基礎映像\nFROM golang:latest\n\n# 設定工作目錄\nWORKDIR /app\n\n# 複製 go.mod 和 go.sum 文件\nCOPY go.mod go.sum ./\n\n# 下載依賴\nRUN go mod download\n\n# 複製源代碼文件到工作目錄\nCOPY . .\n\n# 構建應用程序\nRUN go build -o main .\n\n# 暴露端口\nEXPOSE 8082\n\n# 執行應用程序\nCMD [\"./main\"]\n```\n\n## docker-compose.yml\n```\nversion: \"2.1\"\n\nservices:\n    db:\n        image: mysql:5.7\n        command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n        environment:\n            MYSQL_ROOT_PASSWORD: root\n            MYSQL_DATABASE: go\n        ports:\n            - \"3306:3306\"\n        restart: always\n\n    phpmyadmin:\n        image: phpmyadmin/phpmyadmin\n        environment:\n            PMA_HOST: db\n            PMA_PORT: 3306\n        ports:\n            - \"8084:80\"\n        depends_on:\n            - db\n\n    go-app:\n        build: .\n        ports:\n            - \"8082:8082\"\n        depends_on:\n            - db\n```\n\n這邊設定了 phpmyadmin跟 mysql 服務，另外有一個go-app 的服務運行這個專案\n\n## 啟用docker-compose\n```\ndocker-compose up -d\n```\n![image](https://hackmd.io/_uploads/HkpcFix56.png)\n>運行結果\n\n![image](https://hackmd.io/_uploads/ByzLhixca.png)\n>phpmyadmin連線\n\n# Postman 測試\n\n## 查詢全部留言 - 成功(無資料)\n![image](https://hackmd.io/_uploads/Hy_Ja5x96.png)\n\n## 查詢全部留言 - 成功(有資料)\n![image](https://hackmd.io/_uploads/HkqgWig5T.png)\n\n## 查詢{id}留言 - 成功\n![image](https://hackmd.io/_uploads/rkPUWig56.png)\n\n## 查詢{id}留言 - 失敗\n![image](https://hackmd.io/_uploads/rJeKWilqp.png)\n\n## 新增留言 - 成功\n![image](https://hackmd.io/_uploads/By2w1jxqT.png)\n\n## 修改{id}留言 - 成功\n![image](https://hackmd.io/_uploads/SyYGejec6.png)\n\n## 刪除{id}留言 - 成功\n![image](https://hackmd.io/_uploads/ByDofsxcp.png)\n\n## 執行結果\n![image](https://hackmd.io/_uploads/SJv2GoxcT.png)\n\n## 練習結果Repo\nhttps://github.com/gahgah147/go-restful-api-repository-messageboard\n\n## 測試postmain 內容 export\n```\n{\n\t\"info\": {\n\t\t\"_postman_id\": \"957a0737-049b-4605-b718-07ca8e13d683\",\n\t\t\"name\": \"GO Repository Restful API  留言板\",\n\t\t\"schema\": \"https://schema.getpostman.com/json/collection/v2.1.0/collection.json\",\n\t\t\"_exporter_id\": \"4951341\",\n\t\t\"_collection_link\": \"https://martian-escape-400870.postman.co/workspace/GO-Repository-Restful-API-%25E7%259A%2584%25E7%2595%2599%25E8%25A8%2580%25E6%259D%25BF~4f66f5ef-49b8-47c3-918f-cf7a14414aa4/collection/4951341-957a0737-049b-4605-b718-07ca8e13d683?action=share&source=collection_link&creator=4951341\"\n\t},\n\t\"item\": [\n\t\t{\n\t\t\t\"name\": \"查詢全部留言\",\n\t\t\t\"request\": {\n\t\t\t\t\"method\": \"GET\",\n\t\t\t\t\"header\": [],\n\t\t\t\t\"url\": {\n\t\t\t\t\t\"raw\": \"http://127.0.0.1:8082/api/v1/message/\",\n\t\t\t\t\t\"protocol\": \"http\",\n\t\t\t\t\t\"host\": [\n\t\t\t\t\t\t\"127\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t],\n\t\t\t\t\t\"port\": \"8082\",\n\t\t\t\t\t\"path\": [\n\t\t\t\t\t\t\"api\",\n\t\t\t\t\t\t\"v1\",\n\t\t\t\t\t\t\"message\",\n\t\t\t\t\t\t\"\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"response\": []\n\t\t},\n\t\t{\n\t\t\t\"name\": \"查詢留言\",\n\t\t\t\"request\": {\n\t\t\t\t\"method\": \"GET\",\n\t\t\t\t\"header\": [],\n\t\t\t\t\"url\": {\n\t\t\t\t\t\"raw\": \"http://127.0.0.1:8082/api/v1/message/\",\n\t\t\t\t\t\"protocol\": \"http\",\n\t\t\t\t\t\"host\": [\n\t\t\t\t\t\t\"127\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t],\n\t\t\t\t\t\"port\": \"8082\",\n\t\t\t\t\t\"path\": [\n\t\t\t\t\t\t\"api\",\n\t\t\t\t\t\t\"v1\",\n\t\t\t\t\t\t\"message\",\n\t\t\t\t\t\t\"\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"response\": []\n\t\t},\n\t\t{\n\t\t\t\"name\": \"新增留言\",\n\t\t\t\"request\": {\n\t\t\t\t\"method\": \"POST\",\n\t\t\t\t\"header\": [],\n\t\t\t\t\"body\": {\n\t\t\t\t\t\"mode\": \"raw\",\n\t\t\t\t\t\"raw\": \"{\\r\\n    \\\"message\\\":{\\r\\n        \\\"id\\\":1,\\r\\n        \\\"User_Id\\\": 2,\\r\\n        \\\"Content\\\": \\\"早安\\\",\\r\\n        \\\"Version\\\": 0,\\r\\n        \\\"ID\\\": 0,\\r\\n        \\\"CreatedAt\\\": \\\"2022-03-29T17:39:33.014+08:00\\\",\\r\\n        \\\"UpdatedAt\\\": \\\"2022-03-29T17:39:33.014+08:00\\\",\\r\\n        \\\"DeletedAt\\\": null\\r\\n    }\\r\\n}\",\n\t\t\t\t\t\"options\": {\n\t\t\t\t\t\t\"raw\": {\n\t\t\t\t\t\t\t\"language\": \"json\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"url\": {\n\t\t\t\t\t\"raw\": \"http://127.0.0.1:8082/api/v1/message\",\n\t\t\t\t\t\"protocol\": \"http\",\n\t\t\t\t\t\"host\": [\n\t\t\t\t\t\t\"127\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t],\n\t\t\t\t\t\"port\": \"8082\",\n\t\t\t\t\t\"path\": [\n\t\t\t\t\t\t\"api\",\n\t\t\t\t\t\t\"v1\",\n\t\t\t\t\t\t\"message\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"response\": []\n\t\t},\n\t\t{\n\t\t\t\"name\": \"修改留言\",\n\t\t\t\"request\": {\n\t\t\t\t\"method\": \"POST\",\n\t\t\t\t\"header\": [],\n\t\t\t\t\"body\": {\n\t\t\t\t\t\"mode\": \"raw\",\n\t\t\t\t\t\"raw\": \"{\\r\\n    \\\"message\\\":{\\r\\n        \\\"id\\\":1,\\r\\n        \\\"User_Id\\\": 2,\\r\\n        \\\"Content\\\": \\\"早安\\\",\\r\\n        \\\"Version\\\": 0,\\r\\n        \\\"ID\\\": 0,\\r\\n        \\\"CreatedAt\\\": \\\"2022-03-29T17:39:33.014+08:00\\\",\\r\\n        \\\"UpdatedAt\\\": \\\"2022-03-29T17:39:33.014+08:00\\\",\\r\\n        \\\"DeletedAt\\\": null\\r\\n    }\\r\\n}\",\n\t\t\t\t\t\"options\": {\n\t\t\t\t\t\t\"raw\": {\n\t\t\t\t\t\t\t\"language\": \"json\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"url\": {\n\t\t\t\t\t\"raw\": \"http://127.0.0.1:8082/api/v1/message\",\n\t\t\t\t\t\"protocol\": \"http\",\n\t\t\t\t\t\"host\": [\n\t\t\t\t\t\t\"127\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t],\n\t\t\t\t\t\"port\": \"8082\",\n\t\t\t\t\t\"path\": [\n\t\t\t\t\t\t\"api\",\n\t\t\t\t\t\t\"v1\",\n\t\t\t\t\t\t\"message\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"response\": []\n\t\t},\n\t\t{\n\t\t\t\"name\": \"刪除留言\",\n\t\t\t\"request\": {\n\t\t\t\t\"method\": \"DELETE\",\n\t\t\t\t\"header\": [],\n\t\t\t\t\"body\": {\n\t\t\t\t\t\"mode\": \"raw\",\n\t\t\t\t\t\"raw\": \"{\\r\\n    \\\"message\\\":{\\r\\n        \\\"id\\\":1,\\r\\n        \\\"User_Id\\\": 2,\\r\\n        \\\"Content\\\": \\\"早安\\\",\\r\\n        \\\"Version\\\": 0,\\r\\n        \\\"ID\\\": 0,\\r\\n        \\\"CreatedAt\\\": \\\"2022-03-29T17:39:33.014+08:00\\\",\\r\\n        \\\"UpdatedAt\\\": \\\"2022-03-29T17:39:33.014+08:00\\\",\\r\\n        \\\"DeletedAt\\\": null\\r\\n    }\\r\\n}\",\n\t\t\t\t\t\"options\": {\n\t\t\t\t\t\t\"raw\": {\n\t\t\t\t\t\t\t\"language\": \"json\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"url\": {\n\t\t\t\t\t\"raw\": \"http://127.0.0.1:8082/api/v1/message/1\",\n\t\t\t\t\t\"protocol\": \"http\",\n\t\t\t\t\t\"host\": [\n\t\t\t\t\t\t\"127\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t],\n\t\t\t\t\t\"port\": \"8082\",\n\t\t\t\t\t\"path\": [\n\t\t\t\t\t\t\"api\",\n\t\t\t\t\t\t\"v1\",\n\t\t\t\t\t\t\"message\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"response\": []\n\t\t}\n\t]\n}\n```\n\n# 加入Container 內容持久化設定\n```\nvolumes:\n            - ./db_data:/var/lib/mysql\n```\n在 yaml 中新增 Volumes，Volumes 會將資料存放於 Container 之外，範例中就是會把資料存放於 db_data 這個資料夾\n\n```\ndb:\n        image: mysql:5.7\n        container_name: db\n        command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n        environment:\n            MYSQL_ROOT_PASSWORD: root\n            MYSQL_DATABASE: go\n        volumes:\n            - ./db_data:/var/lib/mysql\n        ports:\n            - \"3306:3306\"\n        restart: always\n        networks:\n          - default\n```\n\n# 設定container之間的連線\n\n加入network設定\n```\nnetworks:\n  default:\n```\n\n並調整 docker-compose 檔案\n```\nversion: \"2.1\"\n\nservices:\n    db:\n        image: mysql:5.7\n        container_name: db\n        command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n        environment:\n            MYSQL_ROOT_PASSWORD: root\n            MYSQL_DATABASE: go\n        volumes:\n            - ./db_data:/var/lib/mysql\n        ports:\n            - \"3306:3306\"\n        restart: always\n        networks:\n          - default\n    phpmyadmin:\n        image: phpmyadmin/phpmyadmin\n        container_name: phpmyadmin\n        environment:\n            PMA_HOST: db\n            PMA_PORT: 3306\n        ports:\n            - \"8084:80\"\n        depends_on:\n            - db\n        networks:\n          - default\n    go-app:\n        build: .\n        container_name: go-app\n        ports:\n            - \"8082:8082\"\n        depends_on:\n            - db\n        networks:\n          - default\n\nnetworks:\n  default:\n```\n\n調整 connect.yaml\n```\nhost: db\nusername: root\npassword: root\ndbname: go\nport: 3306\n```\n\n這邊設定 db連線到db這個 container\n\n# 專案練習 Repo\nhttps://github.com/gahgah147/go-restful-api-repository-messageboard\n\n# 參考資料\nhttps://github.com/880831ian/go-restful-api-repository-messageboard?tab=readme-ov-file\n\n","tags":["Docker","Gin","後端","Go","Mysql"]},{"title":"Azure Blob Storage 設定流程","url":"/2024/01/23/Azure-Blob-Storage-設定流程/","content":"\n\n這一篇是參考以下教學文章\n[[教學] Azure Blob Storage 使用指南 – 創建篇](https://xenby.com/b/238-%E6%95%99%E5%AD%B8-azure-blob-storage-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%89%B5%E5%BB%BA%E7%AF%87)\n實作練習的紀錄\n\n\n# Azure Blob Storage 設定流程\n\nMicrosoft Azure 的 Blob Storage 提供了透過 restful api 來對檔案進行取得檔案以及對其新增、修改刪除的功能，對於在許多機房能夠同時存取非常方便，本篇將教學如何透過 azure portal 創建 Microsoft Azure 的 Blob Storage。\n\n![image](https://hackmd.io/_uploads/SkJpZ2jFp.png)\n\nBlob 主要架構分為三層\n\n![image](https://hackmd.io/_uploads/rJtXbCnFa.png)\n\n| 架構 | 說明 |\n| -------- | -------- | \n| 儲存體帳戶 (storage account)     | 表示一個倉庫帳號，一個使用者可以創間多個儲存體帳戶   |\n| 容器 (container)     | 類似於硬碟的概念，在一個 storage account 可以有多個 container，用來區分不同用途的檔案    |\n| Blob (檔案或資料)  | 類似於檔案系統的檔案，並且可以有資料夾多層式的階層來做更進一步的分類    |\n\n\n# 創建 storage account\n\n首先進入 azure portal \n\n![image](https://hackmd.io/_uploads/B1DgMChKa.png)\n>https://portal.azure.com/\n\n進入頁面中會有Azure 服務清單，點 [建立資源]\n\n![image](https://hackmd.io/_uploads/HJJdz02Fa.png)\n>接著在列表中點 [儲存體] 並選擇 [儲存體帳戶 – Blob、檔案、資料表、佇列]\n\n創建需要填寫儲存體的設定\n\n![image](https://hackmd.io/_uploads/B1Uq4AhK6.png)\n\n* 訂用帳戶：如果是公司的帳號，可能會有多個訂用帳戶用於不同場景，依照需求選擇\n* 資源群組：設定該資源設置屬於群組，可以依照不同專案或者是不同用途來區分，之後用來檢視哪些專案使用多少資源會比較方便\n* 儲存體帳戶名稱：這會影響預設的資源存取 domain，以及簽署存取簽章時需要，不過也能夠自行更改 domain 可參考：針對 Azure 儲存體帳戶設定自訂網域名稱\n* 位置：伺服器機房所在位置\n* 效能：空間硬碟的IO速度等級\n* 帳戶總類：參考 Azure 儲存體帳戶概觀，一般直接選擇 StorageV2\n* 複寫：設定資料在複製多份時會以哪種策略分布\n* 存取層：可參考 Azure Blob 儲存體：經常性、非經常性和封存存取層，主要影響讀取的速度，不同總類的價格也不同\n\n進階設定\n\n![image](https://hackmd.io/_uploads/B12CBC2ta.png)\n\n* 需要安全傳輸：進行資料傳輸過程是否加密，例如使用 restful API 存取時是否只允許使用 https\n* 大型檔案共用：是否有大檔案的需求，如果勾選後可以存放檔案大小上限達 100TB 的檔案\n* Blob 虛刪除：設定檔案刪除是否只是標記為刪除，並且支援將標記的檔案復原功能\n* 階層式命名空間：參考 Azure Data Lake 儲存體，對於極大量資料可以有好的效能\n\n網路設定\n\n![image](https://hackmd.io/_uploads/S1qNLR2FT.png)\n用於設定哪些網路可以存取此 storage，依據自己的用途選擇\n\n資料保護設定\n\n![image](https://hackmd.io/_uploads/SJciI02K6.png)\n\n加密設定\n![image](https://hackmd.io/_uploads/Sk2oPRnY6.png)\n\n標籤設定\n![image](https://hackmd.io/_uploads/SyYyOA2F6.png)\n\n最後會驗證必填的資料是否都有填寫，並且確認設定沒有錯誤按下[建立]\n![image](https://hackmd.io/_uploads/Skac_Cnta.png)\n\n等待它完成部署\n![image](https://hackmd.io/_uploads/HkV1FAnYT.png)\n\n完成部署後，可以點 [前往資源] 進行資源的檢視\n![image](https://hackmd.io/_uploads/SkhZYChFp.png)\n\n而如果要讓服務能夠使用需要先建立容器 (container)\n\n在左邊的列表中找到 [Blob服務]，並且點擊 [容器]\n![image](https://hackmd.io/_uploads/SkJ_tCnK6.png)\n\n並且點擊左上的新增容器按鈕\n\n![image](https://hackmd.io/_uploads/SJMRF0ntT.png)\n\n輸入自己想要的容器名稱，按下 [確定] 建立容器\n\n![image](https://hackmd.io/_uploads/SyP8qC3Ka.png)\n成功後進入容器就可以開始使用，可以選擇手動上傳檔案或是透過程式 API 來進行檔案新增修改刪除\n\n![image](https://hackmd.io/_uploads/r1mqoR3Kp.png)","tags":["Azure","Azure Blob Storage","雲端服務"]},{"title":"使用 Vercel 部署 NestJS 程式","url":"/2024/01/17/使用-Vercel-部署-NestJS-程式/","content":"\n# 前言 \n\n這邊我是參考這篇 [一文教会你如何使用 Vercel 部署你的 NestJS 应用](https://www.levenx.com/article/how-to-deploy-your-nestjs-application-using-vercel#heading-4) 教學文章跟著操作的紀錄\n\n# Nestjs 專案增加 vercel 設定文件\n\n在跟目錄下新增 vercel.json 文件\n\n```\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"src/main.ts\",\n      \"use\": \"@vercel/node\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"src/main.ts\",\n      \"methods\": [\n        \"GET\",\n        \"POST\",\n        \"PUT\",\n        \"DELETE\",\n        \"PATCH\"\n      ]\n    }\n  ]\n}\n```\n\n# Nestjs 專案上傳到github\n\n![image](https://hackmd.io/_uploads/rkGZLZHtT.png)\n\n# 授權给 vercel\n點選右上角頭像展開選單\n![image](https://hackmd.io/_uploads/ByXTLWBKT.png)\n\n選擇setting\n![image](https://hackmd.io/_uploads/SywhLZBt6.png)\n\n選擇 config\n![image](https://hackmd.io/_uploads/B1Ps8ZBtp.png)\n\n# Vercel 平台新增專案\n\n這邊找到剛剛建立的repo 點選import\n![image](https://hackmd.io/_uploads/rkP6w-HY6.png)\n\n修改執行命令，並且執行 deploy\n\n部屬完成\n![image](https://hackmd.io/_uploads/ryEjdZSKp.png)\n\n","tags":["Vercel","Nestjs","後端","CI/CD"]},{"title":"Nuxt3 運行在Docker 上","url":"/2024/01/11/Nuxt3-運行在Docker-上/","content":"\n# 前言\n這邊在練習Nuxt 3時想要運行在Docker 上，所以就找到這篇文章\n[將 Nuxt3 發布至 docker 中，Dockerfile 看這裡就對了](https://www.ruyut.com/2023/04/deploy-nuxt3-to-docker-with-dockerfile.html)\n實際測試可以成功，所以記錄一下過程\n\n# Dockerfile\n```\n# 使用 node 長期支援版\nFROM node:lts-alpine\n\n# 設定工作目錄\nWORKDIR /app\n\n# 複製 package.json 和 package-lock.json 至工作目錄\nCOPY package*.json ./\n\n# 依照指定版本安裝依賴\nRUN npm ci\n\n# 複製所有\nCOPY . .\n\n# 建立生產版本\nRUN npm run build\n\n# 暴露的連接埠\nEXPOSE 3000\n\n# 啟動應用程式\nCMD [\"node\", \".output/server/index.mjs\"]\n```\n\n# 打包\n\n```\ndocker build -t my-nuxt-app .\n```\n\n![image](https://hackmd.io/_uploads/r1pUUXp_T.png)\n\n\n# 啟動\n```\ndocker run -d --name nuxt-app -p 3000:3000 my-nuxt-app\n```\n![image](https://hackmd.io/_uploads/SkGuLmT_T.png)\n\n![image](https://hackmd.io/_uploads/SJX9I7pOa.png)\n> 結果成功執行","tags":["Docker","Nuxt 3"]},{"title":"LinkedIn Redesign Nuxtjs3","url":"/2024/01/09/LinkedIn-Redesign-Nuxtjs3/","content":"\n# LinkedIn Redesign Nuxtjs3\n\n# 準備Figma 設計稿\nhttps://www.figma.com/file/7EeOLaEuMD7cNIsXTM8vp0/LinkedIn-Redesign-UI-Kit-(Community)?node-id=0%3A1&mode=dev\n\n# 建立Nuxt.js 3 專案\n\nnpx nuxi@latest init nuxt-linkedIn-redesign\n\n# 把每一頁透過 Builder.io 產生程式\n\n![image](https://hackmd.io/_uploads/B1ILUFqO6.png)\n\nFramework 選擇 Vue\n![image](https://hackmd.io/_uploads/ryyKLY5Op.png)\n\n# 新增 profile page 元件\n```\nnpx nuxi add page profile\n```\n調整 app.vue 檔案\n```\n<template>\n  <div>\n    <NuxtPage />\n  </div>\n</template>\n```\n{% note info simple %}\n\n另外需要安裝 tailwindcss\n{% endnote %}\n![image](https://hackmd.io/_uploads/B1jHtt5da.png)\n\n成果:\n![image](https://hackmd.io/_uploads/BkJ_tF9ua.png)\n>http://localhost:3000/profile\n\n專案repo:\nhttps://github.com/gahgah147/nuxt-linkedIn-redesign","tags":["Builder.io","Figma","Nuxt 3","tailwindcss"]},{"title":"PixiJS 安裝設定","url":"/2024/01/09/PixiJS-安裝設定/","content":"\n# 前言\n\n這篇文章是我在 2022 iTHome 鐵人賽看到 [PixiJS青銅玩家 系列](https://ithelp.ithome.com.tw/users/20152526/ironman/5741) 文章做的一個紀錄。\n\n# PixiJS 是什麼?\nPixiJS 是一個用於創建2D網頁遊戲和互動內容的快速輕量級渲染引擎。它是一個使用JavaScript編寫的開源庫，提供了簡單而強大的API，使開發者能夠輕鬆地創建高性能的瀏覽器內遊戲和互動應用。\n\n# 安裝PixiJS\n\n## npm\n```\nnpm i pixi.js\n```\n\n## 下載JS文件\n\nhttps://github.com/pixijs/pixijs/releases\n\n可以從以上PixiJS的主要發布頁面中，找到各種版本的PixiJS，現在最新版本是v8.0.0-rc.2，往下滑到Asset的部份，可以看見很多個文件（如下圖），其中最重要的就是pixi.js跟pixi.min.js，這兩個檔案都可以使用。\n\n![image](https://hackmd.io/_uploads/By8t1DcO6.png)\n> https://github.com/pixijs/pixijs/releases/tag/v8.0.0-rc.2\n\n\n## CDN\n\nhttps://cdnjs.com/libraries/pixi.js/4.5.5\n\n![image](https://hackmd.io/_uploads/r1n7XwcuT.png)\n>https://cdnjs.com/libraries/pixi.js\n\n{% note info simple %}\n\n\n.js檔與.min.js檔案的區別\n\n|   | .js檔 | .min.js檔 |\n| -------- | -------- | -------- |\n|優點    | 可讀性高，比較好觀察、修改    | 1. 減小體積，使傳輸變快 2. 可以使JS防止被偷窺、竊取|\n|缺點   | 體積較大，傳輸較慢   |可讀性差|\n{% endnote %}\n\n# 執行\n\n在HTML執行 \n```\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>範例</title>\n</head>\n<body>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.5/pixi.min.js\" ></script>\n    <script>\n        let type = \"WebGL\"\n        if(!PIXI.utils.isWebGLSupported()){\n        type = \"canvas\"\n        }\n\n        PIXI.utils.sayHello(type)\n    </script>\n</body>\n</html>\n```\n\n當我們執行上述程式碼後，假如PixiJS成功可以運作時，以Chrome來說就可以在DevTools中的console裡面看見底下的圖片：\n![image](https://hackmd.io/_uploads/BywBnwc_p.png)\n","tags":["PixiJS","2022 iTHome 鐵人賽"]},{"title":"Nuxt 3 DevTools 視覺化工具","url":"/2024/01/03/Nuxt-3-DevTools-視覺化工具/","content":"\n# 前言\n\n這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 [Nuxt 3 實戰筆記 系列](https://ithelp.ithome.com.tw/users/20152617/ironman/6959) 文章做的一個紀錄，我之前也都有看到發表Nuxt 相關的文章，寫得都很用心仔細很值得跟著練習，我覺得最特別的是 Nuxt 新的 DevTools功能 \n\n# 安裝與啟用 Nuxt DevTools\n\n目前最新版的 Nuxt CLI 在建立專案時，預設已經預置並啟用了 Nuxt DevTools，你無需再另外設置，你可以透過專案下的 ./nuxt.config.ts 檔案確定，devtools.enabled 屬性是否設定為 true。\n\n```\nexport default defineNuxtConfig({\n  devtools: {\n    enabled: true,\n  }\n})\n```\n如果你的專案尚未啟用 Nuxt DevTools，你可以使用下列指令來為專案加入，需要注意的是 Nuxt DevTools 需要 Nuxt v3.1.0 或更高版本。\n```\nnpx nuxi@latest devtools enable\n```\n\n當你使用指令啟用 devtools，等同於下列步驟安裝與配置 @nuxt/devtools 模組。\n\n```\nnpm install -D @nuxt/devtools\n```\n\n```\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  modules: [\n    '@nuxt/devtools',\n  ]\n})\n```\n同樣的你也可以透過設定 devtools.enabled 屬性為 **false，**或使用下列指令來禁用 Nuxt Devtools。\n```\nnpx nuxi@latest devtools disable\n```\n\n接下來我們以 Nuxt 3 的演示專案 Nuxt Movies 來展示 DevTools 的功能，你也可以直接套用在你的專案搭配著本篇介紹一步一步來嘗試使用 Nuxt DevTools。\n\n接下來我們以 Nuxt 3 的演示專案 [Nuxt Movies](https://github.com/nuxt/movies) 來展示 DevTools 的功能，你也可以直接套用在你的專案搭配著本篇介紹一步一步來嘗試使用 Nuxt DevTools。\n\nfork 練習 專案 https://github.com/nalson0219/movies\n\n# 開啟 Nuxt Devtools 面板\n\n安裝並啟用 Nuxt DevTools 後，在你啟動開發伺服器後，使用瀏覽器瀏覽網站頁面上會出現一個 Nuxt Logo 的圖示，如下圖紅色框起處，通常預設會是吸附在頁面底部。\n![image](https://hackmd.io/_uploads/r1_bhFtL6.png)\n> npm run dev 開啟專案\n\n當你把滑鼠滑入圖示時，就會展開工具，如果它遮擋著你的頁面，你也可以拖曳它來移動畫面中貼附的位置。\n\n![image](https://hackmd.io/_uploads/B1K2pttIp.png)\n展開的工具共有三欄，分別為\n1.Nuxt 圖示點擊後可以開啟 Nuxt Devtools 面板\n2.導航至頁面載入時間\n3.檢查器（Inspector）\n\n\n如下圖，當我們需要開啟 Nuxt DevTools 面板，點擊頁面懸浮迷你面板最左方的 Nuxt 圖示便會開啟，當然你也可以透過快捷鍵，例如 Mac 使用 Shift + Option + D 來開啟，開啟後的面板你也可以根據需求來調整大小。\n\n![image](https://hackmd.io/_uploads/ryFw0YFUa.png)\n\n當我們點擊顯示 DevTools 面板，會出現如下圖的概覽，包含了 Nuxt 與 Vue 的版本，甚至提示你版本落後可以進行更新，蓋懶得資料也包含了整個 Nuxt 專案的資訊頁面、元件、載入、模組與插件的數量等，可以很快速的讓你了解專案概況。\n\n![image](https://hackmd.io/_uploads/HJbqRKYIa.png)\n\n# 使用 Nuxt DevTools 檢查器（Inspector）\n\n當你的專案是接手維護或規模比較大的團隊協作時，Nuxt DevTools 整合了 [vite-plugin-vue-inspector](https://github.com/webfansplz/vite-plugin-vue-inspector) 插件，\n這項功能使元件的調整更加的容易，你也可以不必深入完整了解專案結構，就能快速定位渲染的程式。\n\n\n![image](https://hackmd.io/_uploads/B1Drz9KUa.png)\n>點擊檢查器後，當滑鼠滑入畫面的元素便會提示元件檔案位置與行數，點擊後能前往該檔案。\n\n{% note warning simple %}\n這功能我目前測試有問題，點開是不會跳到那邊\n{% endnote %}\n\n# Nuxt DevTools 工具面板介面功能\n![image](https://hackmd.io/_uploads/SJp9QcYI6.png)\n\n如果你是第一次使用或想要調整工具面板的設定，可以點選左下角的圖示，如下圖紅色框起處，就會切換至設定的分頁，在這裡你可以決定左側選單的項目顯示或隱藏，這將有助於關閉一些對你來說不重要的分頁圖示，你也可以在這裡修改深色模式、懸浮迷你面板的縮小間隔時間與 UI 縮放等設置。\n\n![image](https://hackmd.io/_uploads/H1TzEcYIp.png)\n\n基本上 Nuxt DevTools 面板上可以使用功能，多數只要切換至該功能分頁，你就能理解它將帶給你的資訊與協助。\n\n# 小結\n目前 Nuxt DevTools 雖然還處於預覽階段，但已經有許多強大的功能，未來 Nuxt DevTools 計畫提供更直觀、更有趣的方式來呈現數據，除了輕鬆管理與建立 Nuxt 的專案外，在開發工具上也提高框架約定的透明度來改善開發體驗，如果你有興趣也可以關注 Nuxt DevTools 的專案並分享想法與建議甚至做出貢獻，更多資訊與功能也可以查看[官方文件](https://github.com/nuxt/devtools)。\n\n\n# Pages \n在開啟 Nuxt Tools 工具面板後，我們切換到 Pages 分頁。\n![image](https://hackmd.io/_uploads/S1EMrcF86.png)\n\nPages 分頁展示了目前專案所有註冊的頁面路由 (Rotes) 與路由中間件 (Middleware)。\n\n##  所有註冊的頁面路由 -  All Routes \n\n![image](https://hackmd.io/_uploads/HylgUqYI6.png)\n\n\n如果你不熟悉頁面檔案所產生的路由名稱，在下圖的紅色框起處的路由名稱，可以幫助你在使用程式化導航時，以具名的方式來前往路由，如 router.push({ name: 'search' })。\n\n你可以點擊路由的路徑網址就可以同步網頁進行路由導航，點擊就會跳轉至 /search 搜尋頁面，當然你也可以透過面板上方的輸入框來編輯導航路徑。\n\n\n## Middleware\n你也可以看到屬於全域、匿名或僅適用於客戶端或伺服器的路由中間件，點擊就能開啟編輯器跳轉至實作的特定行數。\n\n# Components\nComponents 分頁展示了目前專案所有的元件 (Components)，可以在這邊使用搜尋框搜尋元件的名稱，也可以依據使用與非使用中的元件來進行過濾。\n\n![image](https://hackmd.io/_uploads/BJ4i1jFLa.png)\n\n元件以四種分類的方式於面板上呈現，分別如下：\n\n| 元件類型 | 說明 | \n| -------- | -------- | \n| User components     | 使用者自行建立的元件，通常是放置在專案 ./components 目錄下的元件。 | \n| Runtime components |  在執行時期使用的元件，通常有使用才打包進來。| \n| Built-in components    | Nuxt 的內建元件。 | \n| Components from libraries   |  由外部模組或套件所提供的元件。 | \n\n![image](https://hackmd.io/_uploads/rkgUxjKUp.png)\n\n![image](https://hackmd.io/_uploads/HJHjgstI6.png)\n\n你可以點擊如下圖示按鈕，元件將會以圖 (Graph) 的視覺化效果來呈現，專案中使用的元件彼此之間的關聯。\n![image](https://hackmd.io/_uploads/H18cSoFU6.png)\n\n\n![image](https://hackmd.io/_uploads/Skq_SoKUa.png)\n\n如果透過元件名稱或圖的表示的元件關聯，不能夠滿足你搜尋畫面中所呈現的元件，你可以嘗試使用檢查器 (Inspector)，如下圖紅色框起處的圖示，它的執行方式類似於瀏覽器的除錯工具「檢查元素」。\n\n\n# 組合式函式 - Imports\nImports 分頁展示了目前專案所有的組合式函式 (Imports)，你可以在這邊使用搜尋框搜尋組合式函式的名稱，也可以依據使用與非使用到的組合式函式來進行過濾。\n\n\n![image](https://hackmd.io/_uploads/H1J4IjFIT.png)\n\n元件以四種分類的方式於面板上呈現，分別如下：\n\n|  Imports 類型 | 說明 |\n| -------- | -------- | \n| User composables    | 使用者自行建立的組合式函式，通常是放置在專案 ./composables 目錄下的式。| \n| Built-in composables    | 內建元件，例如 Nuxt 提供的 navigateTo 和 Vue 的 computed 等。 | \n| Components from libraries    | 由外部模組或套件所提供的組合式函式。 | \n\n![image](https://hackmd.io/_uploads/r1ebDiYIp.png)\n\n你可以在這個分頁搜尋與篩選組合式函式，在使用的函式名稱上也會標示綠色 x1, x2 表示使用的次數，當你點擊組合式函式，除了可以複製與跳轉至原始碼的實作，部分組合式函式有提供文件，也可以透過按鈕快速地前往官方文件查看使用說明。\n\n# Modules\n\nModules 分頁展示了，Nuxt 專案內所使用的模組，也會顯示模組版本、官方網站與 GitHub 專案等資訊。\n\n![image](https://hackmd.io/_uploads/HkQG_sYIa.png)\n\n可以點選右下角的 Install New Module 來搜尋並安裝新的 Nuxt 模組\n![image](https://hackmd.io/_uploads/rywNdiF8T.png)\n\n如果專案中使用的模組版本落後，在面板上也會顯示最新的版本號，如下圖紅色框起處，點擊後也會提示升級的指令，或透過介面一鍵升級。\n\n# 靜態資源 - Assets \n\n如下圖 Modules 分頁展示專案內的靜態資源讓你可以在這邊快速瀏覽與搜尋，不過目前僅支援專案下的 public 目錄的檔案。\n![image](https://hackmd.io/_uploads/r1UcOiY8p.png)\n\n![image](https://hackmd.io/_uploads/r1RPFiF8T.png)\n> 需要填入啟動開發伺服器的終端機上提示的 Token 或點擊連結來授權，就可以開始使用。\n\n![image](https://hackmd.io/_uploads/HkJTYsYUa.png)\n> 圖片可以直接拖曳上傳\n\n# 專案內部 Server - Server Routes\n\nServer Routes 分頁展示了目前專案內部 Server API，它可以方便你針對 ./server 目錄下建置的內部 API 來發送與測試 HTTP 請求，有點類似輕便版的 Postman，專為開發者提供的 API 測試工具。\n\n![image](https://hackmd.io/_uploads/r1Km9otUa.png)\n\n# 使用儲存層的資料 - Storage\nStorage 分頁展示了網站伺服器使用到儲存層 (Storage Layer) 時的資料，這項功能對於有使用 Nuxt 建立內部伺服器 API 與搭配使用 Nitro 提供內建儲存層來抽象檔案系統或資料庫做快取操作等。\n\n![image](https://hackmd.io/_uploads/H1HJojtLa.png)\n\n# VS Code\nNuxt DevTools 整合了 VS Code Server，讓完整的 VS Code 編輯器可以整合至開發工具內，也可以安裝 VS Code 的插件及導入你個人化的設定。\n\n接下來，我們切換到下圖紅色框起處的 VS Code 分頁。\n![image](https://hackmd.io/_uploads/rJDXsst8T.png)\n\n![image](https://hackmd.io/_uploads/S10KcLf_6.png)\n\n{% note info simple %}\n這邊要指定 code server port 3080\n{% endnote %}\n\n```\ncode-server --port 3080\n```\n\n\n\n![image](https://hackmd.io/_uploads/BkzKL_zda.png)\n>成功啟用 code server\n\n# Hooks\n\n![image](https://hackmd.io/_uploads/HyzguOzO6.png)\n\nHooks 分頁展示了網站客戶端與伺服器端使用的 Hooks，分頁上條列各個 Hook 名稱、監聽事件數量、執行數與花費時間，對於模組的作者或更進階的使用，它可以幫助你檢查問題與瓶頸進而調整網站的效能。\n\n![image](https://hackmd.io/_uploads/BkkS_dfdT.png)\n\n# Virtual Files\n\n![image](https://hackmd.io/_uploads/S1yvOuGu6.png)\n\nVirtual Files 分頁展示了 Nuxt 產生的虛擬文件，虛擬文件是動態產生的，某些情況你可能會使用到這些檔案，但這些產生的檔案主要是為了支援框架的約定，也屬於適合模組或比較進階的開發者，並更提供更好的開發者體驗。\n\n![image](https://hackmd.io/_uploads/BklSFdOG_T.png)\n\n# Inspect\n![image](https://hackmd.io/_uploads/HkX3ddMdT.png)\n\nInspect 分頁整合了 antfu/vite-plugin-inspect 插件，如下圖，你可以切換不同的呈現方式，或者觀看 Vite 插件的執行時間等。\n\n\n![image](https://hackmd.io/_uploads/HkxeKOfup.png)\n\n![image](https://hackmd.io/_uploads/HJClFOMOp.png)\n\n# Module Contributed View\n\n考量了 Nuxt 的生態系統，Nuxt DevTools 的開發與設計上非常的靈活也具擴展性，不管是官方、社群或個人的模組，都可以像 DevTools 貢獻自己的分頁，使模組也能整合進 Nuxt DevTools 中並提供使用者進行交互。\n\n舉例來說，專案上使用到了 VueUse 與 Viteest 這兩個模組，而且這兩個模組都有整合至 Nuxt DevTools 的分頁中，如下圖在 DevTools 的面板左側就能看到 VueUse 與 Vitest 兩個圖示分頁。\n\n在 VueUse 模組分頁上提供了可使用的組合式函式的搜尋頁面與文件說明。\n\n![image](https://hackmd.io/_uploads/rymwsdf_a.png)\n\n#  Nuxt Vitest \n\n![image](https://hackmd.io/_uploads/BJtmnOzuT.png)\n>import Vitest  模組\n\n![image](https://hackmd.io/_uploads/Sk_G2OfOa.png)\n\n![image](https://hackmd.io/_uploads/HJJgndMu6.png)\n\n# Runtime Configs\n![image](https://hackmd.io/_uploads/rJAEStzOp.png)\n\nRuntime Configs 分頁展示了目前專案 App Config 及公開與私有的 Runtime Configs，這邊也有個小細節，如果是私有的設定 Private Runtime Config，預設是不會展開的。\n\n![image](https://hackmd.io/_uploads/rJ2ISYMda.png)\n\n在每個分類的設定中，都可以使用 JSON Editor 來進行新增編輯與驗證等操作，例如新增一個 primaryColor，如果你編輯數值也會同步響應至變數。\n\n![image](https://hackmd.io/_uploads/r1e9rYfOT.png)\n\n# Payload\n\n![image](https://hackmd.io/_uploads/rkPirKfua.png)\n\nPayload 分頁展示了網站中使用到組合式函式 useState、useAsyncData 與 useFetch 所建立的狀態，這些狀態在伺服器端建立時，會以 JSON Payload 與 HTML 一併回傳給客戶端重複做使用，讓客戶端不必在次請求資料直接在 Payload 中取得。\n\n![image](https://hackmd.io/_uploads/H120rYfO6.png)\n\n你也可以在 State 或 Data 狀態分類中修改各個狀態JSON 結構的 Payload，修改的值也會同步的響應至狀態，例如我們修改頁面中使用 useAsyncData 得到的文章資料 Payload，修改後的 title 頁面中也會同步響應呈現。\n\n\nState 或 Data 狀態分類中，每個狀態都擁有兩個圖示按鈕 Refresh View 與 Generate Data Scheme，分別可以重新同步頁面上的狀態及產生狀態的 Scheme。\n\n![image](https://hackmd.io/_uploads/BkwSLYz_T.png)\n\n# Open Graph\n![image](https://hackmd.io/_uploads/SyPqLKz_T.png)\n\nOpen Graph 分頁，能幫助你在做網頁的 SEO 搜尋引擎最佳化時，查看你對網頁設定的 Meta Tags 並提醒與建議你遺漏的 Meta Tags，除了可以透過上方網址列快速跳轉到其他頁面，也使用旁邊的按鈕圖示來開啟檔案、重新整理資料，另外你也透過面板提供的預覽功能，查看你的 Open Graph Tags 是否設定正確，它以常見的社群媒體預覽不同樣式的連結縮圖。\n\n![image](https://hackmd.io/_uploads/rJnkDYM_T.png)\n\n面板上不僅會呈現遺漏的建議標籤，也可以透過如下圖的紅色框起處，來使用工具提供建議的程式碼片段來添加建議的 Meta Tags。\n\n![image](https://hackmd.io/_uploads/r1lBwYGuT.png)\n\n# Plugins\n\n![image](https://hackmd.io/_uploads/Hy7SKKM_6.png)\nPlugins 分頁依序展示了專案中插件的載入，包含了使用者自訂、套件模組的插件，並依序條列的載入出來，每個插件也會標記上來自於套件或哪個目錄下的檔案，也會依據伺服器端、客戶端等類型來特別標記插件。\n\n![image](https://hackmd.io/_uploads/rJBDYYfup.png)\n\n標示了各個插件載入執行所花費的時間與所有插件的執行總時間，插件在載入執行的時間，其實間接的影響到頁面的請求時間，所以如果對於效能要求比較高的網站，使用介面提供資訊能輔助你追蹤載入較費時的插件。\n\n# Timeline\n![image](https://hackmd.io/_uploads/B1N9KFz_6.png)\n\nTimeline 分頁的功能就像是瀏覽器開發者工具的時間線 (Timeline)，可以讓你追蹤網站的耗費時間的分佈，例如 DOM 事件、分頁元件的渲染等，Nuxt DevTools 的 Timeline 功能預設是關閉的，如下圖依據指引進行啟用就可以開始使用該功能。\n\n![image](https://hackmd.io/_uploads/ByD_stzdp.png)\n>在介面上按下 Start Tracking，並開始操作網頁上的事件，例如點擊連結，介面就會開始紀錄函式的呼叫與花費時間。\n\n\n","tags":["Nuxt 3","2023 iTHome 鐵人賽","DevTools","Vue","前端框架"]},{"title":"Nuxt 3 使用 Nuxi 建立模板檔案","url":"/2023/12/14/Nuxt-3-使用-Nuxi-建立模板檔案/","content":"\n# 前言\n\n這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 [Nuxt 3 實戰筆記 系列](https://ithelp.ithome.com.tw/users/20152617/ironman/6959) 文章做的一個紀錄，我之前也都有看到發表Nuxt 相關的文章，寫得都很用心仔細很值得跟著練習，我覺得最特別的是 Nuxt 新的 DevTools功能 \n\n# 使用 nuxi 快速建立模板檔案\n\n建立檔案的指令格式如下：\n```\nnpx nuxi add <TEMPLATE> <NAME> [--cwd] [--force]\n```\n| 變數 | 功能 | \n| -------- | -------- | \n| TEMPLATE | 指定要產生的檔案模板類型，目前支援專案內常會使用到的 component、page 與伺服器 api 等。 |\n| NAME     | 填寫檔案名稱，也可以以路徑串接，來建立子資料夾中的檔案     | \n| --cwd     | 指定專案起始目錄，預設為 .。    | \n| --force   | 如果檔案存在，強制覆蓋檔案。    | \n\n\n## 建立路由頁面 - nuxi add page \n舉個例子，建立一個 about 路由頁面：\n```\nnpx nuxi add page about\n```\n\n產生出的檔案 ./pages/about.vue 內容如下，預設會有一個模板提供給使用者快速進行後續開發。\n```\n<script lang=\"ts\" setup></script>\n\n<template>\n  <div>\n    Page: foo\n  </div>\n</template>\n\n<style scoped></style>\n\n```\n\n![image](https://hackmd.io/_uploads/ByRF-EuLp.png)\n\n產生出的檔案 ./pages/category/[id].vue\n\n```\nnpx nuxi add page \"category/[id]\"\n```\n\n![image](https://hackmd.io/_uploads/r1jfoEdUp.png)\n\n\n## 建立 composable - nuxi add composable\n```\nnpx nuxi add composable foo\n```\n\n建立 ./composables/foo.ts 檔案\n![image](https://hackmd.io/_uploads/B1_vsVuUa.png)\n\n![image](https://hackmd.io/_uploads/HJKLjVO8a.png)\n\n## 建立 layout - nuxi add layout\n```\nnpx nuxi add layout custom\n```\n\n建立 ./layouts/custom.ts 檔案\n![image](https://hackmd.io/_uploads/BJjciEOL6.png)\n\n![image](https://hackmd.io/_uploads/SyN3iVO8T.png)\n\n## 建立元件 - nuxi add component \n```\nnpx nuxi add component TheHeader\n# 等價\nnpx nuxi add component TheHeader --mode \"client|server\"\n```\n![image](https://hackmd.io/_uploads/HyNo0V_UT.png)\n\n建立 ./components/TheHeader.vue 檔案\n\n在建立元件時，可以添加修飾參數 --mode \"client|server\"、--client、--server，來建立客戶端或伺服器端的元件。\n\n```\nnpx nuxi add component TheFooter --client\n# 等價\nnpx nuxi add component TheFooter --mode client\n```\n![image](https://hackmd.io/_uploads/HkQTC4OIp.png)\n\n建立 ./components/TheFooter.client.vue 檔案\n\n\n```\nnpx nuxi add component TheFooter --server\n# 等價\nnpx nuxi add component TheFooter --mode server\n```\n\n![image](https://hackmd.io/_uploads/ByMZyBuUa.png)\n\n建立 ./components/TheFooter.server.vue 檔案\n\n![image](https://hackmd.io/_uploads/HJO71rd86.png)\n\n\n## 建立插件 - nuxi add plugin\n\n```\nnpx nuxi add plugin analytics\n```\n\n插件的建立，同樣也可以添加修飾參數 --mode \"client|server\"、--client、--server。\n![image](https://hackmd.io/_uploads/rJsSJHuIp.png)\n\n建立 ./plugins/analytics.ts 檔案\n\n![image](https://hackmd.io/_uploads/SkaPkBdLp.png)\n\n## 建立路由中間件 - nuxi add middleware\n\n```\nnpx nuxi add middleware auth\n```\n![image](https://hackmd.io/_uploads/ByEBlrdLT.png)\n建立路由中間件 ./middleware/auth.ts 檔案。\n\n建立時可以添加修飾參數 --global 用以建立通用的全域路由中間件，舉例來說，建立 ./middleware/always-run.global.ts 檔案。\n\n```\nnpx nuxi add middleware always-run --global\n```\n![image](https://hackmd.io/_uploads/rkwvlSu8a.png)\n\n\n\n![image](https://hackmd.io/_uploads/B1_KxBu8T.png)\n\n\n## 建立伺服器 API - nuxi add api\n\n```\nnpx nuxi add api hello\n```\n\n![image](https://hackmd.io/_uploads/S1ehZruUT.png)\n\n建立伺服器 API 處理程式 ./server/api/hello.ts。\n\n建立時可以添加修飾參數 --method post、--method delete 等用以建立不同請求方法的 API，舉例來說，建立 ./server/api/items.post.ts 檔案。\n\n```\nnpx nuxi add api items --method post\n```\n\n![image](https://hackmd.io/_uploads/r1_abrdU6.png)\n\n\n>支援請求方法的參數有 connect, delete, get, head, options, patch, post, put 或 trace\n\n![image](https://hackmd.io/_uploads/BkK1MBOL6.png)\n\n\n# 小結\nnuxi add 指令最重要的是透過指令建立的模板，你不需要在擔心要在哪一個目錄建立，使用的約定是什麼，Nuxt CLI 將會幫你處理好並建立在對應的目錄，在使用 nuxi add 指令建立的模板檔案時，因為 Nuxt 內置了 TypeScript，所以你會發現模板實作多以 TypeScript 的方式來定義，不過也不影響尚未導入 TypeScript 的專案，僅需要把一些 TypeScript 的關鍵字移除及重新命名檔案名稱後，就可以接續檔案內的實作範例來做開發，對於開發上還是能提升不少的速度。\n\n# 心得\n這邊觀察下來我認為算是一個框架規範，每個人使用的話就都會產生固定格式的東西","tags":["Nuxt 3","2023 iTHome 鐵人賽","Vue","前端框架","nuxi"]},{"title":"Nuxt 3 實戰學習筆記 - 環境設定","url":"/2023/12/14/Nuxt-3-實戰學習筆記-環境設定/","content":"\n# 前言\n\n這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 [Nuxt 3 實戰筆記 系列](https://ithelp.ithome.com.tw/users/20152617/ironman/6959) 文章做的一個紀錄，我之前也都有看到發表Nuxt 相關的文章，寫得都很用心仔細很值得跟著練習，我覺得最特別的是 Nuxt 新的 DevTools功能 \n\n# Nuxt CLI 指令\n\nnuxi 全名為 (Nuxt CLI, Nuxt Command Line Interface)，是由 Nuxt 提供開發的標準工具，Nuxt CLI 就像是 Vue CLI 可以建立 Vue 專案，我們當然也就可以使用 Nuxt CLI 來建立 Nuxt 的專案。\n\n# 環境準備\n\n環境準備流程如下，通常主要會用到的nuxi 指令也是這幾個\n\n清除 npx 快取\n建立 Nuxt 專案\n檢查專案相關資訊\n升級 Nuxt 3 版本 \n啟動開發伺服器\n清除自動產生的 Nuxt 檔案和快取\n產生靜態網站使用的預渲染\n打包專案建構生產環境需要的程式包\n預覽網站\n開發工具 Nuxt DevTools\n\n\n更多完整的指令與用法可以參考[官方文件](https://nuxt.com/docs/api/commands/init)。\n \n## 清除 npx 快取 - clear-npx-cache\n\n```\nnpx clear-npx-cache\n```\n![image](https://hackmd.io/_uploads/Syy08m_8T.png)\n\n\n當一切準備就緒後，你可以執行下列指令，它將會安裝最新版本的 Nuxt CLI 並執行 --help 來看相關說明。\n\n```\nnpx nuxi@latest --help\n```\n\n如果你有看到如下圖的相關指令說明，就代表你安裝成功囉！\n![image](https://hackmd.io/_uploads/HJsbvQ_UT.png)\n\n## 使用 nuxi 建立 Nuxt 專案與啟動開發伺服器\n如果你第一次使用 Nuxt 3，依據官網的範例，你可以在終端機執行下列指令，就能開始建立 Nuxt 的專案：\n```\nnpx nuxi@latest init nuxt-app\n```\n\n![image](https://hackmd.io/_uploads/B1bpPX_U6.png)\n> 建立的過程\n\n這邊首先會問  Which package manager would you like to use?\n選擇 npm\n\nAre you interested in participating?\n\n操作完成之後會告訴你接下來如何開啟專案\n✨ Nuxt project has been created with the v3 template. Next steps:\n › cd nuxt-app\n › Start development server with npm run dev\n \n當你在開發時，可以在專案資料夾內執行下列指令來啟動開發伺服器：\n```\nnpm run dev\n```\n\n上述指令，實際上是執行 package.json 中的 scripts 所定義的 dev 對應腳本指令如下：\n```\nnuxt dev\n```\n\n其實也等同於你在專案目錄下執行：\n```\nnpx nuxi dev\n```\n\nnuxi 不僅在啟動開發伺服器與部署編譯上需要使用，開發的過程中，也還有許多不同的指令與參數可以操作使用，以幫助我們開發 Nuxt 專案上的使用。\n\n## 檢查 Nuxt 專案相關資訊 -info\n```\nnpx nuxi info\n```\n![image](https://hackmd.io/_uploads/HydWK7OIp.png)\n\n## 升級 Nuxt 3 版本  -upgrade\n\n```\nnpx nuxi upgrade\n```\n\n這個指令可以用來將目前專案的 Nuxt 3 升級至最新的版本，如果有一些可能行為調整或不相容的情況，可以再依據實際情境搭配 -f, --force 參數來強制更新。\n\n![image](https://hackmd.io/_uploads/By8Qh7OLp.png)\n\n\n## 啟動開發伺服器 - run dev\n\n一個新建立的 Nuxt 專案，當你要啟動開發伺服器，你可以使用下面的指令：\n```\nnpm run dev\n# 或\nnpx nuxi dev\n```\n\nNuxt 的 Nitro 就會幫我們啟動開發伺服器，並監聽 Port: 3000。\n![image](https://hackmd.io/_uploads/BJSPKmdI6.png)\n\n### --port, -p 設定監聽Port\n預設監聽 Port: 3000，若因為衝突或有需要做調整可以使用這個參數\n```\nnpm run dev -- -p 5173\n# 等價\nnpx nuxi dev -p 5173\n\n```\n>使用 npm 執行 scripts，可以加上兩個減號 -- 以添加腳本指令後的參數。\n\n\n### --host, -h 設定 伺服器主機名稱\n\n預設伺服器主機名稱為 localhost，若因為一些跨域或驗證等開發需求，也可以調整\n\n### --open, -o 設定 開啟瀏覽器\n\n當開發伺服器啟動時，開啟瀏覽器並導向到開發的網址。\n\n### --https 設定 啟用https\n在開發時若有一些驗證或請求需要 HTTPS，也可以使用這個參數來啟用 HTTPS，預設情況也含有自簽名的 SSL 證書。\n\n![image](https://hackmd.io/_uploads/rJkfi7dIa.png)\n\n## 清除自動產生的 Nuxt 檔案和快取 -cleanup\n\n```\nnpx nuxi cleanup\n```\n\nNuxt 3 在啟動開發伺服器後，會自動建立 .nuxt 目錄與產生相關的檔案或 TypeScript 使用的類型，建構專案或產生靜態網站時也會建立 .output 或 dist 目錄等，我們可以使用指令來清除這些自動產生的檔案和快取。\n\n### 刪除的目錄包含如下：\n\n* .nuxt\n* .output\n* dist\n* node_modules/.vite\n* node_modules/.cache\n\n\n## 產生靜態網站使用的預渲染  -generate\n\n```\nnpx nuxi generate\n```\n\n我們可以使用以下指令來預渲染專案中的每個路由路徑，並將其結果儲存在純 HTML 當中，其產生的檔案會建立在 .output/public 與 dist 目錄，兩個目錄的檔案內容是一樣的，你可以選擇使用 .output/public 作為靜態網站的部署。\n\n![image](https://hackmd.io/_uploads/BJ9vh7_UT.png)\n\n## 打包專案建構生產環境需要的程式包  -build\n\n```\nnpx nuxi build\n```\n\n當專案開發到一個階段要準備部署時，你會需要打包並建構生產環境所需要的程式，你可以使用以下指令來編譯建構。\n\n![image](https://hackmd.io/_uploads/r10chQOLa.png)\n\n這個指令會建立一個 .output 目錄，其中包含所有應用程式、伺服器與依賴配置，你可以將此目錄作為生產環境使用的目錄進行服務部署。\n\n## 預覽網站 -preview\n\n當使用 nuxi build 專案打包建構完成後，你可以使用下 preview 指令來啟動伺服器，預覽你的 Nuxt 網站。\n\n```\nnpx nuxi preview\n```\n\n![image](https://hackmd.io/_uploads/BkT9pQd86.png)\n\n\n## 開發工具 Nuxt DevTools \n\n```\nnpx nuxi devtools enable\n```\n\n透過最新版本 Nuxt CLI 建置的 Nuxt 3 專案已經將 Nuxt DevTools 預置在 Nuxt 專案中並預設為啟用，如果你的專案的 Nuxt 3 版本還比較舊，可以手動安裝 Nuxt DevTools，或使用以下指令來配置。\n\n![image](https://hackmd.io/_uploads/ByJT67uUT.png)\n\n### 關閉 Nuxt DevTools\n\n```\nnpx nuxi devtools disable\n```\n如果你想要關閉 Nuxt DevTools，可以使用以下指令來關閉，它會提示您是否要將 ./nuxt.config.ts 檔案內的 devtools.enabled 設定為 false 來關閉 DevTools。\n\n\n# 參考來源:\n\nhttps://ithelp.ithome.com.tw/users/20152617/ironman/6959\nhttps://nuxt.com/docs/api/commands/init\n","tags":["Nuxt 3","2023 iTHome 鐵人賽","Vue","前端框架"]},{"title":"Python 網頁服務開發的 UX 與 DX 比較","url":"/2023/11/27/Python-網頁服務開發的-UX-與-DX-比較/","content":"\n這篇文章是我在 Agoda Engineering 部落格的文章閱讀紀錄\n[UX vs. DX in Python Web Servers](https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1)\n\n# UX vs. DX in Python Web Servers\n\nAgoda在11月舉辦了一場與曼谷Python社群合作的ThaiPy聚會。\n演講者是Agoda的高級軟體工程師Mohamad Kamar，他分享了有關“Python Web伺服器中的UX vs DX”的演講。\n他深入探討了Python在Web伺服器架構方面的多樣性，從簡單的同步伺服器到複雜的異步和基於框架的伺服器。\n這篇博客文章總結了演講中討論的要點。\n\n# 什麼是 UX and DX ?\n\n使用者體驗（UX）指的是使用者與網路應用程式互動的整體體驗。\n這包括速度、可用性、可存取性以及整體使用者滿意度等考慮因素。\n\n開發者體驗（DX）代表開發者在建構、維護和擴展網路應用程式時的經驗。\n易於設置、程式碼可維護性和除錯能力等因素在這裡扮演重要的角色。\n\n當專注於改善開發者體驗（DX）或使用者體驗（UX）時，通常會為另一方帶來間接的好處。\n例如，對功能開發速度的關注能夠提供更簡化的結果給最終使用者體驗，同時降低錯誤出現的機率，從而幫助開發者。\n\n# 探索 Python 功能\n\nPython的多用途性彰顯在其處理各種網頁伺服器架構的能力上，從處理一次請求的簡單同步伺服器到更複雜的異步和基於框架的伺服器，Python提供了廣泛的選擇。\n\n每種方法對使用者體驗（UX）和開發者體驗（DX）都有其獨特的影響。\n\n![image](https://hackmd.io/_uploads/BkFj2wWBT.png)\n> 圖片來源: https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1\n\n[XKCD Python Fly Library import](https://xkcd.com/353/)\n\n# 如何衡量網頁伺服器程式碼的開發者體驗\n\n評估開發者體驗（DX）涉及探索多個方面。\n儘管我的分析具有主觀性，但旨在提供在Python網頁伺服器開發中DX景觀的清晰概述：\n\n以下是這些具體區域的分解：\n\n\n1. 安裝的便利性：啟動伺服器有多輕鬆？這包括文件的品質、入門模板的可用性、所需的依賴項數量以及在設置過程中錯誤消息的清晰度等方面。\n1. 代碼可讀性：這是開發者能夠輕鬆導覽和理解代碼庫的程度。這包括命名慣例、代碼組織、註釋的使用，以及是否遵守Python的風格指南（PEP 8）等因素。\n1. 可維護性：此組件評估測試、擴展、更新、修復和增強代碼的簡單程度。可維護性受可移植性的影響（代碼是否可以在不進行重大重構的情況下移動或適應不同的環境或框架）、模塊化和是否遵循最佳實踐等。\n1. 調試設施：這涉及評估網頁伺服器提供的工具和功能，以幫助識別和解決代碼問題。這包括本地調試工具、記錄設施、錯誤消息以及與外部調試工具集成的便利性。 \n\n\n以這些為我們分析DX的基礎，我們可以比較不同方式構建Python網頁伺服器在相互之間的表現。\n\nhttp.server：作為標準Python庫的一部分，http.server的設置是簡單明瞭的，但它僅提供基本功能，對於複雜應用程式的可維護性產生影響。調試和測試能力很大程度上取決於您使用的其他Python庫。\n\n值得注意的是，http.server模組本身的文檔頁面建議開發者不要使用這些庫來構建生產應用程式，因為它缺乏安全功能。\n\n![image](https://hackmd.io/_uploads/S1E9x_ZSa.png)\n> 圖片來源: https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1\n\naiohttp：由於它的異步性質，這使得設置比http.server更為複雜。\n然而，使用Python的asyncio可以實現更有效的I/O操作，對於I/O密集型應用程式，這對可維護性產生積極影響。aiohttp的文檔提供了調試的線索，但測試異步代碼可能會更具挑戰性，需要使用Python的asyncio測試工具。\n\n此外，aiohttp是一個非常輕量的庫，功能沒有這個列表上的其他庫多，通常被用作創建網頁伺服器的補充庫，而不是主要的構建塊。根據JetBrains進行的開發者調查：\n\n>\"大多數框架的受歡迎程度在年復年之間保持穩定。唯一的例外是提供異步程式設計支援的庫。asyncio庫在2022年達到歷史最高水平（21%），aiohttp顯示了輕微的增加，而httpx首次在調查中亮相，被9%的受訪者選擇。\"\n\n![image](https://hackmd.io/_uploads/BJq7bd-BT.png)\n> 圖片來源: https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1\n\n[Python Developer Survey](https://www.jetbrains.com/lp/devecosystem-2022/python/)\n\n* FastAPI：FastAPI因其快速且簡便的設置而受到讚譽，這要歸功於巧妙使用Python型別提示。FastAPI促進可維護的代碼，並包含用於調試和測試支援的內建文檔。\n\n* Flask：以其極簡的方式，Flask提供了簡單的設置和靈活的環境。它為開發者提供了一系列選擇，儘管它缺乏內置的調試工具，但可以透過擴展（如Flask-Debug Toolbar）獲取這些功能。\n\n* Django：以其“一切皆備”的理念而聞名，很多東西在安裝時就已經設置好了，這使得Django對新用戶來說可能有點壓倒性。但一旦配置完成，Django的高度模塊化和可重用的代碼可以使維護變得更加可管理。它配備了一個強大的ORM和管理面板，這可以協助調試，並且還有一個內置的測試框架。\n\nFastAPI、Django和Flask目前是市場上使用最多的框架，其次是Tornado和一些較不知名的庫。對即將到來的部分進行一點預告，前5名最常用的Python庫中沒有一個在最高性能評分中得分。\n\n![image](https://hackmd.io/_uploads/ryQDf_bST.png)\n> 圖片來源: https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1\n\n[Python Developer Survey](https://www.jetbrains.com/lp/devecosystem-2022/python/)\n\n# Developer Preference\n\n開發者的偏好是由個人經驗和項目需求所塑造的。\n隨著時間的推移，他們自然而然地傾向於他們熟悉的技術。\n這種熟悉感提升了他們的舒適度和效率。\n例如，一位精通Django的開發者可能會在網頁伺服器任務中偏好使用它，熟悉其功能、社區和文檔。\n\n項目需求在很大程度上影響開發者在網頁伺服器和框架中的選擇。項目的性質和範圍決定了最佳選擇。\n開發者可能會傾向於使用Flask來創建一個輕量級、小規模的應用程式，而對於功能較為豐富、複雜的項目，可能會選擇Django或Pyramid。\n像伺服器負載、實時更新以及對強大文檔和社區支援的需求等因素也可能影響這些決策。\n\n# Performance Considerations\n性能是選擇網頁伺服器的一個關鍵因素。\n在比較網頁庫的性能時，考慮到WSGI和ASGI標準是很重要的。\n像aiohttp和FastAPI這樣的異步庫是為ASGI環境（例如uvicorn）設計的，而Django和Flask則默認使用WSGI設置（例如gunicorn），可能需要額外的努力進行其他部署。\n\n# Striking a Balance: UX and DX Optimization\n\n平衡使用者體驗（UX）和開發者體驗（DX）更像是一門藝術而非科學。這是關於為正確的任務選擇合適的工具。每個框架的實用性在很大程度上取決於你的具體用例。如果你的項目規模相對較小，使用像Django這樣的重量級框架可能會顯得過於臃腫。相反，像Flask或FastAPI這樣的極簡選擇可能更合適。\n\n對於需要廣泛內建功能且使用一個有主觀意見的框架不是問題的更大、更複雜的項目，Django可能是一個更合適的選擇。如果你喜歡極簡的方法並且喜歡從頭開始建立一切的過程，考慮使用aiohttp。\n\n# Conclusion\n\n選擇合適的Python網頁伺服器框架需要在使用者體驗（UX）和開發者體驗（DX）之間取得平衡。\n每個框架都提供獨特的功能，適用於不同的項目需求。\n了解這些差異並將其與項目需求相一致是實現最佳網頁伺服器選擇的關鍵。\n\n# References\n[Django vs. Flask comparison](https://medium.com/@tj.joyson/an-another-django-vs-flask-comparison-which-one-is-better-236a163c18c6)\n[Python developer survey](https://www.jetbrains.com/lp/devecosystem-2022/python/)\n\n\n# 文章來源 :https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1\n\n","tags":["Python","Agoda Engineering 部落格","UX","DX"]},{"title":"優化前端分析：Agoda 開發者的品質策略與工具","url":"/2023/11/27/優化前端分析：Agoda-開發者的品質策略與工具/","content":"\n這篇文章是我在 [Agoda Engineering 部落格](https://medium.com/agoda-engineering)的文章閱讀紀錄\n[Refining Front End Analytics: Quality Strategies and Tools for Developers at Agoda](https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f)\n\n# Front End (FE) Analytics at Agoda\n\n在Agoda，前端（FE）分析是一個動態框架，旨在追蹤使用者在前端應用程式中的行為和互動。\n這個系統每天處理超過35億個事件，並分析超過1500個上下文字段，對於塑造和優化Agoda面向客戶、合作夥伴和內部應用程式的使用者體驗至關重要。\n\nFE Analytics 提供了一系列廣泛的功能，以滿足Agoda不同專業需求：\n\n* 開發人員和品質保證（QA）：在生產中進行調試和監控用戶互動，並識別問題或趨勢方面發揮了關鍵作用。\n* 產品擁有者：基於新添加的功能計算用戶互動趨勢的變化，並證明/否定提升用戶體驗的假設方面發揮了作用。\n* 分析師：檢查用戶互動中的模式，提供有關不同假設的報告和儀表板方面發揮了作用。\n* 機器學習：檢測詐騙用戶並根據先前的互動個性化搜索結果方面發揮了作用。\n\n\n就隱私擔憂而言，我們確保在這個數據集中不會記錄任何可識別個人信息（PII）。\n數據嚴格僅包含與領域相關的基於互動的上下文，而不是用戶，以符合全球隱私標準，同時保護用戶數據並提供有價值的見解。\n\n![image](https://hackmd.io/_uploads/H1KDVap4p.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n目前，開發人員必須手動將每個事件添加到這個表中，這在保持一致的高質量數據方面存在挑戰。由於有眾多開發人員參與，對最佳實踐的不同解釋，以及可能存在人為錯誤的可能性，確保數據質量具有挑戰性。\n\n本文突顯了我們努力提高數據質量並實施檢查和平衡措施以識別和解決問題的努力。\n\n# Understanding Data Quality\n\n對於依賴數據做出決策的企業而言，確保數據的準確性和適用性至關重要。\n\n忽視這一點可能導致重大後果，例如：\n\n* 可能導致收入損失的誤導性決策。\n* 錯失的機會。\n* 對所有參與者而言的時間和精力浪費。\n\n![image](https://hackmd.io/_uploads/By6y8T6Ep.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n如何衡量所生成數據的質量？我們已經提出了以下需要牢記的因素，特別是針對 FE Analytics，但這些原則應該適用於任何一般數據集。\n\n![image](https://hackmd.io/_uploads/HJ8VYTpVa.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n# The Frontend Data Team\n\n\n在Agoda，有一個專門的團隊致力於構建和維護圍繞用戶互動事件的框架。\n這個團隊由Web和移動應用程式開發人員組成，專注於在源頭最大程度地提高數據質量。\n他們的任務是建立流程，確保更好的數據質量，有時這可能會影響開發人員的體驗和交付時間。\n\n![image](https://hackmd.io/_uploads/BJgpiT6V6.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n以下是這個團隊針對提升數據質量所提出的概述。\n\n# FE Analytics Framework\n\nFE分析框架的開發始於對現有系統的全面審查。\n\n# Building blocks\n\n一個事件通常包含兩個部分:\n\n* 發生事件：用戶在特定應用程序的頁面上與元素進行互動。\n* 內容：該事件周圍狀況的各種狀態。\n\n![image](https://hackmd.io/_uploads/By32h664p.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n# The rocky development process\n\n先前對於發送這些數據是沒有控制的。以下是跟蹤一個硬編碼事件而沒有任何控制的過程。\n\n![image](https://hackmd.io/_uploads/SyTgpaTNT.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n\n基於產品擁有者的需求，開發人員將事件硬編碼，推出了該功能，然後等待了幾天以收集足夠的數據進行分析。\n\n在這一點上，如果幸運的話，他們可能有了良好的數據，或者發現了需要在分析中修復的問題，這將導致進一步的延遲。\n這導致了精力的浪費和延遲的結果，本來可以幫助評估KPI的實現。如果不幸的話，他們可能會做出不受支持的決策，可能影響功能的採用。\n\n隨著時間的推移，這個框架已經進化以應對這些問題，現在提供了一個早期警報系統，用於確定分析是否值得信賴。\n\n\n# Classifying the Issues\n\n為了增強我們FE Analytics的效能，我們將各種團隊遇到的挑戰分類為需要解決的特定類型的問題。\n這些問題可以與事件本身的構建塊相關聯。\n\n## Bad events\n\n* 誤導性事件 — 不正確的操作類型、頁面或應用程式名稱\n* 實施問題 — 事件重複、事件遺漏。\n\n## Bad context\n\n* 誤導性上下文 — 上下文的值錯誤或難以分析。\n* 缺失上下文 — 需要的值遺失。\n\n\n除此之外，我們還存在一個問題，那就是可靠地確定哪個團隊擁有特定的事件。\n我們還需要控制數據，確保人們僅發送純粹的用戶互動，而不將數據混合用於其他目的（如加載時間和內部狀態）。\n![image](https://hackmd.io/_uploads/HkJzATpE6.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n# Defining Events\n\n開發人員首先需要在一個集中的儲存庫中定義一個事件。由於表的扁平結構包含1500多個列，其中在任何給定事件中大多數列都將是空的，我們需要確保特定元素、頁面或應用程式的必需字段是存在的。\n\n因此，這個集中式儲存庫提供了一個用於定義事件的API，看起來如下所示。\n\n![image](https://hackmd.io/_uploads/HyKV1RT4p.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n在定義被創建之後，由我們擁有這個集中式 C# 儲存庫的團隊進行 MR（Merge Request）審查，並對事件的設計質量發表評論。我們確保人們發送必要的事件和上下文，檢查命名以及其他質量準則。\n\n這也成為預期事件的真實來源，從中我們可以:\n\n* 目錄事件\n* 標記事件的擁有權\n* 生成封裝事件標識和上下文的類型化對象\n* 生成用於捕捉回歸的驗證規則。\n\n一旦一切都得到批准，MR（Merge Request）就會被合併。從這一點開始，代碼被生成並作為事件類型的庫的一部分進行部署。\n\n# Implementing Events Using the FE Analytics Library\n\n這個庫基本上提供了一種改進的開發人員體驗，同時確保追踪的事件是前一狀態定義中生成的代碼對象。\n\n在這裡，我們在UI框架的頂部提供了觀察者，以直觀地在UI本身上直接追踪正確的操作。對於事件觀察，我們目前提供API支持\n\n* HTML DOM Observers for web applications\n* SwiftUI for iOS\n* Jetpack Compose for Android\n\n除此之外，我們還允許開發人員從應用程序的邏輯層手動追踪事件，盡管我們強烈建議他們盡可能使用觀察者。\n\n通過使用為事件生成的類型與觀察者，我們確保他們在預期的上下文中追踪元素上的正確操作。\n\n除了提供新的API之外，還需要更多，因為許多事件是使用舊的實現發送的。我們還需要開發人員將事件遷移到新系統，主要是為了進行目錄化和標記擁有權。這可能是一個挑戰，我們還投入了更多的努力來實現更簡便的代碼遷移，正如我的同事在文章[《應對舊代碼：我們如何通過元編程在Agoda加速代碼遷移》](https://medium.com/agoda-engineering/tackling-legacy-code-how-we-accelerate-code-migration-at-agoda-with-metaprogramming-ead43f4ffe4a)中所描述的。\n\n# Testing the Events\n\n測試分析數據是有爭議的，因為編寫測試對於像追踪事件這樣的“簡單”事物被認為很昂貴，往往容易被忽視。為了幫助簡化這個過程，我們的團隊提供了一套與觀察/追踪API綁定的測試工具，以減少撰寫測試所需的步驟。\n\n我們最少期望開發人員能夠手動測試事件，以確保基本合理性。\n然而，這也是一個具有挑戰性的經歷，因為人們必須查看網絡層，基本上是在冗長的請求主體中尋找他們的事件，猶如在一堆中尋找針芥。\n\n最終，儘管已經編寫了測試並通過手動檢查確保事件正確，但在生產環境中仍然有可能發生一些問題。假設根據用例場景（國家、貨幣、屬性等）考慮上下文的所有可能值，那麼上下文的可能組合使得幾乎不可能確保不發生任何回歸。\n\n因此，我們設計了一個系統，利用基於定義生成的規則在prelive和production環境中驗證事件，並根據所涵蓋的情景提供最大的反饋。\n\n# Providing Pre and Post-Production Feedback\n\n我們的驗證系統基於實現JSON Schema規範。\n我們從定義中生成一個JSON Schema“規則”，然後與兩個系統同步，以不同的方式提供反饋。\n\n* 來自分析伺服器的實時反饋：這僅發生在pre-live應用程序中，可在開發或pre-live測試期間使用。\n* 生產後監控：我們無法實時驗證所有事件，因為參與的規模和計算量太大。因此，該系統驗證在生產中接收的一部分事件，並將其記錄下來，我們的報告讀取並將這些問題轉換為直接在擁有事件的團隊的問題追踪看板上提出的錯誤。\n\n![image](https://hackmd.io/_uploads/BkFWBATVa.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n最終，這個設置使得分析開發週期在產品擁有者分析數據之前，具有更多檢查點，以提供反饋，並意識到分析存在問題。\n\n![image](https://hackmd.io/_uploads/ry5VS0aVp.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n# Improving the Debugging Experience\n\n即使這些反饋機制已經就位，我們的開發人員在使用實時反饋機制時仍然需要協助。\n這是相當冗長的，需要一些努力來準確找出他們分析中的問題。\n\n為了使這個過程更加直觀，我們提供了一個開發人員工具，作為一個名為 Mimir 的Chrome擴展的一部分。\n該工具幫助用戶可視化和調試從應用程序發送出去的分析。\n它逐一顯示應用程序發送的分析，如果從伺服器接收到任何驗證反饋，則將其突顯顯示。它不僅連接到瀏覽器中運行的當前Web會話，而且我們還允許其他非Web應用程序通過使用QR碼進行遠程連接，將分析顯示在這個調試器上。\n\n![image](https://hackmd.io/_uploads/Bk_0HRp4T.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n![image](https://hackmd.io/_uploads/Hku1806Ea.png)\n>圖片來源: https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f\n\n有了這一點，我們將體驗提升到一個難以爭辯的地步，即由於任何困難，不進行手動測試分析是困難的。\n\nMimir Chrome擴展對Agoda的內部用戶提供的不僅僅是調試分析的功能，這是另一篇文章的主題。\n\n# Conclusion\n\n在Agoda，FE Analytics對於收集和分析用戶互動數據至關重要，這對於提升用戶體驗至關重要。\n由於這個系統的每個事件都需要由開發人員實現，存在錯誤和不一致性的可能性很高，最終可能導致錯誤的決策，以及時間和收入的損失。為了確保數據質量並減少任何可能的問題，FE數據團隊維護了一個系統和流程，使開發人員能夠定義、實現和測試他們的事件，在開發過程中獲得早期反饋，並通過觀察生產中的事件提前發出警告。\n\n這個流程仍然有很大的改進空間，我們正在努力設計更好的API和保護措施，以在分析問題進入生產之前預防它們。\n\n# 文章來源:https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f","tags":["Agoda Engineering 部落格","前端","Front End Analytics","Front End"]},{"title":"Google Analytics 4 練習紀錄","url":"/2023/11/13/Google-Analytics-4-練習紀錄/","content":"\n這篇是記錄我在看[鐵人賽  跟著 OXXO 一起學 GA4 ( Google Analytics 4 )](https://ithelp.ithome.com.tw/articles/10314237) 的過程 \n\n# GA4 介紹\n\n## GA4 是什麼？\n\nGoogle Analytics 4 ( GA4 ) 是 Google 的最新版本分析工具，與過去的版本不同的是，GA4 更加注重事件驅動的分析，除了支持跨設備和跨平台數據收集，也提供了更多人工智慧和機器學習功能，能夠更有效地透過流量了解使用者。\n\nGA4 以「事件 Events」為資料收集的基礎，除了幾個基本事件，如果要分析額外資訊，則需要自行建立其他額外事件，這種全新的資料收集架構，大幅提高在商業應用上的深度與彈性，但也增加了不少學習門檻，且 GA4 目前仍在不斷發展階段，許多未來「可能調整」的介面或功能，也是導入 GA4 時需要面對的挑戰。\n\n## 發展歷程\n\n自 2005 年推出以來，GA 整合了許多的功能，已經成為一個廣泛使用且不可或缺的分析工具，下方簡單整理了 GA 的發展歷程與重要里程碑：\n\n| 年份 | 概要 | \n| -------- | -------- | \n| 1997     | 網站數據分析工具 Urchin 誕生    | \n| 2005     | Google 收購 Urchin，正式推出 Google Analytics ( GA )。    | \n| 2008\t    | 加入 Custom Reports 和 Advanced Segments 功能，增強自訂分析和進階分析的能力。  | \n| 2009\t    | 加入 Event Tracking 功能，增強深度監測和分析使用者互動行為。  | \n| 2011\t    | 加入 Multi-Channel Funnels ( MCF ) 功能，降低多管道歸因分析門檻，並加入 Real-Time 即時監看數據的功能。 | \n| 2012\t    | 發佈 Google Tag Manager ( GTM )，讓使用者更能有效地整合自己的 GA 程式碼。 | \n| 2012\t    | 發佈Universal Analytics ( UA )，允許跨設備和跨平台數據收集。 | \n| 2013\t    | 發佈 Measurement Protocol 測量協議，定義從任何系統或裝置傳送資料到 Google Anlaytics 的方法。 | \n| 2014\t    | 發佈 Enhanced ecommerce，增強電商處理數據功能。 | \n| 2016\t    | 發佈 Google Analytics 360，整體解決方案升級為 Google Analytics Solutions。 | \n| 2018\t    | 發佈 Google Marketing Platform，整合 Google Analytics 360 和 DoubleClick。 | \n| 2019\t    | 發佈 APP + Web Property ( 取代 Google Analytics For APP )。| \n| 2020\t    | 發佈 Google Analytics 4 ( GA4 )，也是 APP + Web 的延伸。| \n| 2023\t    | 全面使用 GA4，停用通用版本 GA。| \n\n## 特色\n1. 智慧化報告：透過更加智慧化的報告，更容易了解使用者行為。\n1. 注重資料隱私：更強大的資料隱私功能，可以更好地保護用戶的資料安全 ( 例如無 Cookie 的評估功能、行為與轉換模擬 )。\n1. 跨設備追蹤：具有跨設備追蹤功能，可以追蹤使用者在不同設備上的互動。\n1. 事件驅動：以事件 (而非工作階段) 為基礎的資料。\n1. 客製化功能：具有更加靈活的客製化功能，可以根據使用者需求定製不同的報告。\n1. 整合媒體平台：整合 Google 廣告系統，可以更好地管理網絡廣告。\n1. 預測功能：不需要複雜模型即可提供指引。\n\n# 建立分析資源\n\n## 單純建立 GA4 分析資源\n登入 Google 帳戶之後，從下方的網址可以前往 Google Analytics 平台：\n![](https://hackmd.io/_uploads/BJzAdSAM6.png)\n>https://analytics.google.com/analytics/web/provision/#/provision\n\n{% note info simple %}\n點擊開始評估就能啟用 Google Analytics 的帳戶\n{% endnote %}\n\n![](https://hackmd.io/_uploads/S1DuKrRMT.png)\n>在帳戶設定步驟，將「帳戶共用設定」的共用方式全部勾選 ( 或是使用預設值也可以 )。\n\n在資源設定步驟，輸入資源名稱以及對應的貨幣、時區，進階選項會詢問是否建立通用版的 GA，根據個人需求選擇是否同時建立 ( 因為 2023 年 7 月以後 Google 不支援通用版 GA，因此可以不用建立 )。\n![image.png](https://hackmd.io/_uploads/SJItkkbXa.png)\n\n![image.png](https://hackmd.io/_uploads/ByksJ1Z7p.png)\n>建立商家資訊\n\n![image.png](https://hackmd.io/_uploads/HJT61kZQT.png)\n>選擇業務目標\n\n![image.png](https://hackmd.io/_uploads/ryaSxJ-QT.png)\n>設定資料串流\n\n![image.png](https://hackmd.io/_uploads/HJ8qxkZXa.png)\n>一個 GA4 的分析資源就會建立完成。\n\n\n如果已經有 Google Analytics 的帳戶和資源，點擊左下角的「設定」按鈕圖示，就能「建立帳戶」或從現有帳戶「建立資源」。\n\n#  安裝資料收集代碼\n\n![image.png](https://hackmd.io/_uploads/rJB7VCW7a.png)\n點擊該筆資料串流，開啟串流設定畫面後捲動到最下方，點擊「查看代碼操作說明」。\n\n![image.png](https://hackmd.io/_uploads/S1S8EAZQa.png)\n> 複製要放在網站中的資料收集代碼，並將這些資料收集代碼，按照說明放在網頁的 HTML 中\n\n```\n<!-- Google tag (gtag.js) -->\n<script async src=\"https://www.googletagmanager.com/gtag/js?id=G-RQQ6S8TM5J\"></script>\n<script>\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'G-RQQ6S8TM5J');\n</script>\n```\n\n## 測試 GA4 資料收集代碼\n參考下方範例程式碼，將資料收集代碼放入網頁 HTML 裡，可以使用 JS Bin 的線上網頁編輯器進行測試 ( 參考「使用測試網頁」)。\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n\n  <!-- Google tag (gtag.js) -->\n  <script async src=\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXX\"></script>\n  <script>\n    window.dataLayer = window.dataLayer || [];\n    function gtag(){dataLayer.push(arguments);}\n    gtag('js', new Date());\n    gtag('config', 'G-XXXXXX);\n  </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n網頁開啟後，應該就能在 GA4 資源的「首頁」裡，看到過去 30 分鐘的使用者出現「1」個使用者，這也表示資料收集代碼已經順利安裝成功。\n>GA4 的「即時」通常可能會有三十秒到一分鐘左右的延遲。\n要正確執行代碼，不能單純開啟網頁，而是要在本機環境啟用一個網頁伺服器，或使用 JS Bin 的線上網頁編輯器進行測試 ( 參考「使用測試網頁」 )\n\n![image.png](https://hackmd.io/_uploads/ByXNBAWQT.png)\n\n## 查看 GA4 資料串流評估 ID\n如果要查看 GA4 資料串流評估 ID，可以從「管理 > 資源 > 資料串流」裡，點擊想要查看的資料串流。\n![image.png](https://hackmd.io/_uploads/H1RvBCbmp.png)\n\n## 刪除與還原帳戶\n\n如果要刪除帳戶，可以從「管理 > 帳戶 > 帳戶詳情」的頁面，點擊「丟進垃圾桶」就能刪除帳戶。\n![image.png](https://hackmd.io/_uploads/BJ1k1uwm6.png)\n>點擊「丟棄帳戶」，就會將該帳戶放入垃圾桶。\n\n![image.png](https://hackmd.io/_uploads/rkTgJuDQ6.png)\n\n前往「已經被丟棄的帳戶」的「管理 > 帳戶 > 垃圾桶」，就能看到被刪除的帳戶，垃圾桶中的項目在保留 35 天之後，就會永久刪除。系統會在變更記錄中留下刪除記錄 ( 帳戶如果存在垃圾桶中，無法使用帳戶設定以及篩選器功能 )。\n\n\n![image.png](https://hackmd.io/_uploads/ryU7k_wmp.png)\n\n勾選要還原的帳戶，點擊「還原」，就能還原帳戶 ( 還原帳戶需要有「編輯者」權限的使用者 )。\n![image.png](https://hackmd.io/_uploads/rkwV1_wQa.png)\n\n## 刪除與還原資源\n如果要刪除資源，可以從「管理 > 資源 > 資源設定」的頁面，點擊「丟進垃圾桶」就能刪除資源。\n![image.png](https://hackmd.io/_uploads/rkOv1_wma.png)\n\n點擊「移至垃圾桶」，就會將該資源放入垃圾桶。\n![image.png](https://hackmd.io/_uploads/r10_JuPQa.png)\n\n前往「管理 > 帳戶 > 垃圾桶」，就能看到被刪除的資源，垃圾桶中的項目在保留 35 天之後，就會永久刪除。系統會在變更記錄中留下刪除記錄，點擊「還原」，就能還原資源 ( 還原帳戶需要有「編輯者」權限的使用者 )。\n\n## 移動資源\n\n移動資源功能可以將資源從「來源」帳戶移至「目標」帳戶，移動資源時，例如代碼 ID、資源設定、資料串流、報表資料、資源層級整合等項目會跟著移動，但是例如變更記錄則會保留在來源帳戶中。如果要移動資源，可以從「管理 > 資源 > 資源設定」的頁面，點擊「移動資源」。\n\n![image.png](https://hackmd.io/_uploads/ry91gdwma.png)\n\n選擇要移動到的帳戶，勾選確認變更後，點擊「開始移動」就會移動資源。\n\n![image.png](https://hackmd.io/_uploads/Bk6Wguv7a.png)\n\n## 查看帳戶與資源變更紀錄\n\n只要帳戶有所更動，在「管理 > 帳戶 > 帳戶變更紀錄」裡都會看到相關資訊。\n\n![image.png](https://hackmd.io/_uploads/SySte_w76.png)\n\n如果是資源變更資訊，可以在「管理 > 資源 > 資源變更紀錄」裡看到相關資訊。\n\n![image.png](https://hackmd.io/_uploads/SkNugOvQa.png)\n\n## 開啟設定輔助程式\n\n![image.png](https://hackmd.io/_uploads/HJWQGuvXT.png)\n設定輔助程式可以讓使用者快速進行 GA4 的常用設定，只要點擊各項設定後方的「>」，就會引導至對應的設定畫面或直接進行設定，如果勾選標示完成，上方也會顯示完成的進度條。\n\n設定輔助程式可以進行的設定\n下方列出設定輔助程式可以進行的相關設定：\n\n| 設定 | 說明 |\n| -------- | -------- | \n| 收集網站和應用程式資料     | 前往「資料串流」新增資料串流收集資料( 教學參考 )。     | \n| 啟用 Google 信號     | 前往「資料設定 > 資料收集」啟用或關閉 Google 信號( 教學參考 )。     | \n| 設定轉換     | 前往「轉換」管理轉換事件( 教學參考 )。     |\n| 定義目標對象     | 前往「目標對象」管理目標對象。     |\n| 連結至 Google Ads    | 前往「Google Ads 連結」管理 Google Ads 的連結。  |\n| 針對 GA4 轉換出價    | 確認是否使用GA4 轉換出價。  |\n| 將廣告指定給 GA4 目標對象  | 確認是否將廣告指定給 GA4 目標對象。  |\n| 管理使用者 | 前往「資源存取管理」管理使用者權限，或匯入通用版 GA 使用者資料。  |\n| 匯入資料 | 確認是否使用匯入資料 ( 教學參考 )。  |\n| 連結至 BigQuery | 前往「BigQuery 連結」管理與 BigQuery 的連結。  |\n| 設定 User-ID | 確認是否使用 User-ID ( 教學參考 )。  |\n| 使用 Measurement Protocol | \t確認是否使用 Measurement Protocol ( 教學參考 )。  |\n\n# 使用測試網頁\n\n## JS Bin\n\n> 網址：https://jsbin.com/?html,output\n\n開啟 JS Bin 後，將 GA4 的資料收集代碼貼到 HTML 欄位的程式碼裡，放在 </head> 之前，按下右上角的「Run width JS」就會執行網頁，隨後在 GA4 的即時監控中就能看到出現一個使用者。\n\n![image.png](https://hackmd.io/_uploads/Hkwfd3KmT.png)\n\n## JSFiddle\n> 網址：https://jsfiddle.net/\n\n開啟 JSFiddle 後，將 GA4 的資料收集代碼貼到 HTML 欄位的程式碼裡，按下左上角的「Run」就會執行網頁，隨後在 GA4 的即時監控中就能看到出現一個使用者。\n\n![image.png](https://hackmd.io/_uploads/Hy9qKhYm6.png)\n\n## CodePen\nCodePen 是一個偏向「網頁作品展示」的線上編輯器，除了可以編輯 HTML、CSS 和 JavaScript，更加入社群的功能，讓程式設計師可以在平台裡分享自己的程式作品。\n\n> 網址：https://codepen.io/\n\n開啟 CodePen 後，將 GA4 的資料收集代碼貼到 HTML 欄位的程式碼裡，按下左上角的「Run」就會執行網頁，隨後在 GA4 的即時監控中就能看到出現一個使用者。\n![image.png](https://hackmd.io/_uploads/BkjFs2tma.png)\n\n#  啟用示範帳戶\nGoogle Analytics 示範帳戶是功能完整的 GA 帳戶，可供任何 Google 使用者存取。其中包含一個通用版 GA 資源和兩個 GA4 資源，在 Google 官方教學裡，也是使用示範帳戶進行展示，這篇文章會介紹如何啟用 Google Analytics 示範帳戶。\n\n## 存取示範帳戶\nGoogle Analytics 提供了三個示範帳戶，登入並建立 Google Analytics 帳戶後 ( 參考「建立分析資源」)，點擊示範帳戶網址，示範帳戶就會自動加入自己的 GA 資源裡 ( 參考「示範帳戶」 )。\n\n>[Google Analytics (分析) 4 資源：Google 商品網路商店 (網站資料)](https://support.google.com/analytics/answer/6367342#access&zippy=%2C%E6%9C%AC%E6%96%87%E5%85%A7%E5%AE%B9)\n>[Google Analytics (分析) 4 資源：Flood-It! (應用程式和網站資料)](https://support.google.com/analytics/answer/6367342#access)\n>[通用 Analytics (分析) 資源：Google 商品網路商店 (網站資料)](https://support.google.com/analytics/answer/6367342#access&zippy=%2C%E6%9C%AC%E6%96%87%E5%85%A7%E5%AE%B9)\n\n# GTM\nGTM ( Google Tag Manager ) 是 Google 提供的免費網站標籤管理工具，它可以讓網站管理者更容易的新增、編輯和刪除網站上的追蹤程式碼 ( 例如 Google Analytics、Facebook Pixel、Google Ads Conversion Tracking...等 )，GTM 可以透過網頁標籤嵌入網頁，在不需要接觸網站原始碼的情況下，就能快速管理所有網站追蹤程式碼。\n\n![image](https://hackmd.io/_uploads/rkXLCWiQT.png)\n\n## GTM 和 GA 的差別\nGTM ( Google Tag Manager ) 和 GA ( Google Analytics ) 都是 Google 所提供的工具，但是它們的功能和使用方式有所不同。\n\nGTM 是一個「網站標籤管理工具」，它可以讓管理者更容易地管理和部署網站上的跟蹤標籤，例如 GA 追蹤碼、Facebook Pixel...等。GTM 提供一個容器，在不需要進入網站原始碼的情況下，就能進行添加、編輯和刪除追蹤標籤。它還提供了許多進階功能，例如事件追蹤、電子商務追蹤、自定義 JavaScript 程式碼...等。\n\nGA 是一個「分析工具」，它可以幫助管理者追蹤和分析使用者的行為和互動。GA 也可以掌握使用者的地理位置、瀏覽器類型、裝置類型、訪問時間、頁面流量...等，並進一步分析訪問者的行為，例如頁面停留時間、轉換率、漏斗分析，GA 甚至還提供許多報表和圖表，可以更有效的了解各項數據和趨勢。\n\n\n|  | 功能 | 進階功能 |\n| -------- | -------- | -------- |\n| GTM     | 網站標籤管理工具 | 事件追蹤、電子商務追蹤、自定義 JavaScript 程式碼...   |\n| GA     | 分析工具 | 掌握使用者的地理位置、瀏覽器類型、裝置類型、訪問時間、頁面流量... |\n\n![image](https://hackmd.io/_uploads/rk0lQMs76.png)\n>GTM 可以用於部署 GA 追蹤碼，而 GA 可以分析 GTM 中所設置的事件和行為。\n\n## 使用 GTM 的好處\n\n對於管理者而言，使用 GTM 有下列幾個好處：\n\n* 簡化網站追蹤程式碼管理流程：管理者可以更快速地添加、刪除和更新程式碼，不需要依賴開發人員。\n* 提高網站效能：GTM 可以將多個跟蹤程式碼整合成一個標籤，減少網站載入時間。\n* 提供更好的追蹤功能，GTM 可以追蹤網站的各種行為和互動 ( 例如點擊、頁面滾動、表單提交...等 )。\n* 追蹤碼統一管理：所有追蹤碼都可以從後台清楚呈現，維護更新非常方便。\n\n## GTM 對行銷人員的好處\n\n通常行銷人員並不如程式設計師一般的熟悉程式編輯，因此對於行銷人員而言，GTM 有下列幾個好處：\n\n* 更容易管理和追蹤：GTM 還提供了許多追蹤功能 ( 事件追蹤、電子商務追蹤、網站轉換追蹤...等 )，行銷人員可以更好的了解使用者在網站上的行為和互動，並能追蹤訂單、收入和轉換率等重要指標，也可以透過網站轉換追蹤去追蹤特定目標，甚至進行 A/B 測試，比較不同版本的網站，找到最有效的方案。\n* 不需要過度仰賴程式設計師：行銷人員可以透過 GTM 快速添加、編輯和刪除追蹤標籤，不需要過度依賴開發人員，節省時間和成本。\n\n總而言之，對於行銷人員而言，透過 GTM 可以更容易去了解使用者行為和網站效能，並且可以幫助他們更有效地執行網站的改善和數據驅動的行銷策略。\n\n## 使用GTM\n\n> 原文參考：[開始使用 GTM](https://steam.oxxostudio.tw/category/ga4/gtm/start-use.html)\n\n登入 GTM\n使用 Google 帳號登入 GTM，登入後可以建立帳戶，或查看自己 Google 帳號下的 GA 追蹤代碼。\n\n>GTM 網址：https://tagmanager.google.com/\n\n![image](https://hackmd.io/_uploads/rJmQoGimT.png)\n\n在「建立帳戶」頁籤裡，可以建立 GTM 的帳戶已變進行代碼管理，切換到「Google 代碼」頁籤，則可以管理自己 Google 帳號下擁有管理或觀察權限的 GA 追蹤代碼。\n\n![image](https://hackmd.io/_uploads/H1AJhfj7p.png)\n\n### 建立帳戶\n要使用 GTM 必須先「建立帳戶」，該帳戶與個人帳戶不同，是專門用來管理 GTM 代碼的帳戶，點擊「建立帳戶」按鈕，簡單輸入帳戶名稱以及容器名稱 ( 通常是以網站網址作爲名稱 )。\n\n>在 GTM 裡，會使用「容器」安裝各種不同工具與代碼，每個帳號下可以具有有多個不同的容器，每個容器裡可以建立多個不同種類的代碼，容器彼此獨立互不影響。\n\n\n![image](https://hackmd.io/_uploads/HJA-pGsXa.png)\n\n確認相關條款後，GTM 的帳戶就建立完成。\n\n![image](https://hackmd.io/_uploads/BydB6Momp.png)\n\n### 新增代碼\n點擊左側「代碼」選項，點擊右上方的「新增」，就能在 GTM 的容器裡，新增相關的追蹤代碼。\n![image](https://hackmd.io/_uploads/H1yBCMjQa.png)\n\n點擊「代碼設定」欄位，就能選擇要加入的代碼類型，在「精選」的區域通常是 Google 自家追蹤代碼。\n\n![image](https://hackmd.io/_uploads/S1xx1moQ6.png)\n\n如果有其他沒有在清單裡面的代碼，就需要使用「自訂 HTML 代碼」進行部署，甚至也可以使用「自訂圖片代碼」部署像素廣告代碼\n![image](https://hackmd.io/_uploads/r1ydxQs7T.png)\n\n### 安裝 GTM 容器代碼\n如果要透過 GTM 執行各種代碼的追蹤，必須要先將 GTM 的容器代碼放到網站 HTML 裡，點擊「管理」頁籤，點選「安裝 Google 代碼管理工具」。\n\n![image](https://hackmd.io/_uploads/r1P9xmjXa.png)\n點擊後，按照操作步驟，將 GTM 容器程式碼放到網頁 HTML 中指定的位置，放在 <head></head> 裡的是主要容器代碼，放在 <body></body> 裡的是在瀏覽器不支援 JavaScript 時才會啟用的代碼。\n\n![image](https://hackmd.io/_uploads/r11ngmomT.png)\n\n\n### 認識 GTM 的 Data Layer\n\n資料層 ( Data Layer ) 是 GTM 運作的基礎，也是 GTM 用於收集網站數據的關鍵。Data Layer 屬於一種 JavaScript 物件，目的在於儲存網站中所獲得的數據，讓 GTM 可以輕鬆地檢測到並追蹤這些數據，並在特定事件發生時進行觸發，GTM 可以更準確地追蹤使用者行為並收集更豐富的數據。\n\n觀察安裝在 HTML 裡的 GTM 程式碼，可以發現裡面出現了「dataLayer」的文字，在程式碼中的 dataLayer 代表程式變數，目的是透過變數收集數據，並藉由 push 的命令將數據傳送到 GTM，因此透過 GTM 操作自訂事件時，常常會使用dataLayer.push的語法。\n\n# gtag.js\ngtag.js 是 Google Analytics 的 JavaScript 追踪代碼，它取代了以前 的Analytics.js 代碼。gtag.js 可以直接嵌入網站代碼中，以收集使用者的行為數據，並更加精確地測量網站的流量與互動成效。\n>詳細設定參考：[安裝 GA4 資料收集代碼](https://steam.oxxostudio.tw/category/ga4/info/install.html)\n\n只要將 gtag.js 的資料收集代碼放到網頁 HTML 中指定的位置，網頁開啟後就會開始收集數據，基本的範例如下：\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n\n  <!-- Google tag (gtag.js) -->\n  <script async src=\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXX\"></script>\n  <script>\n    window.dataLayer = window.dataLayer || [];\n    function gtag(){dataLayer.push(arguments);}\n    gtag('js', new Date());\n    gtag('config', 'G-XXXXXX);\n  </script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n## GTM 和 gtag.js 比較\n\n\n\n\n功能：\n\n| GTM | 全面的標籤管理系統，可以管理許多種不同的標籤和代碼，包括 Google Analytics、AdWords、Facebook Pixel...等。 |\n| -------- | -------- | \n| gtag.js     |專門用於 Google Analytics 數據收集的輕量級追踪代碼。 |\n\n實現方式：\n\n| GTM | 屬於中間層的「容器」，可以在不更改網站代碼的情況下進行管理和部署作業。 |\n| -------- | -------- | \n| gtag.js     |直接嵌入到網站 HTML 中的追踪代碼，不需要通過中間層容器進行管理。 |\n\n\n效率：\n\n| GTM | 因使用時需要通過中間層容器進行處理，可能會對網站速度產生輕微的影響。 |\n| -------- | -------- | \n| gtag.js     |直接將資料傳遞至 Google Analytics，速度相對較快。 |\n\n難易度：\n\n| GTM | GTM 可能需要較長的學習曲線，去熟悉其控制介面和設定方式，且仍需學習 GA4 的用法。 |\n| -------- | -------- | \n| gtag.js     |只需要知道程式碼安裝的位置和寫法，同樣也需要學習 GA4 的用法。 |\n\n\n跨平台部署：\n\n| GTM | 可以跨多個平台進行部署，包括網站、移動應用程序和 AMP 頁面等等。 |\n| -------- | -------- | \n| gtag.js     |只能在網站中使用，無法應用於移動應用程序或 AMP 頁面等其他平台。 |\n\n版本控制：\n\n| GTM | 允許使用版本控制系統來管理和維護標籤與容器版本。 |\n| -------- | -------- | \n| gtag.js     |沒有版本控制功能，所有更改都必須手動維護。 |\n\n# 安裝 GTM 容器代碼\n使用 Google 帳號登入 GTM 並進入管理帳戶，點擊「管理」頁籤，點選「安裝 Google 代碼管理工具」。\n\n>GTM 網址：https://tagmanager.google.com/\n參考：開始使用 GTM\n\n![image](https://hackmd.io/_uploads/S1sHOxkE6.png)\n\n點擊後，按照操作步驟，將 GTM 容器程式碼放到網頁 HTML 中指定的位置，放在 <head></head> 裡的是主要容器代碼，放在 <body></body> 裡的是在瀏覽器不支援 JavaScript 時才會啟用的代碼。\n\n![image](https://hackmd.io/_uploads/SJYPul1E6.png)\n\n# 新增 GA4 設定代碼\n回到 GTM 帳戶，點擊左側「代碼」選項，點擊右上方的「新增」，在 GTM 的容器裡，新增相關的追蹤代碼。\n![image](https://hackmd.io/_uploads/SyC5uey4T.png)\n\n點擊「代碼設定」，選擇「Google Analytics ( 分析 )：GA4 設定」，填入 GA4 的評估 ID\n\n![image](https://hackmd.io/_uploads/Syd-YgJ46.png)\n\n在「觸發條件」裡設定觸發條件為「All Pages」。\n![image](https://hackmd.io/_uploads/r1APKekNT.png)\n\n完成後儲存代碼，點擊右上方的「提交」。\n![image](https://hackmd.io/_uploads/BJUE9gkVp.png)\n\n輸入這次更動的版本名稱和內容，按下「發布」，就能發布並更新 GTM 代碼內容。\n![image](https://hackmd.io/_uploads/r11vqxyNp.png)\n\n如果順利發布完成，就會出現已經上線的畫面。\n![image](https://hackmd.io/_uploads/rkrq9gJVa.png)\n\n# 檢查 GA4 代碼是否正確安裝\n\n回到已經安裝 GTM 容器代碼的網頁，重新執行該網頁，此時從 GA4 的即時總覽裡，應該就能看到出現了使用者，這表示 GA4 已經順利安裝在 GTM 裡並正常執行收集數據。\n\n![image](https://hackmd.io/_uploads/ryGyjxk4a.png)\n\n\n\n參考資料:\n[GA4 ( Google Analytics 4 ) 教學]( )\n[2023 ithome鐵人賽 - 跟著 OXXO 一起學 GA4 ( Google Analytics 4 )系列](https://ithelp.ithome.com.tw/articles/10314237)","tags":["GA4"]},{"title":"Agoda全端工程師的日常生活","url":"/2023/11/11/Agoda全端工程師的日常生活/","content":"\n> 這篇文章是我在 [Agoda Engineering 部落格](https://medium.com/agoda-engineering)的文章閱讀紀錄\n[A Day in the Life of a Full-Stack Engineer](https://medium.com/agoda-engineering/a-day-in-the-life-of-a-full-stack-engineer-33f640270ae9)\n\n\n在軟體開發不斷變化的領域中，全端工程師的角色既關鍵又全面。\n這些多才多藝的專業人員是網絡的建築師和建造者，同時負責製作用戶界面元素，\n同時管理保持數字平台運行順暢的服務器端流程。\n這是一個要求不僅廣泛技能，還需要解決問題思維和持續學習的角色。\n在這篇文章中，Maksym Zavodniuk分享了他作為一名全端工程師的見解。\n\n# 全端工程師的角色\n全端工程師負責設計和實現後端（BE）和前端（FE）任務上的功能。\n我們精通於前端使用的語言和庫，如JavaScript、React、Angular和Vue，並使用CSS進行界面設計。\n在後端方面，我們熟練地管理像MongoDB、SQL或PostgreSQL這樣的數據庫。\n根據我們的具體專業深度，我們可能更傾向於前端或後端。\n\n\n# 在Agoda的一天生活\n我已經在Agoda工作了三年，目前在WhiteLabel預訂創建團隊工作。在Agoda的我們的全端工程師每天的任務可以千變萬化。這些任務從後端（BE）導向的職責到純粹的前端（FE）任務，有時還包括兩者的混合。有時，我們甚至深入研究配置CI/CD流水線和理解各種服務的內部運作。\n\n對於一些任務，需要對系統有更深入的了解。在這種情況下，我們通常會從一個“調查”任務開始。這裡的主要目標是進行研究，收集有關數據處理、流程以及數據在數據庫中的表示方式的信息。這是一種情況，其中後端和前端的經驗確實有助於看清為什麼會做出某些決策的全貌。\n\n最近，我們有一個任務是防止重復預訂，確保相同的房型不會在相同的名字和日期下被預訂兩次。這個任務需要對數據庫進行更新，以存儲用戶信息以供比較。在前端，我們還實現了一個驗證機制，以提醒用戶警告。\n\n# 技術技能和工具\n\n作為一名網頁全端工程師，了解JavaScript是至關重要的。這是使您的Web應用程序動態且現代化的唯一方法。當構建後端應用程序時，JavaScript通常也用作一種常見的編程語言，特別是對那些從前端背景轉向的工程師。在整個技術堆疊上使用相同的語法相當方便。然而，成為一名全端工程師並不一定意味著您需要堅守單一的編程語言。\n\n為了保持平衡，我在工作中經常在前端和後端的任務之間切換。在我的業餘時間，我喜歡從事個人的側項目，通常探索與我的日常工作任務不同的技術。\n\n# 有效的溝通和協作\n確保前端（FE）和後端（BE）團隊之間的無縫溝通和協作至關重要。我們使用協作技巧，如集思廣益、設計審查、調查工作單，以及通過API契約保持清晰度。\n\n# 專業成長和學習\n我通過參與技術社區、在Agoda與同事討論、參加課程、閱讀文章，並透過一些實踐或PoC來保持對新技術的更新。\n\n# 回顧一個重要的職業時刻\n我職業生涯中的一個重要時刻是我第一份全端角色的工作，那時我使用了MEAN stack。這是一個實踐經驗，讓我能夠看到我的貢獻在整個開發堆棧中變為現實，從前端表單驗證到後端數據處理。\n\n# 成為一名全端工程師的職業建議\n如果你希望追求一個全端工程師的職業或者加入Agoda公司，我的建議是在前端（FE）和後端（BE）開發方面建立堅實的基礎。實際經驗至關重要。不要害怕動手去做，通過實踐學習。不要回避挑戰，它們是深化你專業知識的機會。\n\n作為一名Agoda公司的全端工程師，我的職業生涯一直是一個不斷學習、適應和解決問題的旅程。這是一項需要對技術充滿熱情並致力於終身學習的工作。無論是解決數據庫問題還是創建響應式用戶界面，全端工程師的職業之路充滿了成長和創新的機會。\n\n\n","tags":["Agoda","Full-Stack"]},{"title":"pytest-sugar 測試輸出美化與隨機測試","url":"/2023/10/27/pytest-sugar-測試輸出美化與隨機測試/","content":"\n今天我們要介紹該如何美化我們在進行測試時終端機的輸出，以及讓我們的測試可以隨機的進行\n\n# 測試輸出美化套件安裝\n```\npip install pytest-sugar\n```\n\n# 測試案例\n下方為本次會使用到的測試案例，透過參數化的方式建立四次測試\n```\nimport pytest\n\nargvalues = [[1, 1, 2], [4, 4, 8]]\n\n\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=argvalues)\ndef test_add(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n\n\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=argvalues)\ndef example_add(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n```\n\n\n# 結果展示\n```\npytest -s -v ./day_30/test_demo.py\n```\n沒有使用 pytest-sugar 的終端機測試輸出畫面\n![](https://hackmd.io/_uploads/r1kG13_GT.png)\n\n```\npytest -s -v ./day_30/test_demo.py\n```\n有使用 pytest-sugar 的終端機測試輸出畫面\n![](https://hackmd.io/_uploads/ryyu13dMT.png)\n\n# 隨機測試套件安裝\n在 pytest 當中，測試預設是一個接著一個按順序進行測試的，若想要隨機進行測試，可以透過安裝 pytest-random-order 這個第三方套件來協助我們進行\n\n```\npip install pytest-random-order\n```\n# 成果展示\n```\npytest -s -v --random-order ./day_30/test_demo.py\n```\n可以看到下圖當中我們成功將測試打散進行測試\n![](https://hackmd.io/_uploads/S1Igg2dfT.png)\n","tags":["自動化測試","pytest","pytest-sugar","pytest-random-order"]},{"title":"pytest-xdist併發測試","url":"/2023/10/27/pytest-xdist併發測試/","content":"\n這篇是記錄我在看鐵人賽 [Python 與自動化測試的敲門磚 ](https://ithelp.ithome.com.tw/articles/10307902) 的過程\n\npytest-xdist，可以協助我們將 pytest 用併發的方式進行測試，白話來說就是同時進行很多個測試，而不是一個測完才接著下一個\n\n# 套件安裝\n```\npip install pytest-xdist\n```\n\n# 建立測試程式\n建立三個測試程式，並於每個測試案例內都進行等待五秒\n```\nfrom time import sleep\n\n\ndef test_case_1():\n    sleep(5)\n\n\ndef test_case_2():\n    sleep(5)\n\n\ndef test_case_3():\n    sleep(5)\n```\n\n# 成果展示\n\n未使用併發測試時，可以看到測試總共花了 15 秒左右\n![](https://hackmd.io/_uploads/H1XbtoOM6.png)\n\n使用 pytest -n auto 表示要使用併發模式進行測試，可以看到測試時間只花了六秒鐘左右\n![](https://hackmd.io/_uploads/B1iHYj_zT.png)\n\n{% note warning simple %}\n併發數量若使用 auto 會自動抓取電腦 CPU 核心數，來建立併發數量，一般建議使用 CPU 核心數 / 2 的併發數量來進行測試\n可以透過 pytest -n <concurrency_amount> 來進行併發數量的設定，\n例如：pytest -n 3 ./day_29/test_demo.py\n{% endnote %}","tags":["pytest","pytest-xdist"]},{"title":"Pytest 客製化","url":"/2023/10/27/Pytest-客製化/","content":"\n這篇是記錄我在看鐵人賽 [Python 與自動化測試的敲門磚 ](https://ithelp.ithome.com.tw/articles/10307485) 的過程\n\n透過設定 pytest.ini 即可讓我們進行一些簡單的客製化，讓 pytest 更符合我們的需求\n\n# 預設指令\n透過設定 pytest.ini 我們可以達到每次執行 pytest 時，會自動帶入指定的參數，例如：-s、-v ...\n於整個專案最外層建立 pytest.ini 檔案\n\n編輯 pytest.ini\n\n```\n[pytest]\n\naddopts = --maxfail=1 -s -v \n\n```\n範例當中，我們設定了在使用 pytest 時會自動帶入 -s、-v 參數，並且設定當發生一次錯誤時就會停止測試\n\n建立測試程式\n```\nimport pytest\n\nargvalues = [[1, 1, 2], [2, 2, 5], [3, 3, 7], [4, 4, 8]]\n\n\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=argvalues)\ndef test_add(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n```\n範例當中，我們利用參數化的方式建立了四次測試\n\n結果展示\n![](https://hackmd.io/_uploads/rknCv5uMp.png)\n\n\n正常來說應該會有四次的測試結果，下圖為沒有設定 pytest.ini 時的情況，pytest 就成功執行了四次測試並且其中兩次為錯誤\n![](https://hackmd.io/_uploads/BJvtPcdf6.png)\n\n\n# 蒐集條件\n\npytest 預設會自動蒐集開頭為 test 的 function，當然這個部份我們也可以透過 pytest.ini 來進行設定\n\n編輯 pytest.ini\n```\n[pytest]\npython_functions = test_* example_*\n\n```\n建立測試程式\n下方利用參數化的方式建立兩個測試函式，總共數量會是八個測試，並分別用 test_ 開頭以及 example_ 開頭\n```\nimport pytest\n\nargvalues = [[1, 1, 2], [2, 2, 5], [3, 3, 7], [4, 4, 8]]\n\n\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=argvalues)\ndef test_add(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n\n\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=argvalues)\ndef example_add(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n```\n\n利用 pytest --co 觀察蒐集到的測試函式數量，可以看到成功蒐集到八個測試\n\n![](https://hackmd.io/_uploads/rJI2ccOG6.png)","tags":["Pytest"]},{"title":"Pytest 與 Mock","url":"/2023/10/26/Pytest-與-Mock/","content":"\n這篇是記錄我在看鐵人賽 [Python 與自動化測試的敲門磚 ](https://ithelp.ithome.com.tw/articles/10306922) 的過程\n\n專案練習有同步到 github 上，可以前往 [這個網址](https://github.com/gahgah147/PytestMock)\n\n\n# pytest-mock 使用情境\n今天我們要說明該如何再進行測試時，把不想要執行的方法給替換掉，在測試的過程中，有時候只是要測試函式的可用性，但像是發送 email、撰寫檔案等等的函式，往往是不希望被執行的，總不能每執行一次測試就寄一封 mail 給你，這樣信箱會很快就爆炸的，針對這個情況我們就可以透過 pytest-mock 來替我們進行函式的抽換，並回傳假的資料，只要確認函式運行的流程是正確的即可\n\n\n# 套件安裝\n```\npip install pytest-mock\n```\n\n# 抽換屬性\n\n## 建立函式 demo.py\n建立一個透過 sys 取得 platform 的函式\n\n```\nimport sys\n\n\ndef get_sys_platform():\n    platform = sys.platform\n    return platform\n```\n\n## 建立測試函式 test_demo.py\n將會用到的 package 全部 import 近來\n直接在 test case 當中的參數部分打上 mocker 即可進行使用，後面的 MockFixture 只是用來提式型態用的\n建立一個變數用來存放假的回傳資料，此樹使用 new (對齊 mock.path 函式的參數)\n```\nimport sys\nimport demo\nfrom pytest_mock import MockFixture\n\n\ndef test_mock_object(mocker: MockFixture):\n    new = \"test_mock\"\n```\n使用 mocker.patch.object 進行變數的替換\n\n\n| target | 指定要替換的物件 |\n| -------- | -------- | \n| attribute | 指定要替換的物件的屬性 |\n| new | 要回傳的假資料 |\n\n```\nimport sys\nimport demo\nfrom pytest_mock import MockFixture\n\n\ndef test_mock_object(mocker: MockFixture):\n    new = \"test_mock\"\n\n    mocker.patch.object(target=sys,\n                        attribute=\"platform\",\n                        new=new)\n```\n\n實際呼叫想要測試的函式並進行驗證\n```\nimport sys\nimport demo\nfrom pytest_mock import MockFixture\n\n\ndef test_mock_object(mocker: MockFixture):\n    new = \"test_mock\"\n    mocker.patch.object(target=sys,\n                        attribute=\"platform\",\n                        new=new)\n\n    result = demo.get_sys_platform()\n    print(result)\n\n    assert result == new\n```\n下圖中我們實際執行此測試函式，可以看到終端機上印出 test_mock 字串且測試結果為 passed\n![](https://hackmd.io/_uploads/HytEAsvfa.png)\n\n# 抽換函式\n\n## 建立函式\n\ndemo.py 新增以下程式\n\n```\ndef add(num1, num2):\n    return num1 + num2\n\n\ndef calculate(num1, num2):\n    add_result = add(num1=num1, num2=num2)\n\n    return add_result\n```\n\n## 建立測試函式\n透過 mocker.patch 直接進行抽換\n\n| target | 使用 \"字串\" 指定要抽換的函式路徑，當成式執行到此函式時，會直接回傳一個假資料並不會實際執行該函式 | \n| -------- | -------- | \n| return_value     | 指定要回傳的假資料     | \n\ntest_demo.py 新增以下程式\n\n```\nimport demo\nfrom pytest_mock import MockFixture\n\n\ndef test_mock_function(mocker: MockFixture):\n    return_value = 100\n\n    mocker.patch(target=\"demo.add\",\n                 return_value=return_value)\n\n    result = demo.calculate(num1=10, num2=10)\n    print(result)\n\n    assert result == return_value\n```","tags":["pytest","Mock"]},{"title":"自動化測試 CI/CD","url":"/2023/10/25/自動化測試-CI-CD/","content":"\n這篇是記錄我在看鐵人賽 [Python 與自動化測試的敲門磚 ](https://ithelp.ithome.com.tw/articles/10290529) 的過程\n\n# CI/CD 簡介\nCI/CD 其實是指兩個部分，分別是 Continuous Integration (持續整合) 以及 Continuous Deployment (持續部屬)\n\n## CI 持續整合\n在軟體開發的過程中，通常會由無數個開發人員一起工作，然而隨著程式碼以及人數的增加，專案會越來越難進行整合，這個時候我們就可以透過 CI 來進行。與其說 CI 是個工具，不如說 CI 是一種合作模式，藉由簡單的設定來讓 CI 工具替我們進行測試，就可以降低我們的專案在進行更新、整合時碰到問題的機率。\n\n在 CI 執行的過程中，會建議每個開發人員每天上班前先做一次 pull 的動作，於每天下班前至少執行一次 push 的動作，以此確保 CI 的運行效率。\n\n## CD 持續部屬\n每當我們透過 CI 將專案整合完成後，便可以透過 CD 來進行自動化的部屬，減少我們在測試與部屬之間所耗費的時間\n\n# CI/CD 常用工具\n## GitLab\n於 GitLab 上提供了 CI/CD 的介面，藉由在某處部屬好的 docker image，即可進行 CI/CD，為目前主流的 CI/CD 工具\n\n\n## GitHub\nGitHub 於 2019 年推出了 GitHub Actions，此工具可以協助我們進行 CI，不過由於此功能還算新，尚有許多功能不成熟，因此比較建議使用在小型專案的 CI 當中\n\n## Jenkins\n為目前主流的 CD 工具，藉由 GitLab 進行 CI 後，會將程式碼打包到 Jenkins 進行自動化部屬\n\n# GitHub 設定\n\n## 建立 yml file\n\n進入 github 專案並點選 Actions 選項\n![](https://hackmd.io/_uploads/B1bGcmKlT.png)\n\n![](https://hackmd.io/_uploads/SynUsXKx6.png)\n> 需要點擊啟用 Actions 設定\n \n![](https://hackmd.io/_uploads/B1Rqj7Fxp.png)\n點擊 New Workflow\n\n在 Workflows 欄位底下輸入 \"python\" 進行搜尋\n![](https://hackmd.io/_uploads/SJpG5Xte6.png)\n\n選擇 Python Application，並點選 Configure 選項\n![](https://hackmd.io/_uploads/Bkum5mYxp.png)\n\n將跳轉後出現的頁面的程式碼滑到最底下，並將 pytest 更改為 echo \"hello\"\n\n點選右上方 \"Start Commit\" 選項\n![](https://hackmd.io/_uploads/BkD4qQtla.png)\n\n點選 \"Commit new file\" 選項\n![](https://hackmd.io/_uploads/HycBcXYep.png)\n\n{% note info simple %}\n測試若有設定過會出錯，需要新建立一個repository才會成功\n{% endnote %}\n\n頁面會自動跳轉回專案首頁，請點選回 \"Actions\"，就可以看到 github 按照剛剛建立的檔案建立了一個 CI 任務\n\n![](https://hackmd.io/_uploads/HyOv9QKlT.png)\n\n點進此任務，並選擇 build 選項\n![](https://hackmd.io/_uploads/Bk-uqQFla.png)\n\n點選 \"Test with pytest\" 部分即可看到剛剛修改的 echo \"hello\"\n![](https://hackmd.io/_uploads/S10t27tgp.png)\n\n![](https://hackmd.io/_uploads/HJ2O9XYlp.png)\n\n## 修改 yml\n\n由於我們剛剛是直接在 github 上進行 commit 來新增 workflows，因此我們要先回到專案上執行 git pull 確保專案同步\n\n執行完 git pull 後即可在專案上看到 \".github\" 這個目錄，並且有 \"workflows\" 這個子目錄\n\n\"workflows\" 目錄下會有一個 python-app.yml 檔案，這個就是我們等一下要修改的檔案\n\n![](https://hackmd.io/_uploads/rJ-s9mYxp.png)\n\n在修改 yml 前我們先建立幾個簡單的 test case 並存放到 day_22/test_demo.py 目錄下\n![](https://hackmd.io/_uploads/Byso9XKx6.png)\n\n```\n  def test_export_report_1():\n      a = 1 + 1\n      b = 2 + 2\n\n      assert b > a\n\n\n  def test_export_report_2():\n    a = 2 + 2\n    b = 4 + 4\n\n    assert a < b\n```\n打開 python-app.yml\n\n將剛剛的 echo \"hello\" 修改為 pytest -s -v ./day_22/test_demo.py\n```\n# This workflow will install Python dependencies, run tests and lint with a single version of Python\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Python application\n\non:\n  push:\n    branches: [ \"master\" ]\n  pull_request:\n    branches: [ \"master\" ]\n\npermissions:\n  contents: read\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python 3.10\n      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.10\"\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install flake8 pytest\n        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi\n    - name: Lint with flake8\n      run: |\n        # stop the build if there are Python syntax errors or undefined names\n        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics\n        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide\n        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics\n    - name: Test with pytest\n      run: |\n        pytest -s -v ./day_22/test_demo.py\n```\n\n## 察看結果\n修改完成後，我們就可以將整個專案 push 到 Github 上，這個時候我們就可以回到剛剛的 \"Actions\" 頁面察看結果了\n\n下圖中我們可以看到 Acitons 這邊多了一個任務，任務名稱會使用剛剛的 commit message 命名\n![](https://hackmd.io/_uploads/HkdxiQKxT.png)\n\n點進去該任務後就可以查看 pytest 的執行結果了\n![](https://hackmd.io/_uploads/ryZWjQtgT.png)\n\n## python-app.yml\n\n### 運行於指定的 branch 上\n\n我們可以透過 on 參數來設定當哪個 branch 被推上 Github 上時要進行 CI 的動作，由於 CI 的進行也是需要耗費一定的資源，因此不太可能讓所有瑣碎的 branch 被推上去時都自動進行一次，透過設定 branches 可以指定那些 branch 被推上來時要執行 CI\n\n補充：可以看到 on 底下有分為 push 以及 pull_request 兩個層級，分別代表著 Github 上的兩種協作方式\n```\non:\n  push:\n    branches: [ \"master\" ]\n  pull_request:\n    branches: [ \"master\" ]\n```\n\n### 建立 CI 任務\n\n| 變數 | 功能 |\n| -------- | -------- |\n| runs-on    | 為 CI 執行時最底下的一個 docker image 名稱，設定完成後 CI 會於執行時使用該 image 建立環境   | \n| steps   | 為實際 CI 執行的細項，每一個細項開頭都會使用 \"-\" 來表示 | \n| uses   | 為為運行此 steps 時啟動的服務，為 docker image 名稱 | \n| name   | 為此 step 的名稱 |  \n| run   | 為此 step 要執行的命令 | \n\n```\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n      \n    - name: Set up Python 3.10\n      uses: actions/setup-python@v3\n      with:\n        python-version: \"3.10\"\n    \n    - name: Test with pytest\n      run: |\n        pytest -s -v ./day_22/test_demo.py\n```\n\n\n# GitLab 設定\n\n## 建立 CI/CD runner\n\n在 GitLab 運行 CI/CD 時，同樣需要一個 runner 在背後執行，只是在 GitHub 的時候，他們幫我們做好了，因此我們不需要去碰到這塊，下面的方法為建立 runner 並和 GitLab 上的專案綁定的方法\n\n{% note info simple %}\n接下來的步驟請先在要建立 runner 的電腦上安裝 docker\n{% endnote %}\n\n前往 GitLab 專案的 Setting 裡面的 CI/CD 頁面\n\n![](https://hackmd.io/_uploads/HJPEL21Ma.png)\n> Setting > CI/CD\n\n\n![](https://hackmd.io/_uploads/SJwSU2yfT.png)\n> 找到 Runner 部分並打開，可以看到要和 runner 做連線的網址以及 token\n\n打開 terminal\n\n建立 docker volume\n```\ndocker volume create gitlab-runner\n```\n![](https://hackmd.io/_uploads/SJ1MO21fp.png)\n\n啟動 docker 並將他連上剛剛建立的 volume\n\n```\ndocker run -d --name gitlab-runner --restart always -v /var/run/docker.sock:/var/run/docker.sock -v gitlab-runner:/etc/gitlab-runner gitlab/gitlab-runner:latest\n```\n\n使用下方指令進行 runner 與 GitLab 的連線\n\n```\ndocker run --rm -it -v gitlab-runner:/etc/gitlab-runner gitlab/gitlab-runner:latest register\n```\n\n接下來會開始進行註冊程序，我們會以一個問題搭配一個回答的方式撰寫\n\n| 註冊程序 | 回答 | \n| -------- | -------- | \n| Enter the GitLab instance URL     | 寫上剛剛在 GitLab 上看到的 url  | \n| Enter the registration token     | 寫上剛剛在 GitLab 上看到的 token  | \n| Enter a description for the runner     | 寫上你想要為這個 runner 的描述，這邊使用 \"nickchen1998_ithelp_2022_marathon\"  | \n| Enter tags for the runner     | 為這個 runner 增加 tag，用來指派 CI/CD 任務用，這邊先寫上 \"nickchen1998_ithelp_2022_marathon\"  | \n| Enter optional maintenance note for the runner     | 這部份我們不需要，直接按 Enter |  \n| Enter an executor | 這邊我們輸入 \"docker\"，用來作為 runner 運行的環境 | \n| Enter the default Docker image | 當 yaml 檔沒有指定要使用的 image 時，預設會使用的 image，這邊我們輸入 \"python:latest\" | \n\n註冊完成\n\n\n![](https://hackmd.io/_uploads/By4VF3Jz6.png)\n\n\n![](https://hackmd.io/_uploads/rk4D5nkzT.png)\n>回到剛剛的 runner 頁面，我們就可以看到一個新的 runner 被建立給這個專案\n\n## 設定環境變數\n\n我們可以透過 Settings 內的 CI/CD 頁面裡面的 Variables 欄位進行環境變數的設定\n\n![](https://hackmd.io/_uploads/HJsfs2yGp.png)\n> Settings > CI/CD > Variables\n\n![](https://hackmd.io/_uploads/ryORi3yz6.png)\n>點選 Add Variable 開始設定環境變數\n\n![](https://hackmd.io/_uploads/r13x221zp.png)\n> 依序輸入 key、value 並點選 Add Variable\n\n![](https://hackmd.io/_uploads/rJk7hnJza.png)\n> 可以看到成功新增的變數\n\n## 設定 yaml 檔案\n\n### 建立 .gitlab-ci.yml\n在整個專案的 \"最外層\" 建立 gitlab-ci.yml 檔案\n\n### 建立流程\n\n直接將工作名稱寫在最外層，並於其下一層利用 stage 表示此工作階段的名稱\n```\nexecute-test:\n  stage: test\n```\n\n將要執行的指令依序寫在 scripts 後方\n```\nexecute-test:\n  stage: test\n  script:\n    - pip3 install pytest\n    - pytest -s -v ./day_25/test_demo.py\n```\n\n最後利用 tag 指定我們要執行這個任務的 runner (昨天文章有提到該如何建立 runner)\n\n```\nexecute-test:\nstage: test\nscript:\n  - pip3 install pytest\n  - pytest -s -v ./day_25/test_demo.py\ntags:\n  - nickchen1998_ithelp_2022_marathon\n```\n\n### 管理 stage\n透過設定 stage 可以來管理我們要執行哪個部份的腳本\n\n透過下面這段程式碼，我們就成功設定執行所有 stage 為 test 的任務了\n```\nstages:\n  - test\n\nexecute-test:\n  stage: test\n  script:\n    - pip3 install pytest\n    - pytest -s -v ./day_25/test_demo.py\n  tags:\n    - nickchen1998_ithelp_2022_marathon\n```\n\n### 成果展示\n可以看到下圖中 GitLab 順利為我們生成一條 CI pipline\n![](https://hackmd.io/_uploads/ryHR33Vfa.png)\n\n{% note warning simple %}\n這邊要注意 runner 要指定對並且是執行中才會成功，不然會 Pending\n{% endnote %}\n\n![](https://hackmd.io/_uploads/B1IbpnEMT.png)\n\n##  Selenium 設定\n\n### 修改 .gitlab-ci.yml 設定檔案\n\n首先我們要替我們的 .gitlab-ci.yml 加上 service 表示我們要在指定的任務中運行其他服務\n\n```\nstages:\n  - test\n\nexecute-test:\n  stage: test\n\n  services:\n\n  script:\n    - pip3 install -r ./requirements.txt\n    - pytest -s -v ./day_26/test_demo.py\n  tags:\n    - nickchen1998_ithelp_2022_marathon\n```\n\n接著透過設定 services 底下的 name 參數來指定我們要使用哪個 docker image，我們會需要使用到 selenium/standalone-chrome 這個 image 來替我們建立一個可以遠端執行 Chrome 的環境\n\n```\nstages:\n  - test\n\nexecute-test:\n  stage: test\n\n  services:\n    - name: selenium/standalone-chrome\n\n  script:\n    - pip3 install -r ./requirements.txt\n    - pytest -s -v ./day_26/test_demo.py\n  tags:\n    - nickchen1998_ithelp_2022_marathon\n```\n\n最後透過設定 alias 參數來為這個 services 進行命名\n```\nstages:\n  - test\n\nexecute-test:\n  stage: test\n\n  services:\n    - name: selenium/standalone-chrome\n      alias: CICD_Selenium\n\n  script:\n    - pip3 install -r ./requirements.txt\n    - pytest -s -v ./day_26/test_demo.py\n  tags:\n    - nickchen1998_ithelp_2022_marathon\n```\n\n{% note info simple %}\nscript 方面我有實際測試，\npip3 install -r ./requirements.txt  \n這行實際運行會出錯，我後來調整成這樣可以運行成功\n\nscript:\n    - pip3 install pytest\n    - pip3 install selenium\n    - pip3 install webdriver_manager\n    - pytest -s -v ./day_26/test_demo.py\n{% endnote %}\n\n### 建立 fixture\n\n建立一個 conftest.py 並將 driver 的 fixture 寫在裡面\n\n```\nimport sys\nimport pytest\nfrom typing import Union\nfrom selenium.webdriver import Remote, Chrome\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n\n@pytest.fixture(name=\"driver\")\ndef driver_fixture() -> Union[Remote, Chrome]:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(f\"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n                         f\"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\")\n\n    if sys.platform == \"win32\":\n        driver = Chrome(ChromeDriverManager().install(),\n                        options=options)\n    else:\n        driver = Remote(command_executor=\"http://CICD_Selenium:4444/wd/hub\",\n                        options=options)\n\n    yield driver\n\n    driver.quit()\n```\n\n### 撰寫測試程式\n```\nfrom selenium.webdriver import Remote, Chrome\nfrom typing import Union\n\n\ndef test_current_url(driver: Union[Remote, Chrome]):\n    driver.get(\"https://ithelp.ithome.com.tw/\")\n\n    correct_url = \"https://ithelp.ithome.com.tw/\"\n    assert driver.current_url == correct_url\n\n    correct_title_start = \"iT 邦幫忙\"\n    assert driver.title.startswith(correct_title_start)\n```\n","tags":["Pytest","Selenium","CI/CD","GitHub","GitLab"]},{"title":"Linux 複製檔案 cp 指令","url":"/2023/10/18/Linux-複製檔案-cp-指令/","content":"\n# 複製檔案\n若要將 source.txt 檔案複製一份到 dest.txt，可以執行：\n```\n# 將 source.txt 複製到 dest.txt\ncp source.txt dest.txt\n```\n# 複製目錄\n如果要複製整個目錄以及該目錄下的所有子目錄與檔案，可以加上 -r 參數（或是 -R、--recursive 參數亦可），以遞迴的方式進行複製：\n\n```\n# 將 myfolder 目錄複製到 /path/to/ 路徑下\ncp -r myfolder /path/to/\n```\n# 強制覆蓋檔案\n如果希望 cp 指令在無法寫入目的檔案時，嘗試刪除目的檔案，再重新複製一份新的檔案，可以加上 -f 或 --force 參數：\n\n```\ncp -f source.txt dest.txt\n```\n\n# 不要覆蓋既有檔案\n如果希望 cp 指令遇到目的檔案已經存在的狀況，不要覆蓋既有的檔案，可以加上 -n 或 --no-clobber 參數：\n```\ncp -n source.txt dest.txt\n```\n\n# 自動備份檔案\n若希望 cp 指令在覆蓋檔案時，可以將舊檔案自動備份起來，可以加上 -b 或 --backup 參數：\n```\ncp -b source.txt dest.txt\n```\n\n# 保留檔案屬性\n若希望 cp 在複製檔案時，可以連同檔案屬性一起複製，可以加上 -p 或 --preserve 參數：\n```\ncp -p source.txt dest.txt\n```\n# 連結檔解析\n\n假設我們建立一個連結檔 link.txt 指向 source.txt：\n\n建立連結檔\n```\nln -s source.txt link.txt\n```\n如果希望 cp 指令在複製連結檔案時，能夠解析連結檔所指向的實際檔案，複製那一個實際的目標檔案，可以加上 -L 或 --dereference 參數：\n\n```\ncp -L link.txt dest.txt\n```\n由於 link.txt 是指向 source.txt 的連結檔，所以這裡的 dest.txt 實際上就是從 source.txt 所複製出來了。\n\n若希望 cp 指令在複製連結檔案時，不要進行連結的解析，僅將連結檔直接複製，則可改用 -P 或 --no-dereference 參數：\n```\ncp -P link.txt link2.txt\n```\n\n\n# 參考資料\n[Linux 複製檔案 cp 指令用法教學與範例](https://blog.gtwang.org/linux/linux-cp-command-copy-files-and-directories-tutorial/)\n\n[HowtoForge：Linux cp command tutorial for beginners (8 examples)](https://www.howtoforge.com/linux-cp-command/)\n[GeeksforGeeks：cp command in Linux with examples](https://www.geeksforgeeks.org/cp-command-linux-examples/)","tags":["Linux"]},{"title":"Docker 基本操作 - 進入容器","url":"/2023/10/16/Docker-容器操作/","content":"\nDocker 進入容器 \n\n以下文章是在使用 Docker 時查詢到的好文章 我覺得[這篇](https://philipzheng.gitbook.io/docker_practice/)記錄的很詳細，所以記錄一下\n\n# exec 命令\ndocker exec 是Docker內建的命令。下面示範如何使用該命令。\n```\n$ sudo docker run -idt ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n$ sudo docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n243c32535da7        ubuntu:latest       \"/bin/bash\"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia\n$sudo docker exec -ti nostalgic_hypatia bash\nroot@243c32535da7:/#\n```\n\n# attach 命令\ndocker attach 亦是Docker內建的命令。下面示例如何使用該命令。\n```\n$ sudo docker run -idt ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n$ sudo docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n243c32535da7        ubuntu:latest       \"/bin/bash\"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia\n$sudo docker attach nostalgic_hypatia\nroot@243c32535da7:/#\n```\n按下 ctrl + P 然後 ctrl + Q 跳離容器，讓它繼續在背景執行。\n但是使用 attach 命令有時候並不方便。當多個視窗同時 attach 到同一個容器的時候，所有視窗都會同步顯示。當某個視窗因命令阻塞時,其他視窗也無法執行操作了。\n\n# nsenter 命令\n\n## 安裝\nnsenter 工具已含括在 util-linux 2.23 後的版本內。 如果系統中 util-linux 包沒有該命令，可以按照下面的方法從原始碼安裝。\n\n```\n$ cd /tmp; curl https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz | tar -zxf-; cd util-linux-2.24;\n$ ./configure --without-ncurses\n$ make nsenter && sudo cp nsenter /usr/local/bin\n```\n\n## 使用\nnsenter 可以存取另一個程式的命名空間。nsenter 要正常工作需要有 root 權限。 很不幸，Ubuntu 14.4 仍然使用的是 util-linux 2.20。安裝最新版本的 util-linux（2.24）版，請按照以下步驟：\n```\n$ wget https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz; tar xzvf util-linux-2.24.tar.gz\n$ cd util-linux-2.24\n$ ./configure --without-ncurses && make nsenter\n$ sudo cp nsenter /usr/local/bin\n```\n\n為了連線到容器，你還需要找到容器的第一個程式的 PID，可以透過下面的命令取得。\n```\nPID=$(docker inspect --format \"{{ .State.Pid }}\" <container>)\n```\n透過這個 PID，就可以連線到這個容器：\n```\n$ nsenter --target $PID --mount --uts --ipc --net --pid\n```\n下面給出一個完整的例子。\n```\n$ sudo docker run -idt ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n$ sudo docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n243c32535da7        ubuntu:latest       \"/bin/bash\"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia\n$ PID=$(docker-pid 243c32535da7)\n10981\n$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid\nroot@243c32535da7:/#\n```\n更簡單的，建議大家下載 .bashrc_docker，並將內容放到 .bashrc 中。\n```\n$ wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker;\n$ echo \"[ -f ~/.bashrc_docker ] && . ~/.bashrc_docker\" >> ~/.bashrc; source ~/.bashrc\n```\n這個檔案中定義了很多方便使用 Docker 的命令，例如 docker-pid 可以取得某個容器的 PID；而 docker-enter 可以進入容器或直接在容器內執行命令。\n```\n$ echo $(docker-pid <container>)\n$ docker-enter <container> ls\n```\n\n\n參考文章: https://philipzheng.gitbook.io/docker_practice/container/enter","tags":["Docker"]},{"title":"Selenium 自動化測試","url":"/2023/10/03/Selenium-自動化測試/","content":"\n這篇是記錄我在看鐵人賽 [Python 與自動化測試的敲門磚 ](https://ithelp.ithome.com.tw/articles/10290529) 的過程\n\n# 套件安裝\n\nselenium：用來建立模擬器\nwebdriver_manager：用來協助我們做驅動程式的安裝，可以無需實際下載瀏覽器的驅動程式\n```\npip install selenium\npip install webdriver_manager\n```\n\n# 快速入門\n程式解析：\n\n透過 make_webdriver 內的程式碼，可以建立一個 Chrome 物件，習慣上我們會將此物件命名為 driver\n透過實作該方法得到 driver\n透過 driver.get() 對網址進行請求，這個時候 driver 就會實際替我們開啟一個瀏覽器\n為了展示開啟成功，使用 time.sleep() 讓瀏覽器畫面停止一下\n使用 driver.quit() 來確保瀏覽器完全關閉，不會殘留在記憶體當中\n\n```\nimport time\nfrom selenium.webdriver import Chrome\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n\ndef make_webdriver() -> Chrome:\n    driver = Chrome(ChromeDriverManager().install())\n\n    return driver\n\n\nif __name__ == '__main__':\n    url = \"https://ithelp.ithome.com.tw/questions\"\n    _driver = make_webdriver()\n    \n    _driver.get(url=url)\n    time.sleep(10)\n    \n    _driver.quit()\n```\n\n成果展示：\n\n可以看到下圖當中，透過 selenium 開啟的瀏覽器上方會有註明受到測試軟體控制\n\n# 加上參數\n\n我們可以透過加上一些參數，來設定瀏覽器開啟時的相關設定，下方直接透過程式講解\n程式解析：\n\nimport Options 這個 class\n於 function 內實作此 class\n透過 add_argument 加入參數\n--headless：讓瀏覽器進入無頭模式，簡單來說就是放在背景運行，不會實際開一個視窗出來\n--start-maximized：確保瀏覽器每次執行時都可以開到最大的視窗，避免 RWD 造成一些元素讀不到\n\n```\nfrom selenium.webdriver.chrome.options import Options\n\ndef create_options() -> Options:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--start-maximized\")\n\n    return options\n```\n完整程式碼：\n透過在 driver 中添加 options 參數，我們即可為 driver 做一些瀏覽器的設定\n```\nfrom selenium.webdriver import Chrome\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n\ndef make_webdriver() -> Chrome:\n    options = create_options()\n    driver = Chrome(ChromeDriverManager().install(),\n                    options=options)\n\n    return driver\n\n\ndef create_options() -> Options:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--start-maximized\")\n\n    return options\n\n\nif __name__ == '__main__':\n    url = \"https://ithelp.ithome.com.tw/questions\"\n    _driver = make_webdriver()\n\n    _driver.get(url=url)\n\n    _driver.quit()\n```\n\n# 搭配 fixture\n\n在撰寫測試程式的時候，driver 就特別適合撰寫成 fixture 來進行使用，下面也是直接附上範例\n\n程式解析：\n\n建立一個 fixture 並命名為 driver\n建立 options\n建立 driver 並指派 options 參數\n透過 yield 將 driver 回傳出去\n測試程式結束後回到 fixture 內執行 driver.quit() 退出 driver\n\n```\nimport pytest\nfrom selenium.webdriver import Chrome\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n\n@pytest.fixture(name=\"driver\")\ndef driver_fixture() -> Chrome:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--start-maximized\")\n\n    driver = Chrome(ChromeDriverManager().install(),\n                    options=options)\n\n    yield driver\n\n    driver.quit()\n```\n\n# 建立 driver 函式\n首先我們先建立一個通用的可以回傳 driver 的函式，這個部份我們昨天介紹過了，今天就直接上範例方便大家對應函式名稱\n\n本次進行範例說明所請求的網址為 PTT 熱門版，下方範例中有附上網址\n```\nfrom selenium.webdriver import Chrome\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\n\nurl = \"https://www.ptt.cc/bbs/index.html\"\n\n\ndef make_chrome_driver() -> Chrome:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--start-maximized\")\n\n    driver = Chrome(ChromeDriverManager().install(),\n                    options=options)\n    return driver\n```\n\n# 使用 CSS_SELECTOR 定位\nSelenium 的官方文件中，提供了許多種定位 HTML 元素的方式，今天我們就挑兩種比較常用的來進行介紹，首先我們先介紹 CSS_SELECTOR\n\nCSS_SELECTOR 語法：<html 元素名稱><CSS 名稱>，其中 CSS 名稱可以是複數個，下面附上使用範例，至於該如何取得 CSS，我們可以透過在網頁上按又鍵開啟 \"檢查\" 選項來進行查看\n\n程式解析：\n\n取得 driver 並進行請求\n使用 driver.find_element 來尋找元素，並指定使用 CSS_SELECTOR 進行尋找，第二個參數為 CSS 條件\n印出該元素的資訊\n使用 driver.find_elements 尋找所有在葉面上已出現並符合 CSS 條件的資訊\n透過 generator 的方式來印出所有元素的文字資訊\n補充說明：\n每一個透過 selenium 找到的元素都一定有 text 屬性以及 get_attribute() 方法，其中 text 會印出該元素下所有的文字資訊，get_attribute() 則可以該元素的相關資訊，例如：class、href ... 等等，下方的範例為取得 text\n\n```\nfrom selenium.webdriver.common.by import By\n\ndef demo_css_selector():\n    driver = make_chrome_driver()\n    driver.get(url=url)\n    \n    # 回傳最先找到的元素，若沒有找到則會跳 error\n    data = driver.find_element(By.CSS_SELECTOR, \"div.b-ent\").text\n    print(data)\n    \n    # 會尋找目前葉面當中所有符合條件的元素，並回傳一個 list，若沒找到會回傳一個空 list\n    datas = driver.find_elements(By.CSS_SELECTOR, \"div.b-ent\")\n    [print(tmp.text) for tmp in datas]\n```\n\n# 使用 XPATH 定位\n\n接下來的範例當中，我們會使用 XPATH 的方式尋找元素，並使用 get_attribute() 來取得該元素的 class\n\n補充：我們同樣可以透過 \"檢查\" 來複製該元素在網頁上的 XPATH\n\n在 \"檢查\" 當中找到該元素\n對該元素點選右鍵，選取 \"複製\" -> \"複製 XPATH\" or \"複製完整 XPATH\"\n至於 XPATH 的使用方式則不是本次重點，之後可以在鐵人賽後找時間進行說明\n\n程式解析：\n運作邏輯基本上一樣，只是 By.CSS_SELECTOR 更換成 By.XPATH，並搭配 XPATH 條件\n```\ndef demo_xpath():\n    driver = make_chrome_driver()\n    driver.get(url=url)\n\n    data = driver.find_element(By.XPATH, \"//*[@id='main-container']/div[2]/div[1]\")\n    print(data.get_attribute(\"class\"))\n\n    datas = driver.find_elements(By.XPATH, \"//*[@id='main-container']/div[2]/div\")\n    [print(tmp.get_attribute(\"class\")) for tmp in datas]\n```\n# 等待元素出現\n由於 selenium 是實際開啟一個瀏覽器來進行請求，因此會受限於各種情況導致元素會比較慢出現，因此 selenium 提供了一種等待元素的方式，下面附上使用範例\n\n程式解析：\n\n透過 WebDriverWait 進行元素的等待，告訴 Selenium 等待該元素 10 秒，當元素在 10 秒內出現，則會繼續進行下一段程式，但是超過 10 秒還沒出現，則會拋出 Timeout 錯誤\nec.presence_of_element_located 則表示要去尋找目前出現在畫面上的元素，和下方的 of_all 差別為單數之分，用法同 find_element\n\n```\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as ec\n\n\ndef demo_wait():\n    driver = make_chrome_driver()\n    driver.get(url=url)\n    \n    # 單個元素，回傳 webelement 物件\n    data = WebDriverWait(driver, 10).until(\n        ec.presence_of_element_located((By.CSS_SELECTOR, \"div.b-ent\")))\n    print(data.text)\n    \n    # 多個元素，回傳 list\n    datas = WebDriverWait(driver, 10).until(\n        ec.presence_of_all_elements_located((By.CSS_SELECTOR, \"div.b-ent\")))\n    [print(tmp.text) for tmp in datas]\n```\n\n# 建立 driver 函式\n同樣的我們今天一樣先附上建立 driver 的函式，今天比較不一樣的地方是，我們透過 contextmanager 來建立，\n這樣我們就可以透過 yield 以及 with 的方式來操作 driver，並於操作結束後會自動回到此函式內執行 driver.quit()，以此確保瀏覽器會被完全關閉，不殘留在記憶體當中\n\n另外我們今天爬取的目標是 ithelp，因此代入 user-agent 以免被誤認為是機器人而造成範例失敗，理論上如果是拿來測試網頁的話，應該是不用帶入這個參數的，不過還是要視情況而定\n```\nfrom contextlib import contextmanager\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver import Chrome\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n@contextmanager\ndef make_chrome_driver() -> Chrome:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--start-maximized\")\n    options.add_argument(f\"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n                         f\"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\")\n\n    driver = Chrome(ChromeDriverManager().install(),\n                    options=options)\n    yield driver\n    driver.quit()\n```\n\n# 取得基本資訊\n\n我們可以透過 driver 物件本身取得一些瀏覽器的資訊，下面列舉三點並附上程式碼做參考：\n\ndriver.current_url：取得瀏覽器目前所在頁面的網址\ndriver.title：取得瀏覽器目前所在頁面的 title，就是我們可以在瀏覽器最上方看到的分頁的名稱\ndriver.page_source：取得瀏覽器目前所在頁面的 HTML Code，取得後可透過 BeautifulSoup 進行網頁解析\n\n```\ndef demo_basic_info():\n    with make_chrome_driver() as driver:\n        driver.get(\"https://ithelp.ithome.com.tw/\")\n\n        # 取得目前頁面的網址\n        current_url = driver.current_url\n        print(current_url)\n\n        # 取得目前頁面的 title\n        current_title = driver.title\n        print(current_title)\n\n        # 取得目前頁面的 HTML Code\n        current_code = driver.page_source\n        print(current_code)\n```\n\n# 點選元素\n\n在 selenium 當中點選元素的方式有兩種，分別為透過 selenium 找到元素後進行點選以及找到元素後透過執行 javascript 進行點選，後者通常用於當要被點選的按鈕被某個跳出視窗遮住，或是畫面上被隱藏但是 HTML Code 實際上是存在時，我們就可以透過執行 javascript 直接對其進行點選的動作\n\n## 使用 Selenium 點選\n\n程式解析：\n\n利用 selenium 找到 \"技術文章\" 按鈕元素\n透過呼叫元素當中的 click() 方法即代表使用 selenium 內建的方式進行點選\n點選該元素後頁面會進行跳轉，於點選後透過 driver.current_url 來取得該頁面網址\n驗證取得的網址是否如同預期該出現的網址內容\n\n```\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as ec\n\n\ndef demo_click_by_selenium():\n    with make_chrome_driver() as driver:\n        driver.get(\"https://ithelp.ithome.com.tw/\")\n        technical_article_button = WebDriverWait(driver, 30).until(\n            ec.presence_of_element_located((By.XPATH, \"/html/body/div[1]/nav/div[1]/div/ul[1]/li[2]/a\")))\n\n        # click by selenium\n        technical_article_button.click()\n\n        technical_article_url = \"https://ithelp.ithome.com.tw/articles?tab=tech\"\n        current_url = driver.current_url\n\n        assert current_url == technical_article_url\n```\n\n## 使用 Javascript 點選\n\n語法：driver.execute_script(\"arguments[0].click();\", <元素名稱>)\n\n程式解析：\n運作邏輯基本同上面一樣，差別只在於透過 javascript 執行點選的部分，有特別使用註解標記\n\n```\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as ec\n\ndef demo_click_by_javascript():\n    with make_chrome_driver() as driver:\n        driver.get(\"https://ithelp.ithome.com.tw/\")\n        technical_article_button = WebDriverWait(driver, 30).until(\n            ec.presence_of_element_located((By.XPATH, \"/html/body/div[1]/nav/div[1]/div/ul[1]/li[2]/a\")))\n\n        # click by js\n        driver.execute_script(\"arguments[0].click();\", technical_article_button)\n\n        technical_article_url = \"https://ithelp.ithome.com.tw/articles?tab=tech\"\n        current_url = driver.current_url\n\n        assert current_url == technical_article_url\n```\n\n# 鍵盤操作\n\n在 selenium 當中，我們可以透過 send_keys() 方法來對元素進行文字的輸入，另外也可以透過 selenium 提供的 Keys 類別來模擬鍵盤的操作，下面的範例當中我們就分別使用上述兩種方法來進行帳號密碼的輸入，並用 Enter 鍵進行確認\n\n程式解析：\n\n* 先分別透過 selenium 找到輸入帳號、密碼的元素\n* 利用 send_keys() 輸入帳號及密碼\n* 輸入完成後於 password 利用 Keys 模擬 Enter 鍵的操作進行確認以及頁面跳轉\n* 於跳轉後，取得 user name 並進行驗證\n\n```\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as ec\n\n\ndef demo_input_keyboard():\n    with make_chrome_driver() as driver:\n        driver.get(\"https://member.ithome.com.tw/login\")\n        account = WebDriverWait(driver, 30).until(ec.presence_of_element_located((By.XPATH, \"//*[@id='account']\")))\n        password = WebDriverWait(driver, 30).until(ec.presence_of_element_located((By.XPATH, \"//*[@id='password']\")))\n\n        account.send_keys(\"<你的帳號>\")\n        password.send_keys(\"<你的密碼>\")\n        password.send_keys(Keys.ENTER)\n\n        user_name = WebDriverWait(driver, 30).until(\n            ec.presence_of_element_located((By.XPATH, \"//*[@id='editNickname']\")))\n\n        assert user_name.text == \"熊熊工程師\"\n```\n\n# 建立測試目標\n\n1. 確認瀏覽器請求網址後的網址是否為 \"https://ithelp.ithome.com.tw/\"，title 開頭是否為 \"iT 邦幫忙\"\n1. 確認請求 \"https://ithelp.ithome.com.tw/\" 後，網頁上是否有出現 \"技術問答\" 字樣，且 HTML tag 為 h2\n1. 確認請求 \"https://ithelp.ithome.com.tw/\" 後，網也上是否有出現 \"技術問答\"、\"技術文章\"... 等選項按鈕\n\n# 建立 conftest.py\n\n在開始撰寫測試程式前，我們可以先撰寫 fixture 方便後續的測試進行，而由於 driver 確定是每個 test case 都會使用到的功能，因此我們將此 fixture 撰寫在 conftest.py 當中\n\nconftest.py\n\n```\nimport pytest\nfrom selenium.webdriver import Chrome\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n\n@pytest.fixture(name=\"driver\")\ndef driver_fixture() -> Chrome:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--start-maximized\")\n    options.add_argument(f\"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n                         f\"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\")\n\n    driver = Chrome(ChromeDriverManager().install(),\n                    options=options)\n\n    yield driver\n\n    driver.quit()\n```\n# 驗證 url 及 title\n\n程式解析：\n\n先對指定網址進行請求\n驗證請求後跳轉的網址是否正確\n驗證跳轉網址後的頁面的 title 是否開頭為 \"iT 邦幫忙\"\n\n```\nfrom selenium.webdriver import Chrome\n\n\ndef test_current_url(driver: Chrome):\n    driver.get(\"https://ithelp.ithome.com.tw/\")\n\n    correct_url = \"https://ithelp.ithome.com.tw/\"\n    assert driver.current_url == correct_url\n\n    correct_title_start = \"iT 邦幫忙\"\n    assert driver.title.startswith(correct_title_start)\n```\n\n# 驗證元素文字是否正確\n\n程式解析：\n\n建立測試資料\n進行請求\n透過 CSS_SELECTOR 找到元素\n驗證該元素的 text 內容是否符合測試資料\n```\nfrom selenium.webdriver import Chrome\nfrom selenium.webdriver.common.by import By\n\n\ndef test_text_visible(driver: Chrome):\n    correct_text = \"技術問答\"\n\n    driver.get(\"https://ithelp.ithome.com.tw/\")\n    question_h2_element = driver.find_element(\n        By.CSS_SELECTOR, \"h2.tab-title\")\n\n    assert question_h2_element.text == correct_text\n```\n\n# 驗證按鈕選項是否都有出現\n程式解析：\n\n建立測試資料\n進行請求\n透過 driver 先找到位於左方的選項列表元素 (ul)\n在針對該元素尋找所有的選項內容 (li) 並透過 generator 的方式取得文字內容串列\n文字內容串列是否符合正確的測試資料\n```\nfrom selenium.webdriver import Chrome\nfrom selenium.webdriver.common.by import By\n\n\ndef test_element_clickable(driver: Chrome):\n    correct_options = [\"技術問答\", \"技術文章\", \"iT 徵才\",\n                       \"Tag\", \"聊天室\", \"2022 鐵人賽\"]\n\n    driver.get(\"https://ithelp.ithome.com.tw/\")\n    options = driver.find_element(\n        By.CSS_SELECTOR, \"ul.list-unstyled.menu__left\")\n    options = [tmp.text for tmp in options.find_elements(\n        By.CSS_SELECTOR, \"li.menu__item\")]\n\n    assert options == correct_options\n```\n\n# 安裝 Selenium IDE\n\n1. 前往這個網址：https://chrome.google.com/webstore/detail/selenium-ide/mooikfkahbdckldjjndioackbalphokd\n1. 點選 \"加到 Chrome\" 選項\n1. 選擇 \"新增擴充功能\" 選項\n1. 過一陣子之後就可以在 Chrome 的右上角看到 Selenium IDE 被成功加入\nhttps://ithelp.ithome.com.tw/upload/images/20221002/20144024nmnQrxsQAM.png\n\n# 介面介紹\n## 建立新專案\n在開始介面介紹之前，我們先透過下面步驟建立一個簡單的測試計畫\n\n1. 開啟 Selenium IDE\n1. 選擇 \"Record a new test in a new project\" 選項\n1. 輸入 project 名稱，範例使用 \"demo\"\n1. 輸入此測試計畫的目標網址，此處使用 https://ithelp.ithome.com.tw/\n1. 點選 \"START RECORD\" 選項開始進行錄製\n1. 點選該選項之後，就可以看到他幫我們開啟一個連覽器並且右下角有顯示 Recording 字樣\n\n![](https://hackmd.io/_uploads/Syz_9ZFg6.png)\n\n## 介面介紹\n![](https://hackmd.io/_uploads/SkOqcZtla.png)\n\n1. project name：測試計畫名稱，我們可以透過命名計畫名稱來替測試分類\n1. test 分類：分別有 Tests、Test Suites、Executing，此為 Selenium IDE，表示 Test 的部分\n1. Tests：會列出所有 Test case\n1. Test Suites：該計畫內部中的分類，預設會有 Default Suites 的存在\n1. Executing：目前正在執行測試的 test case 會出現在此分類\n1. test case 列表：依照　test 分類顯示出對應的 test case\n1. 指令列表：列出該 test case 當中所有的指令，並會依照順序進行執行\n1. 編輯指令：每個指令都可以透過這個視窗進行編輯、更換\n1. 存檔\n1. 錄製按鈕：按下此按鈕後會開啟瀏覽器並進行錄製\n\n## 錄製腳本展示\n\n我們可以透過錄製腳本的方式來進行測試案例的建立，也可以透過手動插入腳本的方式進行建立，不過在驗證的部分一定是透過手動插入的，Selenium IDE 只能協助我們錄製在我們想驗證的元素出現之前該進行甚麼樣的動作\n\n另外經過筆者實測，建議在開始錄製之前都手動插入一行 open 命令來開啟網址，在錄製的過程中會比較順暢，下面我們就簡單錄製一個腳本給大家看\n\n### 腳本說明\n\n我們會按照下面的步驟來進行腳本的錄製：\n\n1. 開啟　https://ithelp.ithome.com.tw/\n1. 放大瀏覽器畫面\n1. 點選 \"技術文章\"\n1. 驗證 \"h2 技術文章\" 元素是否有出現\n\n### 腳本展示\n\n1. 點選紅色方框按鈕可以進行單個測試程式測試，左方按鈕為執行所有測試程式\n1. 建議於錄製完成後，都將第一行 open 指令中的 \"Target\" 修改成想要到達的網址，避免造成錯誤\n\n![](https://hackmd.io/_uploads/Bkq1jbtlp.png)\n\n### 驗證方式\n\n這個部分會說明一些常用的驗證項目，也就是 assert 的選項\n\n* assert alert：驗證是否有跳出提示視窗\n* assert element present：驗證元素是否有出現\n* assert element not present：驗證元素是否沒出現\n* assert text：驗證元素文字是否為指定的數值\n* assert not text：驗證元素是否不為指定的數值\n\n### 輸出為 Python 腳本\n\n#### 輸出步驟\n\n透過下面的方式可以將錄製好的腳本輸出為 Python 以及其他語言的腳本，然後就可以交給測試部門的 RD 進行程式的重構或使用，進一步套入 CI/CD 進行自動化測試\n\n回到 Tests 分類\n\n點選要匯出的測試案例旁邊的三個按鈕\nhttps://ithelp.ithome.com.tw/upload/images/20221002/20144024nOaNk5J8ye.jpg\n\n選擇 \"EXPORT\" 選項\n\n選擇 \"Python pytest\" 選項\n\n選擇 \"EXPORT\" 選項\n\n#### 腳本展示\n\n透過 Selenium IDE 所輸出的 Python 腳本，可以直接執行，不如果要套入 CI/CD，或是公司本身自有的測試框架或其他種類流程的話，\n都會需要進行某種程度上的重構，這時後錄製腳本的人員如果沒有程式相關背景的話，就可以交給 RD 進行重構並納入自動化測試當中，\n或本身是測試部門的 RD 的話，也可以透過這個小工具來減少我們寫 code 的時間，獲取更多偷懶的機會\n```\n# Generated by Selenium IDE\nimport pytest\nimport time\nimport json\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.action_chains import ActionChains\nfrom selenium.webdriver.support import expected_conditions\nfrom selenium.webdriver.support.wait import WebDriverWait\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\n\n\nclass TestDemo():\n    def setup_method(self, method):\n        self.driver = webdriver.Chrome()\n        self.vars = {}\n\n    def teardown_method(self, method):\n        self.driver.quit()\n\n    def test_demo(self):\n        self.driver.get(\"https://ithelp.ithome.com.tw/\")\n        self.driver.set_window_size(1552, 832)\n        self.driver.find_element(By.LINK_TEXT, \"技術文章\").click()\n        elements = self.driver.find_elements(By.XPATH, \"//h2[contains(.,\\'技術文章\\')]\")\n        assert len(elements) > 0\n        self.driver.close()\n```\n\n# XPATH\n\n## 建立 driver 函式\n這邊就不再贅述，直接上範例，唯一不一樣的地方是，在這個階段我們會直接開啟指定的 url 再將 driver 回傳\n\n```\nfrom contextlib import contextmanager\nfrom selenium.webdriver import Chrome\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n\n@contextmanager\ndef make_chrome_driver() -> Chrome:\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--start-maximized\")\n    options.add_argument(f\"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n                         f\"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\")\n\n    driver = Chrome(ChromeDriverManager().install(),\n                    options=options)\n    driver.get(\"https://ithelp.ithome.com.tw/questions\")\n    yield driver\n    driver.quit()\n```\n## 相對位置 XPATH\n\n在 selenium 當中，我們可以透過相對位置的 XPATH 來定位我們的元素，語法結構大致如下：\n```\nxpath = \"//div[@class='board tabs-content']/div[1]\"\n```\n\n* //：表示當前網頁 or 元素\n* div：要尋找的 HTML tag\n* []：為 XPATH 的運算邏輯，在裡面可以增加 class、id 甚至是 and 等條件，語法為 \"@<屬性名稱>\"，ex: @class、@id、@name...\n* div[1]：同層級且同樣的元素可能會有很多個，例如：ithelp 問答葉面的問題列表，可以透過取串列的方式來取得指定的個數，若沒有預設為取得第一個找到符合條件的元素\n\n上述的 XPATH 語法代表要取得 \"class 為 board tabs-content 的 div\" 底下的 \"第一個 div\"\n\n範例程式：\n```\nfrom selenium.webdriver.common.by import By\n\n\ndef get_question_by_relative_xpath():\n    with make_chrome_driver() as driver:\n        xpath = \"//div[@class='board tabs-content']/div[1]\"\n        question = driver.find_element(By.XPATH, xpath)\n        print(question.text)\n```\n執行結果：\n![](https://hackmd.io/_uploads/ryik6btlp.png)\n\n## 取得多個元素\n\n當你找元素時使用的是 driver.find_elements，XPATH 會協助你將所有符合條件的元素都蒐集回來，下方的範例當中就成功將問答頁面第一頁中所有的問題都爬娶回來並印出數量\n\n範例程式：\n\n可以看到下方範例當中，我們將最後面的 div[1] 取代為 div[@class='qa-list']，表示我們要在這一層取得所有 \"class 為 qa-list的 div\"\n\n```\nfrom selenium.webdriver.common.by import By\n\n\ndef get_questions_by_relative_xpath():\n    with make_chrome_driver() as driver:\n        xpath = \"//div[@class='board tabs-content']/div[@class='qa-list']\"\n        questions = driver.find_elements(By.XPATH, xpath)\n        print(len(questions))\n```\n\n執行結果：\n![](https://hackmd.io/_uploads/S1QMaWYx6.png)\n","tags":["Python","自動化測試","Selenium","XPATH"]},{"title":"TDD 測試驅動開發流程","url":"/2023/10/02/TDD-測試驅動開發流程/","content":"\n這篇是記錄我在看鐵人賽 [Python 與自動化測試的敲門磚 ](https://ithelp.ithome.com.tw/articles/10290529) 的過程\n\n# TDD 簡介\nTDD 全名為 Test-Driven Development 中文翻譯為 「測試驅動開發」，顧名思義就是藉著撰寫測試程式，來一步一步建構出我們的系統，其倡導的概念為，先撰寫測試程式，再撰寫實際相對應的 function，因此程式開發者需要先行和 PM 或使用者討論系統需求，並逐步擬定測試計畫，最後才會真正開始撰寫程式\n\n採用 TDD 開發的優缺點\n\n| 好處 | 壞處 |\n| -------- | -------- | \n| 無須事後再補寫測試程式    | 若系統需求溝通不良，會容易造成系統設計不良   |\n| 每一位 RD 都可以透過測試程式了解每個 function 的內容，較容易熟悉系統   | 測試程式有很大的機率只有 RD 部門看得懂，需要花費多於成本溝通     |\n| 可以確保每個 function 被更動時，可以馬上進行測試，降低錯誤產生    ||\n\n# 3A 原則\n\n在 TDD 當中，對於每個測試程式的撰寫有著 3A 原則 (步驟)，分別為 Arrange、Act 以及 Assert，下面按照順序來進行說明\n\n下面這段程式碼是我們在 demo 3A 原則的時候要進行測試的函式\n```\ndef add_num(num1: int, num2: int) -> int:\n    return num1 + num2\n```\n## Arrange 初始、期望結果\n在這個步驟當中，我們要準備我們的測試環境、測試資料 以及預期結果\n```\ndef test_add_num():\n    # Arrange\n    num1 = 10\n    num2 = 20\n    except_result = 30\n```\n## Act 實際呼叫\n在這個步驟當中，我們就會實際呼叫我們需要測試的 function 來驗證其正確性\n```\ndef test_add_num():\n    # Arrange\n    num1 = 10\n    num2 = 20\n    except_result = 30\n\n    # Act\n    result = add_num(num1, num2)\n```\n## Assert 驗證\n最後我們才會進行驗證，看看該 function 是否如預期的回傳我們想要的值\n```\ndef test_add_num():\n    # Arrange\n    num1 = 10\n    num2 = 20\n    except_result = 30\n\n    # Act\n    result = add_num(num1, num2)\n\n    # Assert\n    assert result == except_result\n```\n以上就是 TDD 針對撰寫每一個 test case 的 3A 原則\n\n# TDD 的開發五步驟\n接下來是要講的部分是，TDD 針對開發流程的五步驟，亦即每一組函式的開發過程 (function + test function)，分別為：\n\n## 新增測試程式\n選定一個要撰寫的需求、功能 (function)\n思考使用情境，準備測試環境以及資料\n先建立測試函式，不要先寫 function 本身 (即先撰寫 test_function)\n對應到 3A 中的 Arrange)\n\n## 執行測試程式 (亮紅燈)\n由於還沒有實踐撰寫 function，因此在這個步驟一定會是錯誤\n這個步驟要確定的是錯誤只發生在沒有撰寫 function 的部分，其他部分必須要確保可以正常運行，例如：fixture\n是否可以正常接收，測試資料語法是否錯誤\n\n## 撰寫 function\n這個步驟我們要開始撰寫 function 本身\n撰寫原則為以最低限度可以回傳正確資料為主，不需要對程式碼進行優化\n對應到 3A 中的 Act\n\n## 執行測試程式 (亮綠燈)\n確保撰寫的功能正常\n驗證回傳資料是否正確\n對應到 3A 中的 Assert\n\n## 優化程式\n在前面四個步驟當中，我們已經將整組 function 以及 test_function 準備完成，接下來我們可以針對 function 進行重構\n重構的過程當中我們可以不斷地執行測試程式，確保每一次改動都可以回傳正確資料\n\n#  TDD 實作\n\n## 需求設定\n建立一個爬蟲針對 ptt 熱門看板 進行爬取\n每執行一次爬蟲腳本，會進行爬取並印出各個版名稱、分類以及最新文章\n\n## 爬蟲部分開發\n\n### 需求思考\n需要一個 url 參數，來進行網址的請求\n回傳格式為 list，每個版資料使用 dictionary 裝起來\n需要驗證項目：\nlist 不可為空\n每個 dictionary 內需要有 board、class 以及 latest_paragraph\n\n### 程式開發\n#### 撰寫測試程式\n可以看到我們在這個步驟憑空撰寫了一個 get_data 的 function 但是實際上並沒有進行任何的 import\ntest_utils.py\n```\ndef test_crawler():\n    # 建立測試參數\n    url = \"https://www.ptt.cc/bbs/index.html\"\n    \n    # 呼叫方法\n    result = get_data(url=url)\n\n    # 進行驗證\n    assert result\n    for data in result:\n        assert data.get(\"board\")\n        assert data.get(\"class\")\n        assert data.get(\"latest_paragraph\")\n```\n\n{% note info simple %}\n需要安裝套件\npip install beautifulsoup4\npip install lxml\n{% endnote %}\n\n#### 執行測試 (亮紅燈)\n接著我們要執行測試，此步驟需要確認錯誤的位置必須在 get_data() 的部分，因為我們還沒有實際撰寫此 function\n\n![](https://hackmd.io/_uploads/S14MLgdeT.png)\n> 圖中我們可以確認，發生錯誤的原因確實是因為沒有此 function\n\n#### 建立 function\nutils.py\n在這個步驟當中，我們實際撰寫了一個爬蟲的 function 並命名為 get_data\n```\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef get_data(url: str) -> list:\n    res = requests.get(url=url)\n    if res.status_code == 200:\n        soup = BeautifulSoup(res.text, \"lxml\")\n\n        result = []\n        targets = soup.find_all(\"div\", class_=\"b-ent\")\n        for target in targets:\n            tmp = {\"board\": target.find(\"div\", class_=\"board-name\").text,\n                   \"class\": target.find(\"div\", class_=\"board-class\").text,\n                   \"latest_paragraph\": target.find(\"div\", class_=\"board-title\").text}\n            result.append(tmp)\n\n        return result\n```\n#### 進行測試 (亮綠燈)\n接著我們要開始進行測試，於測試程式內實際將 get_data 進行 import 並測試調整直到亮綠燈\n\ntest_utils.py\n```\nfrom utils import get_data\n\n\ndef test_crawler():\n    # 建立測試參數\n    url = \"https://www.ptt.cc/bbs/index.html\"\n\n    # 呼叫方法\n    result = get_data(url=url)\n\n    # 進行驗證\n    assert result\n    for data in result:\n        assert data.get(\"board\")\n        assert data.get(\"class\")\n        assert data.get(\"latest_paragraph\")\n        \n```\n下圖中可以看到我們很幸運的一次就成功了，代表可以進入下個步驟\n#### 程式碼優化\n 在這個過程中，我們就可以開始針對程式碼進行重構，切記，每進行一次重構，就要執行一次對應的 test case\n確保每次的異動不會造成 function 異常\n\n由於需求提到需要印出，因此於這個步驟我們替 get_data 加上 print 讓需求完善，並建立腳本進入點\n```\nimport requests\nfrom bs4 import BeautifulSoup\nfrom pprint import pprint\n\n\ndef get_data(url: str) -> list:\n    res = requests.get(url=url)\n    if res.status_code == 200:\n        soup = BeautifulSoup(res.text, \"lxml\")\n\n        result = []\n        targets = soup.find_all(\"div\", class_=\"b-ent\")\n        for target in targets:\n            tmp = {\"board\": target.find(\"div\", class_=\"board-name\").text,\n                   \"class\": target.find(\"div\", class_=\"board-class\").text,\n                   \"latest_paragraph\": target.find(\"div\", class_=\"board-title\").text}\n            result.append(tmp)\n\n        pprint(result)  # pprint 用於自動排版輸出\n        return result\n\n\nif __name__ == '__main__':\n    get_data(url=\"https://www.ptt.cc/bbs/index.html\")\n```\n\n下圖為利用 cmd 執行的結果\n![](https://hackmd.io/_uploads/B1BjwluxT.png)\n>  python3  utils.py\n\n\n參考文章: \nhttps://ithelp.ithome.com.tw/articles/10299287","tags":["Pytest","Python","開發流程","TDD","爬蟲"]},{"title":"在Windows上安裝 pnpm","url":"/2023/09/26/在Windows上安裝-pnpm/","content":"\n# 前言\n\n因為練習Next.js 開發blog 需要安裝 pnpm 紀錄一下 windows 上如何安裝pnpm \n\n後來在[這篇文章](https://stackoverflow.com/questions/75365692/how-to-install-pnpm-on-windows)找到解決方法\n\n參考影片: https://www.youtube.com/watch?v=q5iDjNR1O7Y&ab_channel=GeekyScript\n\n# 打開CMD執行以下指令\n\n```\nset-ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n以上是一個 PowerShell 命令\nset-ExecutionPolicy：這是 用於設置執行策略。\n\nRemoteSigned：這是一個執行策略的值。在這種情況下，它表示允許執行本地（在本機計算機上）簽名過的腳本，但來自遠程位置（例如網絡上的腳本）的腳本需要經過簽名才能執行。這有助於提高安全性，因為它可以防止遠程未經信任的腳本在你的系統上運行。\n\n-Scope CurrentUser：這部分指定了執行策略的作用範圍。在這種情況下，它設置執行策略只對當前使用者（CurrentUser）生效，而不會影響其他使用者。這是一種局部的設置，只影響當前使用者的 PowerShell 會話。\n\n總結起來，這個命令的含義是：將當前使用者的 PowerShell 執行策略設置為 RemoteSigned，這意味著他們可以執行本地簽名過的腳本，但需要簽名的遠程腳本才能運行。這是一種安全的默認策略，可防止未經信任的遠程腳本在系統上執行。\n# 執行 Get-ExecutionPolicy\n```\nGet-ExecutionPolicy\n```\n\nGet-ExecutionPolicy 是 PowerShell 中的一個 cmdlet（命令），它用於檢索當前的執行策略。執行策略指定了哪些 PowerShell 腳本可以在系統上執行，以及它們如何被允許執行。當你運行 Get-ExecutionPolicy 命令時，它會返回當前使用者或系統的執行策略設置。\n\n\n# 查看所有的 Policy 可以執行以下指令\n```\nGet-ExecutionPolicy -list\n```\n\n\n執行策略有不同的級別，包括：\n\nRestricted：這是最嚴格的策略，它禁止執行所有腳本，包括本地和遠程腳本。這通常是預設的策略，以確保系統的安全性。\n\nAllSigned：這個策略要求所有腳本都必須經過數位簽名，無論是本地還是遠程的。只有經過簽名的腳本才能執行。\n\nRemoteSigned：這個策略要求遠程腳本必須經過數位簽名，但本地腳本可以自由執行，不需要簽名。\n\nUnrestricted：這個策略允許所有腳本在系統上執行，不需要簽名。這是最不安全的策略，應謹慎使用。\n\nBypass：這個策略完全禁用執行策略，允許所有腳本自由執行。這是一個非常不安全的設置，應該極少使用，如果需要請謹慎使用\n\n\n#  安裝 pnpm\n```\nnpm i -g pnpm\n```","tags":["pnpm","windows"]},{"title":"使用docker執行jenkins","url":"/2023/09/23/使用docker執行jenkins/","content":"\n# 使用docker執行jenkins\n\n## 拉取docker hub上的jenkins image\n```\ndocker pull jenkinsci/blueocean\n```\n\n## 運行docker 鏡像命令\n\n```\ndocker run \\\n  -u root \\\n  --rm \\\n  -d \\\n  -p 8081:8080 \\\n  -p 50000:50000 \\\n  -v jenkins-data:/root/docker/jenkins_home \\\n  -v $PWD/allure-results:/allure-results \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  jenkinsci/blueocean\n```\n\n![](https://hackmd.io/_uploads/HJaG4-2y6.png)\n> 執行後可以看見docker 運行的狀況\n\n## 打開8081 port，登入jenkins首頁\n![](https://hackmd.io/_uploads/SyJLEWnJp.png)\nhttp://localhost:8081/\n\n## 進入容器取得管理員密碼\n\n點擊docker\n![](https://hackmd.io/_uploads/rytAVWhkT.png)\n\n![](https://hackmd.io/_uploads/BydZSbnyT.png)\n>點擊 Terminal \n\n輸入 cat /var/jenkins_home/secrets/initialAdminPassword\n可以拿到密碼\n\n## 選擇插件，安装jenkins，等待即可完成\n![](https://hackmd.io/_uploads/HJlSPZ21a.png)\n設定系統管理員帳號後就可以使用了","tags":["docker","jenkins"]},{"title":"Pytest 自動測試","url":"/2023/09/22/Pytest-自動測試/","content":"\n# Pytest 指令\n```\npytest <.py 檔案位置>\n```\n範例：pytest .\\day_03\\test_demo.py\n\n## 參數執行\n1.列出每個 test case 的執行狀況\n```\npytest -v <目錄 or 檔案位置>\n```\n\n2.會印出在 test case 內有 print 出來的數值\n```\npytest -s <目錄 or 檔案位置>\n```\n\n3.不同的參數間，也可以進行混用，這邊進行簡單的範例展示\n```\npytest -s -v <目錄 or 檔案位置>：\n```\n\n# 產生報表\n\n## 產出 JSON 格式報表\n\n### 安裝 pytest-json-report 套件\n```\npip install pytest-json-report \n```\n\n### 套件使用\n```\npytest <pytest 原生參數 ex: -s -v> --json-report --json-report-file=<檔案名稱 or ./目錄位置/檔案名稱> <要執行的 .py 檔案 (可省略直接對整個目錄做讀取)>\n```\n使用範例：pytest -s -v --json-report --json-report-file=.\\report\\report.json .\\test_demo.py\n\n### 報表結果解析\n\n\n| Column 1 | Column 2 | \n| -------- | -------- |\n| duration     | 本次測試執行所耗費的時間     | \n| root     | 從哪個目錄下 pytest 指令的     | \n| environment     | 一些環境的設定，例如 Python 版本    |  \n| summary     | 測試結果總攬，collected 的部份表示 pytest 從 root 開始往下蒐集到多少個 test case    | \n| collectors     | 蒐集 test case 的過程  | \n| tests     | 測試的詳細結果，包含 setup、teardown 和 test case 本身的執行過程、時間  | \n\n\n## 產出 HTML 報表\n### 安裝 pytest-html 套件\n```\npip install pytest-html\n```\n### 套件使用\n```\npytest --html=<檔案名稱.html or .\\目錄位置\\檔案名稱.html> <執行的 .py 檔，省略會直接對整個目錄執行>\n```\n使用範例：pytest --html=.\\report\\report.html .\\test_demo.py\n\n![](https://hackmd.io/_uploads/r1hrz_F1p.png)\n\n## Allure\n\n### 安裝 Java JDK\n可參考這篇安裝 Java JDK\nhttps://medium.com/@pierre.viara/install-java-on-windows-10-linux-subsystem-875f1f286ee8\n\n```\nsudo apt update\n```\n![](https://hackmd.io/_uploads/SyTX8dF1p.png)\n\n\n```\nsudo apt install openjdk-11-jdk\n```\n![](https://hackmd.io/_uploads/Hkbrv_Yyp.png)\n\n可以用 java --version 確認是否安裝成功\n```\njava --version\n```\n![](https://hackmd.io/_uploads/SJqUvOY16.png)\n\n### 安裝 Allure\n\n下載地址: https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/\n\n可以選擇適合的版本\n```\ncurl -O https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/2.9.0/allure-commandline-2.9.0.tgz\n```\n![](https://hackmd.io/_uploads/rJYSLtK1T.png)\n\n\n解壓縮\n```\ntar -zxvf allure-commandline-2.9.0.tgz\n```\n![](https://hackmd.io/_uploads/SyiLIYtyp.png)\n\n設定環境\n\n進入解壓縮後的資料夾獲得絕對路徑\n```\ncd allure-2.9.0/bin/\n\npwd\n```\n\n建立軟連結\n```\nsudo ln -s /home/user/allure-2.9.0/bin/allure /usr/bin/allure\n```\n\n![](https://hackmd.io/_uploads/SJ3BtFYk6.png)\n>完成後輸入 allure --version 可以驗證是否安裝成功\n\n### 安裝套件\n```\npip install allure-pytest\n```\n\n### 執行測試與生成報表\n\n方法一\n執行測試並產生 allure 暫存檔\n```\npytest <測試檔案 or 目錄> --alluredir <allure 暫存檔存放位置>\n```\n使用 allure 暫存檔生成報表\n```\nallure generate <allure 暫存檔存放位置> -o <輸出報表位置> --clean\n```\n\n\n方法二\n```\npip install allure-pytest\n```\n \n執行測試並產生 allure 暫存檔\npy.test --alluredir=<allure 暫存檔存放位置> <測試檔案 or 目錄>\n \n使用 allure 暫存檔生成報表\n```\nallure serve <allure 暫存檔存放位置>\n```\n\n{% note warning simple %}\n目前測試產生的\n{% endnote %}\n\n### 使用docker-compose在docker容器中運行pytest\n\n{% note info simple %}\n參考文章: https://geek-docs.com/pytest/pytest-questions/9_pytest_how_to_run_pytest_from_a_docker_container_within_dockercompose.html\n{% endnote %}\n\n安裝套件\n```\n pip install pytest pytest-docker\n```\n\n\n# 環境設定\n\n##  setup、teardown \n在 function 等級設定 setup、teardown 時，會於每個 function 的開始以及結束時都會執行一次\n\n### 建立 .env 檔案\nenv 檔案當中時常會保留我們不想要進入版本控制的重要資訊\n\n{% note info simple %}\n注意： github 上的專案並沒有把 .env 推上去，若想使用請自行建立\n{% endnote %}\n\n\n```\nACCOUNT=\"test_account_123\"\nPASSWORD=\"test_password_123\"\n```\n\n### 安裝套件\n```\npip install python-dotenv\n```\n\n### 撰寫測試環境\n\n建立 test_example.py 檔案\n\n```\nimport os\nimport dotenv\n\n\ndef setup_module():\n    dotenv.load_dotenv(\"./.env\")\n\n\ndef test_get_env_account():\n    print(os.getenv(\"ACCOUNT\"))\n\n\ndef test_get_env_password():\n    print(os.getenv(\"PASSWORD\"))\n```\n\n\n\n## fixture\n### 目錄架構\n![](https://hackmd.io/_uploads/ByeEkGglT.png)\n\n\n### 快速建立 fixtures.py 檔案\n```\nimport pytest\nimport requests\nfrom fake_useragent import FakeUserAgent\n\n\n@pytest.fixture(name=\"headers\", scope=\"function\", autouse=False)\ndef headers_fixture() -> dict:\n    ua = FakeUserAgent()\n    headers = {\"User-Agent\": ua.random}\n\n    return headers\n\n\n@pytest.fixture(name=\"make_user_agent\", scope=\"function\", autouse=False)\ndef make_user_agent_fixture() -> dict:\n    ua = FakeUserAgent()\n    headers = {\"User-Agent\": ua.random}\n\n    return headers\n\n\n@pytest.fixture(name=\"parse_user_agent\", scope=\"function\", autouse=False)\ndef parse_user_agent_fixture(make_user_agent: dict) -> dict:\n    url = \"https://httpbin.org/headers\"\n    res = requests.get(url=url, headers=make_user_agent)\n    user_agent = res.json()[\"headers\"]['User-Agent']\n\n    return {\"User-Agent\": user_agent}\n```\n\n### fixture 裝飾器參數介紹\n\n\n| 參數 | 功能 |\n| -------- | -------- | \n| scope     | 表示作用域，預設為 \"function\"，亦即每個有用到此 fixture 的 test case 都會執行，另外還有 module、class 以及 session 三種     | \n| name | 用來設定 fixture 的別名，預設為函式名稱 | \n| autouse | 預設為 False，若為 True，則會自動進行使用 (根據 scope 作用域而定) | \n\n### 程式解釋\n\n利用 @pytest.fixture 標註該函式為 fixture\n利用 fake_useragent 隨機生成一個 User-Agent (需另外安裝 fake-useragent 套件)\n回傳 headers 給有使用此 fixture 的 test case\n\n\n### 使用 fixture\n接著我們回到 test_demo.py 當中，來使用剛剛所製作的 fixture。使用的方式則非常簡單，首先我們必須將剛剛撰寫好的 fixture 的 function 給 import 進來，這樣 pytest 才抓地到，接著只需要在 test case 接收參數的地方打上剛剛為 fixture 命名的名稱 (若無則預設為 fixture 的 function name)，接著我們就可以在 test case 內使用此 fixture 回傳出的內容了。\n\n1.將要使用 fixture 先進行 import\n```\nimport requests\nfrom fixtures import headers_fixture, parse_user_agent_fixture, make_user_agent_fixture\n```\n\n2.利用 https://httpbin.org/headers 來取得我們送出去的 headers\n```\ndef test_assert_headers(headers: dict):\n    url = \"https://httpbin.org/headers\"\n    res = requests.get(url=url, headers=headers)\n\n    print(res.status_code)\n    print(res.json())\n\n    assert res.status_code == 200\n    assert res.json()['headers'][\"User-Agent\"] == headers[\"User-Agent\"]\n```\n3.最後驗證取得的 headers 和我們利用 fixture 製作的 headers 是否相等\n```\ndef test_assert_user_agent(make_user_agent: dict, parse_user_agent: dict):\n    assert make_user_agent == parse_user_agent\n```\n\n備註：本測試範例只使用了一個 fixture 作為展示，實際上一個 test case 可以同時使用多個 fixture 是沒問題的\n\n### fixture 使用時機\n1. 為 test case 建立環境時\n 若是有很多個 test case 在測試前需要做一些環境的建置、參數的準備，則很適合適用 fixture\n\n2. 當你不想使用 setup、teardown 時\n 由於使用 setup、teardown 會造成該 .py 檔內的所有 test case 都被引響，而 fixture 若沒有被寫在 test case 接收的參數內，則不會被影響 (除非作用域不為 function 且 autouse=False)\n\n\n\n以上練習是參考 iTHome 鐵人賽 Python 與自動化測試的敲門磚 文章跟著練習的內容\n\n\n# 虛擬資料庫\n\n## 虛擬關聯式資料庫 SQLite\n\n### 專案架構介紹\n![](https://hackmd.io/_uploads/BJaRufglp.png)\n\n| 檔案 | 功能 |\n| -------- | -------- | \n| crud.py | 存放對資料庫做 CRUD 操作的函式 |\n| fixtures.py     | 存放使用 pytest 製作出的 fixture| \n| models.py     | 存放 sqlalchemy 建立的 ORM 架構 | \n| test_demo.py  | 存放 test case | \n\n### 資料庫路徑\n\n用在將資料庫與 ORM 架構做連線時的資料庫位置\n\n```\nmysql+pymysql://<username>:<password>@<host>:<port>/<database_name>\n```\n\n今天要介紹的虛擬關聯式資料庫，是使用 SQLite 所提供的 In-memory 的資料庫，使用的路徑非常簡單，如下所示\n\n```\nsqlite://\n```\n\n且由於 python 內自帶 sqlite 的套件，所以只要將上面的路徑放入資料庫連線的路徑，電腦就會動使用記憶體協助我們進行資料表的建立以及操作\n\n### 建立測試內容\n\n這邊我們會先簡單介紹放在 models 的內容以及要被測試的 CRUD 的函式\n\nmodels.py\n建立一張名為 User 的資料表並且有 id 、 username 以及 birthday 三個欄位\n\n```\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import String, Column, Integer, DATETIME\nfrom datetime import datetime\n\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id: int = Column(Integer, primary_key=True, autoincrement=True)\n    username: str = Column(String(64))\n    birthday: datetime = Column(DATETIME)\n```\ncrud.py\n建立一個可以利用 sqlalchemy 寫入資料的 function\n```\nfrom sqlalchemy.orm import Session\nfrom models import User\n\n\ndef create_user_in_sqlite(data: User, session: Session) -> User:\n    session.add(data)\n    session.commit()\n    session.refresh(data)\n\n    return data\n```\n\n### 建立 fixture\n\n接下來就是重點了，sqlalchemy 實際對資料庫進行操作的時後，需要一個 session 物件來協助我們進行操作，接下來我們就要利用 fixture 來替我們在測試前做建立資料表以及產生一個 session 的動作\n\n程式解析：\n\n利用剛剛所介紹的方法，先建立一個 engine 並與虛擬的 sqlite 進行連線\n在測試之前我們先利用 fixture 替我們將資料表建立好，這樣在測試的過程中就不需要再花時間在撰寫建立環境的部分\n接著我們實際建立一個 session 並 yield 出去\n使用 yield 的原因是，當 test case 結束後，就會回到 fixture 內執行接下來的動作\n由於式使用 with 進行 session 的建立，因此也 test case 結束後回到 fixture 內，此 session 會自動關閉\n最後 test case 結束會到 fixture 內將資料表全部刪除，確保下一個 test case 有乾淨的環境做測試\n\n```\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session, sessionmaker\nfrom models import Base\n\n\n@pytest.fixture(name=\"sqlite_session\")\ndef sqlite_session_fixture() -> Session:\n    # 建立 engine\n    engine_url = \"sqlite://\"\n    engine = create_engine(engine_url)\n\n    # 建立資料表\n    Base.metadata.create_all(engine)\n\n    #  yield 出 Session\n    with sessionmaker(bind=engine)() as session:\n        yield session\n\n    # 刪除資料表\n    Base.metadata.drop_all(engine)\n```\n\n### 建立測試程式\n\n接下來就來就準備撰寫 test case 了，一樣附上程式碼並逐行解釋\n\n程式解析：\n\n將所使用到的套件分別進行 import\n建立 test case 並使用 fixture sqlite_session 並提示 IDE 此為一個 Session 型態的參數\n利用 User 建立一個測試資料\n利用 crud 內的函式對資料庫測式寫入\n驗證寫入函式回傳出的 username 是否和我們手動建立的 username 是否一致\n```\nfrom crud import create_user_in_sqlite\nfrom models import User\nfrom fixtures import sqlite_session_fixture\nfrom sqlalchemy.orm import Session\nfrom datetime import datetime\n\nuse_fixtures = [sqlite_session_fixture]\n\n\ndef test_create_user_in_sqlite(sqlite_session: Session):\n    data = User(username=\"test_user\", birthday=datetime.now())\n\n    result: User = create_user_in_sqlite(data=data, session=sqlite_session)\n    print(result.__dict__)\n\n    assert result.username == data.username\n```\n\n{% note info simple %}\n測試需要安裝套件\npip install sqlalchemy\n{% endnote %}\n\n### 成果展示\n接著我們就可以利用 pytest 對 test_demo.py 進行測試了，下方為測試結果截圖\n![](https://hackmd.io/_uploads/Hy_SRflxT.png)\n\n\n## NoSQL 陣營的虛擬資料庫套件 - MongoMock\n\n### 套件安裝\npymongo：正式用來撰寫 mongo 相關的 CRUD 時常用的套件，crud.py 內的 MongoClient，會由此套件產生\n\n```\npip install pymongo\n```\nmongomock：協助用來建立一個虛擬的 MongoClient 讓我們可以透過 fixture 的方式來進行 crud.py 的測試\n\n```\npip install mongomock\n```\n\n### 建立 crud\n這邊會在 crud.py 檔案內建立一個寫入資料的方式，直接附上範例並進行解說\n\n{% note warning simple %}\n注意：在正式的專案檔案中 (即非測試程式) 需要使用 pymongo 所提供的 MongoClient，才不會造成不可避免的錯誤\n{% endnote %}\n\n程式解析：\n\nimport pymongo 的 MongoClient，進行 mongo 的 CRUD\n建立一個 insert_user 函式\n進行資料的寫入\n寫入的同時取得 id\n寫入完畢後透過 id 查詢該筆資料並回傳\n\n```\nfrom pymongo.mongo_client import MongoClient\n\ndatabase_name = \"test\"\ncollection_name = \"user\"\n\n\ndef insert_user(conn: MongoClient, data: dict) -> dict:\n    # 插入資料並取得 id\n    insert_id = conn[database_name][collection_name].insert_one(data).inserted_id\n\n    # 藉由 id 搜尋並回傳\n    result = conn[database_name][collection_name].find_one({\"_id\": insert_id})\n    return result\n```\n\n### 建立 fixtures\n\n接著我們要利用 MongoMock 所提供的 MongoClient 來進行 fixture 的撰寫，在開頭有提到，MongoMock 可以很好的兼容 PyMongo，因此我們可以直接使用 MongoMock 的 MongoClient 來進行 CRUD 的測試，範例如下\n\n注意：雖然 MongoMock 可以很好的兼容 PyMongo 不過由於版本問題，某些功能還是會無法使用，因此若測試過程中有跳錯，請留意一下錯誤訊息，看看是否為 MongoMock 還沒支援相關功能\n\n程式解析：\n\nimport mongomock 的 MongoClient\n建立一個 fixture 命名為 conn\n利用 mongomock 的 MongoClient 建立一個虛擬的連線\n透過 yield 回傳出去給 test case 使用\n```\nimport pytest\nfrom mongomock.mongo_client import MongoClient\n\n\n@pytest.fixture(name=\"conn\")\ndef mongo_client_fixture() -> MongoClient:\n    with MongoClient() as conn:\n        yield conn\n```\n\n### test case 建立\n最後我們要來建立測試程式了，直接附上範例進行解釋\n\n程式解析：\n\n將需要使用到的套件 import 進來\n建立一筆假資料\n調用 crud 當中的 insert_user 進行寫入測試\n驗證回傳出的資料是否和我們建立的假資料內容一致\n```\nfrom datetime import datetime\nfrom pymongo.mongo_client import MongoClient\nfrom fixtures import mongo_client_fixture\nfrom crud import insert_user\n\nuse_fixtures = [mongo_client_fixture]\n\n\ndef test_insert_user(conn: MongoClient):\n    # 建立假資料\n    data = {\"username\": \"nick\",\n            \"email\": \"test@test\",\n            \"birthday\": datetime(year=2022, month=12, day=31)}\n    \n    # 測試 CRUD 方法\n    result = insert_user(data=data, conn=conn)\n    print(result)\n    \n    # 驗證內容\n    assert result[\"username\"] == data[\"username\"]\n    assert result[\"email\"] == data[\"email\"]\n    assert result[\"birthday\"] == data[\"birthday\"]\n```\n\n# 驗證錯誤與跳過案例\n\n## 驗證錯誤\n\n程式解析：\n\n建立 raise_error 函式來手動引發一個錯誤\n於 test_error 內使用 pytest.raises(IndexError) 來驗證函式引發的錯誤種類是否如預期\n\n```\nimport pytest\n\n\ndef raise_error():\n    raise IndexError(\"list 的位置錯誤\")\n\n\ndef test_error():\n    with pytest.raises(IndexError):\n        raise_error()\n```\n\n注意：經筆者測試，在 pytest 驗證到預期內的錯誤訊息後，無法在同個 with 區域內進行其他驗證，都會顯示正確，若有需要驗證其他錯誤 or 案例，則需另開一個 with，或是將程式寫在 with 外部\n\n如下方程式所示，手動驗證一個錯誤的條件需要寫在接收到預期錯誤的 with 區域之外，才會被檢查到錯誤\n\n```\ndef test_error():\n    with pytest.raises(IndexError):\n        raise_error()\n\n    assert 1 + 1 == 3\n```\n\n\n### 驗證錯誤訊息\n\npytest.raises() 除了在接收到預期內的錯誤不會報錯之外，我們也可以針對錯誤訊息的內容進行驗證\n\n程式解析：\n\nwith pytest.raises(IndexError) as exc 我們可以理解成把接收到的錯誤丟給一個叫做 exc 的變數，並於外部做使用\n驗證錯誤訊息的內容\n驗證錯誤訊息的 class name\n\n```\ndef test_error_message():\n    # 將接收到的錯誤丟給一個名為 exc 的變數，該變數可於外部使用\n    with pytest.raises(IndexError) as exc:\n        raise_error()\n    \n    # 印出錯誤訊息內容並驗證\n    print(str(exc.value))\n    assert str(exc.value) == \"list 的位置錯誤\"\n    \n    # 印出錯誤訊息類別並驗證\n    print(str(exc.typename))\n    assert exc.typename == IndexError.__name__\n```\n\n### 跳過 test case\n某些情況下，我們可能會不想讓一些 test case 被執行，比方說某個 function 只能用在某個版本的時候，或是在某種作業系統上該函式使用的套件會失效，又或是暫時不想刪除，碰到這類的情況 pytest 有提供了跳過的功能，分別為 skip 和 skipif\n\n為了測試方便，我們會將接下來的兩個範例連同上面所撰寫的兩個 test case 一起執行，並且觀察 pytest 收集到的 test case 數量\n\n### 直接跳過 skip\n\n程式解析：\n\n利用 @pytest.mark.skip() 裝飾器的方式來標註該案例需要跳過\nreason 則是用來撰寫跳過的原因，該原因會被印在 terminal 上\n```\n@pytest.mark.skip(reason=\"測試案例跳過範例\")\ndef test_skip_test_case():\n    assert 1 + 1 == 3\n```\n結果展示：\n\n可以看到下方圖片中，pytest 有成功蒐集到三個 test case，而第三個 test case 狀態為 SKIPPED 並且原因印出於狀態後方\n\n### 有條件跳過 skipif\n\n我們可以透過指定 sys 內的條件來進行跳過，下方的範例就是讀取目前的作業系統，如果為 \"win32\" 就不執行此範例\n```\nimport sys\n\n\n@pytest.mark.skipif(condition=sys.platform == \"win32\", reason=\"測試跳過指定條件範例\")\ndef test_skip_test_case_by_condition():\n    assert 1 + 1 == 4\n```\n\n另外我們可以透過印出 sys 內的物件及屬性，來查看有哪些條件可以支援\n```\nprint(dir(sys))\n```\n# parametrize 自動生成多筆測試\n\n今天我們要介紹如何利用 pytest 提供的 parametrize 來自動生成多筆測試，這個方式通常用於硬體的測試，需要使用很多不同的數值來對某個功能做測試，例如：USB 寫入速度跟寫入的檔案大小，但測試的 function 其實是一樣的，像這種情況我們就不需要撰寫多個 test case，利用 parametrize 的方式來進行測試即可\n\n## 簡單範例\n下面我們直接上範例來進行解釋\n\n程式解析：\n\n利用裝飾器的方式來進行 parametrize 的撰寫\nargnames 為一組字串，分別要對應到 test case 內所需接收的參數\n注意：請不要將格式寫成　'num1', 'num2'... 應該將所有名稱包在同一組字串內，如　'num1, num2, ...'\nargvalues 用一個串列包起來並將每一組測試資料也用一個串列包起來，形成一個二維串列\n\n```\nimport pytest\n\n\n# 基本範例\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=[(1, 1, 2), (2, 2, 4)])\ndef test_add(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n```\n\n![](https://hackmd.io/_uploads/S1iE5IZea.png)\n\n## 搭配檔案讀取\n除此之外，我們也可以將多組測試參數寫進檔案中，在測試之前先讀取進 python 中，於裝飾器內再指派給 test case\n\ntest_args.json\n\n```\n{\"test_add\": [[1, 1, 2], [2, 2, 4]]}\n```\ntest_demo.py\n\n\n```\nimport json\nimport pytest\n\n\n# 搭配檔案讀取\nwith open(\"./test_args.json\", \"r\", encoding=\"utf8\") as file:\n    test_args = json.loads(file.read())['test_add']\n\n\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=test_args)\ndef test_add_with_json_file(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n```\n\n![](https://hackmd.io/_uploads/BkDTqLWxT.png)\n> 測試結果\n\n## ids 的使用\n如果同時生成許多組測試，可能會造成閱讀上的不易，這時候我們可以透過 ids 來為每一組測試提供名稱\n\n這邊我們會沿用上方讀取 json 後產生的 test_args，並手動根據 test_args 的長度來建立相關的 id，當然 ids 也可以利用讀取檔案的方式讀取近來，只要數量符合測試資料筆數，且型態為 list 即可\n\n```\n# ids 的使用\nids = [f\"case: {i}\" for i in range(1, len(test_args) + 1)]\n\n\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=test_args, ids=ids)\ndef test_add_with_json_file_and_ids(num1: int, num2: int, result: int):\n    assert num1 + num2 == result\n```\n\n![](https://hackmd.io/_uploads/SJkFiIbx6.png)\n> 可以看到 pytest 成功為我們的每組測試都加上名稱\n\n## 搭配 fixture 做使用\n\n網路上有很多 fixture 搭配 parametrize 的使用方式，不過筆者試了一下，發現 fixture 其實可以很直覺的 import 進來直接使用，請看下面範例\n\nfixtures.py\n建立一個 fixture 用來展示用\n\n```\nimport pytest\nfrom mongomock.mongo_client import MongoClient\n\n\n@pytest.fixture(name=\"conn\")\ndef mongo_client_fixture() -> MongoClient:\n    with MongoClient() as conn:\n        yield conn\n\n\n```\n\ntest_demo.py\n可以看到在這個 test case 當中，直接將 import 進來的 fixture name 打在 test case 最後面的參數，即可進行使用，請務必將 fixture 放在最尾端避免造成額外的錯誤\n\n為了驗證是否真的有被 import 近來，第二個 assert 的部分為驗證 conn 參數是否為 MongoClient 型態，而非 None\n\n```\nfrom fixtures import mongo_client_fixture\nfrom mongomock.mongo_client import MongoClient\n\nuse_fixtures = [mongo_client_fixture]\n\n\n# 搭配 fixture 使用\n@pytest.mark.parametrize(argnames='num1, num2, result', argvalues=[(1, 1, 2), (2, 2, 4)])\ndef test_add_with_fixtures(num1: int, num2: int, result: int, conn: MongoClient):\n    assert num1 + num2 == result\n    assert isinstance(conn, MongoClient)\n```\n\n![](https://hackmd.io/_uploads/SJEtnoMe6.png)\n\n# conftest.py \n\n## conftest.py 簡介\n\n白話來說 conftest.py 就是一個可以讓我們存放 \"經常被使用到\" 的 fixture 的地方，被存放在 conftest.py 當中的 fixture 不需要透過 import就可以直接進行使用，pytest 在一開始執行時，就會先去抓是否有 conftest.py 的存在，因此若今天發現你的 fixture 被許多個 test module 使用到的話不彷可以試著將 fixture 放到 conftest.py 當中\n\n順帶一提 conftest.py 的有效範圍是從 conftest.py 所存在的當前目錄以及其所有子目路中的 test case 都可以使用，若於不同目錄則需要另外寫一個 conftest.py\n\n在本次的範例當中，會利用新增 pytest cmd argument 的方式來進行範例展示，下方附上本次專案目錄的結構\n\n![](https://hackmd.io/_uploads/SJuMajGeT.png)\n\n## 範例展示\n### 建立 conftest.py\nconftest.py\n* pytest_addoption 為 pytest 內建的 fixture，可以自定使用 cmd 執行時的參數\n* 建立一個名為 permission 的參數，用來識別權限\n* 建立 permission_fixture 用來讀取權限檔案，來識別使用者可以測試的範圍\n\n```\nimport json\nimport pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"--permission\", default=\"RD\")\n\n\n@pytest.fixture(name=\"permission\")\ndef permission_fixture(pytestconfig):\n    role = pytestconfig.getoption(\"permission\")\n    with open(\"./permission.json\", \"r\") as file:\n        permission_data = json.loads(file.read())\n    if role == \"RD\":\n        permission = permission_data[\"RD\"]\n    else:\n        permission = permission_data[\"costumer\"]\n\n    return permission\n```\n\n### 建立 json 檔用來控制權限\n\npermission.json\n* 如果角色是 RD，則可以進行 select、update、delete\n* 其餘的則定位為 costumer，只能進行 select 的測試\n```\n{\n  \"RD\": [\n    \"select\",\n    \"update\",\n    \"delete\"\n  ],\n  \"costumer\": [\n    \"select\"\n  ]\n}\n```\n\n### 撰寫 test case\ntest_demo.py\n* 大家可以發現，這裡使用 permission 這個 fixture 的時候並沒有像之前一樣進行 import 可以直接使用\n* 分別有 select、update 兩項測試，並且於測試之前會進行權限的驗證\n* 於 test_update_permission 的時候，若權限不足則會引發錯誤，並驗證錯誤訊息\n```\nimport pytest\n\n\ndef test_select_permission(permission: list):\n    if \"select\" in permission:\n        assert True\n    else:\n        assert False\n\n\ndef test_update_permission(permission: list):\n    if \"update\" in permission:\n        assert True\n    else:\n        with pytest.raises(ValueError) as exc:\n            raise ValueError(\"permission not allow\")\n\n        print(str(exc.value))\n        assert str(exc.value) == \"permission not allow\"\n```\n### 結果展示\n啟動 pytest 指令:\n```\npytest -s -v --permission costumer .\\test_demo.py\n```\n![](https://hackmd.io/_uploads/r1iJe2Gxp.png)\n>可以看到當 permission 為 costumer 時，成功地引發了錯誤並通過錯誤訊息的驗證\n\n```\npytest -s -v --permission RD .\\test_demo.py\n```\n![](https://hackmd.io/_uploads/SkK-ehGxp.png)\n>當權限為 RD 時，則 update 的部分不會引發錯誤\n\n\n# 問題排除\n\n## chrome driver版本過舊\nselenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114\n\n這個原因是 chrome 常常會更新  導致 chrome driver版本過舊\n\n這時候要到這邊下載最新的\nhttps://googlechromelabs.github.io/chrome-for-testing/\n\n```\ncd /tmp\nwget https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/117.0.5938.92/linux64/chromedriver-linux64.zip\n```\n解壓縮\n```\nunzip chromedriver-linux64.zip\n```\n\n到 chromedriver-linux64 資料夾\n```\ncd chromedriver-linux64\n```\n\n```\nsudo mv chromedriver /usr/bin/chromedriver\nsudo chown root:root /usr/bin/chromedriver\nsudo chmod +x /usr/bin/chromedriver\n```\n\n\n\n參考文章: \nhttps://ithelp.ithome.com.tw/articles/10293187\nhttps://blog.csdn.net/qq_24166417/article/details/113850978\nhttps://github.com/nickchen1998/2022_ithelp_marathon","tags":["Pytest","Python","自動化測試"]},{"title":"Python 與自動化測試","url":"/2023/09/21/Python-與自動化測試/","content":"\n\n# 前言\n\n這篇是記錄我在看鐵人賽 [Python 與自動化測試的敲門磚 ](https://ithelp.ithome.com.tw/articles/10290529) 的過程\n\n# 主題\n\n| 主題 | 日程 | \n| -------- | -------- | \n| 簡介     | day 01 | \n| Pytest     | day 02 ~ 10 | \n| TDD     | day 11 ~ 12 |  \n| Selenium     | day 13 ~ 17 | \n| Appium     | day 18 ~ 21 | \n| CI/CD\t    | day 22 ~ 26 | \n| Jenkins  | day 27 ~ 29 | \n| 結語  | day 30 | \n\n# Pytest \nPytest 是一種使用在 Python 語言裡面的一中單元測試框架，而 Pytest 基本上就是由 Python 原生自帶的單元測試框架 Unittest 衍生出來的，所以可以看到有些範例可以和 Unittest 的套件互相兼容混用。\n\nPytest 和 Unittest 相比，有下列幾項優點：\n\n1. 更易於上手，撰寫 testcase 時較為直覺\n2. 擴展性高，可以兼容許多外掛套件\n3. 可以標註某些 testcase 為失敗是正常的\n4. 測試程式撰寫起來相較於 unittest 較為簡潔\n\n# TDD\nTDD 完整名稱為 Test-driven development，中譯為 \"測試驅動開發\"，是一種軟體開發的方式，以這種模式開發的軟體，會需要在開發程式的同時一併撰寫測試程式，簡單來說就是一個 function 產出就要產出一個相對應的 testcase，好處是可以快速的檢查各項功能有沒有發生錯誤，也可以避免在開發完成後再回來補血測試程式，造成某些功能遺漏沒有測到。\n\n# Selenium\n相信很多人對於 Selenium 並不陌生，近年來很常被應用在網路爬蟲上，可以比較簡單的對動態網頁進行爬取，Selenium 最初被開發出來的時候，其實是拿來進行網頁自動化測試的\n\n# Appium\nAppium 顧名思義，適用於測試手機 APP 的一個自動化測試的工具，是一個 Open Source 的專案，Appium 提供跨平台的操作，亦即它可以同時測試 IOS 以及 Android 甚至是 Desktop 的 API\n\n# Jenkins \n除了 Gitlab、Github 之外，Jenkins 也是目前主流的 CI/CD 工具之一，由於 Jenkins 也是開源專案，因此發展速度非常快，也非常容易上手，這邊將花幾天的時間來介紹該如何進行 Jenkins 的操作以及環境的建置\n\n接話來會將以上五個項目分別記錄文章\n\n參考來源: https://ithelp.ithome.com.tw/articles/10290529","tags":["Python","自動化測試","iThome鐵人賽"]},{"title":"Node.js 學習筆記 - NCU 版本檢查介紹及其安裝步驟","url":"/2023/09/20/Node.js 學習筆記 - NCU 版本檢查介紹及其安裝步驟/","content":"\n# Node.js 學習筆記 - NCU 版本檢查介紹及其安裝步驟\n\n## 前言\n在使用 Node.js 開發時，版本問題和各種相依性問題常常導致每次在執行 `npm install` 後，專案啟動時出現錯誤，這真的是非常煩惱。不過，在看到這篇文章 [無痛更新專案中的 npm 相依套件](https://blog.marsen.me/2022/09/08/2022/how_to_npm_update_more_smoothly/) 後，我發現原來有一個名為 `npm-check-updates` 的工具可以使用，這真的解決了許多問題。\n\n## 什麼是NCU?\nNCU (npm-check-updates) 是一個用於 Node.js 的套件，它可以檢查您的 npm（Node Package Manager）項目中的套件，並提示您可用的更新版本。這個工具可以幫助開發者輕鬆地確保他們的項目中使用的套件都是最新版本，從而提高代碼的安全性和可靠性。\n\n## 檢查過時的版本\n首先，我們可以使用 `npm outdated` 來檢查專案中有哪些套件是過時的：\n\n```sh\nnpm outdated\n```\n\n這個命令會列出所有需要更新的套件及其版本資訊。\n\n![image](https://hackmd.io/_uploads/ByrKVUTVR.png)\n>畫面中可以看到我的部落格專案中有4個套件需要更新了。\n\n## 安裝 ncu (npm-check-updates) 工具\n接下來，我們來介紹 `npm-check-updates` 工具，它可以幫助我們更輕鬆地管理和更新專案中的 npm 相依套件。首先，全域安裝 `npm-check-updates`：\n\n```sh\nnpm install -g npm-check-updates\n```\n\n\n\n## 執行更新\n安裝完成後，我們可以使用 `ncu` 命令來檢查並更新相依套件。使用以下命令來更新專案中的套件版本：\n\n```sh\nncu -u\n```\n\n![image](https://hackmd.io/_uploads/ByjbBU6ER.png)\n\n\n這個命令會自動更新 `package.json` 中的相依套件版本到最新版本。接著，我們只需要重新安裝相依套件：\n\n```sh\nnpm install\n```\n\n![image](https://hackmd.io/_uploads/HyXErI6EA.png)\n\n\n## 結論\n通過 `npm-check-updates` 工具，我們可以更輕鬆地管理專案中的相依套件，確保它們始終保持最新，從而避免因為過時的套件版本而引發的各種問題。\n\n參考來源: [無痛更新專案中的 npm 相依套件](https://blog.marsen.me/2022/09/08/2022/how_to_npm_update_more_smoothly/)\n\n希望這篇文章能夠幫助你更好的管理專案中的 npm 相依套件。如果有任何問題或需要進一步的幫助，歡迎在留言區提出。\n","tags":["Node.js","NCU"]},{"title":"Next.js 實作 Blog 功能","url":"/2023/09/20/Next-js-實作-Blog-功能/","content":"\n\n# 前言\n\n這篇是參考 鐵人賽 系列文章 「從零開始打造炫砲個人部落格」系列簡介 - Modern Next.js Blog 系列 實作的紀錄，實際操作上有遇到很多問題，但大致上跟著git修改的部分調整都可以修改成功。\n\n這篇的解說很清楚，彙整的也很完整，推薦跟著教學文章操作。\n\n使用的前端技術\n\n\n| 功能 | Next.js 工具 |\n| -------- | -------- | \n|  UI 樣式  |   Tailwind CSS    | \n|  多語系   |next-i18next     | \n|  SEO meta tags  |next-seo   | \n|  指令面板  | kbar   | \n|  留言系統  | giscus   | \n|  換頁進度條  | nprogress   | \n|  更扎實的 JavaScript  | TypeScript   | \n|  統一程式碼格式  | ESLint, Prettier   | \n|  Markdown/MDX 文章處理  | Contentlayer   | \n|  網站託管  | Vercel   | \n\n\nNext.js：現代全端框架\nVercel：網站託管\nContentlayer：Markdown/MDX 文章處理\n\n參考文章: https://ithelp.ithome.com.tw/articles/10291960\n\n# 官方文件\n\nhttps://nextjs.tw/learn/foundations/about-nextjs/what-is-nextjs\n\n\n\n# 環境設定\n\n建立專案\n```\npnpm create next-app --typescript\n```\n\n啟動 Next.js 專案\n```\npnpm dev\n```\n","tags":["Next.js","Blog","React.js"]},{"title":"在Codespace 上運行Python","url":"/2023/09/12/在Codespace-上運行Python/","content":"\n# 在Codespace 上運行Python\n\n範例原始碼放在 GitHub Repo: [vscode-remote-try-python](https://github.com/gahgah147/vscode-remote-try-python)\n\n參考文章:[Setting up a Python project for GitHub Codespaces](https://docs.github.com/en/codespaces/setting-up-your-project-for-codespaces/adding-a-dev-container-configuration/setting-up-your-python-project-for-codespaces)\n\n\n# 1. 在 codespace 上開啟 project\nGo to https://github.com/microsoft/vscode-remote-try-python.\nClick Use this template, then \n\n![](https://hackmd.io/_uploads/Hy2vkS6C3.png)\n> 點擊 Open in a codespace.\n\n# 2: 新增 dev container 設定檔案\n\n1.使用 Visual Studio Code 指令 (Ctrl+Shift+P/Shift+Command+P)，\n然後輸入 add dev \n\n![](https://hackmd.io/_uploads/SyuKutTC2.png)\n>點擊 Codespaces: Add Dev Container Configuration Files.\n\n2. 點擊 Create a new configuration.\n\n3. 因為已經存在'.devcontainer/devcontainer.json' 檔案所以未出現這個提示，這邊選擇 Continue \n![](https://hackmd.io/_uploads/r1KsOYaC2.png)\n\n4. 選擇 Show All Definitions.\n![](https://hackmd.io/_uploads/B1a7KKTA3.png)\n\n5. 輸入 python 然後選擇 Python 3\n![](https://hackmd.io/_uploads/BJxOtK6Cn.png)\n\n6. 選擇 python 版本 這邊我們選擇預設值\n![](https://hackmd.io/_uploads/Skj2KtTRh.png)\n\n7. 輸入 py 選擇 Coverage.py (via pipx) 然後點 OK\n![](https://hackmd.io/_uploads/rynr9FpA2.png)\n\n# 3. 修改 devcontainer.json 檔案\n\n1. 修改 devcontainer.json 檔案\n```\n// For format details, see https://aka.ms/devcontainer.json. For config options, see the\n// README at: https://github.com/devcontainers/templates/tree/main/src/python\n{\n  \"name\": \"Python 3\",\n  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile\n  \"image\": \"mcr.microsoft.com/devcontainers/python:0-3.11-bullseye\",\n  \"features\": {\n    \"ghcr.io/devcontainers-contrib/features/coverage-py:2\": {}\n  },\n\n  // Use 'forwardPorts' to make a list of ports inside the container available locally.\n  // \"forwardPorts\": [],\n\n  // Use 'postCreateCommand' to run commands after the container is created.\n  \"postCreateCommand\": \"pip3 install --user -r requirements.txt\",\n\n  // Configure tool-specific properties.\n  \"customizations\": {\n    // Configure properties specific to VS Code.\n    \"vscode\": {\n      // Add the IDs of extensions you want installed when the container is created.\n      \"extensions\": [\n        \"streetsidesoftware.code-spell-checker\"\n      ]\n    }\n  }\n\n  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.\n  // \"remoteUser\": \"root\"\n}\n\n```\n\n2. (Ctrl+Shift+P) 輸入 rebuild\n![](https://hackmd.io/_uploads/Hk11hFaC3.png)\n選擇 Codespaces: Rebuild Container.\n\n# 4. 接下來就能運行 python 了\n\n測試輸入指令: \n```\npython -m flask run\n```\n\n![](https://hackmd.io/_uploads/Hyl83FTA3.png)\n> 選擇  Open in Browser \n\n會看到以下畫面\n![](https://hackmd.io/_uploads/HJ0DhYp03.png)\n\n\n# 5. 可以把修改結果 Commit 上去","tags":["Python","GitHub","Codespace"]},{"title":"Codespaces 上運行 Laravel Docker","url":"/2023/09/06/Codespaces-上運行-Laravel-Docker/","content":"# Codespaces 上運行 Laravel Docker\n\n![](https://hackmd.io/_uploads/H1iYrdrRh.png)\n\n## 前言\n目前因為想要練習 Laravel，所以看到一篇在 Github Codespaces 上運行Laravel 的文章所以來實作，並將結果放在[這邊](https://github.com/nalson0219/laravel-docker)\n\n## 1.創建 Github Repository 從 Laravel Docker 範例\n![](https://hackmd.io/_uploads/rJuObwrCh.png)\n>https://github.com/rakibdevs/laravel-docker\n點擊 Use this template\n\n## 2.建立 Codespace \n\n![](https://hackmd.io/_uploads/B1EEEDrRh.png)\n\n## 3. Build Docker Container\n\n下載必要的套件，並根據Dockerfile 建立 Docker image\n```\n$ docker compose build\n```\n\n完成後可以執行以下指令開啟 Docker container:\n```\n$ docker-compose up -d\n```\n\n![](https://hackmd.io/_uploads/BJxTEPS03.png)\n\n## 4.下載 Laravel\n```\n$ sudo chmod 777 src/\n$ docker compose exec php composer create-project --prefer-dist laravel/laravel .\n```\n\nNow copy .env.example to .env by following this command:\n\n```\n$ cp src/.env.example src/.env\n```\n\n更新 database 設定檔\n```\nDB_HOST=mysql\nDB_PORT=3306\nDB_DATABASE=laravel\nDB_USERNAME=root\nDB_PASSWORD=1234\n```\n\n## 5 Run other esential commands \n\n```\n$ docker compose exec php php artisan storage:link\n$ docker compose exec php chmod -R 777 storage bootstrap/cache\n$ docker compose exec php php artisan migrate:refresh\n\n```\n\n## 6. 產生　APP_KEY\n```\n$ cd src \n$　composer install\n$ php artisan key:generate\n```\n\n接下來點擊 codespace 下方這個圖案就能開啟網頁\n![](https://hackmd.io/_uploads/SkyVGdr0n.png)\n>移動到 3399 port 的本機位置 ctrl + 按一下 就能看到 laravel 畫面\n\n![](https://hackmd.io/_uploads/SJjtMur03.png)\n\n\n參考文章: https://rakibdevs.medium.com/github-codespaces-code-on-the-go-with-laravel-in-docker-container-c31f42212e42\n\n規劃後續練習參考教學文章: https://ithelp.ithome.com.tw/articles/10219573","tags":["Laravel","Docker","Github","Codespaces"]},{"title":"Hexo + Github 建立部落格","url":"/2023/08/31/Hexo-Github-建立部落格/","content":"\n\n# Hexo + Github 建立部落格\n## 為什麼想要架設 Blog\n\n身為一個工程師，不知不覺也工作了四年，工作上使用的套件不管是前端、後端、框架都越來越多，所以想記錄自己曾使用過的套件，要用的時候可以很快的查到。\n\n* 建立自己的工具箱\n* 累積屬於自己在技術專業知識品牌\n* 可以作為作品集展示\n* 另外想紀錄什麼都可以寫上去\n\n## 為什麼選 Hexo \n\n* 可以免費放在Github 上\n* 可以選好看的主題\n* 支援 Markdown  (因為之前有在用 hackmd 紀錄文件)\n\n查找到感覺最完整的架設教學文章是這篇 \n>https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E6%9E%B6%E8%A8%AD-Blog\n\n所以就決定跟著來一起嘗試架設Blog\n\n## 環境設定\n\n### NodeJs\n![](https://hackmd.io/_uploads/Hygizoop62.png)\n>https://nodejs.org/en\n\n{% note info simple %}\n有用Node js 推薦也一起使用 nvm，因為有時候常常會遇到版本問題\n![](https://hackmd.io/_uploads/ryAznjaT3.png)\n>https://github.com/coreybutler/nvm-windows/releases\n\n選擇 nvm-setup 開始下載\n{% endnote %}\n\n### Git\n![](https://hackmd.io/_uploads/H1vIss66n.png)\n>https://git-scm.com/\n\n### Visual Studio Code (vs code)\n![](https://hackmd.io/_uploads/HJ4toipph.png)\n>https://code.visualstudio.com/\n\n## Hexo 設定\n\n安裝 Hexo\n```\nnpm install -g hexo-cli\n```\n\n建立 Hexo 專案\n```\nhexo init hexoblog\n\n```\n會產生一個 hexoblog 資料夾\n```\ncd hexoblog\n```\n\n啓動 Hexo 的伺服器\n```\nhexo server\n```\n\n接下來用瀏覽器打開 http://localhost:4000 就可以看到Hexo 的效果\n![](https://hackmd.io/_uploads/HkTGRjap3.png)\n\n## 要怎麼在在文章上放圖片呢\n查看了各種教學後來決定先把文章圖片放在 HackMD上，再採用設定公開表的方式分享照片\n![](https://hackmd.io/_uploads/SyLWU7JR3.png)\n\n\n## 選擇主題樣式\n\n### 使用 Butterfly 主題樣式\n另外可以選擇其他樣式\n\n![](https://hackmd.io/_uploads/SydzvSNCn.png)\n> https://hexo.io/themes/\n\n因為是我參考 ChanChanDev 圈圈工程師 寫的[這篇文章](https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/#%E9%81%B8%E6%93%87%E4%B8%BB%E9%A1%8C%E6%A8%A3%E5%BC%8F) 實作的，比較起來我也感覺 Butterfly 這個主題最好看\n\n#### 方法一 \n下載 Butterfly 主題及配件\n```\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly\nnpm install cheerio@0.22.0 --save\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n下載完成後，在 .\\Desktop\\mywebsite\\githubBlog\\themes 裡，會看見多了個名叫 Butterfly 的 folder。\n\n更改主題:開啓這個文件 .\\githubBlog\\_config.yml，把主題改為 Butterfly\n```\ntheme: Butterfly\n```\n\n參考官方教學:https://butterfly.js.org/posts/21cfbf15/#%E5%AE%89%E8%A3%9D\n\n另外這個方式會遇到以下問題\n![image](https://hackmd.io/_uploads/HkxXDItSC.png)\n\n這個警告表示你正在將另一個 git 儲存庫添加到當前的 git 儲存庫中。也就是說在我們原本的部落格git專案裡面還有別的git專案\n\n可以用以下方式解決\n```\ngit rm -f --cached themes/Butterfly\ngit submodule add https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly\n```\n\n第一個命令會從索引中刪除 themes/Butterfly，第二個命令則將其重新添加為子模組。這樣做後，Git 應該能正確處理 themes/Butterfly。\n\n#### 方法二 (這方法有個問題就是在 themes/ 底下沒有Butterfly 會沒辦法調整設置)\n安裝 Butterfly 主題樣式\n```\nnpm i hexo-theme-butterfly\n\n```\n安裝 Butterfly 所需的套件\n```\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n\n```\n\n開啓 _config.yml 檔，更改 theme 設定\n```\ntheme: butterfly\n```\n\n在本機端啓動 Hexo 的伺服器，就可以看到套用了 Butterfly 主題樣式的網站囉！\n\n```\nhexo server\n```\n\n![](https://hackmd.io/_uploads/By-YOrEC3.png)\n\n### 應用 Butterfly 主題\n\n#### Front-matter 設定\n\nFront-matter 是 markdown 文件最上方以 --- 分隔的區域，用於指定個別檔案的變數。\n\nPage Front-matter 用於頁面配置\nPost Front-matter 用於文章頁配置\n>如果標注`可選`的參數，可根據自己需要添加，不用全部都寫在 markdown 裏\n\n##### 調整頁面配置: Page Front-matter\n開啓這個文件 .\\githubBlog\\scaffolds\\page.md，改成下面這樣子：\n```\n---\ntitle:\ndate:\ntype: （tags,link,categories這三個頁面需要配置）\ncomments: (是否需要顯示評論，默認true)\ndescription:\ntop_img: (設置頂部圖)\nmathjax:\nkatex:\n---\n\n\n```\n\n更多細節可以參考官方文件:https://butterfly.js.org/posts/dc584b87/#Post-Front-matter\n\n##### 調整文章頁配置: Post Front-matter\n開啓這個文件 .\\githubBlog\\scaffolds\\post.md，改成下面這樣子：\n```\n---\ntitle:\ndate:\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img: （除非特定需要，可以不寫）\ncomments  是否顯示評論（除非設置false,可以不寫）\ncover:  縮略圖\ntoc:  是否顯示toc （除非特定文章設置，可以不寫）\ntoc_number: 是否顯示toc數字 （除非特定文章設置，可以不寫）\ncopyright: 是否顯示版權 （除非特定文章設置，可以不寫）\nmathjax:\nkatex:\nhide:\n---\n```\n\n更多細節可以參考官方文件:https://butterfly.js.org/posts/dc584b87/#Post-Front-matter\n\n#### 創建標籤頁\n輸入以下命令：\n```\nhexo new page tags\n\n```\n開啓這個文件 .\\githubBlog\\source\\tags\\index.md，把 type 設定為 \"tags\"\n```\n---\ntitle: 標籤\ndate: 2024-06-12 00:00:00\ntype: \"tags\"\n---\n\n```\n\n這邊是產生的標籤頁效果 https://<username>.github.io/tags/\n![image](https://hackmd.io/_uploads/S1uihFLH0.png)\n\n#### 創建分類頁\n\n輸入以下命令：\n```\nhexo new page categories\n\n```\n開啓這個文件 .\\githubBlog\\source\\categories\\index.md，把 type 設定為 \"categories\"\n```\n---\ntitle: 分類\ndate: 2024-06-12 00:00:00\ntype: \"categories\"\n---\n```\n\n#### 創建友情連結頁\n輸入以下命令：\n```\nhexo new page link\n```\n開啓這個文件 .\\githubBlog\\source\\link\\index.md，把 type 設定為 \"link\"\n```\n---\ntitle: 友情連結\ndate: 2024-06-12 00:00:00\ntype: \"link\"\n---\n\n```\n\n開啓這個文件（如沒有就自己新增）.\\githubBlog\\source\\_data\\link.yml，內容如下：\n\n\n## Hexo 常用指令\n\n初始化專案 / 建立專案資料夾\n```\nhexo init [資料夾名稱]\n```\n建立一篇新的文章，若標題包括空格，請用引號括起來\n```\nhexo new [layout] <文章標題>\n```\n在本機端啓動伺服器，預設是 http://localhost:4000/\n```\nhexo server\n```\n\n## 指令新增第一篇文章\n```\nhexo new post \"我的第一篇文章 By Hexo\"\n```\n\n會發現在 source 的 _posts 的資料夾多了一個 我的第一篇文章-By-Hexo.md 的檔案。\n\n```\n---\ntitle: 我的第一篇文章 By Hexo\ndate: 2021-03-07 17:15:57\ntags:\n---\n\n# 我的第一篇文章的標題\nhihihi ~ 你好～ 我是第一篇文章的內容～\n在這裏可以用 `Markdown` 語法撰寫\n\n```\n\n##  部署 Deploy 設定\n\n### 申請 Github 帳號\n![](https://hackmd.io/_uploads/rk0N6SV0h.png)\n>https://github.com\n\n### 設定 repository\n\n新增一個public 的 repository，並且命名爲 githubusername.github.io\n\n例如：你的 github 使用者帳號爲 abc_xyz 那麼這個 repository 的名稱就會是 abc_xyz.github.io\n\n### 安裝部署外掛\n\n```\nnpm install hexo-deployer-git --save\n```\n\n### 調整_config.yml 設定\n```\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: git@github.com:abc_xyz/abc_xyz.github.io.git # 貼上剛剛複製的 Github Repository 網址\n  branch: master # 預設分支名稱\n  message:\n```\n\n### 執行以下指令將 Hexo 產生的網站內容上傳到 Github \n\n```\nhexo clean && hexo deploy\n```\n用瀏覽器在網址輸入上述的網址 `https://<username>.github.io`，就可以看到 Hexo 的網站順利地架在 Github 的 Page 上了\n\n![](https://hackmd.io/_uploads/rk5SyU40n.png)\n\n\n## 常用的 Hexo 命令\n### 清理快取文件（db.json）和生成的文件（public）\n```\nhexo clean\n```\n\n### 生成靜態文件\n```\nhexo g\n```\n\n### 啟動本地伺服器\n```\nhexo s       \n```\n\n### 部屬到github上\n```\nhexo d\n```\n\n### 生成完成後再部署\n\n```\nhexo g -d\n```\n\n### 生成完成後再部署時提交的訊息\n```\nhexo g -d -m \"message\"\n```\n\n-m \"message\": 在部署時提交的訊息（通常用於版本控制系統，如 Git）。\n\n### 建立新的文章\n```\nhexo new <post-title>\n```\n\n### 建立新的頁面\n```\nhexo new page <page-title>\n```\n\n### 總攬\n```\nhexo clean   # 清理快取文件（db.json）和生成的文件（public）\nhexo g       # 生成靜態文件\nhexo s       # 啟動本地伺服器\nhexo d       # 部屬到github上\nhexo g -d    # 生成完成後再部署\nhexo g -d -m \"message\"      # 生成完成後再部署時提交的訊息\nhexo new <post-title>       # 建立新的文章\nhexo new page <page-title>  # 建立新的頁面\n```\n","tags":["Github","Node.js","Hexo"],"categories":["架站記錄"]}]