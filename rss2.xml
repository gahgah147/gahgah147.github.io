<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nalson</title>
    <link>https://gahgah147.github.io/</link>
    
    <atom:link href="https://gahgah147.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 29 Oct 2024 03:54:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>GCP - 儲存選擇 Block Storage 與 File Storage 的應用與比較</title>
      <link>https://gahgah147.github.io/2024/10/07/GCP-%E5%84%B2%E5%AD%98%E9%81%B8%E6%93%87-Block-Storage-%E8%88%87-File-Storage-%E7%9A%84%E6%87%89%E7%94%A8%E8%88%87%E6%AF%94%E8%BC%83/</link>
      <guid>https://gahgah147.github.io/2024/10/07/GCP-%E5%84%B2%E5%AD%98%E9%81%B8%E6%93%87-Block-Storage-%E8%88%87-File-Storage-%E7%9A%84%E6%87%89%E7%94%A8%E8%88%87%E6%AF%94%E8%BC%83/</guid>
      <pubDate>Mon, 07 Oct 2024 09:19:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkooImZJkx.jpg&quot; alt=&quot;未命名設計&quot;&gt;&lt;br&gt;在 Google Cloud Platform (GCP) 上，雲端儲存解決方案分為多種類型，以滿足不同的工作負載需求。其中，&lt;stro</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/rkooImZJkx.jpg" alt="未命名設計"><br>在 Google Cloud Platform (GCP) 上，雲端儲存解決方案分為多種類型，以滿足不同的工作負載需求。其中，<strong>Block Storage</strong> 和 <strong>File Storage</strong> 是兩種非常常見的儲存類型，分別適用於不同的應用場景。本文將簡單介紹它們的特點、適用場景，以及在 GCP 中的具體服務。</p><p>以下是Google Cloud Storage Options 官方指南<br><img src="https://hackmd.io/_uploads/SkP1RWbJ1l.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/products/storage/?hl=zh-TW">https://cloud.google.com/products/storage/?hl=zh-TW</a></p></blockquote><h2 id="什麼是-Block-Storage？"><a href="#什麼是-Block-Storage？" class="headerlink" title="什麼是 Block Storage？"></a>什麼是 Block Storage？</h2><p>以下是Google cloud 區塊儲存空間官方說明文件<br><img src="https://hackmd.io/_uploads/SJLgxzZkkx.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/products/block-storage?hl=zh-TW">https://cloud.google.com/products/block-storage?hl=zh-TW</a></p></blockquote><p><strong>Block Storage（區塊存儲）</strong> 是將數據分割成固定大小的區塊，並將每個區塊單獨儲存和管理的一種存儲方式。這種存儲方法類似於傳統的硬碟驅動器，因為每個區塊都可以被單獨存取，並且不需要依賴整個文件結構來讀取數據。這使得 Block Storage 特別適合對於高性能和低延遲有較高需求的應用程序，如數據庫和虛擬機。</p><h3 id="GCP-上的-Block-Storage-服務：Persistent-Disk"><a href="#GCP-上的-Block-Storage-服務：Persistent-Disk" class="headerlink" title="GCP 上的 Block Storage 服務：Persistent Disk"></a>GCP 上的 Block Storage 服務：Persistent Disk</h3><p>以下是 Google Cloud Persistent Disk 官方文件<br><img src="https://hackmd.io/_uploads/rJZrp--Jke.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/persistent-disk?hl=zh-TW">https://cloud.google.com/persistent-disk?hl=zh-TW</a></p></blockquote><p>在 GCP 中，<strong>Persistent Disk</strong> (PD) 是最主要的 Block Storage 服務。Persistent Disk 提供持久性、高可靠性及可擴展的區塊存儲，且能與虛擬機（VM）無縫整合。</p><ul><li><p><strong>特點</strong>：</p><ul><li><strong>持久性</strong>：數據存儲在多個物理位置，確保在硬體故障時仍可恢復數據。</li><li><strong>高效能</strong>：PD 提供高 IOPS（每秒輸入輸出操作次數）與低延遲，適合高性能的工作負載。</li><li><strong>彈性擴展</strong>：PD 可以隨時動態調整大小，無需中斷服務。</li></ul></li><li><p><strong>適用場景</strong>：</p><ul><li>數據庫應用程式，如 MySQL、PostgreSQL。</li><li>高性能虛擬機的存儲需求。</li><li>需要頻繁讀寫操作的工作負載。</li></ul></li></ul><h3 id="Persistent-Disk-的類型"><a href="#Persistent-Disk-的類型" class="headerlink" title="Persistent Disk 的類型"></a>Persistent Disk 的類型</h3><p>在 GCP 上，Persistent Disk 提供了多種選擇，以滿足不同需求：</p><ul><li><strong>Standard Persistent Disk</strong>：適合標準工作負載的成本效益型選擇。</li><li><strong>SSD Persistent Disk</strong>：提供更高的讀寫速度，適合需要快速存取的應用。</li><li><strong>Balanced Persistent Disk</strong>：在性能和成本之間提供平衡，適合大多數應用程式。</li></ul><h2 id="什麼是-File-Storage？"><a href="#什麼是-File-Storage？" class="headerlink" title="什麼是 File Storage？"></a>什麼是 File Storage？</h2><p>以下是 Google Cloud Filestore 官方文件<br><img src="https://hackmd.io/_uploads/HkJqab-ykg.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/filestore?hl=zh-TW">https://cloud.google.com/filestore?hl=zh-TW</a></p></blockquote><p><strong>File Storage（文件存儲）</strong> 是基於文件和文件夾的存儲系統，允許用戶通過標準的檔案存取協議（如 NFS）來存取數據。這種存儲方式類似於傳統的文件伺服器，適合需要共享文件的應用程序，例如內容管理系統和媒體處理工作負載。</p><h3 id="GCP-上的-File-Storage-服務：Filestore"><a href="#GCP-上的-File-Storage-服務：Filestore" class="headerlink" title="GCP 上的 File Storage 服務：Filestore"></a>GCP 上的 File Storage 服務：<strong>Filestore</strong></h3><p>在 GCP 中，<strong>Filestore</strong> 是主要的 File Storage 服務。它是一個完全託管的 NFS 文件系統，專為與虛擬機或容器環境中的應用程式整合而設計。</p><p><strong>特點</strong>：</p><ul><li><strong>簡單易用</strong>：提供類似於傳統文件伺服器的操作體驗，支持標準 NFS 協議。</li><li><strong>高性能</strong>：適合高吞吐量工作負載，例如視頻處理、軟體開發工作流。</li><li><strong>彈性配置</strong>：Filestore 提供多種性能層級，從標準到高性能檔案存儲，以滿足不同的需求。</li></ul><p><strong>適用場景</strong>：</p><ul><li>共享文件系統，例如企業內部文件存取與共享。</li><li>多個 VM 之間的協同工作，特別是需要頻繁存取大文件的應用。</li><li>容器化環境中的數據共享，例如 GKE 中的工作負載。</li></ul><h3 id="Filestore-的類型"><a href="#Filestore-的類型" class="headerlink" title="Filestore 的類型"></a>Filestore 的類型</h3><p>Filestore 提供了多種配置選項：</p><ul><li><strong>Filestore Basic</strong>：適合一般用途的文件存取需求。</li><li><strong>Filestore High Scale</strong>：提供更高的性能和容量，適合需要高吞吐量的應用程式。</li></ul><h2 id="Block-Storage-和-File-Storage-的選擇"><a href="#Block-Storage-和-File-Storage-的選擇" class="headerlink" title="Block Storage 和 File Storage 的選擇"></a>Block Storage 和 File Storage 的選擇</h2><p>在選擇 Block Storage 和 File Storage 時，應根據具體需求來決定：</p><ul><li><strong>Block Storage（Persistent Disk）</strong> 更適合需要低延遲、高性能的應用，如數據庫和需要大量隨機存取的工作負載。</li><li><strong>File Storage（Filestore）</strong> 則更適合需要文件共享或多個應用程式協同工作的情境，例如軟件開發、內容管理系統或多媒體處理。</li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>GCP 提供了多樣化的存儲解決方案，包括 Block Storage（Persistent Disk）和 File Storage（Filestore）。這兩種存儲類型各有優勢，能夠滿足不同的應用需求。選擇合適的存儲方案，不僅可以提升應用程式的性能，還能降低成本並提高系統的靈活性。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/Block-Storage/">Block Storage</category>
      
      
      <comments>https://gahgah147.github.io/2024/10/07/GCP-%E5%84%B2%E5%AD%98%E9%81%B8%E6%93%87-Block-Storage-%E8%88%87-File-Storage-%E7%9A%84%E6%87%89%E7%94%A8%E8%88%87%E6%AF%94%E8%BC%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - 深入解讀 GKE Kubernetes 中的 Service 概念與應用</title>
      <link>https://gahgah147.github.io/2024/09/30/GCP-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AE%80-GKE-Kubernetes-%E4%B8%AD%E7%9A%84-Service-%E6%A6%82%E5%BF%B5%E8%88%87%E6%87%89%E7%94%A8/</link>
      <guid>https://gahgah147.github.io/2024/09/30/GCP-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AE%80-GKE-Kubernetes-%E4%B8%AD%E7%9A%84-Service-%E6%A6%82%E5%BF%B5%E8%88%87%E6%87%89%E7%94%A8/</guid>
      <pubDate>Mon, 30 Sep 2024 02:58:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HyRbG9w0A.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天要來跟大家分享Kubernetes的 Service設定，這篇是我在學習Kubernetes的時候看到官方文件的資料整理。&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/HyRbG9w0A.png" alt="image"></p><p>今天要來跟大家分享Kubernetes的 Service設定，這篇是我在學習Kubernetes的時候看到官方文件的資料整理。</p><p>在 Kubernetes 中，Service 是一個重要的資源，它提供了一個抽象層，將動態變化的 Pod 集合與外部或內部網路的請求進行連接。</p><p>在 Google Kubernetes Engine (GKE) 上使用 Service，可以讓我們更靈活地管理和分配應用的流量，並提升應用的可用性和擴展性。</p><p>本文將帶你深入了解 Kubernetes Service 的類型、其如何運作，以及在 GKE 上如何使用這些 Service。</p><p>以下是官方Kubernetes 的服務介紹文件<br><img src="https://hackmd.io/_uploads/rkwgatD0C.png" alt="image"></p><blockquote><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-clusterip">https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-clusterip</a></p></blockquote><h2 id="什麼是-Kubernetes-Service？"><a href="#什麼是-Kubernetes-Service？" class="headerlink" title="什麼是 Kubernetes Service？"></a>什麼是 Kubernetes Service？</h2><p>Kubernetes 中的 Pod 是應用程序的基本運行單元，但 Pod 的生命週期短暫，IP 地址會隨著創建和刪除而不斷變動。為了解決這個問題，Kubernetes 引入了 Service 概念。Service 是一個穩定的網路實體，能夠自動為一組動態變化的 Pod 提供固定的網路訪問路徑。這使得即使 Pod 被重建或移動，應用也能保持連續的服務。</p><h2 id="Kubernetes-Service-的類型"><a href="#Kubernetes-Service-的類型" class="headerlink" title="Kubernetes Service 的類型"></a>Kubernetes Service 的類型</h2><p>Kubernetes 提供了多種不同類型的 Service，每一種類型都有其特定的應用場景。以下是主要的 Service 類型：</p><h3 id="1-ClusterIP"><a href="#1-ClusterIP" class="headerlink" title="1. ClusterIP"></a>1. <strong>ClusterIP</strong></h3><p>   這是 Kubernetes 中的預設 Service 類型。ClusterIP 為 Service 分配一個集群內部的 IP 地址，僅允許集群內部的 Pod 之間進行通訊。這種 Service 適合內部應用之間的互相調用，而不需要暴露給外部。</p><h3 id="2-NodePort"><a href="#2-NodePort" class="headerlink" title="2. NodePort"></a>2. <strong>NodePort</strong></h3><p>   NodePort 將 Service 暴露在每個節點的特定端口上，允許外部通過節點的 IP 地址和端口號來訪問服務。<br>   這種方式非常簡單，但如果應用需要高流量或高可用性時，則需要配合其他負載平衡技術。</p><p>以下是<code>type: NodePort</code>服務的清單範例，其中指定了NodePort 值（在本例中為30007）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    # 默認情況下，為了方便起見，`targetPort` 被設置為與 `port` 欄位相同的值。</span><br><span class="line">    - port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">      # 可選欄位</span><br><span class="line">      # 默認情況下，為了方便起見，Kubernetes 控制平面會從某個範圍內分配一個端口號</span><br><span class="line">      #（默認：30000-32767）</span><br><span class="line">      nodePort: 30007</span><br></pre></td></tr></table></figure><h3 id="3-LoadBalancer"><a href="#3-LoadBalancer" class="headerlink" title="3. LoadBalancer"></a>3. <strong>LoadBalancer</strong></h3><p>   LoadBalancer 主要用於雲環境中，它會為每個 Service 創建一個雲端提供的負載平衡器（如 GCP 的 LoadBalancer），並自動分配一個外部 IP 地址，方便外部流量直接訪問。這是大多數公有雲平台上應用最廣泛的 Service 類型之一，特別適合需要對外提供服務的應用。</p><p>以下是官方的使用範例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br><span class="line">  clusterIP: 10.0.171.239</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">status:</span><br><span class="line">  loadBalancer:</span><br><span class="line">    ingress:</span><br><span class="line">    - ip: 192.0.2.127</span><br></pre></td></tr></table></figure><h3 id="4-ExternalName"><a href="#4-ExternalName" class="headerlink" title="4. ExternalName"></a>4. <strong>ExternalName</strong></h3><p>   ExternalName 讓 Service 能夠將請求轉發到集群外部的 DNS 名稱。這類 Service 尤其適合集群中的應用需要訪問外部資源時使用。</p><p>例如，下列Service 定義將prod名字空間中的my-service服務對應到 <code>my.database.example.com</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">  namespace: prod</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: my.database.example.com</span><br></pre></td></tr></table></figure><h2 id="Service-與-Pod-的連結"><a href="#Service-與-Pod-的連結" class="headerlink" title="Service 與 Pod 的連結"></a>Service 與 Pod 的連結</h2><p>Kubernetes 使用 Label Selector 將 Service 與一組特定的 Pod 連結在一起。當一個 Service 創建後，會根據 Pod 的標籤來選擇對應的 Pod，並動態維護這些 Pod 的列表。這樣即使 Pod 發生變更，Service 仍然能夠自動更新其連接的目標，保持應用的正常運行。</p><p>此外，Service 會創建一個名為 Endpoints 的資源，記錄與該 Service 連接的 Pod 的實際 IP 地址。這樣，當流量到達 Service 時，Kubernetes 會根據 Endpoints 將流量正確地分發到對應的 Pod。</p><p>以下是 Kubernetes Service 類型的官方說明文件<br><img src="https://hackmd.io/_uploads/HJZqTYwRC.png" alt="image"></p><blockquote><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#publishing-services-service-types">https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#publishing-services-service-types</a></p></blockquote><h2 id="GKE-中的-Service-運作方式"><a href="#GKE-中的-Service-運作方式" class="headerlink" title="GKE 中的 Service 運作方式"></a>GKE 中的 Service 運作方式</h2><p>在 GKE 上，使用 Service 更加簡單和高效。當你在 GKE 上創建一個 LoadBalancer 類型的 Service 時，GCP 會自動創建一個對應的雲端負載平衡器，並分配一個外部 IP 地址。這樣的整合大大簡化了應用對外提供服務的配置過程，讓你無需手動配置複雜的負載平衡器。</p><p>GKE 還提供了 Internal LoadBalancer，讓你可以僅在 VPC 內部使用負載平衡器，這對於內部流量管理和安全隔離來說非常重要。</p><h2 id="實際應用場景"><a href="#實際應用場景" class="headerlink" title="實際應用場景"></a>實際應用場景</h2><p>以下是一些 Kubernetes Service 的常見應用場景：</p><ol><li><p><strong>NodePort 開放外部訪問</strong>：如果你希望將應用程序暴露給外部訪問，但又不想使用負載平衡器，可以選擇 NodePort 類型的 Service。這種方法雖然簡單，但不適合處理大量流量。</p></li><li><p><strong>使用 LoadBalancer 支援高可用性</strong>：當應用需要對外提供高流量或高可用性的服務時，LoadBalancer 是最佳選擇。它能夠自動調整流量並確保應用在多個節點之間進行負載均衡。</p></li><li><p><strong>選擇合適的 Service 類型</strong>：在 Kubernetes 中選擇合適的 Service 類型至關重要。對於內部服務，可以選擇 ClusterIP 或 Internal LoadBalancer，而對於需要暴露給外部的應用，則應使用 LoadBalancer 以提供穩定的外部訪問路徑。</p></li></ol><h2 id="Service-與-Ingress-的區別"><a href="#Service-與-Ingress-的區別" class="headerlink" title="Service 與 Ingress 的區別"></a>Service 與 Ingress 的區別</h2><p>Service 和 Ingress 常常一起使用，但它們在 Kubernetes 中的角色有所不同。Service 主要負責將流量分發給特定的一組 Pod，而 Ingress 則是一種更高層次的資源，提供了基於路徑的流量管理功能。例如，Ingress 可以根據 URL 路徑或主機名將請求轉發到不同的 Service，這對於實現複雜的流量路由非常有用。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>Kubernetes Service 是管理和分發網路流量的核心組件，尤其是在 GKE 這樣的雲端環境中，它可以無縫整合 Google Cloud Platform 的負載平衡器服務。無論是內部應用還是對外的服務，Kubernetes Service 都能提供靈活且高效的解決方案，幫助開發者更好地管理應用的網路需求。</p><p>透過瞭解 Kubernetes Service 的各種類型和運作原理，你將能夠更好地設計和部署應用，確保在各種情境下，應用的可用性和性能都能夠得到充分保障。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/Kubernetes/">Kubernetes</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/30/GCP-%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AE%80-GKE-Kubernetes-%E4%B8%AD%E7%9A%84-Service-%E6%A6%82%E5%BF%B5%E8%88%87%E6%87%89%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - 儲存服務與資料庫工具整理與選擇整理</title>
      <link>https://gahgah147.github.io/2024/09/20/GCP-%E5%84%B2%E5%AD%98%E6%9C%8D%E5%8B%99%E8%88%87%E8%B3%87%E6%96%99%E5%BA%AB%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E8%88%87%E9%81%B8%E6%93%87%E6%95%B4%E7%90%86/</link>
      <guid>https://gahgah147.github.io/2024/09/20/GCP-%E5%84%B2%E5%AD%98%E6%9C%8D%E5%8B%99%E8%88%87%E8%B3%87%E6%96%99%E5%BA%AB%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E8%88%87%E9%81%B8%E6%93%87%E6%95%B4%E7%90%86/</guid>
      <pubDate>Fri, 20 Sep 2024 01:52:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/B1XjX8cpC.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GCP的儲存服務與&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://hac</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/B1XjX8cpC.png" alt="image"></p><blockquote><p>GCP的儲存服務與</p></blockquote><p><img src="https://hackmd.io/_uploads/HJOPXL9pC.png" alt="image"></p><blockquote><p>GCP的資料庫</p></blockquote><p>Google 推出了很多種儲存跟資料庫的服務，選擇合適的儲存解決方案對於確保應用程式的效能與可擴展性至關重要。Google Cloud Platform (GCP) 提供了多樣化的儲存產品，每種產品針對不同的應用場景與需求進行了優化。今天將透過一個決策流程，幫助您快速理解並選擇適合的 GCP 儲存方案。</p><p>大家可以在下面這個網址找到GCP具體總共有哪些服務與圖示<br><img src="https://hackmd.io/_uploads/ryV1cDY6R.png" alt="image"></p><blockquote><p><a href="https://googlecloudcheatsheet.withgoogle.com/">https://googlecloudcheatsheet.withgoogle.com/</a></p></blockquote><h1 id="GCP-有哪些儲存服務與資料庫工具"><a href="#GCP-有哪些儲存服務與資料庫工具" class="headerlink" title="GCP 有哪些儲存服務與資料庫工具?"></a>GCP 有哪些儲存服務與資料庫工具?</h1><p><img src="https://hackmd.io/_uploads/Hk8cKwK6R.png" alt="image"></p><h2 id="Cloud-Storage"><a href="#Cloud-Storage" class="headerlink" title="Cloud Storage"></a>Cloud Storage</h2><p><img src="https://hackmd.io/_uploads/B1gG2vtTC.jpg" alt="cloud-storage-productcard"></p><p>Cloud Storage 是 Google Cloud 提供的物件存儲解決方案，適合儲存大量的非結構化數據，如圖片、影片、備份文件等。它具備高度耐久性和可擴展性，適合需要長期存儲和全球訪問的應用程式。</p><h2 id="Cloud-Bigtable"><a href="#Cloud-Bigtable" class="headerlink" title="Cloud Bigtable"></a>Cloud Bigtable</h2><p><img src="https://hackmd.io/_uploads/SkxV3PF60.jpg" alt="cloud-bigtable-productcard"></p><p>Cloud Bigtable 是一個高效能的 NoSQL 資料庫，特別適合大規模數據分析、物聯網數據處理和金融資料管理。它以極低延遲和高吞吐量著稱，適用於需要快速讀寫大量資料的應用場景。</p><h2 id="Cloud-Datastore"><a href="#Cloud-Datastore" class="headerlink" title="Cloud Datastore"></a>Cloud Datastore</h2><p><img src="https://hackmd.io/_uploads/r17PhPYTC.jpg" alt="datastore-productcard"></p><p>Cloud Datastore 是一個分散式 NoSQL 文件資料庫，專為需要高擴展性的應用程式設計。它支持強一致性和事務處理，適合用於儲存具有複雜查詢需求的半結構化數據。</p><h2 id="Cloud-Firestore"><a href="#Cloud-Firestore" class="headerlink" title="Cloud Firestore"></a>Cloud Firestore</h2><p><img src="https://hackmd.io/_uploads/ryP3aDF6A.png" alt="firestore"></p><p>Cloud Firestore 是 Firebase 的一部分，提供即時同步功能，支援 Web 和移動應用程式。它與 Cloud Datastore 有相似之處，但針對即時應用進行了優化，特別適合多設備同步和快速更新數據的應用程式。</p><h2 id="Cloud-SQL"><a href="#Cloud-SQL" class="headerlink" title="Cloud SQL"></a>Cloud SQL</h2><p><img src="https://hackmd.io/_uploads/H1B_3PtaR.jpg" alt="cloud-sql-productcard"></p><p>Cloud SQL 是一個全託管的關聯式資料庫服務，支持 MySQL、PostgreSQL 和 SQL Server。它提供自動化的備份、擴展和維護功能，適合需要傳統 SQL 資料庫的應用程式。</p><h2 id="Persistent-Disk"><a href="#Persistent-Disk" class="headerlink" title="Persistent Disk"></a>Persistent Disk</h2><p><img src="https://hackmd.io/_uploads/H1ASnvtaC.jpg" alt="persistent-disk-productcard"></p><p>Persistent Disk 是一個高性能的持久化塊存儲，主要用於虛擬機器（VM）的數據存儲。它具備高可用性和可擴展性，適合需要快速存取和持久化數據的 VM 應用場景。</p><h2 id="Filestore"><a href="#Filestore" class="headerlink" title="Filestore"></a>Filestore</h2><p><img src="https://hackmd.io/_uploads/ByTv6vY6A.png" alt="filestore"><br>Filestore 是一個完全託管的檔案存儲服務，支援 NFS（網路檔案系統）協議，適合需要低延遲、高效能的工作負載，如機器學習模型訓練和基於檔案的應用程式。</p><h2 id="MemoryStore"><a href="#MemoryStore" class="headerlink" title="MemoryStore"></a>MemoryStore</h2><p><img src="https://hackmd.io/_uploads/HJ8q6PKaC.png" alt="memorystore"></p><p>MemoryStore 是一個完全託管的內存資料庫服務，支持 Redis 和 Memcached。它主要用於緩存數據，提升應用程式的讀取性能，適合需要極低延遲的應用場景。</p><h2 id="Local-SSD"><a href="#Local-SSD" class="headerlink" title="Local SSD"></a>Local SSD</h2><p><img src="https://hackmd.io/_uploads/r1NxV85a0.png" alt="image"></p><p>Local SSD 是 Google Cloud 提供的高速本地存儲，直接連接到虛擬機器（VM）。與 Persistent Disk 不同，Local SSD 提供更高的 IOPS 和更低的延遲，適合需要極高效能的工作負載，如數據庫應用和實時數據處理。需要注意的是，Local SSD 的數據在 VM 停止時不會保留，因此適合臨時數據的存儲需求。</p><h2 id="Backup-And-DR-Service"><a href="#Backup-And-DR-Service" class="headerlink" title="Backup And DR Service"></a>Backup And DR Service</h2><p><img src="https://hackmd.io/_uploads/S1LfNL96R.png" alt="image"><br>Backup and DR Service 是 GCP 提供的備份與災難恢復解決方案，專為確保數據安全和業務連續性設計。它支持自動化備份管理，幫助企業快速從故障或災難中恢復數據。此服務適合需要數據保護和高可用性的業務。</p><h2 id="Alloy-DB"><a href="#Alloy-DB" class="headerlink" title="Alloy DB"></a>Alloy DB</h2><p><img src="https://hackmd.io/_uploads/HytrQUcT0.png" alt="image"></p><p>AlloyDB 是 Google Cloud 針對高效能工作負載打造的託管 PostgreSQL 資料庫服務。它結合了 Google Cloud 的基礎架構與開源 PostgreSQL，提供極高的性能、可用性和擴展性，適合需要同時滿足高效能與 SQL 功能的應用場景。</p><p>什麼是 Alloy DB? 官方介紹影片<br><a href="https://youtu.be/YODa-x0_3l0">https://youtu.be/YODa-x0_3l0</a></p><p><img src="https://hackmd.io/_uploads/SybfmI5T0.png" alt="image"></p><h2 id="Cloud-Spanner"><a href="#Cloud-Spanner" class="headerlink" title="Cloud Spanner"></a>Cloud Spanner</h2><p><img src="https://hackmd.io/_uploads/HkBSx_taR.png" alt="cloud_spanner"></p><p>Cloud Spanner 是全球分散式的關聯式資料庫，支援水平擴展和強一致性，適合需要高可用性、可擴展性和一致性的應用程式。它是 GCP 的旗艦數據庫服務之一，能同時支持全球分佈的資料寫入和複雜查詢。</p><h2 id="Database-Migration-Service"><a href="#Database-Migration-Service" class="headerlink" title="Database Migration Service"></a>Database Migration Service</h2><p><img src="https://hackmd.io/_uploads/B1uUgdYaC.png" alt="database_migration_service"></p><p>Database Migration Service 是一個完全託管的資料庫遷移工具，支持將 MySQL、PostgreSQL 和 SQL Server 資料庫無中斷地遷移到 Google Cloud。它簡化了數據庫的遷移過程，確保應用程式能在遷移期間持續運行。</p><h1 id="如何判斷要選擇什麼產品"><a href="#如何判斷要選擇什麼產品" class="headerlink" title="如何判斷要選擇什麼產品?"></a>如何判斷要選擇什麼產品?</h1><p>這邊有一個決策樹可以參考<br><img src="https://hackmd.io/_uploads/B1cTEwKaA.png" alt="image"></p><h3 id="1-資料是否需要直接與使用者互動？"><a href="#1-資料是否需要直接與使用者互動？" class="headerlink" title="1. 資料是否需要直接與使用者互動？"></a>1. 資料是否需要直接與使用者互動？</h3><p>這是選擇儲存方案的第一個問題。如果您的應用程式需要處理來自使用者的即時請求（例如文件上傳或下載），這將大大影響您的選擇。</p><ul><li><strong>需要 Media SDK</strong>：如果您的應用程式需要支援多媒體處理，則 <strong>Firebase Storage</strong> 是最合適的選擇。Firebase 提供了強大的 SDK，讓您可以輕鬆地與客戶端互動。</li><li><strong>不需要 Media SDK</strong>：如果不需要多媒體處理，那麼 <strong>Cloud Storage</strong> 是最常用的選擇。它是一個物件存儲服務，適合處理大規模非結構化數據，如圖片、影片、備份檔案等。</li></ul><h3 id="2-您的工作負載是否需要分析？"><a href="#2-您的工作負載是否需要分析？" class="headerlink" title="2. 您的工作負載是否需要分析？"></a>2. 您的工作負載是否需要分析？</h3><p>如果您的應用程式需要對數據進行大量的查詢和分析，這將引導您使用不同的儲存方案。</p><ul><li><strong>需要數據分析</strong>：如果需要進行即時或批量分析，<strong>BigQuery</strong> 是一個理想的選擇。它是一個伺服器無需管理的數據倉儲解決方案，提供了大規模並行查詢的能力。</li><li><strong>不需要數據分析</strong>：如果您的數據主要用於存儲，而非大量查詢或分析，您可以進一步考慮數據的持久性和一致性需求。</li></ul><h3 id="3-您的數據是否需要一致性？"><a href="#3-您的數據是否需要一致性？" class="headerlink" title="3. 您的數據是否需要一致性？"></a>3. 您的數據是否需要一致性？</h3><p>數據的一致性與分佈式系統中的複雜性息息相關。如果數據需要確保高一致性，則會有不同的儲存選項。</p><ul><li><strong>需要強一致性</strong>：如果您需要強一致性並且您的應用程式數據高度關聯，<strong>Cloud SQL</strong> 或 <strong>Cloud Spanner</strong> 是不錯的選擇。<strong>Cloud SQL</strong> 支援關聯數據庫如 MySQL、PostgreSQL 和 SQL Server，適合傳統應用。<strong>Cloud Spanner</strong> 則是一個全球分佈式的關聯數據庫，適合處理水平擴展的需求。</li><li><strong>不需要強一致性</strong>：如果應用對於一致性的需求較低，或者資料是非結構化的，您可以考慮 NoSQL 方案，例如 <strong>Firebase Realtime Database</strong> 或 <strong>Cloud Datastore</strong>，這些解決方案更適合快速存取和非結構化資料。</li></ul><h3 id="4-是否需要高可用性與橫向擴展？"><a href="#4-是否需要高可用性與橫向擴展？" class="headerlink" title="4. 是否需要高可用性與橫向擴展？"></a>4. 是否需要高可用性與橫向擴展？</h3><p>如果您的應用程式預期將需要大規模的橫向擴展，那麼選擇具有高可用性與自動擴展功能的存儲解決方案是關鍵。</p><ul><li><strong>需要橫向擴展</strong>：如果您的應用程式需要處理大量的讀寫請求並保持高可用性，<strong>Cloud Spanner</strong> 是最好的選擇之一。它支援全球分佈式存儲，並且具有極高的擴展能力和一致性保證。</li><li><strong>不需要橫向擴展</strong>：如果應用程式的需求相對穩定並且不需要大規模擴展，<strong>Cloud SQL</strong> 提供了一個簡單且熟悉的選擇，適合中小型應用。</li></ul><hr><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>GCP 提供了各種儲存解決方案，從物件存儲的 <strong>Cloud Storage</strong> 到關聯數據庫的 <strong>Cloud SQL</strong>，再到專為高效能分析設計的 <strong>BigQuery</strong>。根據應用程式的需求，我們可以針對數據的互動性、持久性、一致性和可擴展性來選擇最適合的方案。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%B3%87%E6%96%99%E5%BA%AB/">資料庫</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/20/GCP-%E5%84%B2%E5%AD%98%E6%9C%8D%E5%8B%99%E8%88%87%E8%B3%87%E6%96%99%E5%BA%AB%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E8%88%87%E9%81%B8%E6%93%87%E6%95%B4%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - 權限控管功能 Identity and Access Management (IAM)</title>
      <link>https://gahgah147.github.io/2024/09/19/GCP-%E6%AC%8A%E9%99%90%E6%8E%A7%E7%AE%A1%E5%8A%9F%E8%83%BD-Identity-and-Access-Management-IAM/</link>
      <guid>https://gahgah147.github.io/2024/09/19/GCP-%E6%AC%8A%E9%99%90%E6%8E%A7%E7%AE%A1%E5%8A%9F%E8%83%BD-Identity-and-Access-Management-IAM/</guid>
      <pubDate>Thu, 19 Sep 2024 07:55:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;在 Google Cloud Platform（GCP）中，&lt;strong&gt;Identity and Access Management (IAM)&lt;/strong&gt; 是一個核心的安全性功能，它用來控制誰可以訪問什麼資源。IAM 提供精細的權限控制，允許組織為每個資源設置適</description>
        
      
      
      
      <content:encoded><![CDATA[<p>在 Google Cloud Platform（GCP）中，<strong>Identity and Access Management (IAM)</strong> 是一個核心的安全性功能，它用來控制誰可以訪問什麼資源。IAM 提供精細的權限控制，允許組織為每個資源設置適當的存取權限，並確保數據安全。</p><p><img src="https://hackmd.io/_uploads/rkH-_IF6A.png" alt="image"><br>＞<a href="https://cloud.google.com/security/products/iam?hl=zh-tw">https://cloud.google.com/security/products/iam?hl=zh-tw</a></p><h1 id="什麼是-IAM？"><a href="#什麼是-IAM？" class="headerlink" title="什麼是 IAM？"></a>什麼是 IAM？</h1><p><img src="https://hackmd.io/_uploads/SycNdIYpR.png" alt="image"><br>＞<a href="https://cloud.google.com/security/products/iam?hl=zh-tw">https://cloud.google.com/security/products/iam?hl=zh-tw</a></p><p>GCP IAM 是一種基於角色的訪問控制系統，通過定義特定的角色和權限，讓使用者、群組或應用程式擁有恰當的資源存取權限。它透過以下三個基本元素來實現訪問控制：</p><ul><li>**身份 (Identity)**：可以是使用者、群組、服務帳號等。</li><li>**角色 (Role)**：權限的集合，用來授予身份訪問特定 GCP 資源的權限。</li><li>**資源 (Resource)**：GCP 上的任何可管理物件，如 Compute Engine VM、Cloud Storage bucket、BigQuery 資料集等。</li></ul><h1 id="IAM-的主要特點"><a href="#IAM-的主要特點" class="headerlink" title="IAM 的主要特點"></a>IAM 的主要特點</h1><p><img src="https://hackmd.io/_uploads/HkM8OIFpR.png" alt="image"></p><ul><li><p><strong>精細化控制</strong>：IAM 允許您為每個資源設置非常細緻的存取控制。可以為單一用戶或群組分配不同層級的權限，從而避免過度的存取權限。</p></li><li><p>**基於角色的存取控制 (RBAC)**：IAM 使用角色來管理權限，每個角色包含不同的操作權限。例如，”查看者”角色只能查看資源，而”編輯者”角色則能修改資源。<br><img src="https://hackmd.io/_uploads/rJODdUFpA.png" alt="image"></p></li><li><p>**預定義角色 (Predefined Roles)**：GCP 提供了多種預定義的角色，這些角色是針對特定的 GCP 服務設計的。例如，<code>storage.admin</code> 角色允許管理 Cloud Storage 資源，而 <code>compute.viewer</code> 角色允許查看 Compute Engine 資源。<br><img src="https://hackmd.io/_uploads/By9F_IFT0.png" alt="image"></p></li><li><p>**自定義角色 (Custom Roles)**：除了預定義的角色，您還可以創建自定義角色來滿足特定需求。自定義角色允許您選擇並組合不同的權限來完全控制訪問。</p></li></ul><h1 id="IAM-的核心概念"><a href="#IAM-的核心概念" class="headerlink" title="IAM 的核心概念"></a>IAM 的核心概念</h1><p><img src="https://hackmd.io/_uploads/HJjquItp0.png" alt="image"></p><ul><li><p>**身份 (Identities)**：可以是 GCP 中的使用者帳號、群組、服務帳號或 Google 帳號。這些身份是授予角色的主體。</p></li><li><p>**角色 (Roles)**：角色是權限的集合，每個角色都可以包含多個權限。GCP 提供了三種類型的角色：</p><ul><li>**基本角色 (Basic Roles)**：如 <code>Viewer</code>、<code>Editor</code>、<code>Owner</code>。這些是傳統角色，適用於所有 GCP 服務。</li><li>**預定義角色 (Predefined Roles)**：針對特定 GCP 服務的角色，提供精細化的權限控制。</li><li>**自定義角色 (Custom Roles)**：您可以根據需求創建自定義角色，包含您選擇的權限。</li></ul></li><li><p>**權限 (Permissions)**：權限定義了身份能夠執行哪些操作。例如，<code>storage.buckets.create</code> 是一個允許創建 Cloud Storage bucket 的權限。</p></li></ul><h1 id="如何管理-IAM-角色與權限？"><a href="#如何管理-IAM-角色與權限？" class="headerlink" title="如何管理 IAM 角色與權限？"></a>如何管理 IAM 角色與權限？</h1><p>最簡單的說法就是:誰可以做什麼，在哪些資源上?</p><p><img src="https://hackmd.io/_uploads/HJ98YIYaR.png" alt="image"></p><p>管理 IAM 主要是通過為身份授予適當的角色。可以通過 GCP 控制台、命令列工具 (<code>gcloud</code>)、或 API 來設置角色。</p><p>以下是基本的操作流程：</p><ol><li><p><strong>選擇要管理的資源</strong>：選擇您想要管理存取權限的資源，如特定的 Compute Engine、Cloud Storage bucket 或 BigQuery 資料集。</p></li><li><p><strong>為身份分配角色</strong>：選擇身份（如使用者、群組或服務帳號），並為其分配適當的角色。</p></li><li><p><strong>檢查和修改權限</strong>：根據需求，檢查現有權限是否符合安全性要求，並調整角色或權限。</p></li></ol><h1 id="最佳實踐"><a href="#最佳實踐" class="headerlink" title="最佳實踐"></a>最佳實踐</h1><p><img src="https://hackmd.io/_uploads/SkkK_LKTA.png" alt="image"></p><ul><li><p><strong>最小權限原則</strong>：只授予身份最低限度的權限，以減少風險。例如，對於需要查看數據的使用者，僅分配 <code>Viewer</code> 角色，而非 <code>Editor</code> 角色。</p></li><li><p><strong>定期審查權限</strong>：定期檢查和更新 IAM 角色和權限，確保使用者或服務帳號的權限符合當前業務需求。</p></li><li><p><strong>使用自定義角色</strong>：當預定義角色無法滿足需求時，考慮創建自定義角色來精細化控制權限。</p></li></ul><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p><img src="https://hackmd.io/_uploads/Hyz5dIYp0.png" alt="image"><br>IAM 是一個強大的存取控制工具，通過角色和權限的組合，讓組織能夠靈活管理資源的訪問權限。正確地設置和管理 IAM 角色是保障 GCP 資源安全的關鍵。通過遵循最小權限原則和定期審查權限，您可以確保系統的安全性和合規性。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/IAM/">IAM</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/19/GCP-%E6%AC%8A%E9%99%90%E6%8E%A7%E7%AE%A1%E5%8A%9F%E8%83%BD-Identity-and-Access-Management-IAM/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TFT聯盟戰旗 - 7邪術使魔鬥凱薩</title>
      <link>https://gahgah147.github.io/2024/09/19/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%97%97-7%E9%82%AA%E8%A1%93%E4%BD%BF%E9%AD%94%E9%AC%A5%E5%87%B1%E8%96%A9/</link>
      <guid>https://gahgah147.github.io/2024/09/19/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%97%97-7%E9%82%AA%E8%A1%93%E4%BD%BF%E9%AD%94%E9%AC%A5%E5%87%B1%E8%96%A9/</guid>
      <pubDate>Thu, 19 Sep 2024 01:36:39 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Hkdb7D_pC.png&quot; alt=&quot;TFT_OPGG_Builder (1)&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天要跟大家介紹的陣容是高邪術使魔鬥凱薩，爭其我發現高邪術使的好處是可以保血量，加上有妮可跟卡莎碧雅</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/Hkdb7D_pC.png" alt="TFT_OPGG_Builder (1)"></p><p>今天要跟大家介紹的陣容是高邪術使魔鬥凱薩，爭其我發現高邪術使的好處是可以保血量，加上有妮可跟卡莎碧雅可以開出女巫+變形師+咒術師3羈絆，強度很高而且後期有機會湊出10邪術使拉高很多上限。</p><h1 id="陣容組成"><a href="#陣容組成" class="headerlink" title="陣容組成"></a>陣容組成</h1><h2 id="魔鬥凱薩"><a href="#魔鬥凱薩" class="headerlink" title="魔鬥凱薩"></a>魔鬥凱薩</h2><p><img src="https://hackmd.io/_uploads/rkXo5lYTR.png" alt="image"><br><img src="https://hackmd.io/_uploads/SyOicetTA.png" alt="image"><br>泯殺<br>獲得會在接下來2秒內遞減的<a href="AP"> 300 &#x2F; 350 &#x2F; 400 </a>護盾，並猛擊目標，對2格的直線距離內造成<a href="AP"> 180 &#x2F; 270 &#x2F; 430 </a>魔法傷害。獲得12%傷害增幅，持續到戰鬥結束。</p><p>魔鬥是在前期的主坦，續戰力很強<br>推薦裝備: 好戰者鎧甲<img src="https://hackmd.io/_uploads/S1R4CltpA.png" alt="image">+龍之爪<img src="https://hackmd.io/_uploads/HyxU0gKTA.png" alt="image"></p><h2 id="星朵拉"><a href="#星朵拉" class="headerlink" title="星朵拉"></a>星朵拉</h2><p><img src="https://hackmd.io/_uploads/Hk4U9gYaC.png" alt="image"><br><img src="https://hackmd.io/_uploads/S13U9lY6R.png" alt="image"><br>超凡入聖<br>在目標位置召喚一道裂隙，造成[ 220 &#x2F; 330 &#x2F; 495 ] (AP)魔法傷害和20%削抗，持續6秒。此技能會隨著施放次數的增加而升級。(總施放次數：3次)</p><p>15施放：與目標相鄰的敵軍將受到削抗並受到[ 110 &#x2F; 165 &#x2F; 245 ] (AP)魔法傷害。<br>30+ 施放：每施放30次，在附近敵軍的位置額外生成一道裂隙，造成30%傷害。 </p><p>削抗：降低魔法防禦</p><p>星朵拉是在前期時的主C，很需要啟動裝來疊加技能強度</p><p>推薦裝備:<img src="https://hackmd.io/_uploads/HJ8ETxFp0.png" alt="image">精進之矛+<img src="https://hackmd.io/_uploads/S1WDTlFpC.png" alt="image">鬼索的狂暴之刃</p><h2 id="布蕾爾"><a href="#布蕾爾" class="headerlink" title="布蕾爾"></a>布蕾爾</h2><p><img src="https://hackmd.io/_uploads/BkuKD8VTC.png" alt="image"><br><img src="https://hackmd.io/_uploads/By4QJDVTR.png" alt="image">必死無疑</p><p>跳躍至最多敵軍聚集處，對2格內的敵軍造成[ 65 &#x2F; 98 &#x2F; 731 ] (AD)物理傷害，並使其暈眩，持續1.25秒。接著進入狂熱狀態，獲得[ 75 &#x2F; 75 &#x2F; 666 ]% (AP)攻速、[ 15 &#x2F; 15 &#x2F; 100 ]%全能吸血，並對目標和鄰近敵軍造成[ 26 &#x2F; 39 &#x2F; 293 ] (AD)額外物理傷害。</p><p>如果已進入狂熱狀態，則強化下一次普攻為撕咬，造成[ 163 &#x2F; 244 &#x2F; 2925 ] (AD)物理傷害。</p><p>布蕾爾是核心英雄，也是後期可以開高上限的主C</p><p>推薦裝備:<img src="https://hackmd.io/_uploads/HyKSSvVaC.png" alt="image">嗜血者+<img src="https://hackmd.io/_uploads/BylUSvVTC.png" alt="image">泰坦的決意</p><h2 id="卡莎碧雅"><a href="#卡莎碧雅" class="headerlink" title="卡莎碧雅"></a>卡莎碧雅</h2><p><img src="https://hackmd.io/_uploads/HkcvKlYp0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HkbTKxFpC.png" alt="image"><br>女巫鋒牙<br>強化下3次普攻，造成[ 135 &#x2F; 200 &#x2F; 300 ] (AP)魔法傷害。</p><h2 id="伊莉絲"><a href="#伊莉絲" class="headerlink" title="伊莉絲"></a>伊莉絲</h2><p><img src="https://hackmd.io/_uploads/B1c1jgF6A.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HkzxjlFTA.png" alt="image"><br>蜘蛛型態</p><p>轉化為蜘蛛型態，將此技能替換為石化毒液，然後施放該技能。</p><p>石化毒液：使目標暈眩1.5秒並對其造成[ 132 &#x2F; 194 &#x2F; 289 ] (HP+AP)魔法傷害。治療[ 160 &#x2F; 190 &#x2F; 230 ] (AP)。</p><h2 id="妮可"><a href="#妮可" class="headerlink" title="妮可"></a>妮可</h2><p><img src="https://hackmd.io/_uploads/r1X-ixKaC.png" alt="image"><br><img src="https://hackmd.io/_uploads/S1O-olFpA.png" alt="image">驚喜！！！</p><p>幻化為螃蟹，持續2秒。在持續時間內，回復12% (HP)生命，並對3名鄰近友軍和3名鄰近敵軍釋放河蟹攻擊。命中的友軍會回復[ 75 &#x2F; 100 &#x2F; 125 ] (AP)生命；命中的敵軍則會受到[ 100 &#x2F; 150 &#x2F; 240 ] (AP)魔法傷害並暈眩1.25秒。</p><h2 id="艾希"><a href="#艾希" class="headerlink" title="艾希"></a>艾希</h2><h2 id="納瑟斯"><a href="#納瑟斯" class="headerlink" title="納瑟斯"></a>納瑟斯</h2><p><img src="https://hackmd.io/_uploads/SJrdw8Np0.png" alt="image"><br><img src="https://hackmd.io/_uploads/rytd5gDnC.png" alt="image">地獄犬<br>從最靠近的[ 3 &#x2F; 4 &#x2F; 10 ]名敵軍身上分別偷取總共[ 300 &#x2F; 480 &#x2F; 5000 ]生命。之後每次施放改為治療[ 250 &#x2F; 300 &#x2F; 900 ] (AP)生命並對目標造成[ 165 &#x2F; 297 &#x2F; 610 ] (HP)物理傷害。</p><h2 id="淣菈"><a href="#淣菈" class="headerlink" title="淣菈"></a>淣菈</h2><p><img src="https://hackmd.io/_uploads/Bkz3jlF6A.png" alt="image"><br><img src="https://hackmd.io/_uploads/S1A2jgtaR.png" alt="image"><br>百變之刃<br>被動：護盾增加60%攻速，持續3秒。</p><p>主動：衝刺最多2格，然後穿過目標對直線上的敵軍造成<a href=""> 180 &#x2F; 270 &#x2F; 405 </a>物理傷害。獲得[ 100 &#x2F; 140 &#x2F; 180 ] (AP)護盾，持續3秒。</p><h2 id="娜米"><a href="#娜米" class="headerlink" title="娜米"></a>娜米</h2><p><img src="https://hackmd.io/_uploads/HyZtoxF6C.png" alt="image"><br><img src="https://hackmd.io/_uploads/ByLtjgt60.png" alt="image"><br>利維坦<br>朝範圍內最多敵軍聚集處發射泡泡，造成<a href="AP"> 240 &#x2F; 360 &#x2F; 1800 </a>魔法傷害。每3次施放後，改為召喚利維坦，使直線上的敵軍暈眩並造成<a href="AP"> 200 &#x2F; 300 &#x2F; 1200 </a>魔法傷害。</p><h1 id="實戰影片"><a href="#實戰影片" class="headerlink" title="實戰影片"></a>實戰影片</h1><p>聯盟戰棋 - 邪術使變形師<br><a href="https://youtu.be/X-XLZOici4k?si=wUQ4bKDcrCK6bwek">https://youtu.be/X-XLZOici4k?si=wUQ4bKDcrCK6bwek</a></p><p>聯盟戰棋 - 邪術使<br><a href="https://youtu.be/ZGpv7BlMGHU?si=alp5oUDgdroauXaI">https://youtu.be/ZGpv7BlMGHU?si=alp5oUDgdroauXaI</a></p><p>聯盟戰棋 - 7邪術使變形師<br><a href="https://www.youtube.com/watch?v=We_fPpmJ8uo">https://www.youtube.com/watch?v=We_fPpmJ8uo</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E6%88%B0%E6%A3%8B/">聯盟戰棋</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/19/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%97%97-7%E9%82%AA%E8%A1%93%E4%BD%BF%E9%AD%94%E9%AC%A5%E5%87%B1%E8%96%A9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TFT聯盟戰旗 - 陣容介紹變形師龍族納瑟斯</title>
      <link>https://gahgah147.github.io/2024/09/16/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%97%97-%E8%AE%8A%E5%BD%A2%E5%B8%AB%E9%BE%8D%E6%97%8F%E7%B4%8D%E7%91%9F%E6%96%AF/</link>
      <guid>https://gahgah147.github.io/2024/09/16/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%97%97-%E8%AE%8A%E5%BD%A2%E5%B8%AB%E9%BE%8D%E6%97%8F%E7%B4%8D%E7%91%9F%E6%96%AF/</guid>
      <pubDate>Mon, 16 Sep 2024 01:08:19 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;今天要跟大家介紹的陣容是變形師龍族整體下來坦克很多，且後期有布蕾爾可以一直變強，但是我覺得中期的物理輸出爆發不夠，常常會沒有辦法第一時間灌倒對方前排坦克&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SyTO8NBnC.png&quot; a</description>
        
      
      
      
      <content:encoded><![CDATA[<p>今天要跟大家介紹的陣容是變形師龍族整體下來坦克很多，且後期有布蕾爾可以一直變強，但是我覺得中期的物理輸出爆發不夠，常常會沒有辦法第一時間灌倒對方前排坦克</p><p><img src="https://hackmd.io/_uploads/SyTO8NBnC.png" alt="TFT_OPGG_Builder (1)"></p><p><img src="https://hackmd.io/_uploads/r1wLDLE60.png" alt="image"><img src="https://hackmd.io/_uploads/S1ALwL4aR.png" alt="image"><img src="https://hackmd.io/_uploads/BJAvDINTR.png" alt="image"><img src="https://hackmd.io/_uploads/SJrdw8Np0.png" alt="image"><img src="https://hackmd.io/_uploads/SyetDIE6R.png" alt="image"><img src="https://hackmd.io/_uploads/BkuKD8VTC.png" alt="image"><img src="https://hackmd.io/_uploads/B16FvL46A.png" alt="image"></p><h1 id="陣容組成"><a href="#陣容組成" class="headerlink" title="陣容組成"></a>陣容組成</h1><h2 id="納瑟斯"><a href="#納瑟斯" class="headerlink" title="納瑟斯"></a>納瑟斯</h2><p><img src="https://hackmd.io/_uploads/SJrdw8Np0.png" alt="image"><br><img src="https://hackmd.io/_uploads/rytd5gDnC.png" alt="image">地獄犬<br>從最靠近的[ 3 &#x2F; 4 &#x2F; 10 ]名敵軍身上分別偷取總共[ 300 &#x2F; 480 &#x2F; 5000 ]生命。之後每次施放改為治療[ 250 &#x2F; 300 &#x2F; 900 ] (AP)生命並對目標造成[ 165 &#x2F; 297 &#x2F; 610 ] (HP)物理傷害。</p><p>狗頭是主要的核心英雄</p><p>建議道具:<img src="https://hackmd.io/_uploads/B1e1HP4aC.png" alt="image">石像鬼磐核+<img src="https://hackmd.io/_uploads/HkreHPEp0.png" alt="image">好戰者鎧甲</p><h2 id="布蕾爾"><a href="#布蕾爾" class="headerlink" title="布蕾爾"></a>布蕾爾</h2><p><img src="https://hackmd.io/_uploads/BkuKD8VTC.png" alt="image"><br><img src="https://hackmd.io/_uploads/By4QJDVTR.png" alt="image">必死無疑</p><p>跳躍至最多敵軍聚集處，對2格內的敵軍造成[ 65 &#x2F; 98 &#x2F; 731 ] (AD)物理傷害，並使其暈眩，持續1.25秒。接著進入狂熱狀態，獲得[ 75 &#x2F; 75 &#x2F; 666 ]% (AP)攻速、[ 15 &#x2F; 15 &#x2F; 100 ]%全能吸血，並對目標和鄰近敵軍造成[ 26 &#x2F; 39 &#x2F; 293 ] (AD)額外物理傷害。</p><p>如果已進入狂熱狀態，則強化下一次普攻為撕咬，造成[ 163 &#x2F; 244 &#x2F; 2925 ] (AD)物理傷害。</p><p>布蕾爾是核心英雄，也是後期可以開高上限的主C</p><p>推薦裝備:<img src="https://hackmd.io/_uploads/HyKSSvVaC.png" alt="image">嗜血者+<img src="https://hackmd.io/_uploads/BylUSvVTC.png" alt="image">泰坦的決意</p><h2 id="史矛德"><a href="#史矛德" class="headerlink" title="史矛德"></a>史矛德</h2><p><img src="https://hackmd.io/_uploads/B16FvL46A.png" alt="image"><br><img src="https://hackmd.io/_uploads/ryT5yPVTC.png" alt="image">學習飛行<br>被動：四處飛行並攻擊最靠近的敵軍。</p><p>主動：接下來的[ 4 &#x2F; 4 &#x2F; 30 ]次普攻增加[ 50 &#x2F; 50 &#x2F; 500 ]%攻速。這幾次普攻會發射火球，造成[ 173 &#x2F; 268 &#x2F; 2486 ] (AD+AP)物理傷害。</p><p>龍族升級：改為接下來的[ 6 &#x2F; 6 &#x2F; 99 ]次普攻。火球造成30%(AD+AP)物理傷害。</p><p>史矛德是核心英雄擔任後排主C</p><p>核心道具有: <img src="https://hackmd.io/_uploads/rJWprDN6A.png" alt="image">鬼索的狂暴之刃 + <img src="https://hackmd.io/_uploads/HJO3SwNpC.png" alt="image">無盡之刃</p><h2 id="伊莉絲"><a href="#伊莉絲" class="headerlink" title="伊莉絲"></a>伊莉絲</h2><p><img src="https://hackmd.io/_uploads/S1Or3UNpR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/rybx_UETR.png" alt="image">蜘蛛型態</p><p>轉化為蜘蛛型態，將此技能替換為石化毒液，然後施放該技能。</p><p>石化毒液：使目標暈眩1.5秒並對其造成[ 132 &#x2F; 194 &#x2F; 289 ] (HP+AP)魔法傷害。治療[ 160 &#x2F; 190 &#x2F; 230 ] (AP)。</p><h2 id="嚼嚼"><a href="#嚼嚼" class="headerlink" title="嚼嚼"></a>嚼嚼</h2><p><img src="https://hackmd.io/_uploads/BkfUvIVaR.png" alt="image"><br><img src="https://hackmd.io/_uploads/SkGn_I4aR.png" alt="image">熾熱龍息<br>對目標噴射龍焰，造成[ 224 &#x2F; 336 &#x2F; 514 ] (AD+AP) 物理傷害。對最靠近的2個目標造成50%的超量傷害。</p><p>龍族升級：改為造成[ 295 &#x2F; 443 &#x2F; 674 ] (AD+AP) 物理傷害。超量傷害可以命中4個目標。</p><h1 id="希瓦納"><a href="#希瓦納" class="headerlink" title="希瓦納"></a>希瓦納</h1><p><img src="https://hackmd.io/_uploads/r1wLDLE60.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BknR3LV60.png" alt="image">真龍轉生<br>化為龍形，獲得一個每秒對鄰近敵軍造成[ 68 &#x2F; 104 &#x2F; 159 ] (HP+AP)魔法傷害的氣場。然後飛過2格內最大群的敵軍並使其暈眩[ 1 &#x2F; 1 &#x2F; 1.25 ]秒。</p><p>龍族升級：氣場大小加倍，造成的傷害提升30%。</p><h2 id="妮可"><a href="#妮可" class="headerlink" title="妮可"></a>妮可</h2><p><img src="https://hackmd.io/_uploads/S1ALwL4aR.png" alt="image"><br><img src="https://hackmd.io/_uploads/r1Tdp8N60.png" alt="image">驚喜！！！<br>Active<br>50 &#x2F; 125<br>幻化為螃蟹，持續2秒。在持續時間內，回復12% (HP)生命，並對3名鄰近友軍和3名鄰近敵軍釋放河蟹攻擊。命中的友軍會回復[ 75 &#x2F; 100 &#x2F; 125 ] (AP)生命；命中的敵軍則會受到[ 100 &#x2F; 150 &#x2F; 240 ] (AP)魔法傷害並暈眩1.25秒。</p><h2 id="斯溫"><a href="#斯溫" class="headerlink" title="斯溫"></a>斯溫</h2><p><img src="https://hackmd.io/_uploads/BJAvDINTR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/r16x08VTA.png" alt="image">暴雪<br>幻化，增加<a href="AP"> 300 &#x2F; 375 &#x2F; 450 </a>最大生命。幻化時，每秒對2格內的敵軍造成<a href="AP"> 20 &#x2F; 30 &#x2F; 50 </a>魔法傷害。</p><p>如已幻化，則增加<a href="AP"> 180 &#x2F; 230 &#x2F; 280 </a>額外最大生命，並提升傷害<a href="AP"> 10 &#x2F; 15 &#x2F; 25 </a>。</p><h2 id="法洛士"><a href="#法洛士" class="headerlink" title="法洛士"></a>法洛士</h2><p><img src="https://hackmd.io/_uploads/SyetDIE6R.png" alt="image"><br><img src="https://hackmd.io/_uploads/BJBa08EaA.png" alt="image">地獄火雨<br>對5 (攻擊範圍)格內一群敵軍發射一個超新星，對目標和相鄰敵軍造成[ 325 &#x2F; 488 &#x2F; 1438 ] (AD+AP)物理傷害。它會爆炸化為連環火球，對3格內其他所有敵軍造成[ 163 &#x2F; 244 &#x2F; 1438 ] (AD+AP)物理傷害。</p><h1 id="羈絆組成"><a href="#羈絆組成" class="headerlink" title="羈絆組成"></a>羈絆組成</h1><p>羈絆組合有 6變形師<img src="https://hackmd.io/_uploads/SJvCZDNTR.png" alt="image">+3龍族<img src="https://hackmd.io/_uploads/H1jMzPNpC.png" alt="image"><br>+2煉獄使者<img src="https://hackmd.io/_uploads/S1ggMPETA.png" alt="image">+2轟炸槍手<img src="https://hackmd.io/_uploads/BJk-MDVa0.png" alt="image">!</p><p><img src="https://hackmd.io/_uploads/SJo_GwNp0.png" alt="image"><img src="https://hackmd.io/_uploads/ByecGPN60.png" alt="image"><br><img src="https://hackmd.io/_uploads/BJcazvETA.png" alt="image"><br><img src="https://hackmd.io/_uploads/HyF3MDEpA.png" alt="image"></p><p>其中前期的龍族可以降治癒，後期有變形師的高血量，整體來說算是營運的陣容，不適合在低等賭狗。</p><h1 id="增幅裝置"><a href="#增幅裝置" class="headerlink" title="增幅裝置"></a>增幅裝置</h1><p>龍族專精<img src="https://hackmd.io/_uploads/BkrY7D4aC.png" alt="image"> &gt; 永恆生長 <img src="https://hackmd.io/_uploads/S18n7PE60.png" alt="image"> &gt; 潘朵拉的道具 II <img src="https://hackmd.io/_uploads/Hk1C7DNaR.png" alt="image"></p><h1 id="首選道具"><a href="#首選道具" class="headerlink" title="首選道具"></a>首選道具</h1><p>暴風之劍<img src="https://hackmd.io/_uploads/ry28VvVT0.png" alt="image">&gt;反曲弓<img src="https://hackmd.io/_uploads/HJSvVPN6A.png" alt="image">&gt;巨人腰帶<img src="https://hackmd.io/_uploads/rJpvVv4a0.png" alt="image">&gt;格鬥手套<img src="https://hackmd.io/_uploads/H14_4wE6A.png" alt="image"></p><h1 id="實戰影片"><a href="#實戰影片" class="headerlink" title="實戰影片"></a>實戰影片</h1><p>以下是我的頻道紀錄的實戰影片<br><a href="https://youtu.be/4jrcxdVzvbg?si=21RPggQIFkPA85Zw">https://youtu.be/4jrcxdVzvbg?si=21RPggQIFkPA85Zw</a><br><a href="https://youtu.be/TOVzoUnCiwU?si=bCoKu9zeQzi4zZ0e">https://youtu.be/TOVzoUnCiwU?si=bCoKu9zeQzi4zZ0e</a><br><a href="https://youtu.be/TBrnuIPQ1L0?si=Bb5L61i29d0Dq3B1">https://youtu.be/TBrnuIPQ1L0?si=Bb5L61i29d0Dq3B1</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E6%88%B0%E6%A3%8B/">聯盟戰棋</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/16/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%97%97-%E8%AE%8A%E5%BD%A2%E5%B8%AB%E9%BE%8D%E6%97%8F%E7%B4%8D%E7%91%9F%E6%96%AF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - 身分識別管理工具 Identity-Aware Proxy (IAP)</title>
      <link>https://gahgah147.github.io/2024/09/12/GCP-%E8%BA%AB%E5%88%86%E8%AD%98%E5%88%A5%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Identity-Aware-Proxy-IAP/</link>
      <guid>https://gahgah147.github.io/2024/09/12/GCP-%E8%BA%AB%E5%88%86%E8%AD%98%E5%88%A5%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Identity-Aware-Proxy-IAP/</guid>
      <pubDate>Thu, 12 Sep 2024 01:59:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;隨著雲端應用的普及，安全性成為各企業不可忽視的重要議題。Google Cloud Platform（GCP）提供了眾多安全性工具，而其中一個強大的功能就是 &lt;strong&gt;Identity-Aware Proxy（IAP）&lt;/strong&gt;。IAP 透過基於身份的存取控制來</description>
        
      
      
      
      <content:encoded><![CDATA[<p>隨著雲端應用的普及，安全性成為各企業不可忽視的重要議題。Google Cloud Platform（GCP）提供了眾多安全性工具，而其中一個強大的功能就是 <strong>Identity-Aware Proxy（IAP）</strong>。IAP 透過基於身份的存取控制來保護應用程式，確保只有授權用戶可以存取特定的應用或服務。</p><p>以下是GCP  Identity-Aware Proxy（IAP）的官方介紹文件<br><img src="https://hackmd.io/_uploads/B1N4W6k6A.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/security/products/iap?hl=en">https://cloud.google.com/security/products/iap?hl=en</a></p></blockquote><h1 id="什麼是-Identity-Aware-Proxy？"><a href="#什麼是-Identity-Aware-Proxy？" class="headerlink" title="什麼是 Identity-Aware Proxy？"></a>什麼是 Identity-Aware Proxy？</h1><p>Identity-Aware Proxy 是 GCP 提供的一項服務，允許您基於使用者身份來控制應用或虛擬機器的存取權限。IAP 讓傳統的防火牆概念更進一步，將網路安全保護由 IP 位址轉移到使用者身份層級，這有助於確保您的資源能夠被正確的使用者存取，而不需要暴露在網路中。</p><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="基於身份的存取控制"><a href="#基於身份的存取控制" class="headerlink" title="基於身份的存取控制"></a>基於身份的存取控制</h2><p>   IAP 使用 Google Account 驗證使用者身份，並基於特定角色或權限來允許或拒絕使用者的存取請求，確保敏感資料不會被未經授權的個人看到。</p><h2 id="無需暴露公眾-IP"><a href="#無需暴露公眾-IP" class="headerlink" title="無需暴露公眾 IP"></a>無需暴露公眾 IP</h2><p>   傳統的網路安全措施常常依賴防火牆規則，允許特定 IP 位址存取應用程式。但透過 IAP，您可以將應用程式或服務完全保護在內部網路中，僅允許具備正確身份驗證的使用者進行訪問。</p><h2 id="與其他-GCP-服務整合"><a href="#與其他-GCP-服務整合" class="headerlink" title="與其他 GCP 服務整合"></a>與其他 GCP 服務整合</h2><p>   IAP 能與 GCP 的其他安全性服務整合，如 <strong>Cloud Identity</strong> 和 <strong>Google OAuth 2.0</strong>，為 GCP 應用和 VM 提供全面的安全保護。</p><h2 id="支持多種應用架構"><a href="#支持多種應用架構" class="headerlink" title="支持多種應用架構"></a>支持多種應用架構</h2><p>   不論您使用的是 GCP 上的 Compute Engine、Kubernetes Engine 還是 App Engine，都可以透過 IAP 進行身份驗證和存取控制，保護不同類型的應用和服務。</p><h3 id="App-Engine"><a href="#App-Engine" class="headerlink" title="App Engine"></a>App Engine</h3><p><img src="https://hackmd.io/_uploads/HJJUMa1TC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/iap/docs/concepts-overview">https://cloud.google.com/iap/docs/concepts-overview</a></p></blockquote><h3 id="Cloud-Run"><a href="#Cloud-Run" class="headerlink" title="Cloud Run"></a>Cloud Run</h3><p><img src="https://hackmd.io/_uploads/H1iY7ay6R.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/iap/docs/concepts-overview">https://cloud.google.com/iap/docs/concepts-overview</a></p></blockquote><h3 id="Compute-Engine"><a href="#Compute-Engine" class="headerlink" title="Compute Engine"></a>Compute Engine</h3><p><img src="https://hackmd.io/_uploads/HyHo7pkTR.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/iap/docs/concepts-overview">https://cloud.google.com/iap/docs/concepts-overview</a></p></blockquote><h3 id="GKE"><a href="#GKE" class="headerlink" title="GKE"></a>GKE</h3><p><img src="https://hackmd.io/_uploads/HyzAQTJpC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/iap/docs/concepts-overview">https://cloud.google.com/iap/docs/concepts-overview</a></p></blockquote><h3 id="On-premises"><a href="#On-premises" class="headerlink" title="On-premises"></a>On-premises</h3><p><img src="https://hackmd.io/_uploads/B1LeNpyaA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/iap/docs/concepts-overview">https://cloud.google.com/iap/docs/concepts-overview</a></p></blockquote><h1 id="運作流程"><a href="#運作流程" class="headerlink" title="運作流程"></a>運作流程</h1><ol><li><p><strong>使用者驗證</strong><br>當使用者試圖存取受 IAP 保護的應用或資源時，IAP 會首先確認使用者是否已經登入 Google 帳戶，並進行身份驗證。</p></li><li><p><strong>權限檢查</strong><br>IAP 會根據 IAM（Identity and Access Management）中的角色與權限設定來決定使用者是否可以存取特定應用或服務。</p></li><li><p><strong>應用授權</strong><br>一旦身份和權限驗證通過，IAP 會允許該使用者存取應用程式，並將流量轉送到後端服務。</p></li></ol><h2 id="主要優勢"><a href="#主要優勢" class="headerlink" title="主要優勢"></a>主要優勢</h2><ol><li><strong>強化安全性</strong>：避免將應用程式暴露在公網中，僅允許經身份驗證的用戶存取。</li><li><strong>簡化存取管理</strong>：整合 Google 帳戶系統，不需要手動管理 IP 白名單。</li><li><strong>彈性部署</strong>：支持多種雲端應用程式架構，適用於不同規模的企業。</li></ol><h2 id="如何配置-GCP-Identity-Aware-Proxy？"><a href="#如何配置-GCP-Identity-Aware-Proxy？" class="headerlink" title="如何配置 GCP Identity-Aware Proxy？"></a>如何配置 GCP Identity-Aware Proxy？</h2><ol><li><p><strong>啟用 IAP</strong><br>在 GCP Console 中，導航至 <strong>IAP 設定頁面</strong>，選擇需要保護的資源並啟用 IAP 功能。</p></li><li><p><strong>設置 IAM 角色與權限</strong><br>為使用者賦予適當的 IAM 角色，例如 IAP-secured Web App User 或 Viewer，來決定哪些使用者可以存取受保護的應用。</p></li><li><p><strong>測試與驗證</strong><br>配置完成後，測試使用者存取，確認身份驗證與存取控制是否如預期運作。</p></li></ol><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>GCP 的 Identity-Aware Proxy 是一個強大的工具，讓企業能夠基於身份來控制應用和資源的存取，進一步強化雲端安全性。透過簡單的配置，您可以確保敏感應用僅能被授權的使用者存取，降低外部攻擊的風險。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/IAP/">IAP</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/12/GCP-%E8%BA%AB%E5%88%86%E8%AD%98%E5%88%A5%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Identity-Aware-Proxy-IAP/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>吉伊卡哇 - 找回躲在心理的小可愛</title>
      <link>https://gahgah147.github.io/2024/09/10/%E5%90%89%E4%BC%8A%E5%8D%A1%E5%93%87-%E6%89%BE%E5%9B%9E%E8%BA%B2%E5%9C%A8%E5%BF%83%E7%90%86%E7%9A%84%E5%B0%8F%E5%8F%AF%E6%84%9B/</link>
      <guid>https://gahgah147.github.io/2024/09/10/%E5%90%89%E4%BC%8A%E5%8D%A1%E5%93%87-%E6%89%BE%E5%9B%9E%E8%BA%B2%E5%9C%A8%E5%BF%83%E7%90%86%E7%9A%84%E5%B0%8F%E5%8F%AF%E6%84%9B/</guid>
      <pubDate>Tue, 10 Sep 2024 02:03:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;今天想跟大家分享我最近在看的療育可愛動漫，吉伊卡哇 （ちいかわ）《Chiikawa》（日語：ちいかわ）一開始是由日本漫畫家ナガノ（Nagano）創作的漫畫該系列自2020年1月起透過Twitter進行連載，以「希望變成這樣的樣子」的說明一起被描繪出來。&lt;/p&gt;
&lt;p&gt;原來這</description>
        
      
      
      
      <content:encoded><![CDATA[<p>今天想跟大家分享我最近在看的療育可愛動漫，吉伊卡哇 （ちいかわ）《Chiikawa》（日語：ちいかわ）一開始是由日本漫畫家ナガノ（Nagano）創作的漫畫該系列自2020年1月起透過Twitter進行連載，以「希望變成這樣的樣子」的說明一起被描繪出來。</p><p>原來這個漫畫已經4年這麼久了呀?! 大家對個漫畫有興趣的話可以去追蹤作者的X哦 ngnchiikawa＠twitter</p><p><img src="https://hackmd.io/_uploads/SJJK4FhhC.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p>吉伊卡哇是由日文的小的ちいさい（chiisai）跟可愛的かわいい（kawaii）組合起來意思就是小可愛，故事是由吉依卡哇、小八貓與烏薩奇這三個角色展開，每一集的時間都不長大約一分半，而且角色大部分都沒有台詞，主要會講話的是小八貓而且聲音超級可愛，現在看來感覺每一集都好療育，搭配上水墨的畫風線條跟簡單的配色整體的感覺很舒服。</p><h1 id="吉伊卡哇（ちいかわ）"><a href="#吉伊卡哇（ちいかわ）" class="headerlink" title="吉伊卡哇（ちいかわ）"></a>吉伊卡哇（ちいかわ）</h1><p><img src="https://hackmd.io/_uploads/SkGcXth2R.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p>吉伊卡哇是一隻小白鼠，個性給我的感覺就是內向害羞又膽小，遇到很多事情都不敢主動表達，而且常常看到它在哭，臉上都是有眼淚的表情，搭配上哭哭的配音就覺得好可憐又可愛，是個非常善良的小可愛，雖然常常看到膽小的吉伊卡哇在害怕，但是愈到了關鍵時刻又會為了朋友奮不顧身，真是一個勇敢的好孩子。</p><p><img src="https://hackmd.io/_uploads/SyYC7YnnC.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><h1 id="小八（ハチワレ）"><a href="#小八（ハチワレ）" class="headerlink" title="小八（ハチワレ）"></a>小八（ハチワレ）</h1><p><img src="https://hackmd.io/_uploads/r1djEF3nR.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p>小八是吉伊卡哇最好的朋友，是一隻白色的小貓有藍色的耳朵，也是這部作品裡面最常說話的角色，常常幫助吉依卡哇，雖然小八貓家裡很窮又住在山洞裡，但是小八貓常常表現得很樂觀，而且很願意跟朋友分享食物，也很重視朋友送給它的東西，又是個有夢想的小可愛，雖然很窮但是很願意存錢買自己喜歡的東西，像是相機與吉他，小八貓還有自己彈吉他唱歌的劇情超級可愛</p><p><img src="https://hackmd.io/_uploads/HkVvEF22R.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p><img src="https://hackmd.io/_uploads/SyFXVKnnC.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p><img src="https://hackmd.io/_uploads/SydNVFn3C.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><h1 id="烏薩奇（うさぎ）"><a href="#烏薩奇（うさぎ）" class="headerlink" title="烏薩奇（うさぎ）"></a>烏薩奇（うさぎ）</h1><p>烏薩奇是裡面最活潑的小可愛，形象是一隻兔子，出場就會發出很開心的叫聲，感覺隨時都很興奮的狀態有點瘋瘋的，常常會「嗚啦」、「呀哈」，其中我最喜歡的是烏薩奇常常發出「蛤」的聲音，是小可愛中最勇敢的角色，看似神經大條，但卻很聰明，常常幫小八跟吉伊卡哇解決困難，而且還有很厲害的討伐武器</p><p><img src="https://hackmd.io/_uploads/Hy2SXY32A.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p><img src="https://hackmd.io/_uploads/SJFrEthnA.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><h1 id="世界觀設定"><a href="#世界觀設定" class="headerlink" title="世界觀設定"></a>世界觀設定</h1><p><img src="https://hackmd.io/_uploads/HJLWz5nhC.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p>在吉伊卡哇的世界中，存在著嚴苛的階級與勞動制度。居民們必須透過大量的勞動，如除草、討伐、工廠作業，才能賺取足夠的金錢維持生活。</p><p>儘管角色們十分可愛，吉伊卡哇的很多情節實際上都讓人聯想到社會的黑暗面，可愛的畫風和懸疑劇情的搭配更讓讀者毛骨悚然。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p><img src="https://hackmd.io/_uploads/HJmvXY3nR.png" alt="image"></p><blockquote><p>圖片來源 ngnchiikawa＠twitter</p></blockquote><p>以上就是吉伊卡哇的介紹，我很喜歡看吉伊卡哇日常享受食物的劇情，而且他們的生活也都需要工作賺錢，辛苦完成討伐來取得錢來購買生活中需要的物品，也常常讓我帶入到我的日常生活上挑戰的感覺，看著吉依卡哇露出可憐的哭哭表情說著不要，或是小八常常保持樂觀積極，又或是烏薩奇聰明又神經大條的化解難題，也是我想要成為的樣子，很羨慕吉伊卡哇身邊有小八跟烏薩奇這麼好的朋友，好期待後續吉伊卡哇的劇情發展。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E5%8B%95%E6%BC%AB/">動漫</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%90%89%E4%BC%8A%E5%8D%A1%E5%93%87/">吉伊卡哇</category>
      
      <category domain="https://gahgah147.github.io/tags/%E7%99%82%E8%82%B2/">療育</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%8D%A1%E9%80%9A/">卡通</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%8F%AF%E6%84%9B/">可愛</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/10/%E5%90%89%E4%BC%8A%E5%8D%A1%E5%93%87-%E6%89%BE%E5%9B%9E%E8%BA%B2%E5%9C%A8%E5%BF%83%E7%90%86%E7%9A%84%E5%B0%8F%E5%8F%AF%E6%84%9B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Qwiklabs課程紀錄 Orchestrating the Cloud with Kubernetes</title>
      <link>https://gahgah147.github.io/2024/09/05/GCP-Google-Cloud-Skills-Boost-%E7%9A%84-Qwiklabs%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84-Orchestrating-the-Cloud-with-Kubernetes/</link>
      <guid>https://gahgah147.github.io/2024/09/05/GCP-Google-Cloud-Skills-Boost-%E7%9A%84-Qwiklabs%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84-Orchestrating-the-Cloud-with-Kubernetes/</guid>
      <pubDate>Thu, 05 Sep 2024 09:13:25 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkwy8lD3A.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天這篇文章是在記錄我練習Google Cloud Skills Boost 官方學習資源平台的過程，今天練習的課程是 Orche</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/rkwy8lD3A.png" alt="image"></p><p>今天這篇文章是在記錄我練習Google Cloud Skills Boost 官方學習資源平台的過程，今天練習的課程是 Orchestrating the Cloud with Kubernetes，這個 實踐實驗室（Qwiklabs） 主題是在介紹 透過 Kubernetes 自動化調度管理雲端資源 功能。<br><img src="https://hackmd.io/_uploads/BJ42MxP3R.png" alt="image"></p><h1 id="GSP021"><a href="#GSP021" class="headerlink" title="GSP021"></a>GSP021</h1><p><img src="https://hackmd.io/_uploads/ry3n7gD2C.png" alt="image"></p><h1 id="總覽"><a href="#總覽" class="headerlink" title="總覽"></a>總覽</h1><p>Kubernetes 是開放原始碼專案 (可透過 kubernetes.io 存取)，能夠在許多不同環境中運作，包括筆記型電腦、高可用性的多節點叢集、公有雲、地端部署、虛擬機器和裸機環境。</p><p>在本研究室中，使用 Kubernetes Engine 等代管環境可讓您專心體驗 Kubernetes，不必費心設定基礎架構。Kubernetes Engine 是專用於部署容器化應用程式的代管環境。這項服務匯集了開發人員效率提升、資源效率、自動化作業和開放原始碼靈活性等方面的最新技術，有助於縮短上市時間。</p><div class="note info simple"><p>應用程式託管於 GitHub，並提供 12 因子應用程式範例。在本研究室中，將使用以下 Docker 映像檔：</p><ul><li>kelseyhightower&#x2F;monolith：包含 Auth 和 Hello 服務的單體。</li><li>kelseyhightower&#x2F;auth：Auth 微服務，可為通過驗證的使用者產生 JWT 權杖。</li><li>kelseyhightower&#x2F;hello：Hello 微服務，會向通過驗證的使用者打招呼。</li><li>nginx：Auth 和 Hello 服務的前端。</li></ul></div><h1 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h1><ul><li>使用 Kubernetes Engine 佈建完整的 Kubernetes 叢集。</li><li>使用 kubectl 部署及管理 Docker 容器。</li><li>使用 Kubernetes 的 Deployment 和 Service 將應用程式拆解成微服務。</li></ul><h1 id="Google-Kubernetes-Engine"><a href="#Google-Kubernetes-Engine" class="headerlink" title="Google Kubernetes Engine"></a>Google Kubernetes Engine</h1><ol><li><p>在 Cloud Shell 環境中，輸入以下指令來設定可用區：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud config set compute/zone us-central1-c</span><br></pre></td></tr></table></figure></li><li><p>啟動要使用的cluster：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters create io --zone us-central1-c</span><br></pre></td></tr></table></figure></li></ol><h1 id="工作-1：取得程式碼範例"><a href="#工作-1：取得程式碼範例" class="headerlink" title="工作 1：取得程式碼範例"></a>工作 1：取得程式碼範例</h1><ol><li>從 Cloud Shell 指令列複製原始碼：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsutil cp -r gs://spls/gsp021/* .</span><br></pre></td></tr></table></figure></li><li>變更為本研究室所需的目錄：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd orchestrate-with-kubernetes/kubernetes</span><br></pre></td></tr></table></figure><ol start="3"><li>列出檔案以便查看：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><h1 id="工作-2：Kubernetes-快速示範"><a href="#工作-2：Kubernetes-快速示範" class="headerlink" title="工作 2：Kubernetes 快速示範"></a>工作 2：Kubernetes 快速示範</h1><p>如要開始使用 Kubernetes，最簡單的方法是運用 <code>kubectl create</code> 指令。</p><ol><li>使用這項指令啟動 nginx 容器的單一執行個體：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx:1.10.0</span><br></pre></td></tr></table></figure><p>Kubernetes 已建立 Deployment。稍後會再針對 Deployment 進行說明，目前您只需要知道 Deployment 可讓 Pod 保持運作，即使執行 Pod 的節點發生問題也沒關係。</p><p>Kubernetes 中的所有容器都是透過 Pod 執行。</p><ol start="2"><li>使用 <code>kubectl get pods</code> 指令查看運作中的 nginx 容器：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><ol start="3"><li>nginx 容器處於「運作中」狀態後，您就可以使用 kubectl expose 指令，在 Kubernetes 外部公開該容器：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment nginx --port 80 --type LoadBalancer</span><br></pre></td></tr></table></figure><ol start="4"><li><p>使用 <code>kubectl get services</code> 指令列出服務：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><div class="note info simple"><p>「ExternalIP」欄位可能需要幾秒鐘才會填入服務的外部 IP 位址。這是正常現象，只要每隔幾秒重新執行 kubectl get services 指令，直到該欄位填入位址即可。</p></div></li><li><p>在這項指令中加入外部 IP，從遠端連至該 Nginx 容器：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://&lt;External IP&gt;:80</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HkOmZA8hC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BJ-SW0U2A.png" alt="image"></p><h1 id="工作-3：Pod"><a href="#工作-3：Pod" class="headerlink" title="工作 3：Pod"></a>工作 3：Pod</h1><p>Kubernetes 的核心是 <a href="https://kubernetes.io/docs/concepts/workloads/pods/">Pod</a>。</p><p>Pod 代表並存放了一或多個容器。一般來說，如果多個容器之間有硬相依性，就可以包裝在同一個 Pod 中。</p><p><img src="https://hackmd.io/_uploads/H1wD-RLn0.png" alt="image"></p><p>這個範例中有一個包含單體和 nginx 容器的 Pod。</p><p>Pod 也有<a href="https://kubernetes.io/docs/concepts/storage/volumes/">磁碟區</a>。磁碟區是效期與 Pod 相同的資料磁碟，可由該 Pod 中的容器使用。Pod 為所含內容提供共用命名空間，因此範例 Pod 中的兩個容器可互相通訊，並且共用所連接的磁碟區。</p><p>不同的 Pod 還會共用網路命名空間，因此每個 Pod 都有一個 IP 位址。</p><p>接著讓我們來深入瞭解 Pod。</p><h1 id="工作-4：建立-Pod"><a href="#工作-4：建立-Pod" class="headerlink" title="工作 4：建立 Pod"></a>工作 4：建立 Pod</h1><p>Pod 可使用 Pod 設定檔建立。請花點時間瞭解單體 Pod 設定檔。<br>1.前往目錄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/orchestrate-with-kubernetes/kubernetes</span><br></pre></td></tr></table></figure><p>2.執行以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat pods/monolith.yaml</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Sk2CbRI3A.png" alt="image"></p><p>輸出結果會顯示公開設定檔：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: monolith</span><br><span class="line">  labels:</span><br><span class="line">    app: monolith</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: monolith</span><br><span class="line">      image: kelseyhightower/monolith:1.0.0</span><br><span class="line">      args:</span><br><span class="line">        - &quot;-http=0.0.0.0:80&quot;</span><br><span class="line">        - &quot;-health=0.0.0.0:81&quot;</span><br><span class="line">        - &quot;-secret=secret&quot;</span><br><span class="line">      ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br><span class="line">        - name: health</span><br><span class="line">          containerPort: 81</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpu: 0.2</span><br><span class="line">          memory: &quot;10Mi&quot;</span><br></pre></td></tr></table></figure><p>這裡有幾點要注意。從輸出結果可看出：</p><ul><li>Pod 包含一個容器 (單體)。</li><li>您在容器啟動時傳遞了幾個引數至容器。</li><li>您開啟了用於 http 流量的通訊埠 80。</li></ul><ol start="3"><li>使用 <code>kubectl</code> 建立單體 Pod：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f pods/monolith.yaml</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/B1iVz08hA.png" alt="image"></p><ol start="4"><li>檢查 Pod。請使用 <code>kubectl get pods</code> 指令列出在預設命名空間中運作的所有 Pod：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rJ-IMC83R.png" alt="image"></p><div class="note info simple"><p>單體 Pod 可能需要幾秒鐘才會開始運作。單體容器映像檔必須先從 Docker Hub 提取出來才能執行。</p></div><ol start="5"><li>Pod 開始運作後，請使用 <code>kubectl describe</code> 指令取得更多有關該單體 Pod 的資訊：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pods monolith</span><br></pre></td></tr></table></figure><p>您會看到許多關於該單體 Pod 的資訊，包括 Pod 的 IP 位址和事件記錄。這些資訊在疑難排解時可派上用場。</p><p><img src="https://hackmd.io/_uploads/HkVe7A8n0.png" alt="image"></p><p>Kubernetes 可根據設定檔中的描述建立 Pod，並讓您在 Pod 運作時輕鬆查看相關資訊。到了這個階段，您已經可以建立 Deployment 所需的所有 Pod！</p><h1 id="工作-5：與-Pod-互動"><a href="#工作-5：與-Pod-互動" class="headerlink" title="工作 5：與 Pod 互動"></a>工作 5：與 Pod 互動</h1><p>根據預設，Pod 會獲分配私人 IP 位址，且無法從叢集外部連線。請使用 <code>kubectl port-forward</code> 指令將本機通訊埠對應至單體 Pod 內部的通訊埠。</p><div class="note info simple"><p>在本研究室的後續部分中，您必須透過多個 Cloud Shell 分頁設定 Pod 之間的通訊。如果指令是透過第二或第三個指令殼層執行，則會在指令的操作說明中標示。</p></div><ol><li>開啟第二個 Cloud Shell 終端機。您現在有兩個終端機，分別用於執行 <code>kubectl port-forward</code> 指令及下達 <code>curl</code> 指令。</li></ol><p><img src="https://hackmd.io/_uploads/Hk44Q0I3C.png" alt="image"></p><ol start="2"><li>在第 2 個終端機中，執行以下指令來設定通訊埠轉送：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward monolith 10080:80</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BytLXAInC.png" alt="image"></p><p>3.接著在第 1 個終端機中使用 curl 開始與 Pod 通訊：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:10080</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rJItmCI3A.png" alt="image"></p><p>很好！容器傳回了友善的回應：「Hello」。</p><ol start="4"><li>接著使用 <code>curl</code> 指令，看看連到安全端點時會發生什麼事：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:10080/secure</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJe6XAI3C.png" alt="image"></p><p>糟糕！</p><ol start="5"><li>嘗試登入，從單體取回驗證權杖：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u user http://127.0.0.1:10080/login</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJgmHVA8nC.png" alt="image"></p><ol start="6"><li><p>畫面上顯示登入提示時，使用密碼登入。<br><img src="https://hackmd.io/_uploads/rypEHRIhR.png" alt="image"><br>這邊的密碼在這邊</p></li><li><p>由於 Cloud Shell 無法妥善複製較長的字串，因此請為權杖建立環境變數。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOKEN=$(curl http://127.0.0.1:10080/login -u user|jq -r &#x27;.token&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HJvYHCI2A.png" alt="image"></p><ol start="8"><li><p>系統提示您輸入主機密碼時，再次輸入密碼。</p></li><li><p>使用以下指令複製權杖，並透過 <code>curl</code> 使用該權杖連至安全端點：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Authorization: Bearer $TOKEN&quot; http://127.0.0.1:10080/secure</span><br></pre></td></tr></table></figure><p>應用程式應該會傳回回應，讓我們知道一切都運作正常。</p></li><li><p>使用 <code>kubectl logs</code> 指令查看 <code>monolith</code> Pod 的記錄。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs monolith</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r13L8AIn0.png" alt="image"></p><ol start="11"><li>開啟第 3 個終端機，並使用 -f 標記取得即時記錄串流：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs -f monolith</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkB9LRL3C.png" alt="image"></p><ol start="12"><li>如果您在第 1 個終端機中使用 curl 與單體互動，記錄就會在第 3 個終端機中更新：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:10080</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Bk5hI0Ln0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BkhTUAUnR.png" alt="image"></p><p>13.使用 <code>kubectl exec</code> 指令在單體 Pod 內執行互動式殼層。如要在容器內進行疑難排解，這個殼層就能派上用場：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec monolith --stdin --tty -c monolith -- /bin/sh</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rkS7D0L30.png" alt="image"></p><ol start="14"><li>舉例來說，在單體容器中建立殼層後，您就能使用 ping 指令測試外部連線：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 3 google.com</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/SydLw08hR.png" alt="image"></p><p>15.使用完這個互動式殼層後，請務必登出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Hy8KvA8hA.png" alt="image"></p><p>如您所見，只要使用 <code>kubectl</code> 指令，就能輕鬆與 Pod 互動。如需從遠端連至容器，或是取得登入殼層，Kubernetes 提供所有必要資源。</p><h1 id="工作-6：Service"><a href="#工作-6：Service" class="headerlink" title="工作 6：Service"></a>工作 6：Service</h1><p>Pod 不會永久有效，可能會因許多因素停止或啟動 (例如未通過有效性或完備性檢查)，進而造成一個問題：</p><p>與一組 Pod 通訊會發生什麼情形？這些 Pod 重新啟動時可能會有不同的 IP 位址。</p><p>在這種時候，<a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> 便能派上用場。Service 可為 Pod 提供穩定的端點。</p><p><img src="https://hackmd.io/_uploads/HkHnwRI3R.png" alt="image"></p><p>Service 會根據標籤決定要在哪個 Pod 上運作。如果 Pod 的標籤正確，Service 就會自動辨識並公開 Pod。</p><p>Service 為一組 Pod 提供的存取層級取決於 Service 類型。目前 Service 分為以下三種：</p><ul><li>ClusterIP (內部)：這是預設類型，表示這項 Service 只會在叢集內部顯示</li><li>NodePort：為叢集中的每個節點提供可從外部存取的 IP</li><li>LoadBalancer：新增雲端服務供應商的負載平衡器，用於將 Service 的流量轉送至當中的節點</li></ul><p>接下來您將瞭解如何：</p><ul><li>建立 Service</li><li>使用標籤選取器，對外公開一部分的 Pod</li></ul><h1 id="工作-7：建立-Service"><a href="#工作-7：建立-Service" class="headerlink" title="工作 7：建立 Service"></a>工作 7：建立 Service</h1><p>在建立 Service 前，請先建立可處理 https 流量的安全 Pod。</p><ol><li>如果您變更了目錄，請務必返回 <code>~/orchestrate-with-kubernetes/kubernetes</code> 目錄：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/orchestrate-with-kubernetes/kubernetes</span><br></pre></td></tr></table></figure><ol start="2"><li>查看單體 Service 設定檔：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat pods/secure-monolith.yaml</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/S1a6OAI3C.png" alt="image"></p><ol start="3"><li>建立安全單體 Pod 及其設定資料：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic tls-certs --from-file tls/</span><br><span class="line">kubectl create configmap nginx-proxy-conf --from-file nginx/proxy.conf</span><br><span class="line">kubectl create -f pods/secure-monolith.yaml</span><br></pre></td></tr></table></figure></li></ol><p>您已建立安全的 Pod，接著要對外公開安全單體 Pod。為此，請建立 Kubernetes Service。</p><p><img src="https://hackmd.io/_uploads/SyXWYA830.png" alt="image"></p><ol start="4"><li>查看單體 Service 設定檔：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat services/monolith.yaml</span><br></pre></td></tr></table></figure><p>輸出內容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: &quot;monolith&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: &quot;monolith&quot;</span><br><span class="line">    secure: &quot;enabled&quot;</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: &quot;TCP&quot;</span><br><span class="line">      port: 443</span><br><span class="line">      targetPort: 443</span><br><span class="line">      nodePort: 31000</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BJbQtCIhC.png" alt="image"></p><div class="note info simple"><p>注意事項：</p><ul><li><p>輸出內容包含選取器，用來自動尋找及公開含有「app: monolith」和「secure: enabled」標籤的 Pod。</p></li><li><p>現在您必須公開節點通訊埠，這樣才能將外部流量從通訊埠 31000 轉送至位於通訊埠 443 的 nginx。</p></li></ul></div><ol start="5"><li>使用 <code>kubectl create</code> 指令，透過單體 Service 設定檔建立單體 Service：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f services/monolith.yaml</span><br></pre></td></tr></table></figure><p>輸出內容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service/monolith created6</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/B1zUYRU3A.png" alt="image"></p><p>測試已完成的工作</p><p>請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功建立單體 Pod 和 Service，就會看到評量分數。<br><img src="https://hackmd.io/_uploads/B1Jj_C830.png" alt="image"></p><p>您是使用通訊埠公開 Service，因此如果其他應用程式嘗試繫結至其中一個伺服器的通訊埠 31000，可能會發生通訊埠衝突。</p><p>在一般情況下，Kubernetes 會處理通訊埠指派作業，但在本研究室中，您自行選擇了通訊埠，以便之後設定健康狀態檢查。</p><ol start="6"><li>使用 <code>gcloud compute firewall-rules</code> 指令，允許流量傳送到公開節點通訊埠上的單體 Service：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute firewall-rules create allow-monolith-nodeport \</span><br><span class="line">  --allow=tcp:31000</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/Byc3tAU3C.png" alt="image"></p><p>測試已完成的工作<br>請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功建立防火牆規則來允許通訊埠 31000 的 TCP 流量，就會看到評量分數。</p><p><img src="https://hackmd.io/_uploads/HJVoY08n0.png" alt="image"></p><p>一切都設定完成後，您應該就能從叢集外部連至安全單體 Service，不必使用通訊埠轉送。</p><ol><li>首先，取得其中一個節點的外部 IP 位址。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute instances list</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1EQ508nA.png" alt="image"></p><ol start="2"><li>接著使用 curl 嘗試連至安全單體 Service：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -k https://&lt;EXTERNAL_IP&gt;:31000</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HyPDqCU2A.png" alt="image"></p><p>糟糕！作業逾時。發生了什麼事？</p><div class="note info simple"><p>附註：來驗收一下您的學習成果吧。</p><p>請使用以下指令回答下方問題：<br>kubectl get services monolith</p><p>kubectl describe services monolith</p><p>問題：</p><p>為何單體 Service 無法傳回回應？<br>單體 Service 有幾個端點？<br>Pod 必須有哪些標籤，單體 Service 才能辨識？</p></div><p>提示：關鍵在於標籤。您將在下一節修正錯誤。</p><h1 id="工作-8：為-Pod-新增標籤"><a href="#工作-8：為-Pod-新增標籤" class="headerlink" title="工作 8：為 Pod 新增標籤"></a>工作 8：為 Pod 新增標籤</h1><p>目前單體 Service 沒有端點。如要排解這類問題，其中一個方法是使用 <code>kubectl get pods</code> 指令和標籤查詢。</p><p>1.您會發現有幾個包含單體標籤的 Pod 正在運作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l &quot;app=monolith&quot;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Sy-3qRIhA.png" alt="image"></p><p>2.但如果是「app&#x3D;monolith」和「secure&#x3D;enabled」呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l &quot;app=monolith,secure=enabled&quot;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/By3aqAIhA.png" alt="image"></p><p>您會發現這個標籤查詢並未顯示任何結果。您似乎需要加上「secure&#x3D;enabled」標籤。</p><ol start="3"><li>使用 <code>kubectl label</code> 指令，為安全單體 Pod 新增缺少的 <code>secure=enabled</code> 標籤。完成後，您可以確認標籤是否已更新。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pods secure-monolith &#x27;secure=enabled&#x27;</span><br><span class="line">kubectl get pods secure-monolith --show-labels</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HJY-jRI2C.png" alt="image"></p><ol start="4"><li><p>為 Pod 加上正確標籤後，請查看單體 Service 的端點清單：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe services monolith | grep Endpoints</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HyX4oC8hC.png" alt="image"></p></li><li><p>再次連到其中一個節點進行測試。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute instances list</span><br><span class="line">curl -k https://&lt;EXTERNAL_IP&gt;:31000</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJSDoAIhA.png" alt="image"></p><p>測試已完成的工作<br>請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功為單體 Pod 新增標籤，就會看到評量分數。<br><img src="https://hackmd.io/_uploads/SyW_oA8hR.png" alt="image"></p><h1 id="工作-9：透過-Kubernetes-部署應用程式"><a href="#工作-9：透過-Kubernetes-部署應用程式" class="headerlink" title="工作 9：透過 Kubernetes 部署應用程式"></a>工作 9：透過 Kubernetes 部署應用程式</h1><p>本研究室的目標是協助您做好準備，以便在實際工作環境中調度資源及管理容器。在這種時候，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#what-is-a-deployment">Deployment</a> 便能派上用場。Deployment 可透過宣告方式，確保運作中的 Pod 數量與使用者指定的所需 Pod 數量相同。</p><p><img src="https://hackmd.io/_uploads/Hk15oR8h0.png" alt="image"></p><p>Deployment 的主要好處在於簡化了 Pod 管理作業的低層級細節。Deployment 實際上會使用 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 來啟動及停止 Pod。如果 Pod 需要更新或調度資源，Deployment 就會處理。假如 Pod 因故停止運作，Deployment 也可重新啟動 Pod。</p><p>請查看以下簡短範例：</p><p><img src="https://hackmd.io/_uploads/SkS3iRIhR.png" alt="image"></p><p>Pod 的生命週期取決於建立時所在的節點。在上方範例中，Node3 已停止運作，並連帶使一個 Pod 停止運作。在這個情況下，Deployment 建立了新的 Pod 並在 Node2 上啟動該 Pod，因此您不必手動建立新的 Pod 及尋找節點。</p><p>很方便吧！</p><p>接著來運用您學到的所有 Pod 和 Service 相關知識，使用 Deployment 將單體式應用程式拆解成較小的 Service。</p><h1 id="工作-10：建立-Deployment"><a href="#工作-10：建立-Deployment" class="headerlink" title="工作 10：建立 Deployment"></a>工作 10：建立 Deployment</h1><p>您要將單體式應用程式拆解成三個不同的部分：</p><ul><li>Auth：為通過驗證的使用者產生 JWT 權杖。</li><li>Hello：向通過驗證的使用者打招呼。</li><li>Frontend：將流量轉送至 Auth 和 Hello Service。</li></ul><p>您現在可以為每項 Service 分別建立 Deployment。之後，您將為 Auth 和 Hello Deployment 定義內部 Service，並為 Frontend Deployment 定義外部 Service。完成後，您就能像處理單體一樣與微服務互動，只不過每項微服務都能獨立調度資源和部署！</p><p>1.首先檢查 Auth Deployment 設定檔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat deployments/auth.yaml</span><br></pre></td></tr></table></figure><p>輸出內容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: auth</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchlabels:</span><br><span class="line">      app: auth</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: auth</span><br><span class="line">        track: stable</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: auth</span><br><span class="line">          image: &quot;kelseyhightower/auth:2.0.0&quot;</span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 80</span><br><span class="line">            - name: health</span><br><span class="line">              containerPort: 81</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Deployment 建立了 1 個備用資源，而您使用的是 2.0.0 版的 Auth 容器。</p><p>執行 <code>kubectl create</code> 指令來建立 Auth Deployment 時，會產生一個符合 Deployment 資訊清單資料的 Pod。這表示您可以變更「Replicas」欄位指定的數字來調整 Pod 數量。</p><p>2.總之，請建立 Deployment 物件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f deployments/auth.yaml</span><br></pre></td></tr></table></figure><ol start="3"><li>接著來建立 Auth Deployment 的 Service。使用 kubectl create 指令建立 Auth Service：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f services/auth.yaml</span><br></pre></td></tr></table></figure><ol start="4"><li>現在使用相同指令來建立並公開 Hello Deployment：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f deployments/hello.yaml</span><br><span class="line">kubectl create -f services/hello.yaml</span><br></pre></td></tr></table></figure><ol start="5"><li>再次使用相同指令來建立並公開 Frontend Deployment：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.conf</span><br><span class="line">kubectl create -f deployments/frontend.yaml</span><br><span class="line">kubectl create -f services/frontend.yaml</span><br></pre></td></tr></table></figure><div class="note info simple"><p>您必須透過容器儲存設定資料，因此要另外建立 Frontend。</p></div><ol start="6"><li>與 Frontend 互動，擷取其外部 IP 並執行 curl 指令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services frontend</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rkX52RL2R.png" alt="image"></p><div class="note info simple"><p>外部 IP 位址可能需要一分鐘才能產生。如果 EXTERNAL-IP 欄狀態為「待處理」，請再次執行上方指令。</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -k https://&lt;EXTERNAL-IP&gt;</span><br></pre></td></tr></table></figure><p>您會收到「hello」回應！</p><p>測試已完成的工作<br>請點選下方的「Check my progress」，確認您的研究室進度。如果您已成功建立 Auth、Hello 和 Frontend Deployment，就會看到評量分數。</p><p><img src="https://hackmd.io/_uploads/HJZPhRIhA.png" alt="image"></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這篇文章記錄在 Google Cloud Skills Boost 上學習 “Orchestrating the Cloud with Kubernetes” 的過程，並介紹了 Kubernetes 的基本概念與實際操作流程。內容涵蓋如何建立 Kubernetes 叢集、部署容器、與 Pod 互動等，使用 kubectl 指令來進行 Kubernetes 管理與資源操作。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/Kubernetes/">Kubernetes</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/05/GCP-Google-Cloud-Skills-Boost-%E7%9A%84-Qwiklabs%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84-Orchestrating-the-Cloud-with-Kubernetes/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - 微服務管理工具 Anthos Service Mesh</title>
      <link>https://gahgah147.github.io/2024/09/05/GCP-%E5%BE%AE%E6%9C%8D%E5%8B%99%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Anthos-Service-Mesh/</link>
      <guid>https://gahgah147.github.io/2024/09/05/GCP-%E5%BE%AE%E6%9C%8D%E5%8B%99%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Anthos-Service-Mesh/</guid>
      <pubDate>Thu, 05 Sep 2024 08:50:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;隨著微服務架構在現代應用程式開發中的普及，如何有效管理和保護這些服務成為了企業面臨的一大挑戰。GCP Anthos Service Mesh 正是為了解決這些問題而設計的。本文將帶您深入了解這項強大的工具，並展示它如何幫助企業提升微服務的可觀察性、安全性和管理效率。&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>隨著微服務架構在現代應用程式開發中的普及，如何有效管理和保護這些服務成為了企業面臨的一大挑戰。GCP Anthos Service Mesh 正是為了解決這些問題而設計的。本文將帶您深入了解這項強大的工具，並展示它如何幫助企業提升微服務的可觀察性、安全性和管理效率。</p><p><img src="https://hackmd.io/_uploads/rkpXM8H2C.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/anthos/service-mesh?hl=zh-tw">https://cloud.google.com/anthos/service-mesh?hl=zh-tw</a> </p></blockquote><h1 id="什麼是-Anthos-Service-Mesh"><a href="#什麼是-Anthos-Service-Mesh" class="headerlink" title="什麼是 Anthos Service Mesh?"></a>什麼是 Anthos Service Mesh?</h1><p><img src="https://hackmd.io/_uploads/BJLIMLSnA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/anthos/service-mesh?hl=zh-tw">https://cloud.google.com/anthos/service-mesh?hl=zh-tw</a></p></blockquote><p>Anthos Service Mesh 是由 Google Cloud 提供的一種開源服務網格解決方案，它建立在 Istio 架構之上，專門用於管理微服務之間的流量和安全性。它為企業提供了一個統一的平台來管理分散在多個 Kubernetes 集群中的微服務，並確保這些服務之間的通信安全和高效。</p><p>Anthos Service Mesh 的核心功能包括：<br><strong>服務發現</strong>：自動識別並管理微服務之間的相互依賴關係。<br><strong>負載均衡</strong>：根據服務的運行狀態和性能自動調整流量分配。<br><strong>安全通信</strong>：通過啟用自動化的 mTLS 加密，確保所有服務之間的通信安全。<br><strong>監控和可觀察性</strong>：提供深入的監控工具，讓運維人員可以實時查看服務的性能數據。</p><h1 id="什麼是-Istio"><a href="#什麼是-Istio" class="headerlink" title="什麼是 Istio?"></a>什麼是 Istio?</h1><p>Istio 是一個開源的**服務網格 (Service Mesh)**，它為微服務架構提供了統一的連線、安全性、可觀察性和策略管理功能。具體來說，Istio 可以幫助管理服務之間的通信，無需改動應用程式的程式碼，並且能在複雜的分散式系統中實現流量控制、服務間安全通信、故障處理、以及性能監控等功能。</p><h2 id="Istio-的核心功能："><a href="#Istio-的核心功能：" class="headerlink" title="Istio 的核心功能："></a>Istio 的核心功能：</h2><ol><li><p><strong>流量管理</strong>：Istio 提供細粒度的流量控制能力，允許設定服務之間的流量分配，如負載平衡、故障轉移、AB 測試、金絲雀發布等。</p></li><li><p><strong>安全性</strong>：透過強化身份驗證、授權控制和加密通信，Istio 確保微服務之間的通信是安全的。</p></li><li><p><strong>可觀察性</strong>：它自動收集微服務間的網路流量數據，並生成詳細的日誌、度量和追蹤資料，方便監控和排查問題。</p></li><li><p><strong>策略管理</strong>：Istio 可以應用不同的策略，如速率限制 (Rate Limiting)、配額控制、重試等，來保護和管理服務。</p></li></ol><h2 id="Istio-的架構："><a href="#Istio-的架構：" class="headerlink" title="Istio 的架構："></a>Istio 的架構：</h2><p>Istio 主要由兩個核心組件構成：</p><ul><li><strong>Data Plane</strong> (資料平面)：使用 Envoy 代理，攔截並管理所有服務之間的網路流量。</li><li><strong>Control Plane</strong> (控制平面)：管理和配置代理，並處理流量的路由策略和安全政策。</li></ul><p>總的來說，Istio 是專為微服務架構設計的，能夠提升應用的可觀察性、安全性和可靠性，是現代分散式系統中的重要工具之一。</p><h1 id="Anthos-Service-Mesh-的關鍵優勢"><a href="#Anthos-Service-Mesh-的關鍵優勢" class="headerlink" title="Anthos Service Mesh 的關鍵優勢"></a>Anthos Service Mesh 的關鍵優勢</h1><h2 id="可觀察性"><a href="#可觀察性" class="headerlink" title="可觀察性"></a>可觀察性</h2><p><img src="https://hackmd.io/_uploads/Syw3GIrhR.png" alt="image"></p><p>Anthos Service Mesh 提供了豐富的監控和分析工具，可以讓企業深入了解微服務的運行狀況。透過服務網格的拓撲圖、請求流量分析和錯誤率統計，運維人員可以快速發現並解決潛在問題，從而提高整體系統的穩定性。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p><img src="https://hackmd.io/_uploads/H1jizLB20.png" alt="image"></p><p>在現代企業應用中，安全性始終是重中之重。Anthos Service Mesh 自動啟用 mTLS 加密，確保所有微服務之間的通信都是安全的。此外，它還支持基於策略的訪問控制，允許企業精細化地管理每個服務的訪問權限。</p><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><p><img src="https://hackmd.io/_uploads/Sy0nfLBnC.png" alt="image"></p><p>Anthos Service Mesh 支持多種流量控制策略，如藍綠部署和金絲雀發布，這使得企業能夠在不影響用戶體驗的情況下安全地推出新版本。這些功能讓開發和運維團隊能夠更靈活地管理應用的升級過程。</p><h2 id="跨集群支持"><a href="#跨集群支持" class="headerlink" title="跨集群支持"></a>跨集群支持</h2><p><img src="https://hackmd.io/_uploads/H1kJm8H2C.png" alt="image"></p><p>Anthos Service Mesh 能夠在多個 GKE 集群之間提供一致的服務網格管理，支持跨區域的服務部署和高可用性。這意味著即使某一個集群發生故障，其他集群依然能夠承擔流量，確保應用的連續性。</p><h1 id="如何使用-Anthos-Service-Mesh"><a href="#如何使用-Anthos-Service-Mesh" class="headerlink" title="如何使用 Anthos Service Mesh"></a>如何使用 Anthos Service Mesh</h1><p>可以進入google 官方文件查看入門導覽教學<br><img src="https://hackmd.io/_uploads/HklMXIH3C.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/kubernetes-engine/enterprise/docs/learn/scalable-apps?_ga=2.238410240.1494422275.1592695936-1900483699.1589728994&;_gac=1.91806056.1592697064.Cj0KCQjwoaz3BRDnARIsAF1RfLd1AG6iP5E0DlpdRVXB9SYvt2H_ML7e7Jg99akGivXs32s4NfgQge8aAmUxEALw_wcB">https://cloud.google.com/kubernetes-engine/enterprise/docs/learn/scalable-apps?_ga=2.238410240.1494422275.1592695936-1900483699.1589728994&amp;%3B_gac=1.91806056.1592697064.Cj0KCQjwoaz3BRDnARIsAF1RfLd1AG6iP5E0DlpdRVXB9SYvt2H_ML7e7Jg99akGivXs32s4NfgQge8aAmUxEALw_wcB</a></p></blockquote><p>還有有以下介紹資源<br><img src="https://hackmd.io/_uploads/rJ-v7LH2A.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/anthos/service-mesh?hl=zh-tw">https://cloud.google.com/anthos/service-mesh?hl=zh-tw</a></p></blockquote><h2 id="部署過程"><a href="#部署過程" class="headerlink" title="部署過程"></a>部署過程</h2><p>首先，您需要在 GKE 上啟用並配置 Anthos Service Mesh。這通常涉及到設置 Istio 控制平面和數據平面，並將其集成到您的現有 Kubernetes 集群中。</p><h2 id="服務發現與流量路由"><a href="#服務發現與流量路由" class="headerlink" title="服務發現與流量路由"></a>服務發現與流量路由</h2><p>一旦 Anthos Service Mesh 部署完成，您可以使用它來進行跨集群的服務發現與流量管理。這允許您將流量根據需求分配到不同的集群，並確保服務始終可用。</p><h2 id="監控與可觀察性"><a href="#監控與可觀察性" class="headerlink" title="監控與可觀察性"></a>監控與可觀察性</h2><p>Anthos Service Mesh 提供了豐富的監控工具，讓您可以實時查看微服務的運行狀況。您可以設置服務級別目標（SLOs），並根據這些指標來監控服務的健康狀況，及時發現並解決潛在問題。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Anthos Service Mesh 是一個功能強大且靈活的微服務管理解決方案，特別適合那些需要管理複雜微服務架構的企業。它的核心優勢在於其卓越的可觀察性、安全性和流量管理能力，讓企業能夠更輕鬆地管理和擴展其應用。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/Anthos/">Anthos</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/05/GCP-%E5%BE%AE%E6%9C%8D%E5%8B%99%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Anthos-Service-Mesh/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>考救生員訓練紀錄 - 報名體育署救生檢定</title>
      <link>https://gahgah147.github.io/2024/09/03/%E8%80%83%E6%95%91%E7%94%9F%E5%93%A1%E8%A8%93%E7%B7%B4%E7%B4%80%E9%8C%84-%E5%A0%B1%E5%90%8D%E9%AB%94%E8%82%B2%E7%BD%B2%E6%95%91%E7%94%9F%E6%AA%A2%E5%AE%9A/</link>
      <guid>https://gahgah147.github.io/2024/09/03/%E8%80%83%E6%95%91%E7%94%9F%E5%93%A1%E8%A8%93%E7%B7%B4%E7%B4%80%E9%8C%84-%E5%A0%B1%E5%90%8D%E9%AB%94%E8%82%B2%E7%BD%B2%E6%95%91%E7%94%9F%E6%AA%A2%E5%AE%9A/</guid>
      <pubDate>Tue, 03 Sep 2024 07:37:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BkkkvN4hR.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://hackmd.io/_uploads/BkkkvN4hR.png" alt="image"></p><p>繼上一篇文章 <a href="https://gahgah147.github.io/2024/07/26/%E6%88%91%E6%83%B3%E8%A6%81%E5%86%8D%E5%8E%BB%E7%95%B6%E6%95%91%E7%94%9F%E5%93%A1/?highlight=%E6%88%91%E6%83%B3%E8%A6%81%E5%86%8D%E5%8E%BB%E7%95%B6%E6%95%91%E7%94%9F%E5%93%A1">我想要再去當救生員</a>之後，順利過完了2週的訓練，其實覺得還蠻充實的，而且還有三天的海訓在福隆，感覺特別充實當天在旁邊還有音樂季耶，感覺夏天的海邊就是很棒，結訓之後就是要準備報名體育署的檢定了。</p><h1 id="線上報名檢定流程"><a href="#線上報名檢定流程" class="headerlink" title="線上報名檢定流程"></a>線上報名檢定流程</h1><p>報名流程教學網址如下:<br><img src="https://hackmd.io/_uploads/SJjduN2qR.png" alt="image"></p><blockquote><p><a href="https://isports.sa.gov.tw/apps/Fessay.aspx?SYS=LGM&MENU_CD=M10&ITEM_CD=T15&MENU_PRG_CD=3&ITEM_PRG_CD=6">https://isports.sa.gov.tw/apps/Fessay.aspx?SYS=LGM&amp;MENU_CD=M10&amp;ITEM_CD=T15&amp;MENU_PRG_CD=3&amp;ITEM_PRG_CD=6</a></p></blockquote><p>首先新進入教育部體育署救生員報名網頁</p><p>會員註冊畫面如下<br><img src="https://hackmd.io/_uploads/B187ENnqA.png" alt="image"></p><blockquote><p><a href="https://isports.sa.gov.tw/Apps/MEM/MEM01/MEM0100M_01V1.aspx?SYS=LGM">https://isports.sa.gov.tw/Apps/MEM/MEM01/MEM0100M_01V1.aspx?SYS=LGM</a></p></blockquote><p><img src="https://hackmd.io/_uploads/BJY97VhcA.png" alt="image"><br><img src="https://hackmd.io/_uploads/ryzb4Eh9A.png" alt="image"></p><p>註冊完成後登入點選<strong>救生員證書檢定報名</strong><br><img src="https://hackmd.io/_uploads/rkcOENh9R.png" alt="image"></p><p>在這邊可以點選擇場次開始選擇<br><img src="https://hackmd.io/_uploads/Bya0NNhc0.png" alt="image"></p><p>選取檢定場次，這邊可以找一下離家近的場次<br><img src="https://hackmd.io/_uploads/H1kGrNh5R.png" alt="image"></p><p>我這邊選的是國立臺灣科技大學的場次<br><img src="https://hackmd.io/_uploads/HkLp8Vhc0.png" alt="image"></p><p>報名資格我選的是訓練證明，因為是最近完成新訓取得的證明</p><p>設定可服務地點，我這邊選擇新北市跟台北市<br><img src="https://hackmd.io/_uploads/rynNP43qR.png" alt="image"></p><p>接下來填寫報名資料<br><img src="https://hackmd.io/_uploads/SyqgFE39A.png" alt="image"></p><p>接下來是提供相關證明文件<br><img src="https://hackmd.io/_uploads/HyHFYV25A.png" alt="image"></p><p>這邊有些資料要填寫像是</p><ul><li>身分證正反面</li><li>警察刑事紀錄證明</li><li>健康諮詢表</li><li>證照大頭照</li></ul><h1 id="申請良民證"><a href="#申請良民證" class="headerlink" title="申請良民證"></a>申請良民證</h1><p>這邊要先去警察局辦良民證，可以先找附近進的警察局線上辦好，再找時間去現場領。</p><p>可以進入以下頁面警察刑事紀錄證明網站申請<br><img src="https://hackmd.io/_uploads/rJkfr4E20.png" alt="image"></p><blockquote><p><a href="https://eli.npa.gov.tw/E7WebO/index01.jsp">https://eli.npa.gov.tw/E7WebO/index01.jsp</a></p></blockquote><p>要滑下來到這邊按申辦<br><img src="https://hackmd.io/_uploads/H16jB4VnR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HJGCSNNhA.png" alt="image"></p><p>在這邊建議選網路申請臨櫃領證，因為我用另外一邊MyData覺得不好用，會一直重複跳不出去。</p><h1 id="考前準備"><a href="#考前準備" class="headerlink" title="考前準備"></a>考前準備</h1><h2 id="救生員題庫"><a href="#救生員題庫" class="headerlink" title="救生員題庫"></a>救生員題庫</h2><p>在檢定資訊 &gt; 救生員題庫這邊可以下載題庫練習<br><img src="https://hackmd.io/_uploads/SkTIOEE3C.png" alt="image"></p><h2 id="檢定科目示範影片區"><a href="#檢定科目示範影片區" class="headerlink" title="檢定科目示範影片區"></a>檢定科目示範影片區</h2><p>在檢定資訊 &gt; 檢定科目示範影片區這邊可以看到術科項目<br><img src="https://hackmd.io/_uploads/BkWVKVVhR.png" alt="image"></p><blockquote><p><a href="https://isports.sa.gov.tw/apps/FvideoList.aspx?SYS=LGM&MENU_CD=M10&ITEM_CD=T08&MENU_PRG_CD=3&ITEM_PRG_CD=4">https://isports.sa.gov.tw/apps/FvideoList.aspx?SYS=LGM&amp;MENU_CD=M10&amp;ITEM_CD=T08&amp;MENU_PRG_CD=3&amp;ITEM_PRG_CD=4</a></p></blockquote><p>有以下項目:基本能力、救援能力、綜合評定、急救能力測驗、救援器材運用</p><h3 id="基本能力"><a href="#基本能力" class="headerlink" title="基本能力"></a>基本能力</h3><h4 id="200公尺救生四式"><a href="#200公尺救生四式" class="headerlink" title="200公尺救生四式"></a>200公尺救生四式</h4><p><img src="https://hackmd.io/_uploads/B1yPoEV2R.png" alt="image"><br><a href="https://youtu.be/sEQtR8LEYaE">https://youtu.be/sEQtR8LEYaE</a></p><h4 id="踩水"><a href="#踩水" class="headerlink" title="踩水"></a>踩水</h4><p><img src="https://hackmd.io/_uploads/SywHsN4nR.png" alt="image"><br><a href="https://youtu.be/1QMk_Y7lrys">https://youtu.be/1QMk_Y7lrys</a></p><h3 id="救援能力"><a href="#救援能力" class="headerlink" title="救援能力"></a>救援能力</h3><h4 id="20公尺潛泳"><a href="#20公尺潛泳" class="headerlink" title="20公尺潛泳"></a>20公尺潛泳</h4><p><img src="https://hackmd.io/_uploads/SyPUsVNhC.png" alt="image"><br><a href="https://youtu.be/2zGyJD20fD4">https://youtu.be/2zGyJD20fD4</a></p><h4 id="25公尺拖帶假人"><a href="#25公尺拖帶假人" class="headerlink" title="25公尺拖帶假人"></a>25公尺拖帶假人</h4><p><img src="https://hackmd.io/_uploads/BkgSiN42A.png" alt="image"><br><a href="https://youtu.be/AgwEw73VOrk">https://youtu.be/AgwEw73VOrk</a></p><h3 id="綜合評定"><a href="#綜合評定" class="headerlink" title="綜合評定"></a>綜合評定</h3><h4 id="模擬救溺-項目一"><a href="#模擬救溺-項目一" class="headerlink" title="模擬救溺 項目一"></a>模擬救溺 項目一</h4><p><img src="https://hackmd.io/_uploads/rJ2OcEVnC.png" alt="image"><br><a href="https://youtu.be/SfbAescgqJQ">https://youtu.be/SfbAescgqJQ</a></p><h4 id="模擬救溺-項目二"><a href="#模擬救溺-項目二" class="headerlink" title="模擬救溺 項目二"></a>模擬救溺 項目二</h4><p><img src="https://hackmd.io/_uploads/HyFecNV2C.png" alt="image"><br><a href="https://youtu.be/aSSLUgJemRE">https://youtu.be/aSSLUgJemRE</a></p><h4 id="模擬救溺-項目三"><a href="#模擬救溺-項目三" class="headerlink" title="模擬救溺 項目三"></a>模擬救溺 項目三</h4><p><img src="https://hackmd.io/_uploads/HJWZ5E4n0.png" alt="image"><br><a href="https://youtu.be/aKVrXbq0P9g">https://youtu.be/aKVrXbq0P9g</a></p><h3 id="急救能力測驗"><a href="#急救能力測驗" class="headerlink" title="急救能力測驗"></a>急救能力測驗</h3><h4 id="心肺復甦術及自動體外心臟電擊去顫器"><a href="#心肺復甦術及自動體外心臟電擊去顫器" class="headerlink" title="心肺復甦術及自動體外心臟電擊去顫器"></a>心肺復甦術及自動體外心臟電擊去顫器</h4><p><img src="https://hackmd.io/_uploads/rJeNqEV3C.png" alt="image"></p><p><a href="https://youtu.be/A_TOTWW_Gz8">https://youtu.be/A_TOTWW_Gz8</a></p><h4 id="異物哽塞含復甦姿勢"><a href="#異物哽塞含復甦姿勢" class="headerlink" title="異物哽塞含復甦姿勢"></a>異物哽塞含復甦姿勢</h4><p><img src="https://hackmd.io/_uploads/SyTS54E3R.png" alt="image"><br><a href="https://youtu.be/Cg9Q1ecb2rk">https://youtu.be/Cg9Q1ecb2rk</a></p><h4 id="長背板救援"><a href="#長背板救援" class="headerlink" title="長背板救援"></a>長背板救援</h4><p><img src="https://hackmd.io/_uploads/H1ZEo4EnC.png" alt="image"><br><a href="https://youtu.be/sMmV6eiuI_E">https://youtu.be/sMmV6eiuI_E</a></p><h3 id="救援器材運用"><a href="#救援器材運用" class="headerlink" title="救援器材運用"></a>救援器材運用</h3><h4 id="拋繩救援"><a href="#拋繩救援" class="headerlink" title="拋繩救援"></a>拋繩救援</h4><p><img src="https://hackmd.io/_uploads/HJFwoN4hA.png" alt="image"><br><a href="https://youtu.be/j9cFR6K4CzM">https://youtu.be/j9cFR6K4CzM</a></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>後來終於是在9月3號完成報名繳費了，我這次是報名9月22號的考試，考試地點是在台科大，希望之後考試一切順利，可以順利拿到體育署的救生員證照。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E6%95%91%E7%94%9F%E5%93%A1/">救生員</category>
      
      
      <comments>https://gahgah147.github.io/2024/09/03/%E8%80%83%E6%95%91%E7%94%9F%E5%93%A1%E8%A8%93%E7%B7%B4%E7%B4%80%E9%8C%84-%E5%A0%B1%E5%90%8D%E9%AB%94%E8%82%B2%E7%BD%B2%E6%95%91%E7%94%9F%E6%AA%A2%E5%AE%9A/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - VPC Network 虛擬私有雲</title>
      <link>https://gahgah147.github.io/2024/08/30/GCP-VPC-Network-%E8%99%9B%E6%93%AC%E7%A7%81%E6%9C%89%E9%9B%B2/</link>
      <guid>https://gahgah147.github.io/2024/08/30/GCP-VPC-Network-%E8%99%9B%E6%93%AC%E7%A7%81%E6%9C%89%E9%9B%B2/</guid>
      <pubDate>Fri, 30 Aug 2024 09:28:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HkB4ZMyhR.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;什麼是-VPC-Network&quot;&gt;&lt;a href=&quot;#什麼是-VPC-Network&quot; class=&quot;headerlin</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/HkB4ZMyhR.png" alt="image"></p><h1 id="什麼是-VPC-Network"><a href="#什麼是-VPC-Network" class="headerlink" title="什麼是 VPC Network ?"></a>什麼是 VPC Network ?</h1><p><img src="https://hackmd.io/_uploads/Syll6bJnA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/vpc?hl=zh-TW">https://cloud.google.com/vpc?hl=zh-TW</a></p></blockquote><p>Google Cloud Platform (GCP) 提供的虛擬私有雲（Virtual Private Cloud，VPC）是用來管理和控制網路資源的核心工具。VPC 是一個邏輯隔離的網路環境，允許用戶在 GCP 中創建和管理他們的網路基礎架構。透過 VPC，您可以靈活地配置子網路、路由、網路安全規則以及多個區域內的網路流量。</p><h2 id="主要功能與特性"><a href="#主要功能與特性" class="headerlink" title="主要功能與特性"></a>主要功能與特性</h2><h3 id="1-全球範圍的網路"><a href="#1-全球範圍的網路" class="headerlink" title="1. 全球範圍的網路"></a>1. <strong>全球範圍的網路</strong></h3><p>GCP VPC 是一個全球性虛擬網路，允許您在全球範圍內創建子網路並管理其資源。無論是將資源分佈在一個區域或是多個區域，VPC 都能確保流量在 Google 的全球骨幹網路上快速且安全地傳輸，減少延遲並提升性能。</p><h3 id="2-子網路-Subnet-和路由"><a href="#2-子網路-Subnet-和路由" class="headerlink" title="2. 子網路 (Subnet) 和路由"></a>2. <strong>子網路 (Subnet) 和路由</strong></h3><p>VPC 支持區域化的子網路配置，讓用戶能夠根據需要在不同的區域中劃分子網路。每個子網路都可以與一個或多個區域相關聯，並通過靈活的路由策略來管理內部和外部的網路流量。</p><h3 id="3-防火牆規則"><a href="#3-防火牆規則" class="headerlink" title="3. 防火牆規則"></a>3. <strong>防火牆規則</strong></h3><p>GCP VPC 提供細緻的防火牆規則，允許您控制進出 VPC 的流量。這些規則可以根據 IP 地址、端口、協議等條件來設定，確保網路的安全性和隔離性。您可以使用這些規則來保護網路中的資源，並根據業務需求靈活調整。</p><h3 id="4-VPC-內的私有-IP-與外部-IP"><a href="#4-VPC-內的私有-IP-與外部-IP" class="headerlink" title="4. VPC 內的私有 IP 與外部 IP"></a>4. <strong>VPC 內的私有 IP 與外部 IP</strong></h3><p>在 VPC 中，您可以分配私有 IP 地址給虛擬機器，這些 IP 地址僅在 VPC 內部使用。此外，您也可以為需要對外連線的資源分配外部 IP 地址。VPC 支持使用 NAT (Network Address Translation) 來管理私有 IP 的外部訪問，確保網路資源的安全性。</p><h3 id="5-跨項目和跨區域的互聯-VPC-Peering"><a href="#5-跨項目和跨區域的互聯-VPC-Peering" class="headerlink" title="5. 跨項目和跨區域的互聯 (VPC Peering)"></a>5. <strong>跨項目和跨區域的互聯 (VPC Peering)</strong></h3><p>GCP VPC 提供了跨項目和跨區域的 VPC Peering 功能，允許不同的 VPC 之間建立私有網路連接。這使得跨不同項目或區域的資源可以無縫地通信，同時保持網路的安全性和隔離性。</p><h3 id="6-Shared-VPC"><a href="#6-Shared-VPC" class="headerlink" title="6. Shared VPC"></a>6. <strong>Shared VPC</strong></h3><p>透過 Shared VPC 功能，您可以在組織內部跨項目共享一個 VPC。這樣，您可以集中管理網路資源，而不需要在每個項目中單獨配置 VPC。Shared VPC 使得多個團隊能夠在同一個 VPC 內安全地協作。</p><h2 id="GCP-VPC-的應用場景"><a href="#GCP-VPC-的應用場景" class="headerlink" title="GCP VPC 的應用場景"></a>GCP VPC 的應用場景</h2><ol><li><p><strong>企業級網路設計</strong>：大型企業可以利用 GCP VPC 創建全球範圍的網路架構，並透過細緻的子網路和路由配置，實現高度可擴展和安全的網路設計。</p></li><li><p><strong>跨區域應用程序</strong>：對於需要在多個地理區域運行的應用程序，VPC 提供了低延遲、高性能的全球網路環境，確保用戶無論身處何地，都能獲得一致的應用體驗。</p></li><li><p><strong>混合雲連接</strong>：透過 VPC 和 Cloud VPN 或 Cloud Interconnect 的結合，企業可以將本地數據中心與 GCP 的 VPC 安全地連接起來，實現混合雲部署，保留現有的投資並提升靈活性。</p></li><li><p><strong>多租戶隔離</strong>：利用 GCP VPC 的防火牆規則和 VPC Peering 功能，企業可以在單一網路環境中隔離不同客戶或部門，確保數據和應用程序的安全性。</p></li></ol><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>GCP VPC 是 Google Cloud 提供的強大網路基礎設施，允許用戶靈活配置和管理全球範圍內的網路資源。無論是單一區域的部署還是跨區域、跨項目的網路架構，VPC 都能夠提供高性能、安全且可擴展的解決方案。如果您的企業正在尋求一個能夠支持多樣化網路需求的雲端平台，GCP VPC 無疑是一個值得考慮的選擇。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/30/GCP-VPC-Network-%E8%99%9B%E6%93%AC%E7%A7%81%E6%9C%89%E9%9B%B2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Anthos 混合雲與多雲管理的工具</title>
      <link>https://gahgah147.github.io/2024/08/29/GCP-Anthos-%E6%B7%B7%E5%90%88%E9%9B%B2%E8%88%87%E5%A4%9A%E9%9B%B2%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7/</link>
      <guid>https://gahgah147.github.io/2024/08/29/GCP-Anthos-%E6%B7%B7%E5%90%88%E9%9B%B2%E8%88%87%E5%A4%9A%E9%9B%B2%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Thu, 29 Aug 2024 08:54:54 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;什麼是-Google-Cloud-Anthos？&quot;&gt;&lt;a href=&quot;#什麼是-Google-Cloud-Anthos？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 Google Cloud Anthos？&quot;&gt;&lt;/a&gt;什麼是 Google Clo</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="什麼是-Google-Cloud-Anthos？"><a href="#什麼是-Google-Cloud-Anthos？" class="headerlink" title="什麼是 Google Cloud Anthos？"></a>什麼是 Google Cloud Anthos？</h1><p><img src="https://hackmd.io/_uploads/BkbFQ3pj0.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/migrate/anthos?hl=zh-tw">https://cloud.google.com/migrate/anthos?hl=zh-tw</a></p></blockquote><p>Google Cloud Anthos 是 Google 雲端平台（GCP）推出的現代化應用程式管理解決方案。Anthos 不僅僅是一個平台，它提供了一整套工具和服務，讓企業能夠在混合雲與多雲環境中更有效率地管理、部署和運行應用程式。無論應用程式部署在本地數據中心、GCP 還是其他雲端服務提供商，Anthos 都能夠提供一致性的運營和管理。</p><p>以下是官方說明影片<br><a href="https://youtu.be/1t6rHa2icqM">https://youtu.be/1t6rHa2icqM</a></p><p>這邊是官方的說明文件<br><img src="https://hackmd.io/_uploads/rkXFZ2Ts0.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/anthos/?hl=zh_tw">https://cloud.google.com/anthos/?hl=zh_tw</a></p></blockquote><hr><h2 id="簡化翻新作業"><a href="#簡化翻新作業" class="headerlink" title="簡化翻新作業"></a>簡化翻新作業</h2><p><img src="https://hackmd.io/_uploads/H1URQnasR.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/migrate/anthos?hl=zh-tw">https://cloud.google.com/migrate/anthos?hl=zh-tw</a></p></blockquote><p>Migrate for Anthos and GKE 讓您能夠快速且輕鬆地將傳統應用程式從虛擬機器 (VM) 遷移到原生容器中，進行應用程式翻新。我們獨特的自動化處理方法能夠自動擷取 VM 中的重要應用程式元素，並將這些元素無縫地插入到 Google Kubernetes Engine (GKE) 或 Anthos 叢集中的容器，從而消除容器不需要的 VM 層（例如訪客作業系統）的負擔。</p><p>這種方法能大幅降低手動執行應用程式翻新專案所需的成本和人力。完成遷移後，您的團隊可以在新的平台上使用相同的服務、政策和方法，以更高效且更具成本效益的方式部署、操作及維護現有的應用程式。</p><hr><h2 id="規劃理想的遷移過程"><a href="#規劃理想的遷移過程" class="headerlink" title="規劃理想的遷移過程"></a>規劃理想的遷移過程</h2><p><img src="https://hackmd.io/_uploads/ByiHU26s0.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/migrate/anthos?hl=zh-tw">https://cloud.google.com/migrate/anthos?hl=zh-tw</a></p></blockquote><p>大多數數位轉型都需要運用不同策略的組合。對於可受益於容器的工作負載，Migrate for Anthos 和 GKE 提供了快速順暢的翻新途徑，而其他更適合做為 VM 的工作負載，則只要使用 Migrate for Compute Engine 照原樣遷移，並利用與 GKE 整合的虛擬私人雲端 (VPC) 網路即可。因此，您不必受限於現有的基礎架構或單一遷移路徑。Google 可讓您根據需求，在您偏好的位置執行工作負載。</p><p>如要瞭解詳情，請觀看這部短片：<a href="https://youtu.be/1t6rHa2icqM">安心遷移至 Google Cloud</a></p><hr><h2 id="輕鬆升級為容器"><a href="#輕鬆升級為容器" class="headerlink" title="輕鬆升級為容器"></a>輕鬆升級為容器</h2><p><img src="https://hackmd.io/_uploads/B1MDLh6oA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/migrate/anthos?hl=zh-tw">https://cloud.google.com/migrate/anthos?hl=zh-tw</a></p></blockquote><p>有些工作負載很容易就會被 IT 人員註記為「無法升級」，但 Migrate for Anthos 可免除一道又一道的人工作業，因此即使是小型的 IT 團隊也能將這些工作負載遷移並翻新。您不必重寫或重新建構應用程式，就能將現有應用程式從伺服器和 VM 自動擷取至容器中，以原生方式運行，進而消除過去阻礙企業升級至容器的複雜性和知識差距。</p><p>閱讀網誌，深入瞭解使用 <a href="https://cloud.google.com/migrate/anthos?hl=zh_tw">Migrate for Anthos 進行容器化的所有優點</a></p><hr><h2 id="迅速發揮現代化的優點"><a href="#迅速發揮現代化的優點" class="headerlink" title="迅速發揮現代化的優點"></a>迅速發揮現代化的優點</h2><p><img src="https://hackmd.io/_uploads/H13_836oR.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/migrate/anthos?hl=zh-tw">https://cloud.google.com/migrate/anthos?hl=zh-tw</a></p></blockquote><p>加速遷移及採用新型平台，可讓企業以更有效率的方式運作，並在現有和新開發的應用程式中使用經過整合的政策、管理方式和技術。此外，您也能重新分配原先須用於維護舊有環境的預算，藉此解決翻新及開發新應用程式所需的額外資金的問題。</p><hr><h2 id="加速採用-Day-2-作業"><a href="#加速採用-Day-2-作業" class="headerlink" title="加速採用 Day 2 作業"></a>加速採用 Day 2 作業</h2><p><img src="https://hackmd.io/_uploads/SkOFUnToC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/migrate/anthos?hl=zh-tw">https://cloud.google.com/migrate/anthos?hl=zh-tw</a></p></blockquote><p>針對「第二天作業」(Day-2 Operation)，您可以切換至新型的持續整合 (CI)&#x2F;持續推送軟體更新 (CD) 管道、以映像檔為基礎的管理方式，以及預期狀態設定，藉此節省與維護、修補及更新 VM 和實體伺服器相關的人力和費用。此外，您也能加速採用新型服務，例如 Anthos 服務網格、Anthos Config Management、角色型存取權控管 (RBAC) 功能和 Cloud Logging 等，藉此輕鬆翻新 IT 藍圖配置，進而整合已遷移和新開發應用程式的政策強制執行作業及管理方式。</p><hr><h1 id="Anthos-的主要功能"><a href="#Anthos-的主要功能" class="headerlink" title="Anthos 的主要功能"></a>Anthos 的主要功能</h1><p><img src="https://hackmd.io/_uploads/H1URQnasR.png" alt="image"></p><ol><li><p><strong>跨雲端管理</strong>：Anthos 允許用戶將應用程式部署在不同的雲端環境中（如 AWS、Azure、On-Premise），同時保持一致的管理界面與運營流程。這樣，企業可以在不同雲端供應商之間靈活移動工作負載，而不會受到平台鎖定的影響。</p></li><li><p><strong>Kubernetes 的強大支持</strong>：Anthos 建基於 Kubernetes，使其能夠無縫整合現代容器化應用程式管理。透過 Anthos，企業可以更輕鬆地在不同的基礎架構上部署和管理 Kubernetes 集群。</p></li><li><p><strong>服務網格與安全性</strong>：Anthos Service Mesh 提供了強大的服務間通信管理與監控功能，確保應用程式之間的通信安全且高效。此外，Anthos 亦提供了強大的政策管理功能，讓 IT 管理員能夠制定與強制執行一致的安全政策。</p></li><li><p><strong>開發者友好</strong>：Anthos 支持 CI&#x2F;CD 流程，讓開發者能夠快速迭代和部署應用程式。借助於其與 Google Cloud Build、Cloud Run 的整合，開發者可以更快地將新功能推向市場。</p></li></ol><h1 id="Anthos-的應用場景"><a href="#Anthos-的應用場景" class="headerlink" title="Anthos 的應用場景"></a>Anthos 的應用場景</h1><p><img src="https://hackmd.io/_uploads/B1MDLh6oA.png" alt="image"></p><ol><li><p><strong>混合雲策略</strong>：企業可以使用 Anthos 在本地數據中心和雲端之間實現應用程式的無縫移動，確保數據保護及合規性同時享受雲端靈活性。</p></li><li><p><strong>多雲管理</strong>：對於運營在多個雲端提供商上的企業，Anthos 能夠提供統一的管理平台，減少複雜性並提升運營效率。</p></li><li><p><strong>現代化應用程式轉型</strong>：透過將傳統應用程式容器化並部署在 Kubernetes 集群中，Anthos 幫助企業實現應用程式的現代化轉型，提升應用程式的可移植性與可擴展性。</p></li></ol><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p><img src="https://hackmd.io/_uploads/H13_836oR.png" alt="image"><br>Google Cloud Anthos 是一個強大的工具集，能夠為企業提供在混合雲與多雲環境中一致且高效的應用程式管理體驗。無論企業是希望推動數位轉型，還是簡化現有的多雲策略，Anthos 都能夠提供支持，確保企業能夠在不犧牲靈活性或安全性的情況下，快速適應市場需求。</p><p>Anthos 的出現標誌著企業雲端管理的新時代，為混合雲與多雲環境提供了無與倫比的靈活性和控制能力。如果您的企業正考慮擴展雲端戰略，或是想要在不同雲端環境中保持一致性，那麼 Google Cloud Anthos 無疑是一個值得考慮的選擇。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/Anthis/">Anthis</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/29/GCP-Anthos-%E6%B7%B7%E5%90%88%E9%9B%B2%E8%88%87%E5%A4%9A%E9%9B%B2%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TFT聯盟戰棋 - 陣容介紹喚蜜師法師維迦</title>
      <link>https://gahgah147.github.io/2024/08/29/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%A3%8B-%E9%99%A3%E5%AE%B9%E4%BB%8B%E7%B4%B9%E5%96%9A%E8%9C%9C%E5%B8%AB%E6%B3%95%E5%B8%AB%E7%B6%AD%E8%BF%A6/</link>
      <guid>https://gahgah147.github.io/2024/08/29/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%A3%8B-%E9%99%A3%E5%AE%B9%E4%BB%8B%E7%B4%B9%E5%96%9A%E8%9C%9C%E5%B8%AB%E6%B3%95%E5%B8%AB%E7%B6%AD%E8%BF%A6/</guid>
      <pubDate>Thu, 29 Aug 2024 07:10:27 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;TFT聯盟戰旗-陣容介紹喚蜜師、法師維迦&quot;&gt;&lt;a href=&quot;#TFT聯盟戰旗-陣容介紹喚蜜師、法師維迦&quot; class=&quot;headerlink&quot; title=&quot;TFT聯盟戰旗 - 陣容介紹喚蜜師、法師維迦&quot;&gt;&lt;/a&gt;TFT聯盟戰旗 - 陣容介紹喚蜜師、法師維迦&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="TFT聯盟戰旗-陣容介紹喚蜜師、法師維迦"><a href="#TFT聯盟戰旗-陣容介紹喚蜜師、法師維迦" class="headerlink" title="TFT聯盟戰旗 - 陣容介紹喚蜜師、法師維迦"></a>TFT聯盟戰旗 - 陣容介紹喚蜜師、法師維迦</h1><p><img src="https://hackmd.io/_uploads/Hkm2FqpsA.png" alt="image"></p><p>今天要跟大家介紹的陣容是喚蜜師、法師維迦整體下來有輸出有坦有回血，且成長很平緩，偏向賭狗陣容</p><p><img src="https://hackmd.io/_uploads/rklUTw6i0.png" alt="TFT_OPGG_Builder"></p><p><img src="https://hackmd.io/_uploads/r1QSn9psR.png" alt="image"></p><h1 id="陣容組成"><a href="#陣容組成" class="headerlink" title="陣容組成"></a>陣容組成</h1><h2 id="布里茲"><a href="#布里茲" class="headerlink" title="布里茲"></a>布里茲</h2><p><img src="https://hackmd.io/_uploads/SkZk9cpo0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/ry5jjcaoC.png" alt="image">蜂蜜屏障<br>獲得298&#x2F;401&#x2F;566(Ability powerHealth)護盾，持續6秒。</p><h2 id="努努"><a href="#努努" class="headerlink" title="努努"></a>努努</h2><p><img src="https://hackmd.io/_uploads/S1oxq9Ts0.png" alt="image"><br><img src="https://hackmd.io/_uploads/Bknl2c6iR.png" alt="image">黏黏嚙咬<br>嚙咬目標，治療250&#x2F;300&#x2F;350(Ability power)生命，造成200&#x2F;300&#x2F;450(Ability power)魔法傷害並附加凍骨效果3秒。<br>凍骨：降低攻速 20%</p><h2 id="維迦"><a href="#維迦" class="headerlink" title="維迦"></a>維迦</h2><p><img src="https://hackmd.io/_uploads/rkfAKcpoA.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Hkev29Tj0.png" alt="image">蜂王的審判<br>被動：每購買一個護符，增加3魔法攻擊。<br>主動：對目標造成240&#x2F;330&#x2F;475(Ability power)魔法傷害。</p><h2 id="薇可絲"><a href="#薇可絲" class="headerlink" title="薇可絲"></a>薇可絲</h2><p><img src="https://hackmd.io/_uploads/BkJWTqTiR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SyVgpcpiA.png" alt="image">個人舒適圈<br>獲得380&#x2F;430&#x2F;480 (Ability power)護盾，持續4秒，每有一名敵軍瞄準薇可絲便增加5%。護盾失效時，對2格內的敵軍造成80&#x2F;120&#x2F;200 (Ability power)魔法傷害。</p><h2 id="希格斯"><a href="#希格斯" class="headerlink" title="希格斯"></a>希格斯</h2><p><img src="https://hackmd.io/_uploads/HJlXq5To0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/r1pFh96s0.png" alt="image">彈跳蜜蜂<br>朝最遠的敵軍投擲一枚彈跳炸彈。炸彈會在命中第一名敵軍時爆炸，對目標造成200&#x2F;300&#x2F;450 (Ability power)魔法傷害，並對附近所有敵軍造成100&#x2F;150&#x2F;225 (Ability power)魔法傷害。</p><h2 id="佳里歐"><a href="#佳里歐" class="headerlink" title="佳里歐"></a>佳里歐</h2><p><img src="https://hackmd.io/_uploads/SyhE5cpjA.png" alt="image"><br><img src="https://hackmd.io/_uploads/SkquicpsR.png" alt="image">匯聚重擊<br>使承受的傷害降低20&#x2F;25&#x2F;30 (Ability power)，持續4秒。發射兩發魔法彈，魔法彈會在3格內距離最遠的敵軍處匯集，使其暈眩1.25&#x2F;1.25&#x2F;1.5秒。每發魔法彈對路徑上的敵軍造成50&#x2F;75&#x2F;115 (Ability power)魔法傷害。<br>法師施放會瞄準不同的敵軍。</p><h2 id="納米"><a href="#納米" class="headerlink" title="納米"></a>納米</h2><p><img src="https://hackmd.io/_uploads/H1Yr99Tj0.png" alt="image"><br><img src="https://hackmd.io/_uploads/Hk1Eiqpi0.png" alt="image">利維坦<br>朝範圍內最多敵軍聚集處發射泡泡，造成240&#x2F;360&#x2F;1800(Ability power)魔法傷害。每3次施放後，改為召喚利維坦，使直線上的敵軍暈眩並造成200&#x2F;300&#x2F;1200(Ability power)魔法傷害。<br>、 </p><h2 id="諾拉與悠咪"><a href="#諾拉與悠咪" class="headerlink" title="諾拉與悠咪"></a>諾拉與悠咪</h2><p><img src="https://hackmd.io/_uploads/B1P8qcpoR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/ryTtc56sA.png" alt="image">傳送門嘉年華<br>朝當前目標射出一顆圓球，爆炸後造成180&#x2F;270&#x2F;1000 (Ability power)魔法傷害，使區域染色5&#x2F;5&#x2F;15秒，期間造成500&#x2F;750&#x2F;3000 (Ability power)魔法傷害。如果圓球落在已染色的區域，它會彈到2格內的新位置，然後爆炸。</p><h2 id="羈絆"><a href="#羈絆" class="headerlink" title="羈絆"></a>羈絆</h2><p>羈絆有 摯友、5喚蜜師、5法師、2先鋒</p><p><img src="https://hackmd.io/_uploads/rJBwpcpj0.png" alt="image"><br><img src="https://hackmd.io/_uploads/r1QSn9psR.png" alt="image"><br><img src="https://hackmd.io/_uploads/HJ9BT5pjC.png" alt="image"></p><h1 id="增幅裝置"><a href="#增幅裝置" class="headerlink" title="增幅裝置"></a>增幅裝置</h1><p>密蜂摯友、法師之紋、喚蜜師之紋</p><h1 id="實戰影片"><a href="#實戰影片" class="headerlink" title="實戰影片"></a>實戰影片</h1><p><a href="https://youtu.be/xW4SY0UtocM?si=wFvIxt8Y1S9OVCHm">https://youtu.be/xW4SY0UtocM?si=wFvIxt8Y1S9OVCHm</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E6%88%B0%E6%A3%8B/">聯盟戰棋</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/29/TFT%E8%81%AF%E7%9B%9F%E6%88%B0%E6%A3%8B-%E9%99%A3%E5%AE%B9%E4%BB%8B%E7%B4%B9%E5%96%9A%E8%9C%9C%E5%B8%AB%E6%B3%95%E5%B8%AB%E7%B6%AD%E8%BF%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Compute Engine 如何優化成本與性能</title>
      <link>https://gahgah147.github.io/2024/08/28/GCP-Compute-Engine-%E5%A6%82%E4%BD%95%E5%84%AA%E5%8C%96%E6%88%90%E6%9C%AC%E8%88%87%E6%80%A7%E8%83%BD/</link>
      <guid>https://gahgah147.github.io/2024/08/28/GCP-Compute-Engine-%E5%A6%82%E4%BD%95%E5%84%AA%E5%8C%96%E6%88%90%E6%9C%AC%E8%88%87%E6%80%A7%E8%83%BD/</guid>
      <pubDate>Wed, 28 Aug 2024 06:14:41 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Syu03foiA.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/Syu03foiA.png" alt="image"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>隨著現代企業越來越依賴雲端技術，Google Cloud Platform (GCP) 成為了許多公司首選的雲端解決方案之一。GCP 提供了靈活且強大的計算資源，但如何在不犧牲性能的情況下優化成本，卻是企業面臨的一大挑戰。本文將探討 GCP 中成本優化與性能優化的策略與最佳實踐，幫助企業在滿足業務需求的同時，最大化利用其資源並控制開支。</p><h2 id="理解-GCP-的成本結構"><a href="#理解-GCP-的成本結構" class="headerlink" title="理解 GCP 的成本結構"></a>理解 GCP 的成本結構</h2><h3 id="計費模式：按需付費-vs-預留折扣"><a href="#計費模式：按需付費-vs-預留折扣" class="headerlink" title="計費模式：按需付費 vs 預留折扣"></a>計費模式：按需付費 vs 預留折扣</h3><p>GCP 的計費模式主要分為按需付費和預留折扣。按需付費適合短期和不確定的工作負載，而預留折扣針對長期穩定的使用情境提供了更具吸引力的價格。舉例來說，對於一年內持續運行的應用，預留折扣能夠節省高達30%的成本。選擇適合的計費模式能幫助企業有效降低雲端成本。</p><h3 id="了解-Compute-Engine-的成本組成"><a href="#了解-Compute-Engine-的成本組成" class="headerlink" title="了解 Compute Engine 的成本組成"></a>了解 Compute Engine 的成本組成</h3><p>Compute Engine 的成本不僅包括運算時間，還涉及到與其相關的儲存、網路以及 IP 地址等費用。例如，標準型虛擬機器的每月運行成本中，儲存和網路的費用可能佔到30%以上。因此，深入理解這些組成部分，並根據需求進行配置，有助於避免不必要的支出。</p><h2 id="選擇合適的-Compute-Engine-類型"><a href="#選擇合適的-Compute-Engine-類型" class="headerlink" title="選擇合適的 Compute Engine 類型"></a>選擇合適的 Compute Engine 類型</h2><h3 id="標準型-vs-高-CPU-vs-高記憶體-vs-GPU-vs-TPU"><a href="#標準型-vs-高-CPU-vs-高記憶體-vs-GPU-vs-TPU" class="headerlink" title="標準型 vs 高 CPU vs 高記憶體 vs GPU vs TPU"></a>標準型 vs 高 CPU vs 高記憶體 vs GPU vs TPU</h3><p>GCP 提供多種 Compute Engine 類型，如標準型、高 CPU、高記憶體、GPU 和 TPU。選擇哪一種資源取決於您的應用程式需求。比如，針對需要大量數據處理的應用，高記憶體型可能是最佳選擇，而對於機器學習模型訓練，GPU 或 TPU 能顯著提升計算性能，進而降低訓練時間和成本。</p><h3 id="預計用途-vs-實際需求的匹配"><a href="#預計用途-vs-實際需求的匹配" class="headerlink" title="預計用途 vs 實際需求的匹配"></a>預計用途 vs 實際需求的匹配</h3><p>在選擇資源時，預計用途與實際需求的匹配至關重要。例如，如果應用程式的高峰期較短暫，那麼過度配置高規格的 VM 可能會導致資源浪費。相反，若選擇過低的配置，可能會導致性能瓶頸。因此，精確評估應用的負載模式，有助於找到最適合的資源配置。</p><h3 id="彈性機制與自動縮放-Autoscaling"><a href="#彈性機制與自動縮放-Autoscaling" class="headerlink" title="彈性機制與自動縮放 (Autoscaling)"></a>彈性機制與自動縮放 (Autoscaling)</h3><p>利用 GCP 的自動縮放功能，您可以根據實際負載自動調整資源。這樣可以確保在需求高峰時具備足夠的計算能力，同時在負載減少時降低成本。例如，某線上零售平台在促銷活動期間使用自動縮放功能，成功避免了因過度配置資源導致的成本浪費。</p><h2 id="利用-Sustained-Use-Discounts-和-Committed-Use-Contracts"><a href="#利用-Sustained-Use-Discounts-和-Committed-Use-Contracts" class="headerlink" title="利用 Sustained Use Discounts 和 Committed Use Contracts"></a>利用 Sustained Use Discounts 和 Committed Use Contracts</h2><h3 id="Sustained-Use-Discounts-的自動折扣機制"><a href="#Sustained-Use-Discounts-的自動折扣機制" class="headerlink" title="Sustained Use Discounts 的自動折扣機制"></a>Sustained Use Discounts 的自動折扣機制</h3><p>GCP 提供 Sustained Use Discounts（SUDs），當虛擬機器長時間持續運行時，會自動應用折扣。這種機制非常適合需要長期運行的工作負載，如數據庫或後端服務。在某些情境下，SUDs 甚至可以將成本降低達到20%。</p><h3 id="Committed-Use-Contracts-的長期成本優勢"><a href="#Committed-Use-Contracts-的長期成本優勢" class="headerlink" title="Committed Use Contracts 的長期成本優勢"></a>Committed Use Contracts 的長期成本優勢</h3><p>對於長期穩定的工作負載，您可以選擇 Committed Use Contracts，以較低的價格預留一定量的資源。這種合約可以顯著降低長期成本。例如，某家金融科技公司預留了三年的計算資源，成功將成本削減了近 25%。</p><h3 id="如何判斷選擇哪一種折扣策略最合適"><a href="#如何判斷選擇哪一種折扣策略最合適" class="headerlink" title="如何判斷選擇哪一種折扣策略最合適"></a>如何判斷選擇哪一種折扣策略最合適</h3><p>根據工作負載的特性和穩定性，決定是採用 Sustained Use Discounts 還是 Committed Use Contracts。前者更適合變動性較大的工作負載，後者則適合可預測的長期需求。例如，對於每天持續運行的線上交易平台，Committed Use Contracts 可能是更經濟的選擇。</p><h2 id="透過機器規模優化性能"><a href="#透過機器規模優化性能" class="headerlink" title="透過機器規模優化性能"></a>透過機器規模優化性能</h2><h3 id="調整虛擬機器-VM-的規模來提升效能"><a href="#調整虛擬機器-VM-的規模來提升效能" class="headerlink" title="調整虛擬機器 (VM) 的規模來提升效能"></a>調整虛擬機器 (VM) 的規模來提升效能</h3><p>根據工作負載需求調整虛擬機器的規模，無論是垂直擴展（增加單一 VM 的資源）還是水平擴展（增加多個 VM），都可以顯著提升效能。對於單一計算密集型任務，增加 VM 的 CPU 和記憶體有助於縮短處理時間，提升應用性能。</p><h3 id="垂直擴展與水平擴展的選擇"><a href="#垂直擴展與水平擴展的選擇" class="headerlink" title="垂直擴展與水平擴展的選擇"></a>垂直擴展與水平擴展的選擇</h3><p>垂直擴展適合單一工作負載對 CPU 或記憶體有較高需求的情況，而水平擴展則更適合需要高可用性或分散式運算的情境。例如，一家遊戲公司在應對玩家人數驟增時，選擇了水平擴展多個 VM，以確保伺服器穩定運行。</p><h3 id="適當配置資源以避免過度配置或資源不足"><a href="#適當配置資源以避免過度配置或資源不足" class="headerlink" title="適當配置資源以避免過度配置或資源不足"></a>適當配置資源以避免過度配置或資源不足</h3><p>適當配置資源可以避免不必要的支出，並確保系統在高負載下能夠正常運行。這一點在虛擬機器的選型和調整上尤為重要。例如，一個日常負載較低的應用可能只需要最低配置的 VM，但在某些關鍵時刻則需要快速垂直擴展以應對突發需求。</p><h2 id="利用-Preemptible-VMs-節省成本"><a href="#利用-Preemptible-VMs-節省成本" class="headerlink" title="利用 Preemptible VMs 節省成本"></a>利用 Preemptible VMs 節省成本</h2><h3 id="什麼是-Preemptible-VMs-及其特點"><a href="#什麼是-Preemptible-VMs-及其特點" class="headerlink" title="什麼是 Preemptible VMs 及其特點"></a>什麼是 Preemptible VMs 及其特點</h3><p>Preemptible VMs 是一種低成本的計算選項，適合短期且可中斷的工作負載。這類 VM 的價格比標準 VM 低 70% 以上，但 GCP 可能會在任意時間收回資源。這類 VM 特別適合批次作業或大型資料分析。</p><h3 id="適用場景與風險管理"><a href="#適用場景與風險管理" class="headerlink" title="適用場景與風險管理"></a>適用場景與風險管理</h3><p>Preemptible VMs 適合處理批次作業、資料分析等可中斷的工作負載。例如，一家研究機構在進行大規模基因數據分析時使用了 Preemptible VMs，節省了大量計算成本。在使用這類 VM 時，必須制定應急方案，以應對 VM 被收回的情況，如定期保存進度或使用自動重啟策略。</p><h3 id="節省成本的實際案例"><a href="#節省成本的實際案例" class="headerlink" title="節省成本的實際案例"></a>節省成本的實際案例</h3><p>在處理大規模資料分析時，使用 Preemptible VMs 可以顯著降低成本。例如，某數據處理公司在大規模資料處理項目中，使用 Preemptible VMs 將計算成本降低了 60%，這是一個成功的實踐案例。</p><h2 id="定期監控與調整"><a href="#定期監控與調整" class="headerlink" title="定期監控與調整"></a>定期監控與調整</h2><h3 id="使用-Stackdriver-和其他工具進行監控"><a href="#使用-Stackdriver-和其他工具進行監控" class="headerlink" title="使用 Stackdriver 和其他工具進行監控"></a>使用 Stackdriver 和其他工具進行監控</h3><p>透過 GCP 的 Stackdriver 和其他監控工具，可以實時追蹤系統效能和成本。利用這些工具，企業可以在系統負載變化時即時調整資源配置，避免資源浪費或性能不足的問題。例如，設置自動告警機制，當資源利用率超過預定閾值時，系統會自動通知管理員進行調整。</p><h3 id="自動化與自適應調整策略"><a href="#自動化與自適應調整策略" class="headerlink" title="自動化與自適應調整策略"></a>自動化與自適應調整策略</h3><p>借助自動化工具，您可以實現資源配置的自適應調整，確保系統在不同負載下始終運行在最佳狀態。例如，配置自動縮放策略，使系統根據流量自動擴展或縮減資源，從而有效控制成本。</p><h3 id="經常審查與優化設定"><a href="#經常審查與優化設定" class="headerlink" title="經常審查與優化設定"></a>經常審查與優化設定</h3><p>定期審查並優化設定，能夠及時識別並修正不必要的資源浪費。例如，每季度對現有配置進行一次全面檢查，確保所有資源都得到充分利用，並調整不再適用的配置。</p><h2 id="使用-Google-Kubernetes-Engine-GKE-進行成本與性能優化"><a href="#使用-Google-Kubernetes-Engine-GKE-進行成本與性能優化" class="headerlink" title="使用 Google Kubernetes Engine (GKE) 進行成本與性能優化"></a>使用 Google Kubernetes Engine (GKE) 進行成本與性能優化</h2><h3 id="探討-GKE-的彈性和自動擴展能力"><a href="#探討-GKE-的彈性和自動擴展能力" class="headerlink" title="探討 GKE 的彈性和自動擴展能力"></a>探討 GKE 的彈性和自動擴展能力</h3><p>GKE 提供高度彈性與自動擴展功能，特別適合容器化應用的成本與</p><p>性能優化。通過設置自動擴展策略，您可以根據實際負載動態調整資源，確保在流量高峰時提供足夠的計算能力，而在流量低谷時減少資源使用。例如，一家 SaaS 公司利用 GKE 的自動擴展功能，成功在流量高峰期間保持服務穩定性，同時控制了成本。</p><h3 id="實踐中的-GKE-最佳實踐"><a href="#實踐中的-GKE-最佳實踐" class="headerlink" title="實踐中的 GKE 最佳實踐"></a>實踐中的 GKE 最佳實踐</h3><p>GKE 的最佳實踐包括合理的節點池配置、正確使用標籤與命名空間管理資源、以及充分利用自動縮放功能等。例如，為了降低管理成本，您可以將相似的工作負載分配到同一節點池中，並設置適當的資源限額，以防止單個應用佔用過多資源。</p><h3 id="透過標籤與命名空間管理資源"><a href="#透過標籤與命名空間管理資源" class="headerlink" title="透過標籤與命名空間管理資源"></a>透過標籤與命名空間管理資源</h3><p>標籤與命名空間是管理 GKE 資源的有效工具。通過正確地應用這些工具，您可以實現對資源的精細控制與成本分配。例如，為不同的應用程式和部門分配唯一的標籤，並基於這些標籤進行成本審計與分析，從而提高資源利用效率。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在 GCP 上進行成本與性能優化是一個持續的過程，需要定期的審視與調整。通過深入理解 GCP 的計費模式、正確選擇和配置 Compute Engine 類型、利用折扣策略、監控與自動化工具、以及充分利用 GKE 的功能，企業可以在不犧牲性能的情況下顯著降低雲端支出。隨著雲端技術的不斷發展，企業應該持續學習與應用最新的技術，以保持競爭力並最大化投資回報。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/28/GCP-Compute-Engine-%E5%A6%82%E4%BD%95%E5%84%AA%E5%8C%96%E6%88%90%E6%9C%AC%E8%88%87%E6%80%A7%E8%83%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Google Cloud Skills Boost 的 Qwiklabs課程紀錄 : Google Kubernetes Engine: Qwik Start</title>
      <link>https://gahgah147.github.io/2024/08/28/GCP-Google-Cloud-Skills-Boost-%E7%9A%84-Qwiklabs%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84-Google-Kubernetes-Engine-Qwik-Start/</link>
      <guid>https://gahgah147.github.io/2024/08/28/GCP-Google-Cloud-Skills-Boost-%E7%9A%84-Qwiklabs%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84-Google-Kubernetes-Engine-Qwik-Start/</guid>
      <pubDate>Wed, 28 Aug 2024 03:35:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rJ7NUf3sA.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天這篇文章是在記錄我練習Google Cloud Skills Boost 官方學習資源平台的過程，今天練習的課程是 Googl</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/rJ7NUf3sA.png" alt="image"></p><p>今天這篇文章是在記錄我練習Google Cloud Skills Boost 官方學習資源平台的過程，今天練習的課程是 Google Kubernetes Engine: Qwik Start，這個 實踐實驗室（Qwiklabs） 主題是在介紹 Google 雲端平台上面的Kubernetes 功能。</p><p><img src="https://hackmd.io/_uploads/rkNv8G3jA.png" alt="image"></p><p>我會記錄題目的內容跟翻譯成中文的意思，還有我操作的結果畫面，方便之後複習時可以縮短學習時間。</p><h1 id="什麼是Google-Cloud-Learning-Courses-and-Certifications"><a href="#什麼是Google-Cloud-Learning-Courses-and-Certifications" class="headerlink" title="什麼是Google Cloud Learning Courses and Certifications ?"></a>什麼是Google Cloud Learning Courses and Certifications ?</h1><p><img src="https://hackmd.io/_uploads/Hk4NWznjR.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/learn?hl=zh_tw">https://cloud.google.com/learn?hl=zh_tw</a></p></blockquote><p>Google Cloud Learning Courses and Certifications是 Google Cloud 的學習資源平台。這個網站提供了一系列的學習資源，幫助使用者學習和掌握 Google Cloud 技術。內容包括教學課程、實驗室練習、學習路徑、認證準備資源，以及其他可以幫助使用者提升技能的教育材料。無論是初學者還是有經驗的專業人員，都可以在這裡找到適合的學習內容，進一步了解如何有效地使用 Google Cloud 服務和技術。</p><p><img src="https://hackmd.io/_uploads/Hk_fEz2i0.png" alt="image"></p><p>這邊點擊 訓練 -&gt; 開始訓練 就可以進入 Google Cloud Skills Boost</p><h1 id="什麼是-Google-Cloud-Skills-Boost"><a href="#什麼是-Google-Cloud-Skills-Boost" class="headerlink" title="什麼是 Google Cloud Skills Boost ?"></a>什麼是 Google Cloud Skills Boost ?</h1><p><img src="https://hackmd.io/_uploads/SyTOXGno0.png" alt="image"></p><blockquote><p><a href="https://www.cloudskillsboost.google/">https://www.cloudskillsboost.google/</a></p></blockquote><p>是 Google Cloud 提供的學習平台，專門用來幫助使用者提升雲端技能。該平台包含各種實踐實驗室（Qwiklabs）、學習路徑、課程和其他學習資源，旨在幫助使用者掌握 Google Cloud 的技術和服務。平台上的內容涵蓋了從基礎到進階的各種主題，適合不同經驗水平的學習者。此外，它還提供認證準備資源，幫助學習者準備 Google Cloud 的官方認證考試。</p><h1 id="GSP100"><a href="#GSP100" class="headerlink" title="GSP100"></a>GSP100</h1><p><img src="https://hackmd.io/_uploads/HJao_DYoC.png" alt="image"></p><h1 id="教學影片"><a href="#教學影片" class="headerlink" title="教學影片"></a>教學影片</h1><p><a href="https://www.youtube.com/watch?v=u9nsngvmMK4&feature=youtu.be">Manage Containerized Apps with Kubernetes Engine | Google Cloud Labs</a></p><h1 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview - 概述"></a>Overview - 概述</h1><p><a href="https://cloud.google.com/kubernetes-engine">Google Kubernetes Engine</a> (GKE) provides a managed environment for deploying, managing, and scaling your containerized applications using Google infrastructure. The GKE environment consists of multiple machines (specifically <a href="https://cloud.google.com/compute">Compute Engine</a> instances) grouped to form a <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture">container cluster</a>.</p><p>In this lab, you get hands-on practice with container creation and application deployment with GKE.</p><p>Google Kubernetes Engine (GKE) 提供了一個受管理的環境，用於在 Google 基礎架構上部署、管理和擴展您的容器化應用程式。GKE 環境由多台機器（具體來說是 Compute Engine 實例）組成，這些機器被分組形成一個 容器集群。</p><p>在本次實驗中，您將進行實際操作，練習使用 GKE 進行容器創建和應用程式部署。</p><h1 id="Objectives-目標"><a href="#Objectives-目標" class="headerlink" title="Objectives - 目標"></a>Objectives - 目標</h1><p>In this lab you will learn how to:</p><ul><li>Create a GKE cluster</li><li>Deploy an application to the cluster</li><li>Delete the cluster</li></ul><p>以上內容是在本次實驗中，您將學習如何：</p><ul><li>建立一個 GKE cluster (集群)</li><li>將應用程式部署到該 cluster (集群)</li><li>刪除該 cluster (集群)</li></ul><h2 id="Cluster-orchestration-with-Google-Kubernetes-Engine-使用-Google-Kubernetes-Engine-進行叢集編排"><a href="#Cluster-orchestration-with-Google-Kubernetes-Engine-使用-Google-Kubernetes-Engine-進行叢集編排" class="headerlink" title="Cluster orchestration with Google Kubernetes Engine - 使用 Google Kubernetes Engine 進行叢集編排"></a>Cluster orchestration with Google Kubernetes Engine - 使用 Google Kubernetes Engine 進行叢集編排</h2><p>Google Kubernetes Engine (GKE) clusters are powered by the <a href="https://kubernetes.io/">Kubernetes</a> open source cluster management system. Kubernetes provides the mechanisms through which you interact with your container cluster. You use Kubernetes commands and resources to deploy and manage your applications, perform administrative tasks, set policies, and monitor the health of your deployed workloads.</p><p>Kubernetes draws on the same design principles that run popular Google services and provides the same benefits: automatic management, monitoring and liveness probes for application containers, automatic scaling, rolling updates, and more. When you run your applications on a container cluster, you’re using technology based on Google’s 10+ years of experience with running production workloads in containers.</p><p>以上內容是在描述 GKE 如何可以編輯 Cluster 的原理跟功能介紹</p><p>Google Kubernetes Engine (GKE) 的叢集是由 <a href="https://kubernetes.io/">Kubernetes</a> 開源叢集管理系統提供支持的。Kubernetes 提供了與容器叢集進行互動的機制。您可以使用 Kubernetes 的指令和資源來部署和管理應用程式、執行管理任務、設定政策以及監控已部署工作負載的健康狀況。</p><p>Kubernetes 借鑑了運行 Google 眾多熱門服務的相同設計原則，並提供了相同的優勢：自動管理、應用程式容器的監控和存活探針、自動縮放、滾動更新等功能。當您在容器叢集上運行應用程式時，您正在使用基於 Google 超過十年運行生產環境工作負載經驗的技術。</p><h2 id="Kubernetes-on-Google-Cloud-在-Google-Cloud-上使用-Kubernetes"><a href="#Kubernetes-on-Google-Cloud-在-Google-Cloud-上使用-Kubernetes" class="headerlink" title="Kubernetes on Google Cloud - 在 Google Cloud 上使用 Kubernetes"></a>Kubernetes on Google Cloud - 在 Google Cloud 上使用 Kubernetes</h2><p>When you run a GKE cluster, you also gain the benefit of advanced cluster management features that Google Cloud provides. These include:</p><ul><li><a href="https://cloud.google.com/compute/docs/load-balancing-and-autoscaling">Load balancing</a> for Compute Engine instances</li><li><a href="https://cloud.google.com/kubernetes-engine/docs/node-pools">Node pools</a> to designate subsets of nodes within a cluster for additional flexibility</li><li><a href="https://cloud.google.com/kubernetes-engine/docs/cluster-autoscaler">Automatic scaling</a> of your cluster’s node instance count</li><li><a href="https://cloud.google.com/kubernetes-engine/docs/node-auto-upgrade">Automatic upgrades</a> for your cluster’s node software</li><li><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair">Node auto-repair</a> to maintain node health and availability</li><li><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/logging">Logging and Monitoring</a> with Cloud Monitoring for visibility into your cluster</li></ul><p>Now that you have a basic understanding of Kubernetes, you will learn how to deploy a containerized application with GKE in less than 30 minutes. Follow the steps below to set up your lab environment.</p><p>以上內容是進階介紹 Kubernetes 的功能細節</p><p>當您運行 GKE 叢集時，還可以享受 Google Cloud 提供的進階叢集管理功能。這些功能包括：</p><ul><li>為 Compute Engine 實例提供的<a href="https://cloud.google.com/compute/docs/load-balancing-and-autoscaling">負載平衡</a></li><li>使用<a href="https://cloud.google.com/kubernetes-engine/docs/node-pools">節點池</a>來指定叢集內的節點子集，以增加彈性</li><li>自動調整叢集節點實例數量的<a href="https://cloud.google.com/kubernetes-engine/docs/cluster-autoscaler">自動縮放</a></li><li>為叢集節點軟體提供的<a href="https://cloud.google.com/kubernetes-engine/docs/node-auto-upgrade">自動升級</a></li><li>維護節點健康與可用性的<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair">節點自動修復</a></li><li>使用 Cloud Monitoring 進行叢集的<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/logging">日誌記錄與監控</a>，以提升叢集的可視性</li></ul><p>現在您已經對 Kubernetes 有了基本的了解，接下來將學習如何在不到 30 分鐘內使用 GKE 部署容器化應用程式。請按照以下步驟來設置您的實驗環境。</p><h1 id="Task-1-Set-a-default-compute-zone-設定預設的計算區域"><a href="#Task-1-Set-a-default-compute-zone-設定預設的計算區域" class="headerlink" title="Task 1. Set a default compute zone - 設定預設的計算區域"></a>Task 1. Set a default compute zone - 設定預設的計算區域</h1><p>Your <a href="https://cloud.google.com/compute/docs/regions-zones/#available">compute zone</a> is an approximate regional location in which your clusters and their resources live. For example, us-central1-a is a zone in the us-central1 region.</p><p>In your Cloud Shell session, run the following commands.</p><p>你的 <a href="https://cloud.google.com/compute/docs/regions-zones/#available">計算區域</a> 是叢集及其資源所在的近似區域位置。例如，us-central1-a 是 us-central1 區域中的一個區域。</p><p>在你的 Cloud Shell 會話中，運行以下命令。</p><ol><li>Set the default compute region:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud config set compute/region &quot;REGION&quot;</span><br></pre></td></tr></table></figure><p>Expected output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Updated property [compute/region].</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ryZ5gdKo0.png" alt="image"></p><ol start="2"><li>Set the default compute zone:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud config set compute/zone &quot;ZONE&quot;</span><br></pre></td></tr></table></figure><p>Expected output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Updated property [compute/zone].</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/S1psguFjC.png" alt="image"></p><h1 id="Task-2-Create-a-GKE-cluster-建立一個-GKE-叢集"><a href="#Task-2-Create-a-GKE-cluster-建立一個-GKE-叢集" class="headerlink" title="Task 2. Create a GKE cluster - 建立一個 GKE 叢集"></a>Task 2. Create a GKE cluster - 建立一個 GKE 叢集</h1><p>A <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture">cluster</a> consists of at least one cluster master machine and multiple worker machines called nodes. Nodes are <a href="https://cloud.google.com/compute/docs/instances/">Compute Engine virtual machine (VM) instances</a> that run the Kubernetes processes necessary to make them part of the cluster.</p><div class="note info simple"><p>Note: Cluster names must start with a letter and end with an alphanumeric, and cannot be longer than 40 characters.</p></div><p>Run the following command:</p><p>一個 <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture">叢集</a> 由至少一個叢集主控機器和多個稱為節點的工作機器組成。節點是運行 Kubernetes 所需進程的 <a href="https://cloud.google.com/compute/docs/instances/">Compute Engine 虛擬機器 (VM) 實例</a>，使它們成為叢集的一部分。</p><div class="note info simple"><p>注意：叢集名稱必須以字母開頭並以字母或數字結尾，且名稱長度不得超過 40 個字元。</p></div><p>執行以下指令：</p><p>Create a cluster:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters create --machine-type=e2-medium --zone=ZONE lab-cluster</span><br></pre></td></tr></table></figure><p>You can ignore any warnings in the output. It might take several minutes to finish creating the cluster.</p><p>Expected output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME: lab-cluster</span><br><span class="line">LOCATION: ZONE</span><br><span class="line">MASTER_VERSION: 1.22.8-gke.202</span><br><span class="line">MASTER_IP: 34.67.240.12</span><br><span class="line">MACHINE_TYPE: e2-medium</span><br><span class="line">NODE_VERSION: 1.22.8-gke.202</span><br><span class="line">NUM_NODES: 3</span><br><span class="line">STATUS: RUNNING</span><br></pre></td></tr></table></figure><p>Click Check my progress to verify the objective.<br><img src="https://hackmd.io/_uploads/SJs0cDYj0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Hy-eGdFoR.png" alt="image"></p><blockquote><p>這一步執行會花一段時間</p></blockquote><p><img src="https://hackmd.io/_uploads/SJuDG_KiC.png" alt="image"></p><h1 id="Task-3-Get-authentication-credentials-for-the-cluster-獲取叢集的身份驗證憑證"><a href="#Task-3-Get-authentication-credentials-for-the-cluster-獲取叢集的身份驗證憑證" class="headerlink" title="Task 3. Get authentication credentials for the cluster - 獲取叢集的身份驗證憑證"></a>Task 3. Get authentication credentials for the cluster - 獲取叢集的身份驗證憑證</h1><p>After creating your cluster, you need authentication credentials to interact with it.</p><ul><li>Authenticate with the cluster:</li></ul><p>在建立叢集後，你需要身份驗證憑證來與叢集互動。</p><ul><li>與叢集進行身份驗證：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters get-credentials lab-cluster</span><br></pre></td></tr></table></figure><p>Expected output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fetching cluster endpoint and auth data.</span><br><span class="line">kubeconfig entry generated for my-cluster.</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/S1weX_FiC.png" alt="image"></p><h1 id="Task-4-Deploy-an-application-to-the-cluster-部署應用程式到叢集"><a href="#Task-4-Deploy-an-application-to-the-cluster-部署應用程式到叢集" class="headerlink" title="Task 4. Deploy an application to the cluster - 部署應用程式到叢集"></a>Task 4. Deploy an application to the cluster - 部署應用程式到叢集</h1><p>You can now deploy a containerized application to the cluster. For this lab, you’ll run hello-app in your cluster.</p><p>GKE uses Kubernetes objects to create and manage your cluster’s resources. Kubernetes provides the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> object for deploying stateless applications like web servers. <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> objects define rules and load balancing for accessing your application from the internet.</p><p>1.To <strong>create a new Deployment</strong> <code>hello-server</code> from the <code>hello-app</code> container image, run the following <code>kubectl create</code> command:</p><p>你現在可以將容器化的應用程式部署到叢集。在這個實驗中，你將在叢集中運行 <code>hello-app</code>。</p><p>GKE 使用 Kubernetes 物件來創建和管理叢集的資源。Kubernetes 提供了 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> 物件來部署無狀態應用程式，如網頁伺服器。<a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> 物件則定義了從互聯網訪問你的應用程式的規則和負載均衡。</p><p>1.要從 <code>hello-app</code> 容器映像中<strong>創建一個新的 Deployment</strong> <code>hello-server</code>，請運行以下 <code>kubectl create</code> 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment hello-server --image=gcr.io/google-samples/hello-app:1.0</span><br></pre></td></tr></table></figure><p>Expected output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deployment.apps/hello-server created</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/H1dPXdtj0.png" alt="image"></p><p>This Kubernetes command creates a deployment object that represents <code>hello-server</code>. In this case, <code>--image</code> specifies a container image to deploy. The command pulls the example image from a <a href="https://cloud.google.com/container-registry/docs">Container Registry</a> bucket. <code>gcr.io/google-samples/hello-app:1.0</code> indicates the specific image version to pull. If a version is not specified, the latest version is used.</p><p>這個 Kubernetes 指令會創建一個代表 <code>hello-server</code> 的 Deployment 物件。在這個例子中，<code>--image</code> 指定了要部署的容器映像。該指令會從 <a href="https://cloud.google.com/container-registry/docs">Container Registry</a> 儲存區中提取範例映像。<code>gcr.io/google-samples/hello-app:1.0</code> 表示要提取的特定映像版本。如果未指定版本，則會使用最新版本。</p><p>Click <strong>Check my progress</strong> to verify the objective.<br><img src="https://hackmd.io/_uploads/SJNx2vFsA.png" alt="image"></p><ol start="2"><li>To create a Kubernetes Service, which is a Kubernetes resource that lets you expose your application to external traffic, run the following kubectl expose command:</li></ol><p>要建立一個 Kubernetes Service，它是一種 Kubernetes 資源，允許你將應用程式公開給外部流量，請執行以下 <code>kubectl expose</code> 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment hello-server --type=LoadBalancer --port 8080</span><br></pre></td></tr></table></figure><p>In this command:</p><ul><li><code>--port</code> specifies the port that the container exposes.</li><li><code>type=&quot;LoadBalancer&quot;</code> creates a Compute Engine load balancer for your container.</li></ul><p>Expected output:</p><p>在這個指令中：</p><ul><li><code>--port</code> 指定容器所開放的端口。</li><li><code>type=&quot;LoadBalancer&quot;</code> 為你的容器建立一個 Compute Engine 負載平衡器。</li></ul><p>預期輸出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service/hello-server exposed</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/B1FqQOtjR.png" alt="image"></p><ol start="3"><li>To inspect the <code>hello-server</code> Service, run <code>kubectl get</code>:</li></ol><p>要檢查 <code>hello-server</code> 服務，請執行 <code>kubectl get</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get service</span><br></pre></td></tr></table></figure><p>Expected output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME             TYPE            CLUSTER-IP      EXTERNAL-IP     PORT(S)           AGE</span><br><span class="line">hello-server     loadBalancer    10.39.244.36    35.202.234.26   8080:31991/TCP    65s</span><br><span class="line">kubernetes       ClusterIP       10.39.240.1               433/TCP           5m13s</span><br></pre></td></tr></table></figure><div class="note info simple"><p><strong>Note</strong>: It might take a minute for an external IP address to be generated. Run the previous command again if the EXTERNAL-IP column status is <strong>pending</strong>.</p><p><strong>注意</strong>：生成外部 IP 地址可能需要一分鐘。如果 EXTERNAL-IP 欄位狀態為 <strong>pending</strong>，請再次執行之前的指令。</p></div><p><img src="https://hackmd.io/_uploads/HkT2X_FiA.png" alt="image"></p><ol start="4"><li>To view the application from your web browser, open a new tab and enter the following address, replacing <code>[EXTERNAL IP]</code> with the <code>EXTERNAL-IP</code> for <code>hello-server</code>.</li></ol><p>要在網頁瀏覽器中查看應用程式，開啟一個新標籤頁並輸入以下地址，將 <code>[EXTERNAL IP]</code> 替換為 <code>hello-server</code> 的 <code>EXTERNAL-IP</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[EXTERNAL-IP]:8080</span><br></pre></td></tr></table></figure><p><strong>Expected output</strong>: The browser tab displays the message <strong>Hello, world!</strong> as well as the version and hostname.</p><p><strong>預期輸出</strong>：瀏覽器標籤頁顯示消息 <strong>Hello, world!</strong> 以及版本和主機名稱。</p><p>這邊實作產生的 EXTERNAL-IP 是 34.85.205.6 測試瀏覽的畫面如下</p><p><img src="https://hackmd.io/_uploads/HkjG4OtsR.png" alt="image"></p><blockquote><p><a href="http://34.85.205.6:8080/">http://34.85.205.6:8080/</a></p></blockquote><p>Click <strong>Check my progress</strong> to verify the objective.<br><img src="https://hackmd.io/_uploads/BJOVpwYjR.png" alt="image"></p><h1 id="Task-5-Deleting-the-cluster-刪除叢集"><a href="#Task-5-Deleting-the-cluster-刪除叢集" class="headerlink" title="Task 5. Deleting the cluster - 刪除叢集"></a>Task 5. Deleting the cluster - 刪除叢集</h1><ol><li>To delete the cluster, run the following command:<br> 要刪除叢集，請運行以下命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters delete lab-cluster</span><br></pre></td></tr></table></figure></li><li>When prompted, type Y to confirm.</li></ol><p>Deleting the cluster can take a few minutes. For more information on deleted GKE clusters from the Google Kubernetes Engine (GKE) article, <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/deleting-a-cluster">Deleting a cluster</a>.</p><p>當系統提示時，輸入 Y 以確認。</p><p>刪除叢集可能需要幾分鐘。欲了解更多有關從 Google Kubernetes Engine (GKE) 刪除叢集的資訊，請參閱文章 <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/deleting-a-cluster">刪除叢集</a>。</p><p><img src="https://hackmd.io/_uploads/SymdEuYjC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/r1zjr_YsC.png" alt="image"></p><blockquote><p>這邊也可以直接在介面上操作</p></blockquote><p>Click <strong>Check my progress</strong> to verify the objective.</p><p><img src="https://hackmd.io/_uploads/Bkl3aDtsC.png" alt="image"></p><h1 id="Congratulations-恭喜！"><a href="#Congratulations-恭喜！" class="headerlink" title="Congratulations! - 恭喜！"></a>Congratulations! - 恭喜！</h1><p>You have just deployed a containerized application to Google Kubernetes Engine! In this lab, you created a GKE cluster, deployed a containerized application to the cluster, and deleted the cluster. You can now apply this knowledge to deploy your own applications with GKE.</p><p>您剛剛成功將容器化應用程式部署到 Google Kubernetes Engine！在這個實驗中，您建立了一個 GKE 叢集，將容器化應用程式部署到叢集，並刪除了該叢集。現在，您可以將這些知識應用到部署您自己的應用程式上。</p><h2 id="Next-steps-Learn-more-下一步-了解更多"><a href="#Next-steps-Learn-more-下一步-了解更多" class="headerlink" title="Next steps &#x2F; Learn more - 下一步 &#x2F; 了解更多"></a>Next steps &#x2F; Learn more - 下一步 &#x2F; 了解更多</h2><p>This lab is part of a series of labs called Qwik Starts. These labs are designed to give you some experience with the many features available with Google Cloud. Search for “Qwik Starts” in the <a href="http://google.qwiklabs.com/catalog">Google Cloud Skill Boost catalog</a> to find the next lab you’d like to take!</p><p>這個實驗是 Qwik Starts 系列實驗的一部分。這些實驗旨在讓您體驗 Google Cloud 提供的眾多功能。您可以在 <a href="http://google.qwiklabs.com/catalog">Google Cloud Skill Boost 目錄</a> 中搜尋 “Qwik Starts” 來找到您想參加的下一個實驗！</p><h2 id="Google-Cloud-training-and-certification-Google-Cloud-培訓與認證"><a href="#Google-Cloud-training-and-certification-Google-Cloud-培訓與認證" class="headerlink" title="Google Cloud training and certification - Google Cloud 培訓與認證"></a>Google Cloud training and certification - Google Cloud 培訓與認證</h2><p>…helps you make the most of Google Cloud technologies. <a href="https://cloud.google.com/training/courses">Our classes</a> include technical skills and best practices to help you get up to speed quickly and continue your learning journey. We offer fundamental to advanced level training, with on-demand, live, and virtual options to suit your busy schedule. <a href="https://cloud.google.com/certification/">Certifications</a> help you validate and prove your skill and expertise in Google Cloud technologies.</p><p>…幫助您充分利用 Google Cloud 技術。我們的<a href="https://cloud.google.com/training/courses">課程</a>涵蓋了技術技能和最佳實踐，能夠幫助您快速上手並持續學習。我們提供從基礎到高級的培訓課程，並有隨選、現場和虛擬選項以適應您的繁忙日程。<a href="https://cloud.google.com/certification/">認證</a>能幫助您驗證和證明您在 Google Cloud 技術方面的技能和專業知識。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>今天跟大家分享 Google Cloud Skills Boost 中 Google Kubernetes Engine: Qwik Start 課程的操作過程，包括設置計算區域、創建 GKE 叢集、部署應用程式到叢集、獲取身份驗證憑證以及刪除叢集的步驟。</p><p>之後我還會持續練習 Qwiklabs 的內容並記錄分享給大家，如果有問題歡迎在部落格文章留言詢問。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/Google-Cloud-Skills-Boost/">Google Cloud Skills Boost</category>
      
      <category domain="https://gahgah147.github.io/tags/Kubernetes/">Kubernetes</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/28/GCP-Google-Cloud-Skills-Boost-%E7%9A%84-Qwiklabs%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84-Google-Kubernetes-Engine-Qwik-Start/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用ATOM 和 RSS 格式把Hexo內容搬到 Wordpress 上的流程</title>
      <link>https://gahgah147.github.io/2024/08/27/%E4%BD%BF%E7%94%A8ATOM-%E5%92%8C-RSS-%E6%A0%BC%E5%BC%8F%E6%8A%8AHexo%E5%85%A7%E5%AE%B9%E6%90%AC%E5%88%B0-Wordpress-%E4%B8%8A%E7%9A%84%E6%B5%81%E7%A8%8B/</link>
      <guid>https://gahgah147.github.io/2024/08/27/%E4%BD%BF%E7%94%A8ATOM-%E5%92%8C-RSS-%E6%A0%BC%E5%BC%8F%E6%8A%8AHexo%E5%85%A7%E5%AE%B9%E6%90%AC%E5%88%B0-Wordpress-%E4%B8%8A%E7%9A%84%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Tue, 27 Aug 2024 06:14:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;ATOM-和-RSS-的簡介&quot;&gt;&lt;a href=&quot;#ATOM-和-RSS-的簡介&quot; class=&quot;headerlink&quot; title=&quot;ATOM 和 RSS 的簡介&quot;&gt;&lt;/a&gt;ATOM 和 RSS 的簡介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;RSS（Really Sim</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="ATOM-和-RSS-的簡介"><a href="#ATOM-和-RSS-的簡介" class="headerlink" title="ATOM 和 RSS 的簡介"></a>ATOM 和 RSS 的簡介</h1><p><strong>RSS（Really Simple Syndication）</strong> 和 <strong>ATOM</strong> 都是用來分發網路內容的標準格式。它們的主要目的是幫助使用者訂閱和自動獲取網站更新，無需手動訪問網頁。這對於部落格或新聞網站非常有用，因為它能讓讀者即時接收新文章的通知。</p><h2 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h2><p><img src="https://hackmd.io/_uploads/SyJICyojR.png" alt="image"></p><p>RSS 是一種 XML 格式，常見的版本為 RSS 2.0。使用 RSS，網站可以將最新的內容發布到訂閱者的 RSS 閱讀器中。讀者可以使用 RSS 閱讀器訂閱 RSS Feed，當網站更新時，內容會自動推送到他們的裝置上。</p><h2 id="ATOM"><a href="#ATOM" class="headerlink" title="ATOM"></a>ATOM</h2><p><img src="https://hackmd.io/_uploads/r15501oiR.png" alt="image"></p><p>ATOM 是另一種 XML 格式，功能類似於 RSS，但有更多可自定義的元素。ATOM 被認為是 RSS 的改進版，因為它具有更好的格式和結構，適合用於更複雜的內容發佈需求。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>用戶只需將網站提供的 RSS 或 ATOM 連結添加到他們的 RSS 閱讀器中即可。對於網站管理員來說，提供 RSS 或 ATOM Feed 是吸引讀者的重要方式之一，能有效提升內容曝光率。</p><h1 id="產出-Hexo-的-RSS-摘要格式文章檔案"><a href="#產出-Hexo-的-RSS-摘要格式文章檔案" class="headerlink" title="產出 Hexo 的 RSS 摘要格式文章檔案"></a>產出 Hexo 的 RSS 摘要格式文章檔案</h1><p>RSS 摘要格式可以方便 WordPress 導入，在 _config.yml 檔案中調整設定</p><p>在 Hexo 中，如果要生成 RSS 摘要（也稱為 RSS Feed），你需要安裝一個 RSS 插件並進行相應設定。以下是詳細步驟：</p><h2 id="安裝-RSS-插件"><a href="#安裝-RSS-插件" class="headerlink" title="安裝 RSS 插件"></a>安裝 RSS 插件</h2><h3 id="方法一-hexo-generator-feed"><a href="#方法一-hexo-generator-feed" class="headerlink" title="方法一 : hexo-generator-feed"></a>方法一 : <code>hexo-generator-feed</code></h3><p>首先，你需要安裝 <code>hexo-generator-feed</code> 插件。打開終端機並在你的 Hexo 專案目錄下執行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/H13fgKHjR.png" alt="image"></p><h3 id="方法二-hexo-migrator-rss"><a href="#方法二-hexo-migrator-rss" class="headerlink" title="方法二 : hexo-migrator-rss"></a>方法二 : <code>hexo-migrator-rss</code></h3><p>後來有看到這一篇hexo官方說明文件<br><a href="https://hexo.io/zh-tw/docs/migration">https://hexo.io/zh-tw/docs/migration</a></p><p>裡面有提到使用 <code>hexo-migrator-rss</code> 這個工具來進行轉移</p><p>首先，安裝 hexo-migrator-rss 外掛。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-migrator-rss --save</span><br></pre></td></tr></table></figure><p>一旦外掛安裝完成，執行下列指令，從 RSS 轉移所有文章。 source 可以是檔案路徑或網址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate rss &lt;source&gt;</span><br></pre></td></tr></table></figure><p>這邊我最終是使用 hexo-generator-feed 產生的</p><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 <code>_config.yml</code></h2><p>安裝完成後，你需要在 Hexo 的主配置檔 <code>_config.yml</code> 中添加 RSS 的相關設定。以下是我設定的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span> </span><br><span class="line"><span class="attr">type:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">atom</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rss2</span></span><br><span class="line">  <span class="attr">path:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rss2.xml</span></span><br><span class="line"><span class="attr">limit:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">hub:</span></span><br><span class="line"><span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><div class="note info simple"><p>變數內容說明</p><ul><li><strong>enable</strong>：啟用或停用此插件。預設為啟用。</li><li><strong>type</strong>：Feed 的類型。可以是 <code>atom</code> 或 <code>rss2</code>。指定為 <code>[&#39;atom&#39;, &#39;rss2&#39;]</code> 以輸出這兩種類型。（預設：<code>atom</code>）</li><li><strong>path</strong>：Feed 的路徑。如果指定了多種類型，路徑必須按照類型的順序排列。（預設：<code>atom.xml/rss2.xml</code>）</li><li><strong>limit</strong>：Feed 中顯示的最大文章數量。（設為 <code>0</code> 或 <code>false</code> 以顯示所有文章）</li><li><strong>hub</strong>：PubSubHubbub hub 的 URL。（如果不使用，請保持空白）</li><li><strong>content</strong>：（可選）設為 <code>true</code> 時，會在 Feed 中包含整篇文章的內容。</li><li><strong>content_limit</strong>：（可選）摘要內容的字數上限。僅在 <code>content</code> 設為 <code>false</code> 且沒有自訂文章描述時使用。</li><li><strong>content_limit_delim</strong>：（可選）如果使用 <code>content_limit</code> 來縮短文章內容，僅在達到字數上限前的最後一個指定分隔符處截斷內容。預設不使用。</li><li><strong>order_by</strong>：Feed 的排序方式。（預設：<code>-date</code>，即按日期倒序）</li><li><strong>icon</strong>：（可選）自訂 Feed 圖示。預設使用主設定中的 email 對應的 Gravatar。</li><li><strong>autodiscovery</strong>：自動發現 Feed 的設定。（預設：<code>true</code>）許多主題已提供此功能，如果需要停用，可能需要調整主題設定。</li><li><strong>template</strong>：自訂模板路徑。這個檔案將用來生成 Feed 的 XML 檔案，預設模板為 <code>atom.xml</code> 和 <code>rss2.xml</code>。即使插件設定為輸出多種 Feed 類型，也可以只指定一個自訂模板。</li></ul></div><p>依照這樣以上設定執行產生時，會生成下面兩種內容的網址:<br><a href="https://gahgah147.github.io/atom.xml">https://gahgah147.github.io/atom.xml</a><br><a href="https://gahgah147.github.io/rss2.xml">https://gahgah147.github.io/rss2.xml</a></p><h2 id="生成靜態文件"><a href="#生成靜態文件" class="headerlink" title="生成靜態文件"></a>生成靜態文件</h2><p>設定完成後，執行以下命令生成靜態文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>或是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成後，RSS 文件會自動保存在你的 public 資料夾中，路徑是 <code>public/rss.xml</code>（或者你在配置中設定的路徑）。</p><p>實際上我平常部屬到github.io網頁上的流程是這樣，一樣可以更新到RSS 或是ATOM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="驗證-RSS"><a href="#驗證-RSS" class="headerlink" title="驗證 RSS"></a>驗證 RSS</h2><p>在瀏覽器中打開 <code>http://你的網站域名/atom.xml</code> 或是 <code>http://你的網站域名/rss2.xml</code>（或你設定的路徑）檢查 RSS 是否正確生成。</p><p>例如我這邊產生的是<br><code>https://gahgah147.github.io/atom.xml</code>和<code>https://gahgah147.github.io/rss2.xml</code></p><p>我這邊成功產生的RSS畫面<br><img src="https://hackmd.io/_uploads/rysfWFSsC.png" alt="image"></p><blockquote><p><a href="https://gahgah147.github.io/atom.xml">https://gahgah147.github.io/atom.xml</a></p></blockquote><h1 id="將文章導入-WordPress"><a href="#將文章導入-WordPress" class="headerlink" title="將文章導入 WordPress"></a>將文章導入 WordPress</h1><p>我後來是使用 FeedWordPress 這個套件來匯入</p><p><img src="https://hackmd.io/_uploads/BknKO6YjA.png" alt="image"></p><p>安裝完成之後在 New source 這邊輸入生成的  <code>http://你的網站域名/atom.xml</code><br><img src="https://hackmd.io/_uploads/H1uou6FsA.png" alt="image"></p><p>然後在這邊點選 Update Now<br><img src="https://hackmd.io/_uploads/S1j1YatiA.png" alt="image"></p><p>以下是我成功匯入的Hexo 部落格文章<br><img src="https://hackmd.io/_uploads/rJWAOpqi0.png" alt="image"></p><h1 id="為什麼這邊Wordpress-的標題點進去之後都會導引到hexo的文章連結"><a href="#為什麼這邊Wordpress-的標題點進去之後都會導引到hexo的文章連結" class="headerlink" title="為什麼這邊Wordpress 的標題點進去之後都會導引到hexo的文章連結?"></a>為什麼這邊Wordpress 的標題點進去之後都會導引到hexo的文章連結?</h1><p>當使用 RSS 將 Hexo 的文章同步到 WordPress 時，如果標題點進去後會導引到 Hexo 的文章連結，這通常是因為 RSS Feed 中的文章連結 (link 標籤) 指向的是原始網站（即 Hexo 部署的站點）。</p><p>原因分析： RSS Feed 的結構中，每篇文章都有一個 link 標籤，這個標籤是用來指定該文章的原始連結。在你將 RSS Feed 匯入到 WordPress 時，這些連結會保留原本的目標（即 Hexo 部落格的 URL），因此在 WordPress 中點擊標題後會導向原始的 Hexo 網頁。</p><p>使用 FeedWordPress 套件時，默認情況下匯入的文章會保留 RSS Feed 中的原始連結，因此點擊標題時會跳轉到 Hexo 的文章連結。然而，FeedWordPress 提供了一些選項，可以讓你調整這種行為。</p><p>你可以按照以下步驟來修改：</p><ol><li><p><strong>設定 FeedWordPress 將文章匯入為 WordPress 本地內容：</strong></p><ul><li>在 WordPress 後台，進入「FeedWordPress」的設定頁面。</li><li>在「Feeds &amp; Updates」中，找到並點選你已經設定的 RSS Feed。</li><li>在該 Feed 的詳細設定中，找到「Posts &amp; Links」部分。</li></ul></li></ol><p><img src="https://hackmd.io/_uploads/B1Nz31os0.png" alt="image"></p><ul><li>會看到一個選項「Permalinks point to:」，將此選項設置為「The local copy on this website」而不是「The original source of the syndicated item」。</li></ul><p><img src="https://hackmd.io/_uploads/HJFUhyoj0.png" alt="image"></p><blockquote><p>這邊應該要改為The local copy on this website</p></blockquote><p>   這樣設置後，FeedWordPress 會將匯入的文章設置為本地的 WordPress 文章，並且點擊標題後將導向 WordPress 上的文章頁面，而非 Hexo 原始連結。</p><ol start="2"><li><p><strong>手動修改匯入的文章：</strong></p><p>如果希望更加自定義某些文章的行為，也可以在文章匯入後手動編輯文章中的連結。</p></li></ol><p>透過這些設定，就可以讓 FeedWordPress 將 RSS Feed 的文章匯入為 WordPress 本地內容，避免跳轉到 Hexo 的文章頁面。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這樣就可以成功同步 Hexo 的文章到 WordPress 部落格文章上，有些細節還是要花點時間測試調整之後才知道如何改動，這些功能實際大約花了我3天時間，大家如果之後有需要把hexo部落格搬家可以參考看看，同時也可以考慮保留兩邊的部落格，因為自動化導入RSS的功能我覺得其實蠻方便的，另外Hexo加上github的架設其實不用額外花錢維護。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E6%9E%B6%E7%AB%99%E8%A8%98%E9%8C%84/">架站記錄</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Wordpress/">Wordpress</category>
      
      <category domain="https://gahgah147.github.io/tags/Hexo/">Hexo</category>
      
      <category domain="https://gahgah147.github.io/tags/ATOM/">ATOM</category>
      
      <category domain="https://gahgah147.github.io/tags/RSS/">RSS</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/27/%E4%BD%BF%E7%94%A8ATOM-%E5%92%8C-RSS-%E6%A0%BC%E5%BC%8F%E6%8A%8AHexo%E5%85%A7%E5%AE%B9%E6%90%AC%E5%88%B0-Wordpress-%E4%B8%8A%E7%9A%84%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Harbor：Docker的港口 - 容器映像檔管理工具</title>
      <link>https://gahgah147.github.io/2024/08/23/Harbor%EF%BC%9ADocker%E7%9A%84%E6%B8%AF%E5%8F%A3-%E5%AE%B9%E5%99%A8%E6%98%A0%E5%83%8F%E6%AA%94%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <guid>https://gahgah147.github.io/2024/08/23/Harbor%EF%BC%9ADocker%E7%9A%84%E6%B8%AF%E5%8F%A3-%E5%AE%B9%E5%99%A8%E6%98%A0%E5%83%8F%E6%AA%94%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Fri, 23 Aug 2024 02:37:17 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SJByrurj0.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;隨著容器技術的普及，企業在部署和管理容器應用時面臨越來越多的挑戰。如何有效地管理和保護大量的容器映像檔成為企業的重要課題。Harb</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/SJByrurj0.png" alt="image"></p><p>隨著容器技術的普及，企業在部署和管理容器應用時面臨越來越多的挑戰。如何有效地管理和保護大量的容器映像檔成為企業的重要課題。Harbor 作為一個企業級的容器映像檔管理解決方案，應運而生，提供了全面的功能來解決這些問題。</p><h2 id="什麼是-Harbor？"><a href="#什麼是-Harbor？" class="headerlink" title="什麼是 Harbor？"></a>什麼是 Harbor？</h2><p>Harbor 是一個開源的容器映像檔倉庫，最初由 VMware 開發，後來捐贈給 CNCF（Cloud Native Computing Foundation）。Harbor 的設計目標是提供一個安全、可靠且高效的容器映像檔管理平台。它不僅僅是一個映像檔倉庫，更是一個具備多種企業級功能的管理解決方案。</p><h2 id="Harbor-的主要功能"><a href="#Harbor-的主要功能" class="headerlink" title="Harbor 的主要功能"></a>Harbor 的主要功能</h2><ol><li><p><strong>多租戶支持與角色管理</strong></p><ul><li>Harbor 提供了完善的多租戶支持，可以為不同的團隊或項目設置獨立的命名空間，並基於角色的權限管理來控制對映像檔的訪問權限。這樣可以確保不同團隊的數據隔離和訪問控制，提升了企業級應用的安全性。</li></ul></li><li><p><strong>映像檔簽名與漏洞掃描</strong></p><ul><li>Harbor 集成了映像檔簽名和漏洞掃描功能。使用者可以在推送映像檔之前，對其進行簽名，保證映像檔的完整性和可信度。同時，Harbor 會自動掃描映像檔中的漏洞，並生成詳細的報告，幫助開發者及時修復安全問題。</li></ul></li><li><p><strong>鏡像複製</strong></p><ul><li>在全球部署應用時，映像檔的高效傳輸至關重要。Harbor 提供了跨數據中心和雲環境的鏡像複製功能，確保映像檔能夠快速部署到全球各地的數據中心，減少了部署延遲並提升了應用的可用性。</li></ul></li><li><p><strong>細粒度的訪問控制</strong></p><ul><li>透過集成 OAuth 及 LDAP，Harbor 支持基於用戶、組別、命名空間的細粒度訪問控制，從而保證了敏感數據的安全性。管理者可以根據需要靈活設置用戶和組別的訪問權限，確保只有授權用戶才能夠訪問特定的映像檔。</li></ul></li><li><p><strong>審計日誌</strong></p><ul><li>Harbor 提供了全面的審計日誌功能，記錄所有用戶的操作行為，幫助企業進行安全審計和問題追踪。這在合規性要求高的環境中特別重要，確保企業能夠符合各種法規和內部安全政策。</li></ul></li><li><p><strong>Web UI 及 RESTful API</strong></p><ul><li>Harbor 提供了直觀的 Web UI，方便用戶管理和瀏覽映像檔，同時還提供了功能強大的 RESTful API，供開發者進行二次開發或集成。這使得 Harbor 能夠靈活地融入企業現有的開發和運維流程中。</li></ul></li></ol><h2 id="為什麼選擇-Harbor？"><a href="#為什麼選擇-Harbor？" class="headerlink" title="為什麼選擇 Harbor？"></a>為什麼選擇 Harbor？</h2><p>Harbor 的多功能性和可擴展性使其成為企業管理容器映像檔的理想選擇。它不僅能夠幫助企業提高容器應用的安全性，還能夠簡化映像檔的管理和部署流程，讓企業可以更專注於核心業務的開發和創新。</p><p>Harbor 的開源性意味著企業可以根據自己的需求進行定制，並且擁有活躍的社區支持，保證了持續的更新和改進。無論是大型企業還是初創公司，Harbor 都能為其容器映像檔管理提供有力的支持。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>隨著容器技術的日益普及，選擇一個合適的容器映像檔管理工具至關重要。Harbor 作為一個功能豐富、安全性強、易於擴展的解決方案，能夠滿足企業在多租戶管理、漏洞掃描、鏡像複製等方面的需求，是企業級應用的不二之選。</p><p>Harbor 為企業提供了強大的工具來應對容器管理中的各種挑戰，從而讓企業能夠在雲原生應用的開發和運營中更加從容。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      <category domain="https://gahgah147.github.io/tags/Harbor/">Harbor</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/23/Harbor%EF%BC%9ADocker%E7%9A%84%E6%B8%AF%E5%8F%A3-%E5%AE%B9%E5%99%A8%E6%98%A0%E5%83%8F%E6%AA%94%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Velero: Kubernetes 中的帆船備份與災難復原工具</title>
      <link>https://gahgah147.github.io/2024/08/23/Velero-Kubernetes-%E4%B8%AD%E7%9A%84%E5%B8%86%E8%88%B9%E5%82%99%E4%BB%BD%E8%88%87%E7%81%BD%E9%9B%A3%E5%BE%A9%E5%8E%9F%E5%B7%A5%E5%85%B7/</link>
      <guid>https://gahgah147.github.io/2024/08/23/Velero-Kubernetes-%E4%B8%AD%E7%9A%84%E5%B8%86%E8%88%B9%E5%82%99%E4%BB%BD%E8%88%87%E7%81%BD%E9%9B%A3%E5%BE%A9%E5%8E%9F%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Fri, 23 Aug 2024 02:30:09 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rJS0m_SoC.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;隨著 Kubernetes (K8s) 在全球企業中的接受度不斷上升，越來越多的企業選擇使用 K8s 來部署服務。K8s 的靈活性</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/rJS0m_SoC.png" alt="image"></p><p>隨著 Kubernetes (K8s) 在全球企業中的接受度不斷上升，越來越多的企業選擇使用 K8s 來部署服務。K8s 的靈活性和可擴展性使得它成為現代企業基礎設施的重要組成部分。然而，隨著應用程式的日益複雜，備份與災難復原成為了運營過程中不可忽視的課題。這篇文章將介紹 Velero，一款強大的開源工具，專為 Kubernetes 集群的備份、還原、災難復原以及資料遷移設計。</p><h2 id="為什麼需要備份？"><a href="#為什麼需要備份？" class="headerlink" title="為什麼需要備份？"></a>為什麼需要備份？</h2><p>在生產環境中，難免會遇到一些不可控的因素或意外操作，甚至是程式錯誤，這些都可能導致服務停擺。如果集群龐大或部署的服務繁多，快速找出問題來源並不容易。在某些情況下，集群設定可能已被改動，而我們也記不得原本的配置。此時，如果有備份，便能夠迅速將集群恢復至正常狀態。</p><h2 id="需要備份的內容"><a href="#需要備份的內容" class="headerlink" title="需要備份的內容"></a>需要備份的內容</h2><p>K8s 使用 Controller pattern 來管理集群狀態，透過與 API Server 的協作，確保集群達到預期狀態。因此，我們需要備份的是儲存對象狀態的資料。</p><p>最少需要備份以下兩個部分：</p><ol><li><strong>etcd</strong>：etcd 是 K8s 中非常重要的元件，用於儲存集群的網路配置以及對象的狀態訊息。還原 etcd 等同於還原 K8s 集群狀態。</li><li>**Persistent Volume (PV)**：雖然 etcd 還原了 K8s 集群狀態，但 PV 的內容不屬於 K8s 集群狀態的一部分，如資料庫中的資料。因此，除了 etcd 外，還需要備份 PV 的內容。</li></ol><h2 id="Velero-的功能介紹"><a href="#Velero-的功能介紹" class="headerlink" title="Velero 的功能介紹"></a>Velero 的功能介紹</h2><p>Velero 是一款開源工具，專為安全地備份與還原 Kubernetes 集群資源和持久性卷（Persistent Volumes）而設計。它的三大主要功能包括：</p><ol><li><strong>災難復原</strong>：當 K8s 集群發生問題時，能夠快速恢復。</li><li><strong>資料遷移</strong>：在不同的 K8s 集群之間遷移應用程式。</li><li><strong>資料保護</strong>：對 Persistent Volume 進行備份，確保資料的完整性。</li></ol><h2 id="Velero-的架構"><a href="#Velero-的架構" class="headerlink" title="Velero 的架構"></a>Velero 的架構</h2><p>Velero 通過實作 Custom Resource Definition (CRD)，並由 Velero Controller 執行備份與還原操作。備份過程大致如下：</p><ol><li>使用者透過 velero CLI 建立 Backup object。</li><li>BackupController 監聽並驗證此事件。</li><li>BackupController 查詢 API Server，並備份目標資源。</li><li>最後，BackupController 將備份的資源上傳至指定的 Object Storage Service。</li></ol><h2 id="備份過程中的注意事項"><a href="#備份過程中的注意事項" class="headerlink" title="備份過程中的注意事項"></a>備份過程中的注意事項</h2><p>Velero 支援兩種主要的 PV 備份方式：</p><ol><li><strong>Volume Snapshot</strong>：利用 storage provider 的 snapshot 功能對資料進行快照。適合需要確保資料一致性的場景，如公有雲提供的 block storage（如 EBS、Google Compute Engine Disks、Azure Managed Disks）。</li><li><strong>Restic</strong>：一個支援多系統的備份還原工具，適用於沒有 snapshot 支援的場景。Restic 可以透過 Velero 備份 PV 的資料，但對於有資料一致性要求的應用，建議在備份前凍結資料。</li></ol><h2 id="還原操作"><a href="#還原操作" class="headerlink" title="還原操作"></a>還原操作</h2><p>在還原過程中，Velero 支援一些特殊操作，如：</p><ul><li>復原到指定的 namespace。</li><li>保存 service 的 NodePort。</li><li>改變 PV&#x2F;PVC 的 StorageClass。</li></ul><p>此外，Velero 也支援多種 hooks 來控制還原行為。</p><h2 id="使用範例"><a href="#使用範例" class="headerlink" title="使用範例"></a>使用範例</h2><p>假設我們部署了一個 nginx server 並使用 PV 儲存 log 檔案。透過 Velero，我們可以輕鬆地將整個 K8s 集群進行備份，然後在需要時進行還原。具體操作步驟如下：</p><ol><li>安裝 CSI Driver，並配置 hostpath storage class。</li><li>部署 nginx server 並掛載 PV。</li><li>使用 Velero 進行備份。</li><li>刪除 nginx 部署，模擬災難場景。</li><li>使用 Velero 還原 nginx server，並檢查資料恢復情況。</li></ol><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Velero 操作簡單，且輕量化的設計使其能夠支援多種平台。雖然本文演示了如何進行備份與還原，但 Velero 也支援跨集群遷移，只需在新 K8s 集群上安裝 Velero，便可輕鬆進行還原操作。然而，使用 Velero 前需仔細閱讀官方文件，了解其功能與限制，以確保能滿足自身需求。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Kubernetes/">Kubernetes</category>
      
      <category domain="https://gahgah147.github.io/tags/Velero/">Velero</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%82%99%E4%BB%BD/">備份</category>
      
      <category domain="https://gahgah147.github.io/tags/%E7%81%BD%E9%9B%A3%E9%82%84%E5%8E%9F/">災難還原</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/23/Velero-Kubernetes-%E4%B8%AD%E7%9A%84%E5%B8%86%E8%88%B9%E5%82%99%E4%BB%BD%E8%88%87%E7%81%BD%E9%9B%A3%E5%BE%A9%E5%8E%9F%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Google Compute Engine (GCE) 簡介與操作實例</title>
      <link>https://gahgah147.github.io/2024/08/23/GCP-Google-Compute-Engine-GCE-%E7%B0%A1%E4%BB%8B%E8%88%87%E6%93%8D%E4%BD%9C%E5%AF%A6%E4%BE%8B/</link>
      <guid>https://gahgah147.github.io/2024/08/23/GCP-Google-Compute-Engine-GCE-%E7%B0%A1%E4%BB%8B%E8%88%87%E6%93%8D%E4%BD%9C%E5%AF%A6%E4%BE%8B/</guid>
      <pubDate>Fri, 23 Aug 2024 02:24:19 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Google-Compute-Engine-是什麼&quot;&gt;&lt;a href=&quot;#Google-Compute-Engine-是什麼&quot; class=&quot;headerlink&quot; title=&quot;Google Compute Engine 是什麼?&quot;&gt;&lt;/a&gt;Google Com</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Google-Compute-Engine-是什麼"><a href="#Google-Compute-Engine-是什麼" class="headerlink" title="Google Compute Engine 是什麼?"></a>Google Compute Engine 是什麼?</h1><p><img src="https://hackmd.io/_uploads/BkfHy_rjA.png" alt="image"></p><p>Google Compute Engine 是 GCP 的核心運算服務，專門提供可擴展的虛擬機器，讓企業能夠運行各種工作負載。Compute Engine 支援多種作業系統、機器類型與區域選擇，並能夠與其他 GCP 服務如 Cloud Storage 和 BigQuery 無縫整合，提供靈活且高效的雲端運算解決方案。</p><p>Google Compute Engine 的主要優勢包括：</p><ol><li><strong>可擴展性</strong>：無論是單一 VM 還是成千上萬的 VM，Compute Engine 都能夠快速部署並靈活應對工作負載的變化。</li><li><strong>自動化管理</strong>：自動縮放、快照、備份和恢復等功能讓企業輕鬆管理和維護基礎架構。</li><li><strong>高效運行</strong>：Compute Engine 提供多種機器類型，從一般用途到高性能運算，適應不同的計算需求。</li></ol><p><img src="https://hackmd.io/_uploads/r1QhkdSoC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/products/compute">https://cloud.google.com/products/compute</a></p></blockquote><h1 id="如何在-GCP-中將-VM-複製到另一個專案並保留相同固定-IP"><a href="#如何在-GCP-中將-VM-複製到另一個專案並保留相同固定-IP" class="headerlink" title="如何在 GCP 中將 VM 複製到另一個專案並保留相同固定 IP?"></a>如何在 GCP 中將 VM 複製到另一個專案並保留相同固定 IP?</h1><p><img src="https://hackmd.io/_uploads/BJpQkdBoR.png" alt="image"><br>在企業的業務連續性和災難恢復計畫中，維持關鍵系統的高可用性至關重要。GCP 平台提供了靈活的虛擬機（VM）管理功能，允許用戶將 VM 複製到其他專案，同時保留相同的固定 IP，從而確保網路配置的穩定性與一致性。本文將介紹如何在 GCP 中完成這一操作，並適用於備援環境的準備。</p><h2 id="準備工作"><a href="#準備工作" class="headerlink" title="準備工作"></a>準備工作</h2><p>在開始複製 VM 之前，請確保以下幾點：</p><ul><li><strong>權限檢查</strong>：確認你在源專案和目標專案中擁有足夠的權限，尤其是跨專案操作的權限。</li><li><strong>資源準備</strong>：目標專案中是否已配置好必要的網路、子網和防火牆規則，以適應複製後的 VM。</li><li><strong>IP 地址確認</strong>：確保目標專案中沒有其他資源占用你打算保留的固定 IP。</li></ul><h1 id="跨專案複製-VM-的步驟"><a href="#跨專案複製-VM-的步驟" class="headerlink" title="跨專案複製 VM 的步驟"></a>跨專案複製 VM 的步驟</h1><h2 id="創建-VM-映像"><a href="#創建-VM-映像" class="headerlink" title="創建 VM 映像"></a>創建 VM 映像</h2><p>首先，我們需要將源 VM 打包成映像，以便在目標專案中創建新的 VM。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute images create my-vm-image \</span><br><span class="line">  --source-disk=my-source-vm \</span><br><span class="line">  --source-disk-zone=us-central1-a \</span><br><span class="line">  --family=my-vm-family</span><br></pre></td></tr></table></figure><h2 id="將映像複製到目標專案"><a href="#將映像複製到目標專案" class="headerlink" title="將映像複製到目標專案"></a>將映像複製到目標專案</h2><p>接下來，我們需要將映像共享給目標專案，然後在目標專案中使用該映像創建 VM。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute images add-iam-policy-binding my-vm-image \</span><br><span class="line">  --member=<span class="string">&#x27;user:target-project-user@example.com&#x27;</span> \</span><br><span class="line">  --role=<span class="string">&#x27;roles/compute.imageUser&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="在目標專案中創建新的-VM"><a href="#在目標專案中創建新的-VM" class="headerlink" title="在目標專案中創建新的 VM"></a>在目標專案中創建新的 VM</h2><p>使用複製的映像在目標專案中創建 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute instances create my-new-vm \</span><br><span class="line">  --image=my-vm-image \</span><br><span class="line">  --zone=us-central1-b \</span><br><span class="line">  --project=target-project-id</span><br></pre></td></tr></table></figure><h1 id="保留與配置相同的固定-IP"><a href="#保留與配置相同的固定-IP" class="headerlink" title="保留與配置相同的固定 IP"></a>保留與配置相同的固定 IP</h1><h2 id="釋放原專案中的固定-IP"><a href="#釋放原專案中的固定-IP" class="headerlink" title="釋放原專案中的固定 IP"></a>釋放原專案中的固定 IP</h2><p>在源專案中釋放該固定 IP，並將其設置為共享狀態，這樣在目標專案中可以重新綁定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute addresses delete my-vm-ip \</span><br><span class="line">  --region=us-central1 \</span><br><span class="line">  --project=source-project-id</span><br></pre></td></tr></table></figure><h2 id="在目標專案中重新分配固定-IP"><a href="#在目標專案中重新分配固定-IP" class="headerlink" title="在目標專案中重新分配固定 IP"></a>在目標專案中重新分配固定 IP</h2><p>將相同的 IP 地址分配給目標專案中的新 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute addresses create my-vm-ip \</span><br><span class="line">  --addresses=EXTERNAL_IP_ADDRESS \</span><br><span class="line">  --region=us-central1 \</span><br><span class="line">  --project=target-project-id</span><br></pre></td></tr></table></figure><h1 id="測試與驗證"><a href="#測試與驗證" class="headerlink" title="測試與驗證"></a>測試與驗證</h1><p>當所有配置完成後，務必進行測試以確保 VM 能夠正常運行並成功使用所保留的固定 IP。可以進行以下測試：</p><ul><li><strong>Ping 測試</strong>：檢查新 VM 是否可以通過固定 IP 回應請求。</li><li><strong>連線測試</strong>：驗證服務端口是否能正常連接。</li></ul><h1 id="最佳實踐與注意事項"><a href="#最佳實踐與注意事項" class="headerlink" title="最佳實踐與注意事項"></a>最佳實踐與注意事項</h1><ul><li><strong>定期演練</strong>：為了確保備援環境的有效性，建議定期演練整個流程並進行必要的調整。</li><li><strong>監控和日誌</strong>：利用 GCP 的監控和日誌工具，實時監控系統健康狀況並快速應對問題。</li></ul><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>通過在 GCP 中將 VM 複製到不同專案並保留相同的固定 IP，企業能夠更有效地管理備援環境，提升系統的容錯能力和業務連續性。這一流程不僅簡化了災難恢復的操作，還確保了網路配置的一致性，是確保高可用性的最佳選擇之一。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/23/GCP-Google-Compute-Engine-GCE-%E7%B0%A1%E4%BB%8B%E8%88%87%E6%93%8D%E4%BD%9C%E5%AF%A6%E4%BE%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Google SecOps 雲端資訊安全運營工具</title>
      <link>https://gahgah147.github.io/2024/08/22/GCP-Google-SecOps-%E9%9B%B2%E7%AB%AF%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8%E9%81%8B%E7%87%9F%E5%B7%A5%E5%85%B7/</link>
      <guid>https://gahgah147.github.io/2024/08/22/GCP-Google-SecOps-%E9%9B%B2%E7%AB%AF%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8%E9%81%8B%E7%87%9F%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Thu, 22 Aug 2024 06:54:47 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;以下圖片是我今天看到線上 APAC Security Digital Summit 2024影片分享的片段&lt;br&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ryj-X4Vj0.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天主要有講了四</description>
        
      
      
      
      <content:encoded><![CDATA[<p>以下圖片是我今天看到線上 APAC Security Digital Summit 2024影片分享的片段<br><img src="https://hackmd.io/_uploads/ryj-X4Vj0.png" alt="image"></p><p>今天主要有講了四個大主題<br>Google Cloud：Google 的雲端服務平台，提供運算、存儲、數據分析等各種雲端解決方案。</p><p>Google SecOps：Google 提供的安全運營解決方案，整合了威脅檢測、響應、合規性管理等功能，幫助企業保護其雲端環境的安全。</p><p>Mandiant：Mandiant 是一家網路安全公司，專注於威脅情報和事件響應。Mandiant 被 Google Cloud 收購後，與 Google 的安全服務整合，提升整體安全能力。</p><p>Marketplace：Google Cloud Marketplace 提供各種第三方的工具和服務，幫助企業擴展其雲端功能，涵蓋安全、數據分析、開發等多個領域。</p><p>這一篇文章主要想要分享我新看到的Google SecOps。</p><p>隨著數位化轉型的加速，企業在雲端環境中面臨的安全威脅日益增加。為了有效應對這些挑戰，Google Cloud 提供了一套強大的安全運營（Security Operations，SecOps）解決方案，幫助企業構建更加安全和穩定的雲端環境。這篇文章將介紹 Google SecOps 的核心功能及其如何幫助企業保護其數據和基礎設施。</p><h1 id="什麼是-Google-SecOps？"><a href="#什麼是-Google-SecOps？" class="headerlink" title="什麼是 Google SecOps？"></a>什麼是 Google SecOps？</h1><p><img src="https://hackmd.io/_uploads/S1PgyDNj0.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/security">https://cloud.google.com/security</a></p></blockquote><p>Google SecOps 是一套由 Google Cloud 提供的安全解決方案，旨在整合安全運營的各個方面，幫助企業快速檢測、分析和應對安全威脅。SecOps 是由 Security（安全）和 Operations（運營）結合而成的概念，強調安全與運營之間的協作，以保障雲端環境的整體安全性。</p><h2 id="Google-SecOps-的核心功能"><a href="#Google-SecOps-的核心功能" class="headerlink" title="Google SecOps 的核心功能"></a>Google SecOps 的核心功能</h2><h3 id="威脅檢測與響應"><a href="#威脅檢測與響應" class="headerlink" title="威脅檢測與響應"></a>威脅檢測與響應</h3><ul><li>Google SecOps 利用先進的威脅檢測技術，實時監控雲端環境，識別潛在的安全威脅。透過整合 Google 的威脅情報和機器學習技術，SecOps 可以快速偵測到異常行為並自動啟動響應措施。</li></ul><h3 id="整合的安全分析"><a href="#整合的安全分析" class="headerlink" title="整合的安全分析"></a>整合的安全分析</h3><ul><li>Google 提供的 Security Command Center 是 SecOps 的核心組件之一，它能夠集中管理和分析來自各種 Google Cloud 服務的安全訊號。這種集中式的管理能讓安全團隊更快發現威脅並采取相應行動。</li></ul><h3 id="合規性管理與監控"><a href="#合規性管理與監控" class="headerlink" title="合規性管理與監控"></a>合規性管理與監控</h3><ul><li>Google SecOps 幫助企業確保其雲端環境符合各類合規標準，無論是全球的 GDPR 還是區域性的數據保護規範。透過自動化的合規性檢查，SecOps 能夠持續監控合規狀況，並在發現違規時及時通知相關團隊。</li></ul><h3 id="自動化與協作"><a href="#自動化與協作" class="headerlink" title="自動化與協作"></a>自動化與協作</h3><ul><li>Google SecOps 強調自動化和團隊協作，減少人為錯誤並提高回應速度。自動化的威脅響應流程能夠快速封鎖惡意活動，防止損害擴大。同時，SecOps 平台支持跨團隊協作，確保安全事件的有效處理。</li></ul><h1 id="使用-Google-SecOps-的好處"><a href="#使用-Google-SecOps-的好處" class="headerlink" title="使用 Google SecOps 的好處"></a>使用 Google SecOps 的好處</h1><h2 id="強化威脅防禦"><a href="#強化威脅防禦" class="headerlink" title="強化威脅防禦"></a>強化威脅防禦</h2><p>得益於 Google 的全球安全情報網絡和強大的機器學習能力，SecOps 能夠提前預測並防禦各類網路攻擊，有效降低企業遭受攻擊的風險。</p><h2 id="提升運營效率"><a href="#提升運營效率" class="headerlink" title="提升運營效率"></a>提升運營效率</h2><p>自動化工具和集中化管理平台使得安全團隊能更有效率地處理大量安全事件，減少了人工操作的時間和錯誤率。</p><h2 id="合規性無縫管理"><a href="#合規性無縫管理" class="headerlink" title="合規性無縫管理"></a>合規性無縫管理</h2><p>SecOps 能夠輕鬆管理和檢查合規性，確保企業在全球不同地區都能遵守相關法律法規，降低因不合規帶來的風險。</p><h2 id="快速響應能力"><a href="#快速響應能力" class="headerlink" title="快速響應能力"></a>快速響應能力</h2><p>在發生安全事件時，SecOps 可以自動調動資源、封鎖威脅並進行恢復，確保業務不中斷，將損失降到最低。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>在當今快速變化的數位世界中，安全運營已成為企業成功的關鍵因素之一。Google SecOps 透過先進的技術與強大的分析能力，幫助企業應對日益複雜的安全挑戰，保障數據與業務的安全性。對於希望在雲端環境中建立堅固防線的企業來說，Google SecOps 是不可或缺的合作夥伴。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/">資訊安全</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/22/GCP-Google-SecOps-%E9%9B%B2%E7%AB%AF%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8%E9%81%8B%E7%87%9F%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Google Cloud Platform 的地區(Regions) 和區域(Zones)</title>
      <link>https://gahgah147.github.io/2024/08/21/GCP-Google-Cloud-Platform-%E7%9A%84%E5%9C%B0%E5%8D%80-Regions-%E5%92%8C%E5%8D%80%E5%9F%9F-Zones/</link>
      <guid>https://gahgah147.github.io/2024/08/21/GCP-Google-Cloud-Platform-%E7%9A%84%E5%9C%B0%E5%8D%80-Regions-%E5%92%8C%E5%8D%80%E5%9F%9F-Zones/</guid>
      <pubDate>Wed, 21 Aug 2024 06:54:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HJxggfmoC.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;什麼是-GCP-的-Regions-和-Zones？&quot;&gt;&lt;a href=&quot;#什麼是-GCP-的-Regions-和-Zo</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/HJxggfmoC.png" alt="image"></p><h1 id="什麼是-GCP-的-Regions-和-Zones？"><a href="#什麼是-GCP-的-Regions-和-Zones？" class="headerlink" title="什麼是 GCP 的 Regions 和 Zones？"></a>什麼是 GCP 的 Regions 和 Zones？</h1><p><img src="https://hackmd.io/_uploads/S1F_oWms0.png" alt="image"></p><blockquote><p>官方說明文件鏈接：<a href="https://cloud.google.com/about/locations">Regions and Zones | Google Cloud</a></p></blockquote><p>在 Google Cloud Platform (GCP) 中，<strong>Regions</strong> 和 <strong>Zones</strong> 是雲端基礎設施的核心概念。Region 是分佈在全球各地的地理區域，每個 Region 由多個獨立的 Zones 組成。這些 Zones 是實際承載應用程式和資料的物理資料中心。正確選擇 Region 和 Zone 不僅影響應用的性能，還涉及數據主權、法律合規性等多方面考量。</p><h1 id="為什麼-Regions-和-Zones-很重要？"><a href="#為什麼-Regions-和-Zones-很重要？" class="headerlink" title="為什麼 Regions 和 Zones 很重要？"></a>為什麼 Regions 和 Zones 很重要？</h1><p>讓我們透過一個具體的情境來理解 Regions 和 Zones 的重要性：</p><p><strong>情境 1：單一資料中心</strong></p><p>想像您的應用程式部署在倫敦的一個資料中心。如果僅依賴這個單一的資料中心，您將面臨以下挑戰：</p><p><img src="https://hackmd.io/_uploads/ry9FnbQi0.png" alt="image"></p><ul><li><p><strong>挑戰 1：全球用戶訪問速度慢（高延遲）</strong><br>來自世界其他地區的用戶可能會因為距離而感受到較高的延遲，影響用戶體驗。</p></li><li><p><strong>挑戰 2：資料中心崩潰的風險（低可用性）</strong><br>如果倫敦的資料中心發生故障，您的應用程式將無法使用，導致業務中斷。</p></li></ul><p><strong>情境 2：多資料中心（單一 Region）</strong></p><p>現在假設您在倫敦增加了一個新的資料中心。這能解決某些問題，但還是會有一些挑戰：<br><img src="https://hackmd.io/_uploads/ByknnW7o0.png" alt="image"></p><ul><li><p><strong>挑戰 1：全球用戶訪問速度慢</strong><br>雖然有多個資料中心，但它們都位於倫敦，全球用戶的訪問速度仍然會受到影響。</p></li><li><p><strong>挑戰 2（已解決）：單一資料中心崩潰</strong><br>如果其中一個資料中心崩潰，另一個資料中心可以接手，確保應用程式的可用性。</p></li><li><p><strong>挑戰 3：整個倫敦地區不可用</strong><br>如果整個倫敦地區發生大範圍的問題（如自然災害），所有資料中心都可能無法運行，您的應用程式將再次面臨中斷風險。</p></li></ul><p><strong>情境 3：多 Region 部署</strong></p><p>為了進一步提升應用的可用性，我們可以在另一個 Region（例如孟買）部署資料中心：</p><p><img src="https://hackmd.io/_uploads/HJ6Thb7jA.png" alt="image"></p><ul><li><p><strong>挑戰 1（部分解決）：全球用戶訪問速度慢</strong><br>通過在多個 Regions 部署應用程式，您可以降低全球用戶的延遲。</p></li><li><p><strong>挑戰 2（已解決）：單一資料中心崩潰</strong><br>如果某個資料中心崩潰，應用程式仍然可以從其他資料中心運行。</p></li><li><p><strong>挑戰 3（已解決）：整個 Region 不可用</strong><br>如果倫敦的所有資料中心都無法使用，您的應用程式仍然可以從孟買的資料中心提供服務。</p></li></ul><p>透過這些情境，我們可以看到選擇多個 Regions 和 Zones 部署應用程式的重要性。Google Cloud 提供了超過 20 個 Regions，並且每年都在不斷擴展，讓您可以在全球範圍內擴展業務。</p><h1 id="GCP-Regions-和-Zones-的用途"><a href="#GCP-Regions-和-Zones-的用途" class="headerlink" title="GCP Regions 和 Zones 的用途"></a>GCP Regions 和 Zones 的用途</h1><p><img src="https://hackmd.io/_uploads/rkf6jZ7jR.png" alt="image"></p><blockquote><p>官方說明文件鏈接：<a href="https://cloud.google.com/compute/docs/regions-zones">Choosing Compute Engine Regions and Zones | Google Cloud</a></p></blockquote><p>GCP 的 Regions 和 Zones 為您提供靈活的部署選項，讓您可以根據業務需求來優化應用程式的性能和可靠性。</p><ul><li><strong>數據存儲與處理</strong>：選擇距離最近的 Region 來降低延遲，提升用戶體驗。分散數據存儲於多個 Zones 也能減少單點故障風險。</li><li><strong>高可用性與容災</strong>：利用多 Zone 部署，確保應用的高可用性。如果某個 Zone 出現故障，其他 Zones 可以即時接手，保持應用運行。</li></ul><h1 id="GCP-在亞太地區的-Regions-概況"><a href="#GCP-在亞太地區的-Regions-概況" class="headerlink" title="GCP 在亞太地區的 Regions 概況"></a>GCP 在亞太地區的 Regions 概況</h1><p>針對台灣的使用者，GCP 提供了多個在亞太地區的 Regions，這些 Regions 可以有效降低延遲並提供良好的網路連接性。以下是對台灣使用者最具吸引力的幾個 Regions：</p><ul><li><strong>台灣（asia-east1）</strong>：這是距離台灣最近的 Region，可以提供最低的延遲。</li><li><strong>香港（asia-east2）</strong>：在亞洲其他地區擁有業務的台灣公司可以考慮香港 Region。</li><li><strong>新加坡（asia-southeast1）</strong>：對於東南亞業務需求較大的公司，新加坡 Region 是不錯的選擇。</li></ul><p>在選擇 Region 時，台灣的使用者應該根據業務需求、數據主權考量、法律合規性以及成本來做出決定。</p><h1 id="如何選擇適合的-Region-和-Zone"><a href="#如何選擇適合的-Region-和-Zone" class="headerlink" title="如何選擇適合的 Region 和 Zone"></a>如何選擇適合的 Region 和 Zone</h1><p>選擇適合的 Region 和 Zone 是確保應用高效運行的重要步驟。以下是幾個關鍵考量：</p><ul><li><strong>性能與延遲</strong>：GCP 提供工具來測量不同 Regions 和 Zones 的延遲。使用者可以利用這些工具來選擇延遲最低的 Region。</li><li><strong>成本考量</strong>：不同的 Regions 可能會有不同的費用結構。在選擇 Region 時，除了性能，也需要考量運營成本。</li></ul><p><img src="https://hackmd.io/_uploads/Skgm0WXoC.png" alt="image"></p><blockquote><p>各據點的產品供應情形：<a href="https://cloud.google.com/about/locations">Regions and Zones | Google Cloud</a></p></blockquote><p>在選擇地區時可以先查看一下，你會使用到的服務在那個地區有沒有支援</p><h1 id="如何在同一-Region-內實現高可用性？"><a href="#如何在同一-Region-內實現高可用性？" class="headerlink" title="如何在同一 Region 內實現高可用性？"></a>如何在同一 Region 內實現高可用性？</h1><p>為了在同一 Region 內達到高可用性，GCP 提供了 <strong>Zones</strong> 概念。每個 Region 內有三個或更多的 Zones，這些 Zones 透過低延遲的網路連接在一起。這樣的設計可以提高應用的可用性和故障容忍度。</p><ul><li><strong>增加可用性與容錯性</strong>：多 Zone 部署可以確保即使某個 Zone 出現故障，應用仍然能夠正常運行。</li></ul><h1 id="GCP-Regions-和-Zones-的最佳實踐"><a href="#GCP-Regions-和-Zones-的最佳實踐" class="headerlink" title="GCP Regions 和 Zones 的最佳實踐"></a>GCP Regions 和 Zones 的最佳實踐</h1><ul><li><strong>多 Zone 部署</strong>：為了提高應用的高可用性，建議在多個 Zones 部署應用，這樣即使某個 Zone 出現故障，其他 Zones 也可以接手。</li><li><strong>跨 Region 備份與容災</strong>：設定跨 Region 的備份計劃有助於保障數據安全，防止在單一 Region 失效時數據丟失。</li></ul><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>選擇適當的 GCP Region 和 Zone 是確保雲端應用高效、可靠運行的關鍵。對於台灣的使用者，應根據具體業務需求選擇最合適的 Region 和 Zone，並採取最佳實踐來優化部署策略。</p><p>今天介紹了 Regions 和 Zones，其實目前感覺最簡單是從最接近的點，然後如果是預算沒有上限最好是所有地區都部屬資料中心，這樣可用性最高，但最終還是要考量成本跟預算來做最好的配置，</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/21/GCP-Google-Cloud-Platform-%E7%9A%84%E5%9C%B0%E5%8D%80-Regions-%E5%92%8C%E5%8D%80%E5%9F%9F-Zones/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Google 的雲端服務 Google Cloud Platform 介紹</title>
      <link>https://gahgah147.github.io/2024/08/21/GCP-Google-%E7%9A%84%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99-Google-Cloud-Platform-%E4%BB%8B%E7%B4%B9/</link>
      <guid>https://gahgah147.github.io/2024/08/21/GCP-Google-%E7%9A%84%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99-Google-Cloud-Platform-%E4%BB%8B%E7%B4%B9/</guid>
      <pubDate>Wed, 21 Aug 2024 02:39:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/rkfsA6zo0.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在這個數位化轉型的時代，雲端運算已成為企業快速發展和應對市場變化的關鍵。Google Cloud Platform (GCP) 作</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/rkfsA6zo0.png" alt="image"></p><p>在這個數位化轉型的時代，雲端運算已成為企業快速發展和應對市場變化的關鍵。Google Cloud Platform (GCP) 作為領先的雲端服務提供商之一，為各種規模的企業提供了豐富的工具和服務，助力他們實現創新、優化運營並提高效率。本篇文章將深入探討 GCP 的核心功能、使用案例以及為什麼它是現代企業的理想選擇。</p><p><img src="https://hackmd.io/_uploads/S1dCpTfiC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/">https://cloud.google.com</a></p></blockquote><h1 id="什麼是-Google-Cloud-Platform？"><a href="#什麼是-Google-Cloud-Platform？" class="headerlink" title="什麼是 Google Cloud Platform？"></a>什麼是 Google Cloud Platform？</h1><p>Google Cloud Platform 是由 Google 提供的綜合雲端服務套件，涵蓋了運算、存儲、數據分析、人工智慧、機器學習、網路等多個領域。GCP 的產品組合多樣化，無論是初創公司還是大型企業，都能在 GCP 上找到適合自己的解決方案。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li><strong>彈性運算能力</strong>：GCP 提供多種運算選項，如 Compute Engine 的虛擬機、Kubernetes Engine 的容器編排，以及 Cloud Run 的無伺服器運算，滿足不同工作負載的需求。</li><li><strong>強大的存儲和數據管理</strong>：從 Cloud Storage 的物件存儲，到 BigQuery 的數據分析，GCP 為各類數據提供高可用性、可擴展性和安全性。</li><li><strong>先進的人工智慧和機器學習</strong>：GCP 擁有強大的 AI&#x2F;ML 工具，如 Vertex AI，助力企業構建、訓練和部署機器學習模型，輕鬆實現 AI 驅動的業務創新。</li><li><strong>全球網路基礎設施</strong>：依託於 Google 的全球網路，GCP 提供快速、安全、可靠的網路服務，確保應用和服務在全球範圍內的穩定運行。</li></ol><h1 id="目前主流的雲端服務"><a href="#目前主流的雲端服務" class="headerlink" title="目前主流的雲端服務"></a>目前主流的雲端服務</h1><p>目前市面上最主要的雲端服務有三家，Google 提供的Google Cloud Platform (GCP)、Amazon提供的Amazon Web Services (AWS)、微軟提供的Microsoft Azure </p><h2 id="Google-Cloud-Platform-GCP"><a href="#Google-Cloud-Platform-GCP" class="headerlink" title="Google Cloud Platform (GCP)"></a><strong>Google Cloud Platform (GCP)</strong></h2><ul><li>由 Google 提供的綜合雲端服務平台，涵蓋運算、存儲、數據分析、機器學習等多領域，擁有強大的全球網路基礎設施。</li></ul><h2 id="Amazon-Web-Services-AWS"><a href="#Amazon-Web-Services-AWS" class="headerlink" title="Amazon Web Services (AWS)"></a><strong>Amazon Web Services (AWS)</strong></h2><ul><li>亞馬遜提供的雲端平台，是目前全球市場份額最大的雲服務提供商。AWS 提供超過 200 種服務，包括運算、存儲、數據庫、機器學習、物聯網等。</li></ul><h2 id="Microsoft-Azure"><a href="#Microsoft-Azure" class="headerlink" title="Microsoft Azure"></a><strong>Microsoft Azure</strong></h2><ul><li>微軟的雲端服務平台，擁有廣泛的產品和解決方案，涵蓋運算、人工智慧、數據分析、混合雲、物聯網等領域，並且與 Windows Server 和 SQL Server 等微軟產品高度整合。</li></ul><h1 id="為什麼選擇-Google-Cloud-Platform？"><a href="#為什麼選擇-Google-Cloud-Platform？" class="headerlink" title="為什麼選擇 Google Cloud Platform？"></a>為什麼選擇 Google Cloud Platform？</h1><h2 id="安全性和合規性"><a href="#安全性和合規性" class="headerlink" title="安全性和合規性"></a>安全性和合規性</h2><p>GCP 在安全性上設置了多層保護機制，包括資料加密、自動防禦 DDoS 攻擊、身份驗證管理等，並且符合多項全球和區域的合規標準，讓企業無需擔心數據安全問題。</p><h2 id="可擴展性和彈性"><a href="#可擴展性和彈性" class="headerlink" title="可擴展性和彈性"></a>可擴展性和彈性</h2><p>無論是小規模的試驗項目還是全球範圍的大型應用，GCP 都能隨時隨需擴展，確保系統始終保持最佳性能。這使得企業能夠靈活應對業務增長和市場變化。過去，企業需要購買足夠的基礎設施來應對高峰期的流量需求，但這導致了在低負載時期的資源浪費。使用 GCP 等雲端服務，企業可以按需彈性擴展或縮減資源，確保資源利用率最大化，並降低前期成本。</p><h2 id="降低前期成本與風險"><a href="#降低前期成本與風險" class="headerlink" title="降低前期成本與風險"></a>降低前期成本與風險</h2><p>傳統上，企業需要提前購買大量基礎設施來應對潛在的業務增長，這不僅成本高昂，風險也相對較大。如果這些預期未能實現，投資便成為沉沒成本。GCP 的按需付費模式幫助企業減少了這種風險，使他們能夠更靈活地管理資本支出，將更多資源投入到核心業務中。</p><h2 id="高資源利用率與自動化運維"><a href="#高資源利用率與自動化運維" class="headerlink" title="高資源利用率與自動化運維"></a>高資源利用率與自動化運維</h2><p>在傳統的基礎設施模式下，企業常因應對高峰負載而購買過多的資源，導致大部分時間基礎設施處於閒置狀態。使用 GCP，企業只需為實際使用的資源付費，並且無需專門的維護團隊來管理和維護硬體資源，這對初創公司和中小型企業尤為有利。此外，GCP 提供了自動化的資源管理功能，企業可以將更多精力專注於創新和業務增長。</p><h2 id="整合性與生態系統"><a href="#整合性與生態系統" class="headerlink" title="整合性與生態系統"></a>整合性與生態系統</h2><p>GCP 與許多流行的開源工具、第三方應用以及其他 Google 產品無縫整合，如 Firebase、Google Workspace 等，形成了一個強大且多樣化的生態系統，支持企業構建現代化應用。這樣的整合性讓企業能夠輕鬆地運用多種工具與服務，快速響應市場需求，並持續優化其業務流程。</p><h1 id="GCP-的常見使用案例"><a href="#GCP-的常見使用案例" class="headerlink" title="GCP 的常見使用案例"></a>GCP 的常見使用案例</h1><ol><li><strong>現代應用開發</strong>：利用 GKE、Cloud Functions、App Engine 等服務，快速構建和部署可擴展的雲端應用。</li><li><strong>大數據和分析</strong>：結合 BigQuery、Dataflow 和 Looker，實現大數據的高效存儲、處理和分析。</li><li><strong>人工智慧與機器學習</strong>：透過 Vertex AI、TensorFlow 等工具，為產品和服務引入智能化功能。</li></ol><h1 id="如何開始試用GCP"><a href="#如何開始試用GCP" class="headerlink" title="如何開始試用GCP?"></a>如何開始試用GCP?</h1><p>這邊看到可以取得$300的抵免額，能夠在未來 90 天內試用 Google Cloud。<br>免費試用期結束後不會自動收費，所以大家有興趣可以申請試用3個月看看</p><p><img src="https://hackmd.io/_uploads/HJpzl0MsA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/">https://cloud.google.com</a></p></blockquote><p>這邊可以點選右上角的免費試用開始註冊</p><p><img src="https://hackmd.io/_uploads/H1o7eCzjA.png" alt="image"></p><p>選擇完地區後點選同意並繼續</p><p>接下來是填寫付款資訊，填寫完成後就可以開始試用GCP了<br><img src="https://hackmd.io/_uploads/rJOEx0fjC.png" alt="image"></p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Google Cloud Platform 以其廣泛的服務、強大的功能和卓越的性能，成為了眾多企業數位化轉型的首選平台。無論您是希望優化現有系統，還是構建新一代應用，GCP 都能提供無與倫比的支援和保障。如果您還未開始使用 GCP，現在正是踏上雲端之旅的最佳時機。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/21/GCP-Google-%E7%9A%84%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99-Google-Cloud-Platform-%E4%BB%8B%E7%B4%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP：使用 Google Cloud Storage Transfer Service 管理資料轉移</title>
      <link>https://gahgah147.github.io/2024/08/20/GCP%EF%BC%9A%E4%BD%BF%E7%94%A8-Google-Cloud-Storage-Transfer-Service-%E7%AE%A1%E7%90%86%E8%B3%87%E6%96%99%E8%BD%89%E7%A7%BB/</link>
      <guid>https://gahgah147.github.io/2024/08/20/GCP%EF%BC%9A%E4%BD%BF%E7%94%A8-Google-Cloud-Storage-Transfer-Service-%E7%AE%A1%E7%90%86%E8%B3%87%E6%96%99%E8%BD%89%E7%A7%BB/</guid>
      <pubDate>Tue, 20 Aug 2024 09:15:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/ByI180-jR.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在當今數據驅動的世界中，資料管理和遷移對企業來說至關重要。無論是從本地環境到雲端，還是跨雲平台間的資料轉移，選擇合適的工具是成功的</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/ByI180-jR.png" alt="image"></p><p>在當今數據驅動的世界中，資料管理和遷移對企業來說至關重要。無論是從本地環境到雲端，還是跨雲平台間的資料轉移，選擇合適的工具是成功的關鍵。這篇文章將介紹 Google Cloud 的 Storage Transfer Service（STS），並探討其核心功能、使用案例以及如何輕鬆管理大規模資料轉移。</p><h1 id="什麼是-Storage-Transfer-Service？"><a href="#什麼是-Storage-Transfer-Service？" class="headerlink" title="什麼是 Storage Transfer Service？"></a>什麼是 Storage Transfer Service？</h1><p>以下是官方說明文件<br><img src="https://hackmd.io/_uploads/SJEewRbsA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/storage-transfer/docs/overview">https://cloud.google.com/storage-transfer/docs/overview</a></p></blockquote><p>Google Cloud Storage Transfer Service (STS) 是一個功能強大的工具，專為在各種來源之間自動化大規模資料轉移而設計。無論您需要從本地環境、其他雲端存儲提供者，或在 Google Cloud 的不同存儲桶之間進行資料遷移，STS 都能提供靈活且高效的解決方案。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul><li><strong>多源支援</strong>：STS 支援多種資料來源，如 Amazon S3、Microsoft Azure、Hadoop 分布式文件系統（HDFS）等，讓您能輕鬆整合來自不同平台的資料。</li><li><strong>定時和增量傳輸</strong>：您可以設定定時任務以自動化資料轉移，並支援增量傳輸，確保只轉移新數據，節省時間和資源。</li><li><strong>資料驗證和容錯</strong>：在資料轉移過程中，STS 會自動執行資料完整性驗證，並具有錯誤重試機制，以確保資料轉移的可靠性。</li><li><strong>無縫整合</strong>：與 Google Cloud Storage、BigQuery 等其他 GCP 服務無縫整合，簡化數據流程。</li></ul><h2 id="Storage-Transfer-Service-的使用案例"><a href="#Storage-Transfer-Service-的使用案例" class="headerlink" title="Storage Transfer Service 的使用案例"></a>Storage Transfer Service 的使用案例</h2><ol><li><strong>雲端資料遷移</strong>：將資料從本地資料中心遷移至 Google Cloud Storage，提升可用性和擴展性。</li><li><strong>跨平台資料整合</strong>：從其他雲端平台轉移資料至 GCP，以統一管理和分析。</li><li><strong>資料備份與恢復</strong>：定期將資料備份到不同的 GCP 存儲桶，以增強資料安全性和恢復能力。</li></ol><h1 id="如何使用-Storage-Transfer-Service？"><a href="#如何使用-Storage-Transfer-Service？" class="headerlink" title="如何使用 Storage Transfer Service？"></a>如何使用 Storage Transfer Service？</h1><p>使用 Storage Transfer Service 進行資料轉移的流程相當簡單：</p><ol><li><strong>設定來源和目標</strong>：選擇資料來源（如本地檔案系統或其他雲端平台）和目標（GCS 存儲桶）。</li><li><strong>定義轉移規則</strong>：設定轉移的時間表、範圍（全量或增量），以及是否進行資料壓縮或解壓縮。</li><li><strong>啟動轉移</strong>：開始資料轉移並監控過程，您可以查看傳輸進度、錯誤報告等。</li></ol><p>以下是開始移轉的官方文件<br><img src="https://hackmd.io/_uploads/H1yhDRWoC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/storage-transfer/docs/create-transfers#create_a_transfer">https://cloud.google.com/storage-transfer/docs/create-transfers#create_a_transfer</a></p></blockquote><p>這邊可以看到有多種方式，也可以選擇多種資源，依照實際需求來使用<br><img src="https://hackmd.io/_uploads/SJGz_RWo0.png" alt="image"></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>Google Cloud Storage Transfer Service 是一個功能強大且靈活的工具，能幫助企業有效地管理和遷移大量資料。不論是從本地環境、其他雲端平台，還是 GCP 內部的資料轉移，STS 都能提供可靠的解決方案，滿足多樣化的業務需求。如果您正考慮進行資料遷移，不妨嘗試使用 Storage Transfer Service 來簡化流程並提升效能。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%B3%87%E6%96%99%E8%BD%89%E7%A7%BB/">資料轉移</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/20/GCP%EF%BC%9A%E4%BD%BF%E7%94%A8-Google-Cloud-Storage-Transfer-Service-%E7%AE%A1%E7%90%86%E8%B3%87%E6%96%99%E8%BD%89%E7%A7%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - 雲端證照課程 GCP Associate Cloud Engineer 準備</title>
      <link>https://gahgah147.github.io/2024/08/20/GCP-%E9%9B%B2%E7%AB%AF%E8%AD%89%E7%85%A7%E8%AA%B2%E7%A8%8B-GCP-Associate-Cloud-Engineer-%E6%BA%96%E5%82%99/</link>
      <guid>https://gahgah147.github.io/2024/08/20/GCP-%E9%9B%B2%E7%AB%AF%E8%AD%89%E7%85%A7%E8%AA%B2%E7%A8%8B-GCP-Associate-Cloud-Engineer-%E6%BA%96%E5%82%99/</guid>
      <pubDate>Tue, 20 Aug 2024 05:56:35 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;什麼是-GCP-Associate-Cloud-Engineer？&quot;&gt;&lt;a href=&quot;#什麼是-GCP-Associate-Cloud-Engineer？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 GCP Associate Cloud En</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="什麼是-GCP-Associate-Cloud-Engineer？"><a href="#什麼是-GCP-Associate-Cloud-Engineer？" class="headerlink" title="什麼是 GCP Associate Cloud Engineer？"></a>什麼是 GCP Associate Cloud Engineer？</h1><p>這邊是Google 的 Associate Cloud Engineer 官方文件</p><p><img src="https://hackmd.io/_uploads/ryCkm3WjC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/learn/certification/cloud-engineer">https://cloud.google.com/learn/certification/cloud-engineer</a></p></blockquote><p><img src="https://hackmd.io/_uploads/S1iVmhbjC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/blog/topics/training-certifications/which-google-cloud-certification-exam-should-you-take">https://cloud.google.com/blog/topics/training-certifications/which-google-cloud-certification-exam-should-you-take</a></p></blockquote><p>   Google Certified Associate Cloud Engineer 認證表示您能夠部署應用程式、監控運營和管理企業解決方案。此認證證明您具備使用 Google Cloud Console 和命令行介面執行常見基於平台任務的能力，以維護部署在 Google Cloud 上的解決方案。</p><h1 id="GCP-官方有哪些認證"><a href="#GCP-官方有哪些認證" class="headerlink" title="GCP 官方有哪些認證?"></a>GCP 官方有哪些認證?</h1><p>以下是Google Cloud 認證官方說明文件<br><img src="https://hackmd.io/_uploads/SJmSM2ZoA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/learn/certification?hl=zh_tw#why-get-google-cloud-certified">https://cloud.google.com/learn/certification?hl=zh_tw#why-get-google-cloud-certified</a></p></blockquote><p><strong>Cloud Digital Leader (雲端數位領袖課程)</strong> - 此認證適合任何希望展示其雲端運算基礎知識的人，並展示如何使用 Google Cloud 產品和服務來實現組織目標。</p><p><strong>Associate Cloud Engineer (雲端工程師)</strong> - 此認證適合具有 Google Cloud 基礎知識和經驗的候選人，這些人需具備部署雲端應用、監控運作、以及管理雲端企業解決方案的能力。</p><p><strong>Professional Google Cloud Certifications (專業 Google Cloud 認證)</strong> - 這些認證適合具備深入經驗，能夠根據組織業務需求，為其設置雲端環境，並有服務和解決方案部署經驗的候選人。</p><ul><li><strong>Professional Cloud Architect (雲端架構師)</strong></li><li><strong>Professional Cloud Developer (雲端開發人員)</strong></li><li><strong>Professional Data Engineer (資料工程師)</strong></li><li><strong>Professional Cloud Database Engineer (雲端資料庫工程師)</strong></li><li><strong>Professional DevOps Engineer (雲端開發運作工程師)</strong></li><li><strong>Professional Machine Learning Engineer (機器學習工程師)</strong></li><li><strong>Professional Network Engineer (雲端網路工程師)</strong></li><li><strong>Professional Security Engineer (雲端資安工程師)</strong></li><li><strong>Professional Workspace Administrator (Google Workspace 管理員)</strong></li></ul><p>這邊可以看到Associate Cloud Engineer 是在第二階段的認證</p><h1 id="Associate-Cloud-Engineer-認證驗證的能力"><a href="#Associate-Cloud-Engineer-認證驗證的能力" class="headerlink" title="Associate Cloud Engineer 認證驗證的能力"></a>Associate Cloud Engineer 認證驗證的能力</h1><ul><li>設置雲解決方案環境</li><li>規劃和配置雲解決方案</li><li>部署和實施雲解決方案</li><li>確保雲解決方案的成功運行</li><li>配置訪問和安全性</li></ul><h1 id="Associate-Cloud-Engineer-認證學習路徑"><a href="#Associate-Cloud-Engineer-認證學習路徑" class="headerlink" title="Associate Cloud Engineer 認證學習路徑"></a>Associate Cloud Engineer 認證學習路徑</h1><p>根據恆逸的建議，完成以下三個課程後，能更有效地準備 GCP Associate Cloud Engineer 認證考試：<br><img src="https://hackmd.io/_uploads/SyYjNKbo0.png" alt="image"></p><ol><li><p><strong>GCPFU (Google Cloud基礎知識之核心基礎架構)</strong> </p><ul><li>課程名: Google Cloud Fundamentals: Core Infrastructure</li></ul></li><li><p><strong>GCPAR (使用Google Compute Engine進行架構設計)</strong> </p><ul><li>課程名: Architecting with Google Compute Engine</li></ul></li><li><p><strong>GCPK8S (使用Google Kubernetes Engine進行架構設計)</strong> </p><ul><li>課程名: Architecting with Google Kubernetes Engine</li></ul></li></ol><h1 id="考試內容"><a href="#考試內容" class="headerlink" title="考試內容"></a>考試內容</h1><ul><li>時長：2小時</li><li>註冊費：125美元</li><li>考試形式：Multiple choice and multiple select，遠端或親自在Kryterion考試中心進行。</li><li>先決條件：無</li><li>推薦經驗：6個月以上Google Cloud實務經驗。</li><li>認證更新&#x2F;重新認證：考生必須重新認證以保持其認證狀態。除非在詳細的考試說明中明確說明，否則所有Google Cloud認證的有效期為自認證之日起兩年。您可以在認證到期日期前60天開始嘗試重新認證。</li></ul><h1 id="考試準備資源與建議"><a href="#考試準備資源與建議" class="headerlink" title="考試準備資源與建議"></a>考試準備資源與建議</h1><h2 id="恆逸的課程"><a href="#恆逸的課程" class="headerlink" title="恆逸的課程"></a>恆逸的課程</h2><table><thead><tr><th>課程名稱</th><th>課程簡稱</th><th>時數</th><th>費用</th><th>點數</th><th>連結</th></tr></thead><tbody><tr><td>Google Cloud基礎知識之核心基礎架構</td><td>GCPFU</td><td>7小時</td><td>NT$ 14,000</td><td>3.5</td><td><a href="https://www.uuu.com.tw/Course/Show/1771/Google-Cloud%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E4%B9%8B%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A4%8E%E6%9E%B6%E6%A7%8B">課程連結</a></td></tr><tr><td>使用Google Compute Engine進行架構設計</td><td>GCPAR</td><td>21小時</td><td>NT$ 42,000</td><td>11.0</td><td><a href="https://www.uuu.com.tw/Course/Show/1772/%E4%BD%BF%E7%94%A8Google-Compute-Engine%E9%80%B2%E8%A1%8C%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88">課程連結</a></td></tr><tr><td>使用Google Kubernetes Engine進行架構設計</td><td>GCPK8S</td><td>21小時</td><td>NT$ 42,000</td><td>11.0</td><td><a href="https://www.uuu.com.tw/Course/Show/1889/%E4%BD%BF%E7%94%A8Google-Kubernetes-Engine%E9%80%B2%E8%A1%8C%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88">課程連結</a></td></tr></tbody></table><h2 id="Udemy-課程"><a href="#Udemy-課程" class="headerlink" title="Udemy 課程"></a>Udemy 課程</h2><p>GCP Associate Cloud Engineer - Google Cloud Certification<br><img src="https://hackmd.io/_uploads/r1yyhFbiA.png" alt="image"></p><blockquote><p><a href="https://www.udemy.com/course/google-cloud-certification-associate-cloud-engineer/?couponCode=SKILLS4SALEB">https://www.udemy.com/course/google-cloud-certification-associate-cloud-engineer/?couponCode=SKILLS4SALEB</a></p></blockquote><h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><p><a href="https://www.uuu.com.tw/Course/Partner/Google/section=exam/title=Google%20Cloud%20%E8%AA%8D%E8%AD%89%E8%80%83%E8%A9%A6%E4%BB%8B%E7%B4%B9">恆逸 - Google Cloud 認證考試介紹</a></p><p><a href="https://www.udemy.com/course/google-cloud-certification-associate-cloud-engineer/?couponCode=SKILLS4SALEA">Udemy : GCP Associate Cloud Engineer - Google Cloud Certification</a></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>以上是我目前得知關於GCP Associate Cloud Engineer 認證的資訊，我準備是想要先從Udemy這邊的課程來進行準備，因為課程價格目前看來是最低的，另外之後可能也要定期進行證照的更新。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E8%AD%89%E7%85%A7/">雲端證照</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/20/GCP-%E9%9B%B2%E7%AB%AF%E8%AD%89%E7%85%A7%E8%AA%B2%E7%A8%8B-GCP-Associate-Cloud-Engineer-%E6%BA%96%E5%82%99/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP - Google Cloud Storage (GCS) Google 雲端儲存服務介紹</title>
      <link>https://gahgah147.github.io/2024/08/19/GCP-Google-Cloud-Storage-GCS-Google-%E9%9B%B2%E7%AB%AF%E5%84%B2%E5%AD%98%E6%9C%8D%E5%8B%99%E4%BB%8B%E7%B4%B9/</link>
      <guid>https://gahgah147.github.io/2024/08/19/GCP-Google-Cloud-Storage-GCS-Google-%E9%9B%B2%E7%AB%AF%E5%84%B2%E5%AD%98%E6%9C%8D%E5%8B%99%E4%BB%8B%E7%B4%B9/</guid>
      <pubDate>Mon, 19 Aug 2024 02:33:08 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/Hyk8cFhcC.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在現今的雲端計算時代，儲存和管理大量數據變得比以往任何時候都更加重要。Google Cloud Storage (GCS) 作為 </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/Hyk8cFhcC.png" alt="image"></p><p>在現今的雲端計算時代，儲存和管理大量數據變得比以往任何時候都更加重要。Google Cloud Storage (GCS) 作為 Google Cloud Platform (GCP) 的核心服務之一，提供了一個可靠且可擴展的物件儲存解決方案，適用於各種應用場景。</p><p>簡單來說 Google Cloud Storage 就是在 Google 雲端平台上用來儲存東西的工具。</p><h2 id="什麼是-Google-Cloud-Storage"><a href="#什麼是-Google-Cloud-Storage" class="headerlink" title="什麼是 Google Cloud Storage?"></a>什麼是 Google Cloud Storage?</h2><p>有使用 Google cloud plateform(GCP) 的話可以在介面中查詢到cloud storage像是以下這邊的圖案<br><img src="https://hackmd.io/_uploads/H1tLYq3cC.png" alt="image"></p><p>且在右方可以看到一系列的官方教學說明，其實建議詳細操作之後就會對這個功能比較熟悉<br><img src="https://hackmd.io/_uploads/HJnpYq29R.png" alt="image"></p><p>另外以下是Google Cloud Storage 的官方介紹文章<br><img src="https://hackmd.io/_uploads/SJodtt35C.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/storage?hl=zh-TW">https://cloud.google.com/storage?hl=zh-TW</a></p></blockquote><p>Google Cloud Storage 是一個物件儲存服務，它允許使用者在雲端中存儲任意大小的數據，包括結構化和非結構化數據。GCS 提供了高可用性和耐久性，並支持全球範圍內的數據存取，這使得它成為企業和開發者的理想選擇。</p><p>以下是官方的教學介紹影片<br><a href="https://youtu.be/wNOs3LlsH6k">https://youtu.be/wNOs3LlsH6k</a></p><h2 id="Google-Cloud-Storage-的主要功能有哪些"><a href="#Google-Cloud-Storage-的主要功能有哪些" class="headerlink" title="Google Cloud Storage 的主要功能有哪些?"></a>Google Cloud Storage 的主要功能有哪些?</h2><h3 id="1-一流的數據分析和機器學習-AI-工具：當資料存入-Cloud-Storage-後，即可輕鬆運用-Google-Cloud-的強大工具，包括使用-BigQuery-建立資料倉儲，使用-Dataproc-執行開放原始碼數據分析，或使用-Vertex-AI-建構及部署機器學習-ML-模型。。"><a href="#1-一流的數據分析和機器學習-AI-工具：當資料存入-Cloud-Storage-後，即可輕鬆運用-Google-Cloud-的強大工具，包括使用-BigQuery-建立資料倉儲，使用-Dataproc-執行開放原始碼數據分析，或使用-Vertex-AI-建構及部署機器學習-ML-模型。。" class="headerlink" title="1. 一流的數據分析和機器學習&#x2F;AI 工具：當資料存入 Cloud Storage 後，即可輕鬆運用 Google Cloud 的強大工具，包括使用 BigQuery 建立資料倉儲，使用 Dataproc 執行開放原始碼數據分析，或使用 Vertex AI 建構及部署機器學習 (ML) 模型。。"></a>1. <strong>一流的數據分析和機器學習&#x2F;AI 工具</strong>：當資料存入 Cloud Storage 後，即可輕鬆運用 Google Cloud 的強大工具，包括使用 BigQuery 建立資料倉儲，使用 Dataproc 執行開放原始碼數據分析，或使用 Vertex AI 建構及部署機器學習 (ML) 模型。。</h3><p><img src="https://hackmd.io/_uploads/HJLESc3cA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes">https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes</a></p></blockquote><h3 id="2-自動轉換儲存空間級別：透過物件生命週期管理-OLM-、自動調整級別等功能，您可以輕鬆利用不同儲存空間級別來存放物件，獲得最佳成本效益。您可以在值區層級設定政策，按照上次存取時間自動將物件移至存取頻率較低的儲存空間級別。在存取頻率較低的儲存空間級別中，提前刪除資料或擷取資料都不會產生費用，也沒有級別轉換費用。"><a href="#2-自動轉換儲存空間級別：透過物件生命週期管理-OLM-、自動調整級別等功能，您可以輕鬆利用不同儲存空間級別來存放物件，獲得最佳成本效益。您可以在值區層級設定政策，按照上次存取時間自動將物件移至存取頻率較低的儲存空間級別。在存取頻率較低的儲存空間級別中，提前刪除資料或擷取資料都不會產生費用，也沒有級別轉換費用。" class="headerlink" title="2. 自動轉換儲存空間級別：透過物件生命週期管理 (OLM)、自動調整級別等功能，您可以輕鬆利用不同儲存空間級別來存放物件，獲得最佳成本效益。您可以在值區層級設定政策，按照上次存取時間自動將物件移至存取頻率較低的儲存空間級別。在存取頻率較低的儲存空間級別中，提前刪除資料或擷取資料都不會產生費用，也沒有級別轉換費用。"></a>2. <strong>自動轉換儲存空間級別</strong>：透過物件生命週期管理 (OLM)、自動調整級別等功能，您可以輕鬆利用不同儲存空間級別來存放物件，獲得最佳成本效益。您可以在值區層級設定政策，按照上次存取時間自動將物件移至存取頻率較低的儲存空間級別。在存取頻率較低的儲存空間級別中，提前刪除資料或擷取資料都不會產生費用，也沒有級別轉換費用。</h3><p><img src="https://hackmd.io/_uploads/rkp5H9n9C.png" alt="image"></p><h3 id="3-有服務水準協議保證的洲際規模複製機制：領先業界的雙區域值區支援大量區域。單一的洲際規模值區提供橫跨三大洲的九個區域，復原時間目標-RTO-為零。即便服務發生中斷，應用程式也能順暢存取備用區域中的資料，沒有容錯移轉和容錯回復過程。如果機構的可用性需求極高，搭配使用強化型複製功能與雙區域值區可以提供-15-分鐘的復原點目標-RPO-服務水準協議。"><a href="#3-有服務水準協議保證的洲際規模複製機制：領先業界的雙區域值區支援大量區域。單一的洲際規模值區提供橫跨三大洲的九個區域，復原時間目標-RTO-為零。即便服務發生中斷，應用程式也能順暢存取備用區域中的資料，沒有容錯移轉和容錯回復過程。如果機構的可用性需求極高，搭配使用強化型複製功能與雙區域值區可以提供-15-分鐘的復原點目標-RPO-服務水準協議。" class="headerlink" title="3. 有服務水準協議保證的洲際規模複製機制：領先業界的雙區域值區支援大量區域。單一的洲際規模值區提供橫跨三大洲的九個區域，復原時間目標 (RTO) 為零。即便服務發生中斷，應用程式也能順暢存取備用區域中的資料，沒有容錯移轉和容錯回復過程。如果機構的可用性需求極高，搭配使用強化型複製功能與雙區域值區可以提供 15 分鐘的復原點目標 (RPO) 服務水準協議。"></a>3. <strong>有服務水準協議保證的洲際規模複製機制</strong>：領先業界的雙區域值區支援大量區域。單一的洲際規模值區提供橫跨三大洲的九個區域，復原時間目標 (RTO) 為零。即便服務發生中斷，應用程式也能順暢存取備用區域中的資料，沒有容錯移轉和容錯回復過程。如果機構的可用性需求極高，搭配使用強化型複製功能與雙區域值區可以提供 15 分鐘的復原點目標 (RPO) 服務水準協議。</h3><h3 id="4-使用-Cloud-Storage-做為本機檔案系統：使用者經常選用-Cloud-Storage-儲存訓練資料、模型和查核點，以供-Cloud-Storage-值區中的機器學習專案中的機器學習專案使用。Cloud-Storage-FUSE-不僅能讓您充分發揮-Cloud-Storage-可擴充、價格實惠、高處理量和簡單易用的特性，同時更支援使用或需要檔案系統語意的應用程式。-Cloud-Storage-FUSE-現在也提供快取功能，與原生機器學習架構資料載入器相比，訓練時間縮短為-2-2-倍，訓練處理量也提升達到-2-9-倍。"><a href="#4-使用-Cloud-Storage-做為本機檔案系統：使用者經常選用-Cloud-Storage-儲存訓練資料、模型和查核點，以供-Cloud-Storage-值區中的機器學習專案中的機器學習專案使用。Cloud-Storage-FUSE-不僅能讓您充分發揮-Cloud-Storage-可擴充、價格實惠、高處理量和簡單易用的特性，同時更支援使用或需要檔案系統語意的應用程式。-Cloud-Storage-FUSE-現在也提供快取功能，與原生機器學習架構資料載入器相比，訓練時間縮短為-2-2-倍，訓練處理量也提升達到-2-9-倍。" class="headerlink" title="4. 使用 Cloud Storage 做為本機檔案系統：使用者經常選用 Cloud Storage 儲存訓練資料、模型和查核點，以供 Cloud Storage 值區中的機器學習專案中的機器學習專案使用。Cloud Storage FUSE 不僅能讓您充分發揮 Cloud Storage 可擴充、價格實惠、高處理量和簡單易用的特性，同時更支援使用或需要檔案系統語意的應用程式。 Cloud Storage FUSE 現在也提供快取功能，與原生機器學習架構資料載入器相比，訓練時間縮短為 2.2 倍，訓練處理量也提升達到 2.9 倍。"></a>4. <strong>使用 Cloud Storage 做為本機檔案系統</strong>：使用者經常選用 Cloud Storage 儲存訓練資料、模型和查核點，以供 Cloud Storage 值區中的機器學習專案中的機器學習專案使用。Cloud Storage FUSE 不僅能讓您充分發揮 Cloud Storage 可擴充、價格實惠、高處理量和簡單易用的特性，同時更支援使用或需要檔案系統語意的應用程式。 Cloud Storage FUSE 現在也提供快取功能，與原生機器學習架構資料載入器相比，訓練時間縮短為 2.2 倍，訓練處理量也提升達到 2.9 倍。</h3><p><img src="https://hackmd.io/_uploads/BkY0SqhqR.png" alt="image"></p><h3 id="5-利用檔案目錄報告管理物件儲存空間-目錄報告包含與物件相關的中繼資料資訊，例如物件的儲存空間級別、ETag-和內容類型。這些資訊可協助您分析儲存成本、稽核及驗證物件，並確保資料安全無虞且符合法規。您可以將目錄報告匯出為半形逗號分隔值-CSV-檔案或-Apache-Parquet-檔案，進一步使用-BigQuery-等工具進行分析。進一步瞭解儲存空間分析目錄報告。"><a href="#5-利用檔案目錄報告管理物件儲存空間-目錄報告包含與物件相關的中繼資料資訊，例如物件的儲存空間級別、ETag-和內容類型。這些資訊可協助您分析儲存成本、稽核及驗證物件，並確保資料安全無虞且符合法規。您可以將目錄報告匯出為半形逗號分隔值-CSV-檔案或-Apache-Parquet-檔案，進一步使用-BigQuery-等工具進行分析。進一步瞭解儲存空間分析目錄報告。" class="headerlink" title="5. 利用檔案目錄報告管理物件儲存空間:目錄報告包含與物件相關的中繼資料資訊，例如物件的儲存空間級別、ETag 和內容類型。這些資訊可協助您分析儲存成本、稽核及驗證物件，並確保資料安全無虞且符合法規。您可以將目錄報告匯出為半形逗號分隔值 (CSV) 檔案或 Apache Parquet 檔案，進一步使用 BigQuery 等工具進行分析。進一步瞭解儲存空間分析目錄報告。"></a>5. <strong>利用檔案目錄報告管理物件儲存空間</strong>:目錄報告包含與物件相關的中繼資料資訊，例如物件的儲存空間級別、ETag 和內容類型。這些資訊可協助您分析儲存成本、稽核及驗證物件，並確保資料安全無虞且符合法規。您可以將目錄報告匯出為半形逗號分隔值 (CSV) 檔案或 Apache Parquet 檔案，進一步使用 BigQuery 等工具進行分析。進一步瞭解儲存空間分析目錄報告。</h3><p><img src="https://hackmd.io/_uploads/ryXz89n5R.png" alt="image"></p><blockquote><p>以上內容都是來自Google cloud storage官方說明文件，還有更多功能可以展開查看<a href="https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes">https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes</a></p></blockquote><h2 id="GCS-的應用場景"><a href="#GCS-的應用場景" class="headerlink" title="GCS 的應用場景"></a>GCS 的應用場景</h2><h3 id="1-數據備份和災難恢復：GCS-是數據備份的理想選擇，並能夠與全球各地的資料中心協同工作來進行災難恢復。"><a href="#1-數據備份和災難恢復：GCS-是數據備份的理想選擇，並能夠與全球各地的資料中心協同工作來進行災難恢復。" class="headerlink" title="1. 數據備份和災難恢復：GCS 是數據備份的理想選擇，並能夠與全球各地的資料中心協同工作來進行災難恢復。"></a>1. <strong>數據備份和災難恢復</strong>：GCS 是數據備份的理想選擇，並能夠與全球各地的資料中心協同工作來進行災難恢復。</h3><p><img src="https://hackmd.io/_uploads/BkD0Uq35C.png" alt="image"></p><blockquote><p>以上圖片是來自Google cloud storage官方說明文件<a href="https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes">https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes</a></p></blockquote><p>運作原理:Cloud Storage 的 <a href="https://cloud.google.com/storage/docs/storage-classes#nearline">Nearline Storage</a> 提供快速、低成本且高度耐用的儲存服務，可用來存放每月存取不到一次的資料，能降低備份和封存成本，並保留即時存取資料的能力。所有儲存空間級別的延遲時間皆為毫秒等級，且透過同一個 API 來存取，所以除了復原作業之外，Cloud Storage 中的備份資料也可以用於其他用途</p><p><a href="https://cloud.google.com/storage/docs/storage-classes#nearline">關於Nearline Storage 的詳細介紹可以參考這個官方文件</a></p><h3 id="2-內容存放與傳遞：GCS-可以作為靜態網站或應用程式資源的存儲位置，並能與-CDN（內容分發網絡）配合，提升內容傳遞速度。"><a href="#2-內容存放與傳遞：GCS-可以作為靜態網站或應用程式資源的存儲位置，並能與-CDN（內容分發網絡）配合，提升內容傳遞速度。" class="headerlink" title="2. 內容存放與傳遞：GCS 可以作為靜態網站或應用程式資源的存儲位置，並能與 CDN（內容分發網絡）配合，提升內容傳遞速度。"></a>2. <strong>內容存放與傳遞</strong>：GCS 可以作為靜態網站或應用程式資源的存儲位置，並能與 CDN（內容分發網絡）配合，提升內容傳遞速度。</h3><p><img src="https://hackmd.io/_uploads/BkX0Pqn5A.png" alt="image"></p><blockquote><p>以上圖片是來自Google cloud storage官方說明文件<a href="https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes">https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes</a></p></blockquote><p>運作原理:利用 Cloud Storage 的異地備援功能，將音訊或視訊直接串流至應用程式或網站。異地備援儲存空間具備最高級別的可用性與效能，因此非常適合以低延遲而高 QPS 的方式，將內容提供給位於不同地理區域的使用者。</p><ol start="3"><li><strong>大數據分析</strong>：GCS 與 BigQuery 等工具整合，方便儲存並分析大量結構化和非結構化數據。</li></ol><p><img src="https://hackmd.io/_uploads/rywxu539R.png" alt="image"></p><blockquote><p>以上圖片是來自Google cloud storage官方說明文件<a href="https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes">https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes</a></p></blockquote><p>運作原理:建立用於數據分析的資料湖泊<br>開發及部署資料管道和儲存空間，以便分析大量資料。Cloud Storage 具備高可用性、效能和同步一致性，可讓您安心地準確處理數據分析工作負載。</p><p><a href="https://cloud.google.com/bigquery/docs/create-cloud-storage-table-biglake#cloud-storage-as-data-lake">關於使用cloud storage建立的資料湖泊(BigLake tables)可以參考這篇官方介紹文件</a></p><ol start="4"><li><strong>機器學習與 AI</strong>:GCS 可以啟動 Google 推薦的預先設定解決方案，透過生成式 AI 快速擷取文字，並為儲存在 Cloud Storage 中的大量文件產生摘要。</li></ol><p><img src="https://hackmd.io/_uploads/Sk8kiqnqC.png" alt="image"></p><blockquote><p>以上圖片是來自Google cloud storage官方說明文件<a href="https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes">https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes</a></p></blockquote><ol start="5"><li><strong>託管網站</strong>：可以使用 Google Cloud 控制台中建構、託管及經營動態網站。</li></ol><p><img src="https://hackmd.io/_uploads/rkWcs525R.png" alt="image"></p><blockquote><p>以上圖片是來自Google cloud storage官方說明文件<a href="https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes">https://cloud.google.com/storage?hl=zh-TW#object-storage-for-companies-of-all-sizes</a></p></blockquote><p>運作原理:使用 Python 和 JavaScript，推出可公開存取及自訂的直接出貨零售產品範例網站。</p><h2 id="如何使用-Google-Cloud-Storage"><a href="#如何使用-Google-Cloud-Storage" class="headerlink" title="如何使用 Google Cloud Storage"></a>如何使用 Google Cloud Storage</h2><h3 id="1-建立-Bucket：在-GCS-中，所有數據都儲存在-Bucket-中。首先，創建一個-Bucket，並選擇適合的存儲類別與區域。"><a href="#1-建立-Bucket：在-GCS-中，所有數據都儲存在-Bucket-中。首先，創建一個-Bucket，並選擇適合的存儲類別與區域。" class="headerlink" title="1. 建立 Bucket：在 GCS 中，所有數據都儲存在 Bucket 中。首先，創建一個 Bucket，並選擇適合的存儲類別與區域。"></a>1. <strong>建立 Bucket</strong>：在 GCS 中，所有數據都儲存在 Bucket 中。首先，創建一個 Bucket，並選擇適合的存儲類別與區域。</h3><p><img src="https://hackmd.io/_uploads/r17mp535C.png" alt="image"></p><blockquote><p>可以先點擊畫面中的Create</p></blockquote><p><img src="https://hackmd.io/_uploads/HyaXG7giC.png" alt="image"></p><blockquote><p>這邊設定bucket的名字，例如 test-bucket-2024-08-19 </p></blockquote><p><img src="https://hackmd.io/_uploads/S1YcfXxsR.png" alt="image"></p><blockquote><p>設定地點</p></blockquote><p><img src="https://hackmd.io/_uploads/SJqnM7lsA.png" alt="image"></p><blockquote><p>選擇儲存類型</p></blockquote><p><img src="https://hackmd.io/_uploads/BkVeX7eiC.png" alt="image"></p><blockquote><p>選擇如何控制對物件的存取權限</p></blockquote><p><img src="https://hackmd.io/_uploads/B15JEQgoR.png" alt="image"></p><blockquote><p>這部份是在解釋如何保護 Google Cloud Storage (GCS) 中的物件數據，以及可用的額外數據保護選項。</p></blockquote><p><strong>選擇如何保護物件數據</strong><br>您的數據在 Cloud Storage 中始終受到保護，但您還可以選擇以下額外的數據保護選項，以增加安全層級。</p><p><strong>數據保護選項</strong></p><p><strong>自定義軟刪除策略（用於數據恢復）</strong><br>   啟用後，將覆蓋預設的保留期。刪除的物件將在指定的時間內被保留，在此期間可以恢復。如果設置為 0 天，則刪除的物件無法恢復。了解更多</p><p><strong>物件版本控制（用於版本管理）</strong><br>   用於恢復被刪除或覆蓋的物件。為了最小化存儲版本的成本，建議限制每個物件的非當前版本數量，並設定它們在若干天後過期。了解更多</p><p><strong>保留（用於合規性）</strong><br>   用於在指定的時間內防止刪除或修改存儲桶中的物件。</p><p>接下來按下 Create 之後會顯示以下畫面<br><img src="https://hackmd.io/_uploads/SJ3VVQgoR.png" alt="image"></p><p>這邊可以選擇是否要公開開放存取這個Bucket</p><p><img src="https://hackmd.io/_uploads/rkSkLXeoC.png" alt="image"></p><blockquote><p>這邊可以看到我們剛剛創建的Bucket</p></blockquote><h3 id="2-上傳與管理數據：使用-GCP-提供的工具或-API，將文件上傳至-Bucket，並設定存取控制與生命周期管理。"><a href="#2-上傳與管理數據：使用-GCP-提供的工具或-API，將文件上傳至-Bucket，並設定存取控制與生命周期管理。" class="headerlink" title="2. 上傳與管理數據：使用 GCP 提供的工具或 API，將文件上傳至 Bucket，並設定存取控制與生命周期管理。"></a>2. 上傳與管理數據：使用 GCP 提供的工具或 API，將文件上傳至 Bucket，並設定存取控制與生命周期管理。</h3><p><img src="https://hackmd.io/_uploads/rkSkLXeoC.png" alt="image"></p><blockquote><p>這邊可以點選我們剛剛創建的Bucket進入查看細節</p></blockquote><p><img src="https://hackmd.io/_uploads/B1iPIQgoA.png" alt="image"></p><blockquote><p>這邊可以看到Bucket的細節</p></blockquote><p><img src="https://hackmd.io/_uploads/BJ9mP7loR.png" alt="image"></p><blockquote><p>這邊可以看到上傳檔案的按紐</p></blockquote><p><img src="https://hackmd.io/_uploads/S1kYP7xoC.png" alt="image"></p><blockquote><p>可以測試上傳檔案</p></blockquote><h3 id="3-訪問與整合：透過網址或整合至其他-GCP-服務中訪問存儲在-GCS-的數據，並根據需求設定許可權。"><a href="#3-訪問與整合：透過網址或整合至其他-GCP-服務中訪問存儲在-GCS-的數據，並根據需求設定許可權。" class="headerlink" title="3. 訪問與整合：透過網址或整合至其他 GCP 服務中訪問存儲在 GCS 的數據，並根據需求設定許可權。"></a>3. 訪問與整合：透過網址或整合至其他 GCP 服務中訪問存儲在 GCS 的數據，並根據需求設定許可權。</h3><p>具體來說，可以查看以下兩份文件來實作：</p><p><strong><a href="https://cloud.google.com/storage/docs/access-public-data">公開訪問和連結的官方指南</a></strong> - 這份文件描述如何設定物件的公開連結以及使用不同的 URL 格式來存取 GCS 中的數據。</p><p><img src="https://hackmd.io/_uploads/H1Mkt7gjA.png" alt="image"></p><blockquote><p>使用URL的方式</p></blockquote><p><img src="https://hackmd.io/_uploads/SkXMt7xsA.png" alt="image"></p><blockquote><p>還有使用程式語言的方式存取，可以依照你的需求來選擇</p></blockquote><p><strong><a href="https://cloud.google.com/storage/docs/reference/libraries">使用客戶端程式庫來存取</a></strong> - 此文件涵蓋了如何將 GCS 與 BigQuery、Compute Engine 以及其他 GCP 服務整合。</p><p><img src="https://hackmd.io/_uploads/ByaOK7esA.png" alt="image"></p><blockquote><p>這邊可以看到各種程式語言的客戶端程式庫(client library)，這邊可以依照你的環境需求做使用。</p></blockquote><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>今天跟大家介紹的Google Cloud Storage的簡單概念跟使用情境，Google Cloud Storage 是一個靈活且強大的物件存儲解決方案，適合各種規模的企業和開發者使用。無論是備份數據、內容傳遞、還是大數據分析，GCS 都能提供高效且經濟的存儲選擇。隨著企業對數據管理需求的不斷增長，GCS 為其提供了穩定且可靠的雲端儲存支持。</p><p>如果您有興趣了解更多細節，歡迎在下方留言跟我討論。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/GCS/">GCS</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF/">雲端</category>
      
      <category domain="https://gahgah147.github.io/tags/Google/">Google</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/19/GCP-Google-Cloud-Storage-GCS-Google-%E9%9B%B2%E7%AB%AF%E5%84%B2%E5%AD%98%E6%9C%8D%E5%8B%99%E4%BB%8B%E7%B4%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Honeygain 蜜蜂幣 - 使用手機掛網輕鬆賺取被動收入的好工具</title>
      <link>https://gahgah147.github.io/2024/08/16/Honeygain-%E8%9C%9C%E8%9C%82%E5%B9%A3-%E4%BD%BF%E7%94%A8%E6%89%8B%E6%A9%9F%E6%8E%9B%E7%B6%B2%E8%BC%95%E9%AC%86%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7/</link>
      <guid>https://gahgah147.github.io/2024/08/16/Honeygain-%E8%9C%9C%E8%9C%82%E5%B9%A3-%E4%BD%BF%E7%94%A8%E6%89%8B%E6%A9%9F%E6%8E%9B%E7%B6%B2%E8%BC%95%E9%AC%86%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Fri, 16 Aug 2024 06:34:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;哈囉，大家好，我是 Nalson 今天要跟大家分享一個輕鬆賺取被動收入的工具——&lt;a href=&quot;https://r.honeygain.me/GAHGA2FC21&quot;&gt;Honeygain&lt;/a&gt;。這個平台支援手機和電腦，只要安裝 &lt;a href=&quot;https://r.hon</description>
        
      
      
      
      <content:encoded><![CDATA[<p>哈囉，大家好，我是 Nalson 今天要跟大家分享一個輕鬆賺取被動收入的工具——<a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a>。這個平台支援手機和電腦，只要安裝 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 的 APP 或電腦程式，然後像平常一樣使用設備，就能輕鬆透過掛機網路來賺取額外收入。</p><p>不需要額外的操作或投入，只要保持設備連網，你就能開始積累收益，讓被動收入變得簡單又實在。</p><p><img src="https://hackmd.io/_uploads/ryiG3zic0.png" alt="image"></p><h1 id="Honeygain-是什麼"><a href="#Honeygain-是什麼" class="headerlink" title="Honeygain 是什麼?"></a>Honeygain 是什麼?</h1><p><a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 是一個可以讓使用者賺取被動收入的應用程式和平台。透過 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a>，用戶可以分享自己設備（如手機或電腦）的閒置網路頻寬，來幫助企業進行各種網路相關的任務，如網路研究、廣告驗證和內容交付等。作為回報，用戶會根據分享的網路流量量獲得相應的報酬。</p><p><img src="https://hackmd.io/_uploads/H1UESBjcA.png" alt="image"></p><p>使用 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 非常簡單，只需要下載並安裝應用程式，註冊帳號後啟動應用即可開始賺錢。該應用在背景運行，不會影響設備的日常使用。隨著網路流量的累積，用戶可以將賺取的積分兌換成現金或其他獎勵。<a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 特別適合不常使用全部網路頻寬的用戶，因為它能夠將閒置的資源轉化為收益。</p><p><img src="https://hackmd.io/_uploads/S1Qkifo9C.png" alt="image"></p><blockquote><p><a href="https://r.honeygain.me/GAHGA2FC21">https://r.honeygain.me/GAHGA2FC21</a></p></blockquote><h1 id="為什麼-Honeygain-掛網可以賺錢"><a href="#為什麼-Honeygain-掛網可以賺錢" class="headerlink" title="為什麼 Honeygain 掛網可以賺錢?"></a>為什麼 Honeygain 掛網可以賺錢?</h1><p><img src="https://hackmd.io/_uploads/SkkVVSi9C.png" alt="image"></p><p><a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 掛網可以賺錢的原因是它將用戶設備的閒置網路頻寬出租給第三方企業，用來進行各種合法的網路相關任務。這些企業可能需要大量分散式的網路流量來進行以下活動：</p><ol><li><strong>市場研究</strong>：企業利用全球各地的網路流量來進行價格比較、趨勢分析或競爭對手調查。</li><li><strong>廣告驗證</strong>：用來檢查廣告在不同地區的顯示情況，以確保其準確性和合規性。</li><li><strong>內容交付</strong>：企業可能需要透過多個節點來分發內容，以確保穩定和快速的傳輸。</li></ol><p>當你在設備上安裝並啟用 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 後，它會在背景中將閒置的網路頻寬出租給這些企業，並根據你所分享的網路流量給予報酬。因為這些任務需要遍佈全球的多個網路節點，<a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 提供了企業所需的分佈式網路資源，而你則可以輕鬆獲得一筆被動收入。</p><p>更多詳細資訊可以參考以下官方介紹影片。<br><a href="https://youtu.be/6RDNT-f8Pv4?si=Blic3oABWI9EvGa7">https://youtu.be/6RDNT-f8Pv4?si=Blic3oABWI9EvGa7</a></p><h1 id="如何開始註冊使用-Honeygain"><a href="#如何開始註冊使用-Honeygain" class="headerlink" title="如何開始註冊使用 Honeygain?"></a>如何開始註冊使用 Honeygain?</h1><p>點擊這裡註冊，透過<a href="https://r.honeygain.me/GAHGA2FC21">我的Honeygain推薦連結註冊</a>可獲得 3 美元獎勵。以下是註冊流程：</p><p>點擊連結：進入 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 網站。<br>註冊帳號：輸入你的資料並完成註冊。<br>驗證信箱：收取並確認驗證郵件。<br>開始賺錢：登入後即可開始使用 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 賺取收入。</p><p><img src="https://hackmd.io/_uploads/HyPy_rsqA.png" alt="image"></p><p>透過我的連結進入可以看到我的邀請代碼<br><img src="https://hackmd.io/_uploads/H19h_Hs5A.png" alt="image"></p><p>註冊成功會發驗證信到你的信箱，點選確認驗證信箱，然後會跳轉到主頁面，<br><img src="https://hackmd.io/_uploads/ryShtrjc0.png" alt="image"></p><h1 id="主頁面畫面"><a href="#主頁面畫面" class="headerlink" title="主頁面畫面"></a>主頁面畫面</h1><p>主頁面畫面很簡單容易理解<br><img src="https://hackmd.io/_uploads/ryShtrjc0.png" alt="image"></p><h2 id="honeygain-檔案下載方式"><a href="#honeygain-檔案下載方式" class="headerlink" title="honeygain 檔案下載方式"></a>honeygain 檔案下載方式</h2><p><img src="https://hackmd.io/_uploads/rJOHEr35C.png" alt="image"></p><p>目前支援 <a href="https://download.honeygain.com/windows-app/Honeygain_install.exe?_gl=1*1ty5rzq*_gcl_au*OTg0MzI2MzgzLjE3MTc2MzQ2OTA.*_ga*NTA5NjE0NTgzLjE3MTc2MzQ2OTA.*_ga_3LNFBDTH6H*MTcyMzc3Mzc0MS4zLjEuMTcyMzc3ODEzNS4wLjAuMA..">Windows</a>、<a href="https://download.honeygain.com/android-app/honeygain_app.apk?_gl=1*13rc0ah*_gcl_au*OTg0MzI2MzgzLjE3MTc2MzQ2OTA.*_ga*NTA5NjE0NTgzLjE3MTc2MzQ2OTA.*_ga_3LNFBDTH6H*MTcyMzc3Mzc0MS4zLjEuMTcyMzc3ODEzNS4wLjAuMA..">Android</a>、<a href="https://resources.honeygain.com/macos-app/Honeygain_1.5.1.dmg?_gl=1*13rc0ah*_gcl_au*OTg0MzI2MzgzLjE3MTc2MzQ2OTA.*_ga*NTA5NjE0NTgzLjE3MTc2MzQ2OTA.*_ga_3LNFBDTH6H*MTcyMzc3Mzc0MS4zLjEuMTcyMzc3ODEzNS4wLjAuMA..">For macOS</a>、<a href="https://hub.docker.com/r/honeygain/honeygain">For Linux</a></p><p>可以依照你自己的使用狀況下載</p><h2 id="蜜蜂收集畫面"><a href="#蜜蜂收集畫面" class="headerlink" title="蜜蜂收集畫面"></a>蜜蜂收集畫面</h2><p>其中有蜜蜂收集條，搜集滿之後就可以換取20美元出來<br><img src="https://hackmd.io/_uploads/HJjEqSsqC.png" alt="image"></p><h2 id="收集紀錄報表"><a href="#收集紀錄報表" class="headerlink" title="收集紀錄報表"></a>收集紀錄報表</h2><p>這邊是30天內的蒐集量狀況<br><img src="https://hackmd.io/_uploads/SkbnqHo5R.png" alt="image"></p><h2 id="Honeygain-掛網裝置顯示"><a href="#Honeygain-掛網裝置顯示" class="headerlink" title="Honeygain 掛網裝置顯示"></a>Honeygain 掛網裝置顯示</h2><p>以下這張圖是目前有啟用 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 掛網的裝置<br><img src="https://hackmd.io/_uploads/HkwCqHsqC.png" alt="image"></p><h2 id="Honeygain-額外賺錢方式"><a href="#Honeygain-額外賺錢方式" class="headerlink" title="Honeygain 額外賺錢方式"></a>Honeygain 額外賺錢方式</h2><p>除了網路掛機，你還可以透過以下方式賺取額外收益：</p><ol><li>打開蜂蜜罐抽獎：每天收集 15 MB 就可以參加抽獎。</li><li>成就系統：完成成就後可獲得額外積分。</li><li>邀請好友：透過推薦連結，好友每賺取 10GB，你可獲得 25% 的積分分成。</li></ol><h3 id="打開蜂蜜罐抽獎"><a href="#打開蜂蜜罐抽獎" class="headerlink" title="打開蜂蜜罐抽獎"></a>打開蜂蜜罐抽獎</h3><p>這邊是一個每天可以打開蜂蜜罐的機會<br><img src="https://hackmd.io/_uploads/rynkjSj5C.png" alt="image"></p><p>一般每天會像這樣，收集滿 15 MB 之後就可以打開蜂蜜抽獎<br><img src="https://hackmd.io/_uploads/By7QlrnqC.png" alt="image"></p><p>每天分享每 15 MB就可以，打開蜂蜜罐的畫面<br><img src="https://hackmd.io/_uploads/BJq8hMjcC.png" alt="image"></p><h3 id="成就系統"><a href="#成就系統" class="headerlink" title="成就系統"></a>成就系統</h3><p>這邊是成就系統，完成成就之後也可以獲得額外的積分<br><img src="https://hackmd.io/_uploads/BkxhxrncR.png" alt="image"></p><h3 id="邀請好友"><a href="#邀請好友" class="headerlink" title="邀請好友"></a>邀請好友</h3><p>這邊是邀請好友獲得的機制，這邊也可以產生你自己的邀請碼，有人透過這個邀請碼使用<a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a>來取得積分時你也可以分享到25%的積分<br><img src="https://hackmd.io/_uploads/HJF-bHn9A.png" alt="image"></p><p>其實如果朋友數量夠多的話應該會是一筆不錯的被動收入。趕快試試看吧！</p><h1 id="進階賺錢攻略：啟用Jumptask賺取額外的10-積分"><a href="#進階賺錢攻略：啟用Jumptask賺取額外的10-積分" class="headerlink" title="進階賺錢攻略：啟用Jumptask賺取額外的10%積分"></a>進階賺錢攻略：啟用Jumptask賺取額外的10%積分</h1><h2 id="Jumptask是什麼"><a href="#Jumptask是什麼" class="headerlink" title="Jumptask是什麼?"></a>Jumptask是什麼?</h2><p>JumpTask 是一個去中心化的自由工作（gig economy）平台，透過區塊鏈技術連接企業和自由工作者。該平台允許用戶完成各種微型任務（如填寫問卷、測試應用程式、參與市場調查等），並以加密貨幣（通常是其原生代幣 JT）來獲取報酬。</p><p>JumpTask 的目標是透過去中心化的方式為企業提供靈活的勞動力，同時為全球的自由工作者提供賺取收入的機會。這種模式消除了傳統平台的中介費用，讓企業和工作者都能享受更高的收益和效率。</p><h2 id="如何在-Honeygain-上面使用-JumpTask"><a href="#如何在-Honeygain-上面使用-JumpTask" class="headerlink" title="如何在 Honeygain 上面使用 JumpTask"></a>如何在 Honeygain 上面使用 JumpTask</h2><p><img src="https://hackmd.io/_uploads/SJYlDB35A.png" alt="image"></p><p>這邊可以在官方網站看到 JumpTask 與 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 合作，允許 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 用戶將他們的收益直接兌換成 JumpTask 的加密貨幣，並在 JumpTask 平台上使用這些代幣進行更多任務或提取到加密貨幣錢包。</p><p>使用 Jumptask 的話可以獲取額外的10% 收入，但是這邊要注意Jumptask 是加密貨幣，加密貨幣的價值是會上下浮動的，且出金方式要改為加密貨幣出金。</p><p><img src="https://hackmd.io/_uploads/SJ0iLBh90.png" alt="image"></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>總的來說，<a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 是一個不需要投入額外時間和精力就能賺取被動收入的好工具。只要安裝應用程式並保持設備連網，你就能輕鬆將閒置的網路頻寬轉化為現金收入。對於那些擁有穩定網路連線的用戶來說，這是一個非常實用的賺錢方法。</p><p>此外，透過完成成就、打開蜂蜜罐、邀請好友等多種方式，你還可以進一步增加收益。如果你正在尋找一個輕鬆無壓力的被動收入來源，那麼 <a href="https://r.honeygain.me/GAHGA2FC21">Honeygain</a> 絕對值得一試。立即透過我的推薦連結註冊，開始體驗簡單又有趣的賺錢方式吧！，如果有嘗試也歡迎跟我討論賺取蜜蜂的結果。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/">被動收入</category>
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/">被動收入</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/">區塊鏈</category>
      
      <category domain="https://gahgah147.github.io/tags/Honeygain/">Honeygain</category>
      
      <category domain="https://gahgah147.github.io/tags/JumpTask/">JumpTask</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/16/Honeygain-%E8%9C%9C%E8%9C%82%E5%B9%A3-%E4%BD%BF%E7%94%A8%E6%89%8B%E6%A9%9F%E6%8E%9B%E7%B6%B2%E8%BC%95%E9%AC%86%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>蝦皮分潤計畫介紹：如何賺取額外被動收入</title>
      <link>https://gahgah147.github.io/2024/08/14/%E8%9D%A6%E7%9A%AE%E5%88%86%E6%BD%A4%E8%A8%88%E7%95%AB%E4%BB%8B%E7%B4%B9%EF%BC%9A%E5%A6%82%E4%BD%95%E8%B3%BA%E5%8F%96%E9%A1%8D%E5%A4%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/</link>
      <guid>https://gahgah147.github.io/2024/08/14/%E8%9D%A6%E7%9A%AE%E5%88%86%E6%BD%A4%E8%A8%88%E7%95%AB%E4%BB%8B%E7%B4%B9%EF%BC%9A%E5%A6%82%E4%BD%95%E8%B3%BA%E5%8F%96%E9%A1%8D%E5%A4%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/</guid>
      <pubDate>Wed, 14 Aug 2024 06:33:49 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/H1mzKpYqC.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在數位時代，線上購物成為了我們生活中不可或缺的一部分。隨著電商平台的迅速發展，蝦皮（Shopee）作為其中的領導者，提供了多種創造</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/H1mzKpYqC.png" alt="image"></p><p>在數位時代，線上購物成為了我們生活中不可或缺的一部分。隨著電商平台的迅速發展，蝦皮（Shopee）作為其中的領導者，提供了多種創造收入的方式。其中，蝦皮分潤計畫（Shopee Affiliate Program）是一個非常吸引人的選擇。如果你對賺取額外收入感興趣，這個計畫或許正是你所需要的！</p><h1 id="什麼是蝦皮分潤計畫？"><a href="#什麼是蝦皮分潤計畫？" class="headerlink" title="什麼是蝦皮分潤計畫？"></a>什麼是蝦皮分潤計畫？</h1><p>蝦皮分潤計畫是一個聯盟行銷計畫，讓網站擁有者、部落客、社交媒體影響者等，通過推廣蝦皮平台上的商品來賺取佣金。參加這個計畫的會員可以獲得獨特的聯盟鏈接，並將這些鏈接放置在自己的網站、部落格或社交媒體上，當有用戶通過這些鏈接進行購買時，會員便能夠獲得一定比例的佣金。</p><p><img src="https://hackmd.io/_uploads/HyLGOpt90.png" alt="image"></p><blockquote><p><a href="https://help.shopee.tw/portal/10/article/123888-%E8%9D%A6%E7%9A%AE%E5%88%86%E6%BD%A4%E8%A8%88%E7%95%AB%E4%BB%8B%E7%B4%B9?previousPage=secondary%20category">https://help.shopee.tw/portal/10/article/123888-%E8%9D%A6%E7%9A%AE%E5%88%86%E6%BD%A4%E8%A8%88%E7%95%AB%E4%BB%8B%E7%B4%B9?previousPage=secondary%20category</a></p></blockquote><h1 id="如何參加蝦皮分潤計畫？"><a href="#如何參加蝦皮分潤計畫？" class="headerlink" title="如何參加蝦皮分潤計畫？"></a>如何參加蝦皮分潤計畫？</h1><ol><li><strong>註冊成為聯盟會員</strong><ul><li>訪問蝦皮分潤計畫申請網站，註冊成為聯盟會員。填寫必要的個人資訊和銀行帳戶資料以便於未來的佣金發放。</li></ul></li></ol><p><img src="https://hackmd.io/_uploads/H1mzKpYqC.png" alt="image"></p><blockquote><p><a href="https://affiliate.shopee.tw/?previousPage=other%20articles">https://affiliate.shopee.tw/?previousPage=other%20articles</a></p></blockquote><p>點選立刻加入後會需要登入蝦皮帳號<br><img src="https://hackmd.io/_uploads/SJKAYaK5R.png" alt="image"></p><p>填寫完資料之後會顯示以下畫面<br><img src="https://hackmd.io/_uploads/B1QX5aF50.png" alt="image"></p><ol start="2"><li><p><strong>選擇推廣商品</strong></p><ul><li>登入聯盟平台後，你可以選擇你想要推廣的商品或店鋪。蝦皮提供了豐富的商品類別，你可以根據你的受眾選擇最合適的商品進行推廣。</li></ul></li><li><p><strong>獲取聯盟鏈接</strong></p><ul><li>生成推廣鏈接或廣告素材，將其放置在你的網站、部落格或社交媒體上。這些鏈接將追蹤所有經由你推廣所產生的交易。</li></ul></li><li><p><strong>推廣與賺取佣金</strong></p><ul><li>當用戶通過你的聯盟鏈接進行購買時，你將會獲得相應的佣金。蝦皮分潤計畫的佣金比例根據不同的商品類別和銷售量會有所不同。</li></ul></li></ol><h1 id="蝦皮分潤計畫的優勢"><a href="#蝦皮分潤計畫的優勢" class="headerlink" title="蝦皮分潤計畫的優勢"></a>蝦皮分潤計畫的優勢</h1><ul><li><strong>高佣金比例</strong>：蝦皮提供具有競爭力的佣金比例，幫助你獲得可觀的收入。</li><li><strong>豐富的商品選擇</strong>：從電子產品到生活用品，蝦皮擁有廣泛的商品種類，適合各種不同的推廣策略。</li><li><strong>簡單的操作</strong>：註冊和使用過程簡單明瞭，適合各種程度的推廣者。</li><li><strong>詳細的報告功能</strong>：提供詳細的銷售報告和數據分析，幫助你了解推廣效果並調整策略。</li></ul><h1 id="如何提高分潤收入？"><a href="#如何提高分潤收入？" class="headerlink" title="如何提高分潤收入？"></a>如何提高分潤收入？</h1><ol><li><strong>選擇熱門商品</strong>：推廣市場上需求量大的商品，提高轉換率和銷售量。</li><li><strong>優化推廣內容</strong>：撰寫吸引人的商品評測和介紹，增加用戶的點擊和購買意願。</li><li><strong>利用社交媒體</strong>：在社交媒體上積極推廣，擴大你的影響力和受眾範圍。</li><li><strong>定期更新內容</strong>：保持網站和部落格內容的更新，吸引更多的流量和訪問。</li></ol><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>蝦皮分潤計畫是一個既簡單又有效的賺錢方式，無論你是部落客、網紅還是網站擁有者，都可以通過參加這個計畫來獲得額外的收入。只要你善用推廣技巧，選擇合適的商品並持續優化你的推廣策略，相信你一定能在蝦皮分潤計畫中獲得滿意的收益！</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7/">聯盟行銷</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/">被動收入</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%9D%A6%E7%9A%AE%E5%88%86%E6%BD%A4%E8%A8%88%E7%95%AB/">蝦皮分潤計畫</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/14/%E8%9D%A6%E7%9A%AE%E5%88%86%E6%BD%A4%E8%A8%88%E7%95%AB%E4%BB%8B%E7%B4%B9%EF%BC%9A%E5%A6%82%E4%BD%95%E8%B3%BA%E5%8F%96%E9%A1%8D%E5%A4%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>探索 Gizzmo AI ：用AI撰寫Amazon聯盟行銷推廣文章賺取被動收入，WordPress 內容創建和聯盟行銷的完美結合</title>
      <link>https://gahgah147.github.io/2024/08/14/%E6%8E%A2%E7%B4%A2-Gizzmo-AI-%EF%BC%9A%E7%94%A8AI%E6%92%B0%E5%AF%ABAmazon%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7%E6%8E%A8%E5%BB%A3%E6%96%87%E7%AB%A0%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5%EF%BC%8CWordPress-%E5%85%A7%E5%AE%B9%E5%89%B5%E5%BB%BA%E5%92%8C%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%B5%90%E5%90%88/</link>
      <guid>https://gahgah147.github.io/2024/08/14/%E6%8E%A2%E7%B4%A2-Gizzmo-AI-%EF%BC%9A%E7%94%A8AI%E6%92%B0%E5%AF%ABAmazon%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7%E6%8E%A8%E5%BB%A3%E6%96%87%E7%AB%A0%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5%EF%BC%8CWordPress-%E5%85%A7%E5%AE%B9%E5%89%B5%E5%BB%BA%E5%92%8C%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%B5%90%E5%90%88/</guid>
      <pubDate>Wed, 14 Aug 2024 03:00:51 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Gizzmo-AI-是什麼&quot;&gt;&lt;a href=&quot;#Gizzmo-AI-是什麼&quot; class=&quot;headerlink&quot; title=&quot;Gizzmo AI 是什麼 ?&quot;&gt;&lt;/a&gt;Gizzmo AI 是什麼 ?&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://hack</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Gizzmo-AI-是什麼"><a href="#Gizzmo-AI-是什麼" class="headerlink" title="Gizzmo AI 是什麼 ?"></a>Gizzmo AI 是什麼 ?</h1><p><img src="https://hackmd.io/_uploads/BkWnyBvcR.png" alt="image"></p><blockquote><p><a href="https://gizzmo.ai/">https://gizzmo.ai/</a></p></blockquote><p>Gizzmo AI 是一款專為 WordPress 使用者設計的 AI 工具，主要用於快速生成高質量且經過 SEO 優化的內容。</p><p>這款工具特別適合於希望通過聯盟行銷來賺取收入的網站擁有者。</p><p>Gizzmo AI 可以自動生成與 Amazon 產品相關的內容，幫助使用者找到合適的關鍵詞並分析文章的語法與拼寫錯誤，還能自動插入 Amazon 的聯盟連結，增加收入潛力。</p><p><img src="https://hackmd.io/_uploads/r11sksF5A.png" alt="image"></p><hr><h1 id="Gizzmo-收費方式"><a href="#Gizzmo-收費方式" class="headerlink" title="Gizzmo 收費方式"></a>Gizzmo 收費方式</h1><p><img src="https://hackmd.io/_uploads/S1-qnBwcC.png" alt="image"></p><blockquote><p><a href="https://gizzmo.ai/#Pricing">https://gizzmo.ai/#Pricing</a></p></blockquote><p><img src="https://hackmd.io/_uploads/HJivb5F50.png" alt="image"></p><p>這裡提供了一個清晰的 Gizzmo AI 收費方案比較表格，包括 Lite、Builder、Pro 和 Unlimited 四種版本的功能和費用差異。</p><table><thead><tr><th><strong>功能 &#x2F; 版本</strong></th><th><strong>Lite (免費)</strong></th><th><strong>Builder ($19.99&#x2F;月)</strong></th><th><strong>Pro ($49.99&#x2F;月)</strong></th><th><strong>Unlimited ($99.99&#x2F;月)</strong></th></tr></thead><tbody><tr><td><strong>每月文章數</strong></td><td>不限</td><td>25 篇</td><td>150 篇</td><td>1000 篇</td></tr><tr><td><strong>產品評測文章</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>產品推薦文章</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>一般內容文章</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>完整的 SEO 工具箱</strong></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>聯盟行銷套件</strong></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>自動化後期製作</strong></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>Amazon 圖片建議</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>專屬帳號限制</strong></td><td>1 個</td><td>1 個</td><td>1 個</td><td>1 個</td></tr><tr><td><strong>退款保證</strong></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>隨時取消</strong></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><p>值得注意的是，Gizzmo AI 的免費版（Lite）已經能夠生成高品質的產品評測和推薦文章，這對於剛起步或資金有限的內容創作者來說是一個非常實用的工具。這意味著你可以利用免費版來產生專業的開箱測試文章，而不需要立刻投入成本。</p><p>因此，如果你需要一個強大的內容生成工具，但又不確定是否要購買高階版本，那麼免費版將是一個很好的起點。隨著需求的增長，你可以隨時升級到更高版本，以獲得更多的功能和服務。</p><hr><h1 id="安裝-Gizzmo-AI-插件步驟"><a href="#安裝-Gizzmo-AI-插件步驟" class="headerlink" title="安裝 Gizzmo AI 插件步驟"></a>安裝 Gizzmo AI 插件步驟</h1><p><strong>登入 WordPress 後台</strong>，點選 <strong>外掛</strong><br>   <img src="https://hackmd.io/_uploads/rJwEiHDqA.png" alt="image"></p><p>點選 <strong>安裝外掛</strong><br>   <img src="https://hackmd.io/_uploads/HkyvoSvcR.png" alt="image"></p><p>查詢 <strong>Gizzmo</strong><br>   <img src="https://hackmd.io/_uploads/SyucjBPqC.png" alt="image"></p><p>點選 <strong>立即安裝</strong><br>   <img src="https://hackmd.io/_uploads/Hyo2jrD5R.png" alt="image"></p><p>點選 <strong>啟用</strong><br>   <img src="https://hackmd.io/_uploads/r1YCiSP50.png" alt="image"></p><p>Gizzmo 插件已成功安裝，會出現在後台選單中<br>   <img src="https://hackmd.io/_uploads/rkFB3rwqC.png" alt="image"></p><hr><h1 id="設定-Gizzmo-後台"><a href="#設定-Gizzmo-後台" class="headerlink" title="設定 Gizzmo 後台"></a>設定 Gizzmo 後台</h1><p>首先填寫一些基本資料，例如名稱、Email 和密碼<br>   <img src="https://hackmd.io/_uploads/Sk8oTSP5R.png" alt="image"></p><p>設定 Gizzmo Chrome 插件<br>   <img src="https://hackmd.io/_uploads/SJqgCrDcA.png" alt="image"></p><p>   點選這個按鈕<br>   <img src="https://hackmd.io/_uploads/SkL8ABwqR.png" alt="image"><br>   前往 Gizzmo Chrome 插件安裝頁面。</p><p>   點選 <strong>加到 Chrome</strong><br>   <img src="https://hackmd.io/_uploads/r1Y90Swq0.png" alt="image"></p><p>   前往 Amazon 的產品頁面，例如：<a href="https://www.amazon.com/dp/B09B8V1LZ3">https://www.amazon.com/dp/B09B8V1LZ3</a><br>   在跳出的 Gizzmo 視窗中填入後台顯示的 token<br>   <img src="https://hackmd.io/_uploads/SJ54xIv5R.png" alt="image"></p><p>   點選 + 把產品加入後台<br>   <img src="https://hackmd.io/_uploads/SyBAxLDcC.png" alt="image"><br>   成功加入的畫面如下：<br>   <img src="https://hackmd.io/_uploads/SkYeWLvqR.png" alt="image"></p><p>   點擊 <img src="https://hackmd.io/_uploads/BJDEbID9A.png" alt="image"> 進入下一步</p><p>   顯示設定成功的畫面<br>   <img src="https://hackmd.io/_uploads/BkmLZUDcA.png" alt="image"></p><hr><h1 id="開始產生文章"><a href="#開始產生文章" class="headerlink" title="開始產生文章"></a>開始產生文章</h1><p>一開始會顯示的公告畫面<br><img src="https://hackmd.io/_uploads/HksibIwcC.png" alt="image"><br>內容是 Gizzmo AI 2.0.7 的更新公告和使用指引。Gizzmo AI 是一個利用人工智慧幫助創建內容的平台。這裡是內容的重點：</p><ul><li><p><strong>歡迎詞</strong>：歡迎使用 Gizzmo AI 2.0.7，平台的使命是幫助你根據真實產品事實和經過驗證的用戶評論創建有價值的內容。</p></li><li><p><strong>注意事項</strong>：</p><ol><li><strong>AI 驅動的內容生成</strong>：使用 AI 生成的內容後，請檢查並調整以符合你的個人風格和語調。</li><li><strong>AI 生成的圖片</strong>：在發佈前，請檢查所有 AI 生成的圖片。</li><li><strong>免責聲明</strong>：不要忘記添加有關亞馬遜佣金和 AI 使用的免責聲明。</li></ol></li><li><p><strong>Gizzmo AI 2.0.7 的新功能</strong>：</p><ul><li>支援比較文章和清單文章。</li><li>增強的自訂選項。</li><li>改進的 UI&#x2F;UX，提供更流暢的工作流程。</li><li>支援更多亞馬遜商店。</li><li>支援 44 種語言。</li></ul></li><li><p><strong>支援</strong>：如果需要幫助，支援團隊隨時提供協助。</p></li></ul><p>接下來點選畫面上的 <strong>Pepare</strong> 讓 AI 幫你產生文章<br><img src="https://hackmd.io/_uploads/SkFMzIw5R.png" alt="image"></p><p>產生中的畫面<br><img src="https://hackmd.io/_uploads/BkJvMIwq0.png" alt="image"></p><p>產生完成<br><img src="https://hackmd.io/_uploads/S189fUDcR.png" alt="image"></p><p>因為免費版所以有些功能不能選擇，但可以將語言調整為繁體中文<br><img src="https://hackmd.io/_uploads/SklCzLPc0.png" alt="image"></p><p>接下來 AI 會開始撰寫文章<br><img src="https://hackmd.io/_uploads/ByUHmLDcR.png" alt="image"></p><p>這邊可以看到 Gizzmo AI 幫我產生的文章草稿<br><img src="https://hackmd.io/_uploads/r1CdmIw90.png" alt="image"></p><p>下面的連結是成功產生的文章，發佈在<a href="https://www.catchorange.com/">我的wordpress版本部落格</a>上<br><a href="https://www.catchorange.com/2024/08/12/amazon-echo-dot-5th-gen-review/">https://www.catchorange.com/2024/08/12/amazon-echo-dot-5th-gen-review/</a></p><hr><h1 id="使用-Gizzmo-AI-寫比較文章"><a href="#使用-Gizzmo-AI-寫比較文章" class="headerlink" title="使用 Gizzmo AI 寫比較文章"></a>使用 Gizzmo AI 寫比較文章</h1><p>這邊上方可以看到Compare 來撰寫比較文章</p><p><img src="https://hackmd.io/_uploads/HklwDqKcC.png" alt="image"></p><p>點選加入<br><img src="https://hackmd.io/_uploads/SyEyKctqA.png" alt="image"></p><p>點選 <img src="https://hackmd.io/_uploads/ry3gYqFq0.png" alt="image"> </p><p>接下來可以看到  Gizzmo AI 生成的比較<br><img src="https://hackmd.io/_uploads/r1WQY9YqC.png" alt="image"></p><p>這邊可以產生文章<br><img src="https://hackmd.io/_uploads/HkOFK9FqR.png" alt="image"></p><p>這邊可以點擊Save as Draft 存成草稿<br><img src="https://hackmd.io/_uploads/BkYG59t5A.png" alt="image"></p><p>下面的連結是成功產生的文章，發佈在<a href="https://www.catchorange.com/">我的wordpress版本部落格</a>上</p><p><a href="https://www.catchorange.com/2024/08/14/ultimate-showdown-raymylo-vs-iron-flask-insulated-water-bottles/">https://www.catchorange.com/2024/08/14/ultimate-showdown-raymylo-vs-iron-flask-insulated-water-bottles/</a></p><p><img src="https://hackmd.io/_uploads/HJPyaqK5R.png" alt="image"></p><p>這邊可以看到比較文章還有一些表格跟評分，文章的內容也感覺很不錯。</p><hr><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>文章的質量其實不錯，Gizzmo AI 在內容生成上表現良好。但由於亞馬遜聯盟行銷目前不支援台灣，我建議如果要撰寫推廣文章，還是選擇撰寫英文版本比較合適，這樣能夠更好地利用聯盟行銷的優勢。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E6%9E%B6%E7%AB%99%E8%A8%98%E9%8C%84/">架站記錄</category>
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/">被動收入</category>
      
      <category domain="https://gahgah147.github.io/tags/Wordpress/">Wordpress</category>
      
      <category domain="https://gahgah147.github.io/tags/Gizzmo-AI/">Gizzmo AI</category>
      
      <category domain="https://gahgah147.github.io/tags/%E7%B6%B2%E7%AB%99%E6%9E%B6%E8%A8%AD/">網站架設</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/14/%E6%8E%A2%E7%B4%A2-Gizzmo-AI-%EF%BC%9A%E7%94%A8AI%E6%92%B0%E5%AF%ABAmazon%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7%E6%8E%A8%E5%BB%A3%E6%96%87%E7%AB%A0%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5%EF%BC%8CWordPress-%E5%85%A7%E5%AE%B9%E5%89%B5%E5%BB%BA%E5%92%8C%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%B5%90%E5%90%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Amazon Associates 亞馬遜聯盟行銷 - 從網路賺取被動收入</title>
      <link>https://gahgah147.github.io/2024/08/12/Amazon-Associates-%E4%BA%9E%E9%A6%AC%E9%81%9C%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7-%E5%BE%9E%E7%B6%B2%E8%B7%AF%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/</link>
      <guid>https://gahgah147.github.io/2024/08/12/Amazon-Associates-%E4%BA%9E%E9%A6%AC%E9%81%9C%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7-%E5%BE%9E%E7%B6%B2%E8%B7%AF%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/</guid>
      <pubDate>Mon, 12 Aug 2024 07:40:35 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;什麼是聯盟行銷？&quot;&gt;&lt;a href=&quot;#什麼是聯盟行銷？&quot; class=&quot;headerlink&quot; title=&quot;什麼是聯盟行銷？&quot;&gt;&lt;/a&gt;什麼是聯盟行銷？&lt;/h1&gt;&lt;p&gt;聯盟行銷最簡單的概念，就是推薦行銷。你可以將亞馬遜上的產品推薦給其他人，只要有人透過你的推薦</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="什麼是聯盟行銷？"><a href="#什麼是聯盟行銷？" class="headerlink" title="什麼是聯盟行銷？"></a>什麼是聯盟行銷？</h1><p>聯盟行銷最簡單的概念，就是推薦行銷。你可以將亞馬遜上的產品推薦給其他人，只要有人透過你的推薦連結購買商品，你就能獲取一部分佣金。這種方式不僅簡單，而且可以持續賺取被動收入，特別適合想要在家工作的朋友們。</p><h1 id="什麼是-Amazon-Associates？"><a href="#什麼是-Amazon-Associates？" class="headerlink" title="什麼是 Amazon Associates？"></a>什麼是 Amazon Associates？</h1><p><img src="https://hackmd.io/_uploads/SkRDCmD9R.png" alt="image"></p><p>亞馬遜是全球最大的電商平台，擁有無數的商品種類，從日常用品到高端電子產品應有盡有。加入 Amazon Associates 計劃意味著你可以選擇大量的產品進行推薦，並且亞馬遜的名氣和信譽也有助於提高你的銷售機會。此外，亞馬遜的聯盟行銷平台也相對容易上手，適合新手。</p><h1 id="如何申請-Amazon-Associates？"><a href="#如何申請-Amazon-Associates？" class="headerlink" title="如何申請 Amazon Associates？"></a>如何申請 Amazon Associates？</h1><p><strong>註冊 Amazon Associates</strong><br>首先，你需要免費註冊一個 Amazon Associates 帳號。你可以通過以下連結立即加入：<br><img src="https://hackmd.io/_uploads/SkRDCmD9R.png" alt="image"></p><blockquote><p><a href="https://affiliate-program.amazon.com/">https://affiliate-program.amazon.com/</a></p></blockquote><p><strong>點選 Sign Up</strong></p><p>你需要填寫一些基本資料，包括你的姓名、email和密碼。<br><img src="https://hackmd.io/_uploads/HyQ1gVPqR.png" alt="image"></p><p><strong>收驗證信</strong><br>這邊會需要進入信箱收驗證碼<br><img src="https://hackmd.io/_uploads/SkZdeEvqR.png" alt="image"></p><p><strong>填寫一些基本資料</strong><br><img src="https://hackmd.io/_uploads/BkTBWNv5A.png" alt="image"></p><p><strong>輸入你的網頁或社交平台</strong><br><img src="https://hackmd.io/_uploads/SJRsMEv9A.png" alt="image"></p><p>接下來，你需要提供你會使用來推廣亞馬遜產品的網站或社交平台，如個人網站、Facebook 粉絲專頁、Instagram 或 YouTube 頻道等。如果你還沒有這些平台，可以先填寫現有的，之後再補充其他的。</p><p><strong>填寫網站的一些內容</strong><br><img src="https://hackmd.io/_uploads/r1dzm4P90.png" alt="image"></p><p>在亞馬遜聯盟營銷中，你可以選擇一個「Associates Store ID」來追蹤從你的聯盟連結進入亞馬遜網站的流量和銷售。這個 ID 是你在亞馬遜聯盟計畫中的唯一識別碼。</p><p>還有網站的內容大致上是什麼?等等的問題之後</p><p><strong>接下來就成功取得 Associate ID 了</strong><br><img src="https://hackmd.io/_uploads/rku3IEw9A.png" alt="image"></p><h1 id="付款方式與週期"><a href="#付款方式與週期" class="headerlink" title="付款方式與週期"></a>付款方式與週期</h1><p>Amazon Associates 提供兩種收款方式，包括 Pay by gift card 和支票。建議選擇 Pay by gift card，因為只要達到 $10 就可以提款，而支票則有更高的提款門檻。</p><p>每個月底會進行結算，但實際上你可能需要等待約兩個月的時間才能收到款項。</p><p><img src="https://hackmd.io/_uploads/r1_adNv9R.png" alt="image"><br>我在這邊選擇 Pay by gift card</p><h1 id="如何推薦商品並獲取佣金？"><a href="#如何推薦商品並獲取佣金？" class="headerlink" title="如何推薦商品並獲取佣金？"></a>如何推薦商品並獲取佣金？</h1><p>申請完成後，你就可以開始推薦商品了。你可以通過登入 Amazon Associates 帳戶，使用 SiteStripe 工具來獲取你想要推薦的商品連結。這個工具會顯示在亞馬遜網站的頂部，方便你隨時生成推薦連結。</p><ol><li><strong>找到商品</strong>：登入 Amazon 並找到你想推薦的商品。</li><li><strong>生成連結</strong>：使用 SiteStripe 工具生成連結。你可以選擇純文字連結、圖片連結或文字+圖片的混合連結。</li><li><strong>嵌入你的網站或社交平台</strong>：將生成的推薦連結嵌入到你的網站、博客文章或社交平台帖子中。</li></ol><h1 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h1><p>在使用 Amazon Associates 時，有一些注意事項需要遵守：</p><ul><li><strong>使用正確的圖片</strong>：不要隨意擷取亞馬遜的商品圖片，而是使用 SiteStripe 工具提供的圖片連結。</li><li><strong>避免自我購買</strong>：你不能通過自己的推薦連結購買商品，這樣的交易無法獲取佣金。</li><li><strong>標示聯盟身份</strong>：在你使用推薦連結的頁面上，務必清楚地標示你參加了 Amazon Associates Program，這樣可以讓讀者知道你會從中獲取佣金。</li><li><strong>不要在 Email 中發布推薦連結</strong>：亞馬遜不允許你在電子郵件中發布推薦連結，只能在網站或社交平台上使用。</li></ul><h1 id="經驗分享與總結"><a href="#經驗分享與總結" class="headerlink" title="經驗分享與總結"></a>經驗分享與總結</h1><p>亞馬遜聯盟行銷是一個值得新手嘗試的被動收入來源。雖然初期可能需要花一些時間來建立內容和推廣商品，但一旦設置完成，隨著時間的推移，你可以不斷地從推薦的商品中獲得收益。</p><p>如果你對聯盟行銷有興趣，不妨立刻開始嘗試，並持續學習和優化你的推廣策略，逐步提升你的被動收入。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7/">聯盟行銷</category>
      
      <category domain="https://gahgah147.github.io/tags/Amazon/">Amazon</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/">被動收入</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/12/Amazon-Associates-%E4%BA%9E%E9%A6%AC%E9%81%9C%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7-%E5%BE%9E%E7%B6%B2%E8%B7%AF%E8%B3%BA%E5%8F%96%E8%A2%AB%E5%8B%95%E6%94%B6%E5%85%A5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>讓孩子愛上閱讀！探索米奇翻翻書的奇妙世界，現在立刻免費索取！</title>
      <link>https://gahgah147.github.io/2024/08/09/%E8%AE%93%E5%AD%A9%E5%AD%90%E6%84%9B%E4%B8%8A%E9%96%B1%E8%AE%80%EF%BC%81%E6%8E%A2%E7%B4%A2%E7%B1%B3%E5%A5%87%E7%BF%BB%E7%BF%BB%E6%9B%B8%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C%EF%BC%8C%E7%8F%BE%E5%9C%A8%E7%AB%8B%E5%88%BB%E5%85%8D%E8%B2%BB%E7%B4%A2%E5%8F%96%EF%BC%81/</link>
      <guid>https://gahgah147.github.io/2024/08/09/%E8%AE%93%E5%AD%A9%E5%AD%90%E6%84%9B%E4%B8%8A%E9%96%B1%E8%AE%80%EF%BC%81%E6%8E%A2%E7%B4%A2%E7%B1%B3%E5%A5%87%E7%BF%BB%E7%BF%BB%E6%9B%B8%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C%EF%BC%8C%E7%8F%BE%E5%9C%A8%E7%AB%8B%E5%88%BB%E5%85%8D%E8%B2%BB%E7%B4%A2%E5%8F%96%EF%BC%81/</guid>
      <pubDate>Fri, 09 Aug 2024 07:42:05 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BkkN4S7qR.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在現今這個數位時代，找到讓孩子沉浸於閱讀的方式並不容易。然而，這款【米奇翻翻書】讓這個挑戰變得有趣且充滿互動性。這本書不僅僅是一部</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://hackmd.io/_uploads/BkkN4S7qR.png" alt="image"></p><p>在現今這個數位時代，找到讓孩子沉浸於閱讀的方式並不容易。然而，這款【米奇翻翻書】讓這個挑戰變得有趣且充滿互動性。這本書不僅僅是一部童書，它還是一個充滿驚喜的閱讀體驗，讓孩子在翻閱每一頁的同時，都能發現新奇的故事情節和生動的圖畫。</p><hr><h1 id="米奇翻翻書的特色"><a href="#米奇翻翻書的特色" class="headerlink" title="米奇翻翻書的特色"></a><strong>米奇翻翻書的特色</strong></h1><p><img src="https://hackmd.io/_uploads/SJbKVHXqA.png" alt="image"><br>取材自迪士尼美語世界《Fun and Games》系列的改編內容，一起認識米奇與他的好朋友，在遊玩中，其實寶貝正在進行人際關係上的美語互動呦！</p><ul><li><p><strong>互動式設計</strong>：每一頁都設計了不同的翻頁機關，讓孩子能夠在閱讀的過程中親自參與，增加了學習的樂趣。</p></li><li><p><strong>色彩繽紛的插畫</strong>：充滿活力的迪士尼角色，像是米奇、米妮和唐老鴨，讓孩子愛不釋手。</p></li><li><p><strong>培養閱讀習慣</strong>：這本書專為啟發孩子的閱讀興趣而設計，適合不同年齡段的孩子閱讀。</p></li></ul><p><img src="https://hackmd.io/_uploads/B1ts4H7cR.png" alt="image"></p><blockquote><p>翻開被遮蓋的卡片，看看藏起來的是哪位迪士尼大明星！</p></blockquote><p><img src="https://hackmd.io/_uploads/rkwRNrXqC.png" alt="image"></p><blockquote><p>掃描翻翻書上的QR code進入網頁 ，認識美式美語的打招呼方式再透過主題歌曲，讓寶貝開心學美語！</p></blockquote><hr><h1 id="為什麼選擇米奇翻翻書？"><a href="#為什麼選擇米奇翻翻書？" class="headerlink" title="為什麼選擇米奇翻翻書？"></a><strong>為什麼選擇米奇翻翻書？</strong></h1><p>米奇翻翻書不僅能夠吸引孩子的注意力，更能啟發他們的想像力。每一頁的設計都精心製作，讓孩子在探索的過程中，發現隱藏的驚喜，從而增加對閱讀的興趣。</p><hr><h1 id="限時優惠活動體驗組，免費申請"><a href="#限時優惠活動體驗組，免費申請" class="headerlink" title="限時優惠活動體驗組，免費申請"></a><strong>限時優惠活動體驗組，免費申請</strong></h1><p>現在透過我的專屬連結免費申請式用【米奇翻翻書】，還有其他體驗組。立即行動，讓孩子踏上閱讀的奇幻旅程！</p><p><img src="https://hackmd.io/_uploads/SJBxLB7cC.png" alt="image"></p><p><a href="https://vbtrax.com/track/clicks/7093/c627c2bc990927defb8dec35dc2e9753743940c172e5eff1113ff408600456ed"><strong>點擊這裡米奇美語體驗組免費申請</strong></a></p><p><img src="https://hackmd.io/_uploads/rkzFvrmcR.png" alt="image"></p><hr><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a><strong>總結</strong></h1><p>別讓您的孩子錯過這個探索書本世界的好機會！透過米奇翻翻書，讓他們在互動中學習，在閱讀中成長。趕快行動吧，透過以下連結購買，讓孩子的閱讀旅程更豐富多彩！</p><p><a href="https://vbtrax.com/track/clicks/7093/c627c2bc990927defb8dec35dc2e9753743940c172e5eff1113ff408600456ed"><strong>點擊這裡米奇美語體驗組免費申請</strong></a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7/">聯盟行銷</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%BF%AA%E5%A3%AB%E5%B0%BC%E7%BE%8E%E8%AA%9E/">迪士尼美語</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/09/%E8%AE%93%E5%AD%A9%E5%AD%90%E6%84%9B%E4%B8%8A%E9%96%B1%E8%AE%80%EF%BC%81%E6%8E%A2%E7%B4%A2%E7%B1%B3%E5%A5%87%E7%BF%BB%E7%BF%BB%E6%9B%B8%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C%EF%BC%8C%E7%8F%BE%E5%9C%A8%E7%AB%8B%E5%88%BB%E5%85%8D%E8%B2%BB%E7%B4%A2%E5%8F%96%EF%BC%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo部落格 - Butterfly 主題調整 第三天</title>
      <link>https://gahgah147.github.io/2024/08/07/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4-%E7%AC%AC%E4%B8%89%E5%A4%A9/</link>
      <guid>https://gahgah147.github.io/2024/08/07/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4-%E7%AC%AC%E4%B8%89%E5%A4%A9/</guid>
      <pubDate>Wed, 07 Aug 2024 08:52:53 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;設計Logo&quot;&gt;&lt;a href=&quot;#設計Logo&quot; class=&quot;headerlink&quot; title=&quot;設計Logo&quot;&gt;&lt;/a&gt;設計Logo&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/HJF2tD1c0.png&quot; al</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="設計Logo"><a href="#設計Logo" class="headerlink" title="設計Logo"></a>設計Logo</h1><p><img src="https://hackmd.io/_uploads/HJF2tD1c0.png" alt="logo"></p><h1 id="今天設定了-Nav-Bar"><a href="#今天設定了-Nav-Bar" class="headerlink" title="今天設定了 Nav Bar"></a>今天設定了 Nav Bar</h1><p><img src="https://hackmd.io/_uploads/S11M3wkcA.png" alt="image"></p><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nav:</span><br><span class="line">  logo: #image</span><br><span class="line">  display_title: true</span><br><span class="line">  fixed: false # fixed navigation bar</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  首頁: / || fas fa-home</span><br><span class="line">  時間軸: /archives/ || fas fa-archive</span><br><span class="line">  標籤: /tags/ || fas fa-tags</span><br><span class="line">  分類: /categories/ || fas fa-folder-open</span><br><span class="line">  # 清單||fas fa-list:</span><br><span class="line">  #   音樂: /music/ || fas fa-music</span><br><span class="line">  #   電影: /movies/ || fas fa-video</span><br><span class="line">  友情連結: /link/ || fas fa-link</span><br><span class="line">  關於: /about/ || fas fa-heart</span><br></pre></td></tr></table></figure><p>這邊設定成了中文</p><h1 id="頭像"><a href="#頭像" class="headerlink" title="頭像"></a>頭像</h1><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  img: /img/logo.png</span><br><span class="line">  effect: true # 頭像會一直轉圈</span><br></pre></td></tr></table></figure><p>這邊換成我設計的Logo了</p><p><img src="https://hackmd.io/_uploads/HJWfAvJ9A.png" alt="image"></p><h1 id="社交圖標-Social-Settings"><a href="#社交圖標-Social-Settings" class="headerlink" title="社交圖標 (Social Settings)"></a>社交圖標 (Social Settings)</h1><p>Butterfly支持 font-awesome v6 圖標.</p><p>書寫格式 圖標名：url || 描述性文字 || color</p><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  fab fa-github: https://github.com/xxxxx || Github || &quot;#hdhfbb&quot;</span><br><span class="line">  fas fa-envelope: mailto:xxxxxx@gmail.com || Email || &quot;#000000&quot;</span><br></pre></td></tr></table></figure><p>這邊我設定了 github的社交連結</p><p><img src="https://hackmd.io/_uploads/HySttceqR.png" alt="image"></p><h1 id="頂部圖"><a href="#頂部圖" class="headerlink" title="頂部圖"></a>頂部圖</h1><table><thead><tr><th>配置</th><th>解釋</th></tr></thead><tbody><tr><td>index_img</td><td>主頁的 top_img</td></tr><tr><td>default_top_img</td><td>默認的 top_img，當頁面的 top_img 沒有配置時，會顯示 default_top_img</td></tr><tr><td>archive_img</td><td>歸檔頁面的 top_img</td></tr><tr><td>tag_img</td><td>tag 子頁面 的 默認 top_img</td></tr><tr><td>tag_per_img</td><td>tag 子頁面的 top_img，可配置每個 tag 的 top_img</td></tr><tr><td>category_img</td><td>category 子頁面 的 默認 top_img</td></tr><tr><td>category_per_img</td><td>category 子頁面的 top_img，可配置每個 category 的 top_img</td></tr></tbody></table><h1 id="運行時間"><a href="#運行時間" class="headerlink" title="運行時間"></a>運行時間</h1><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtimeshow:</span><br><span class="line">  enable: true</span><br><span class="line">  publish_date: 6/7/2018 00:00:00  </span><br><span class="line">  ##網頁開通時間</span><br><span class="line">  #格式: 月/日/年 時間</span><br><span class="line">  #也可以寫成 年/月/日 時間</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SyQSl2xqA.png" alt="image"></p><p>這樣可以顯示已執行時間</p><h1 id="最新評論"><a href="#最新評論" class="headerlink" title="最新評論"></a>最新評論</h1><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Aside widget - Newest Comments</span><br><span class="line">newest_comments:</span><br><span class="line">  enable: true</span><br><span class="line">  sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  limit: 6</span><br><span class="line">  storage: 10 # unit: mins, save data to localStorage</span><br><span class="line">  avatar: true</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這邊我依設定啟動就會顯示空白，我想可能是因為目前還沒有任何評論，所以暫時還是先設定成 false</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>今天設定了Logo、Nav Bar、頂部圖、運行時間、最新評論等等的設定，發現官方文件還有更多詳細內容，超級多設定今天先暫時這樣好了，接下來的設定等改天再找時間來做</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E6%9E%B6%E7%AB%99%E8%A8%98%E9%8C%84/">架站記錄</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Hexo/">Hexo</category>
      
      <category domain="https://gahgah147.github.io/tags/Butterfly/">Butterfly</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/07/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4-%E7%AC%AC%E4%B8%89%E5%A4%A9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>區塊鏈 - Gala Film: Web3版本的Netflix平台，影音產業的區塊鏈革命</title>
      <link>https://gahgah147.github.io/2024/08/06/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Film-Web3%E7%89%88%E6%9C%AC%E7%9A%84Netflix%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%BD%B1%E9%9F%B3%E7%94%A2%E6%A5%AD%E7%9A%84%E5%8D%80%E5%A1%8A%E9%8F%88%E9%9D%A9%E5%91%BD/</link>
      <guid>https://gahgah147.github.io/2024/08/06/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Film-Web3%E7%89%88%E6%9C%AC%E7%9A%84Netflix%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%BD%B1%E9%9F%B3%E7%94%A2%E6%A5%AD%E7%9A%84%E5%8D%80%E5%A1%8A%E9%8F%88%E9%9D%A9%E5%91%BD/</guid>
      <pubDate>Tue, 06 Aug 2024 03:26:35 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;區塊鏈-Gala-Film-Web3版本的Netflix平台，影音產業的區塊鏈革命&quot;&gt;&lt;a href=&quot;#區塊鏈-Gala-Film-Web3版本的Netflix平台，影音產業的區塊鏈革命&quot; class=&quot;headerlink&quot; title=&quot;區塊鏈 - Gala</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="區塊鏈-Gala-Film-Web3版本的Netflix平台，影音產業的區塊鏈革命"><a href="#區塊鏈-Gala-Film-Web3版本的Netflix平台，影音產業的區塊鏈革命" class="headerlink" title="區塊鏈 - Gala Film: Web3版本的Netflix平台，影音產業的區塊鏈革命"></a>區塊鏈 - Gala Film: Web3版本的Netflix平台，影音產業的區塊鏈革命</h1><h1 id="Gala-Film-是什麼？"><a href="#Gala-Film-是什麼？" class="headerlink" title="Gala Film 是什麼？"></a>Gala Film 是什麼？</h1><p><img src="https://hackmd.io/_uploads/BJrrZZyq0.png" alt="image"></p><blockquote><p><a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a></p></blockquote><p><a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 是一個基於區塊鏈技術的影音平台，致力於革新電影和電視節目產業。透過區塊鏈技術，Gala Film 為創作者提供更多的控制權和收益，並為觀眾帶來全新的觀看體驗。</p><h1 id="Gala-Film-的特色"><a href="#Gala-Film-的特色" class="headerlink" title="Gala Film 的特色"></a>Gala Film 的特色</h1><h2 id="1-真正的作品所有權"><a href="#1-真正的作品所有權" class="headerlink" title="1. 真正的作品所有權"></a>1. 真正的作品所有權</h2><p><img src="https://hackmd.io/_uploads/Bk8Cm-kc0.png" alt="image"></p><p>在傳統影音產業中，作品的所有權通常掌握在大型製作公司手中，而創作者獲得的收益有限。在 <a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 上，影音作品以 NFT 的形式存在於區塊鏈上，這意味著創作者可以完全擁有他們的作品並直接從中獲益。</p><h2 id="2-去中心化的影音生態系統"><a href="#2-去中心化的影音生態系統" class="headerlink" title="2. 去中心化的影音生態系統"></a>2. 去中心化的影音生態系統</h2><p><img src="https://hackmd.io/_uploads/S1fqNZy5C.png" alt="image"></p><p><a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 採用了去中心化的架構，消除了中間人的干預。這不僅確保了影音作品的透明度和安全性，還讓創作者和觀眾之間的互動更加直接和公平。</p><h2 id="3-Gala-Nodes-支持的網絡"><a href="#3-Gala-Nodes-支持的網絡" class="headerlink" title="3. Gala Nodes 支持的網絡"></a>3. Gala Nodes 支持的網絡</h2><p><img src="https://hackmd.io/_uploads/Bk6aE-J9A.png" alt="image"></p><p><a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 依賴於 Gala Nodes 來支持其網絡運營。這些節點由社區成員運行，確保了平台的穩定性和安全性，並讓運行節點的成員能夠賺取 GALA 代幣。</p><h2 id="4-豐富多樣的影音內容"><a href="#4-豐富多樣的影音內容" class="headerlink" title="4. 豐富多樣的影音內容"></a>4. 豐富多樣的影音內容</h2><p><a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 平台上有豐富多樣的影音內容，涵蓋各種電影和電視節目類型。無論你是動作片愛好者，還是喜歡浪漫劇，<a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 都能滿足你的需求。</p><p><img src="https://hackmd.io/_uploads/rySeSZyqR.png" alt="image"><br><img src="https://hackmd.io/_uploads/By3-Bbk9R.png" alt="image"><br><img src="https://hackmd.io/_uploads/B1mIr-1cC.png" alt="image"></p><p>目前看來 <a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 上總共有9個電影。</p><h1 id="如何開始？"><a href="#如何開始？" class="headerlink" title="如何開始？"></a>如何開始？</h1><p>加入 <a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 的方式非常簡單：</p><ol><li>註冊 Gala Film 帳戶。<br><img src="https://hackmd.io/_uploads/H1H1UZJcC.png" alt="image"><blockquote><p>可以點選<a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 畫面右上角的註冊</p></blockquote></li></ol><p><img src="https://hackmd.io/_uploads/ByOU8WycC.png" alt="image"></p><ol start="2"><li>瀏覽平台上的影音作品，選擇你喜歡的內容，開始觀看。</li></ol><p>點擊這裡 <a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 註冊並開始你的影音之旅！</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p><a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 不僅僅是一個影音平台，更是一個讓創作者和觀眾能夠真正掌控影音命運的生態系統。無論你是影片創作者還是觀影愛好者，<a href="https://twcouponcenter.com/track/clicks/8873/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ed">Gala Film</a> 都能為你帶來全新的體驗。趕快加入我們，探索這個令人興奮的影音世界吧！</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Web3/">Web3</category>
      
      <category domain="https://gahgah147.github.io/tags/Block-Chain/">Block Chain</category>
      
      <category domain="https://gahgah147.github.io/tags/Gala/">Gala</category>
      
      <category domain="https://gahgah147.github.io/tags/Film/">Film</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/06/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Film-Web3%E7%89%88%E6%9C%AC%E7%9A%84Netflix%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%BD%B1%E9%9F%B3%E7%94%A2%E6%A5%AD%E7%9A%84%E5%8D%80%E5%A1%8A%E9%8F%88%E9%9D%A9%E5%91%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>區塊鏈 - Gala Music : Web3版本的Spotify平台，音樂產業的區塊鏈革命</title>
      <link>https://gahgah147.github.io/2024/08/05/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Music-Web3%E7%89%88%E6%9C%AC%E7%9A%84Spotify%E5%B9%B3%E5%8F%B0%EF%BC%8C%E9%9F%B3%E6%A8%82%E7%94%A2%E6%A5%AD%E7%9A%84%E5%8D%80%E5%A1%8A%E9%8F%88%E9%9D%A9%E5%91%BD/</link>
      <guid>https://gahgah147.github.io/2024/08/05/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Music-Web3%E7%89%88%E6%9C%AC%E7%9A%84Spotify%E5%B9%B3%E5%8F%B0%EF%BC%8C%E9%9F%B3%E6%A8%82%E7%94%A2%E6%A5%AD%E7%9A%84%E5%8D%80%E5%A1%8A%E9%8F%88%E9%9D%A9%E5%91%BD/</guid>
      <pubDate>Mon, 05 Aug 2024 08:59:18 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;什麼是-Gala-Music&quot;&gt;&lt;a href=&quot;#什麼是-Gala-Music&quot; class=&quot;headerlink&quot; title=&quot;什麼是 Gala Music?&quot;&gt;&lt;/a&gt;什麼是 Gala Music?&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ha</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="什麼是-Gala-Music"><a href="#什麼是-Gala-Music" class="headerlink" title="什麼是 Gala Music?"></a>什麼是 Gala Music?</h1><p><img src="https://hackmd.io/_uploads/rJKaoWCt0.png" alt="image"></p><blockquote><p><a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a></p></blockquote><p><a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 是一個基於區塊鏈技術的音樂平台，旨在革新音樂產業。通過區塊鏈技術，Gala Music 不僅讓藝術家擁有他們的作品，還為聽眾提供了一種全新的互動方式，讓音樂創作變得更加公平和透明。</p><h1 id="Gala-Music-的特色"><a href="#Gala-Music-的特色" class="headerlink" title="Gala Music 的特色"></a>Gala Music 的特色</h1><h2 id="1-真正的音樂作品所有權"><a href="#1-真正的音樂作品所有權" class="headerlink" title="1. 真正的音樂作品所有權"></a>1. 真正的音樂作品所有權</h2><p><img src="https://hackmd.io/_uploads/BJcvlGCKR.png" alt="image"></p><p>在傳統音樂產業中，音樂作品的所有權通常掌握在唱片公司手中，藝術家獲得的收益有限。而在 <a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 上，音樂作品以 NFT 的形式存在於區塊鏈上，這意味著藝術家可以完全擁有他們的作品並直接從中獲益。</p><h2 id="2-去中心化的音樂生態系統"><a href="#2-去中心化的音樂生態系統" class="headerlink" title="2. 去中心化的音樂生態系統"></a>2. 去中心化的音樂生態系統</h2><p><img src="https://hackmd.io/_uploads/SyFngzCtC.png" alt="image"></p><p><a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 採用了去中心化的架構，消除了中間人的干預。這不僅確保了音樂作品的透明度和安全性，還讓藝術家和聽眾之間的互動更加直接和公平。</p><h2 id="3-Gala-Nodes-支持的網絡"><a href="#3-Gala-Nodes-支持的網絡" class="headerlink" title="3. Gala Nodes 支持的網絡"></a>3. Gala Nodes 支持的網絡</h2><p><img src="https://hackmd.io/_uploads/rkzJWM0YA.png" alt="image"></p><p><a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 依賴於 Gala Nodes 來支持其網絡運營。這些節點由社區成員運行，確保了平台的穩定性和安全性，並讓運行節點的成員能夠賺取 GALA 代幣。</p><h2 id="4-豐富多樣的音樂內容"><a href="#4-豐富多樣的音樂內容" class="headerlink" title="4. 豐富多樣的音樂內容"></a>4. 豐富多樣的音樂內容</h2><p><img src="https://hackmd.io/_uploads/S1ry6ZAKR.png" alt="image"><br><a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 平台上有豐富多樣的音樂內容，涵蓋各種音樂風格和流派。無論你是流行音樂愛好者，還是喜歡古典音樂，<a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 都能滿足你的需求。</p><h1 id="如何開始？"><a href="#如何開始？" class="headerlink" title="如何開始？"></a>如何開始？</h1><p>加入 <a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 的方式非常簡單：</p><ol><li>註冊 Gala Music 帳戶。</li></ol><p><img src="https://hackmd.io/_uploads/BJu7WG0K0.png" alt="image"></p><blockquote><p>可以點選<a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 畫面右上角的註冊</p></blockquote><p><img src="https://hackmd.io/_uploads/S19rbzCK0.png" alt="image"></p><blockquote><p>這邊可以選擇綁定Google、 Apple或 Facebook也可以設定帳號密碼登入</p></blockquote><ol start="2"><li>瀏覽平台上的音樂作品，選擇你喜歡的作品，開始享受音樂。</li></ol><p>點擊這裡 <a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 註冊並開始你的音樂之旅！</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p><a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 不僅僅是一個音樂平台，更是一個讓藝術家和聽眾能夠真正掌控音樂命運的生態系統。無論你是音樂創作者還是音樂愛好者，<a href="https://vbshoptrax.com/track/clicks/8872/c627c2bc990927d8f18cec35dc2e9753743940c172e5eff1113ff4086f0c58ec">Gala Music</a> 都能為你帶來全新的體驗。趕快加入我們，探索這個令人興奮的音樂世界吧！</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Web3/">Web3</category>
      
      <category domain="https://gahgah147.github.io/tags/Block-Chain/">Block Chain</category>
      
      <category domain="https://gahgah147.github.io/tags/Gala/">Gala</category>
      
      <category domain="https://gahgah147.github.io/tags/Music/">Music</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/05/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Music-Web3%E7%89%88%E6%9C%AC%E7%9A%84Spotify%E5%B9%B3%E5%8F%B0%EF%BC%8C%E9%9F%B3%E6%A8%82%E7%94%A2%E6%A5%AD%E7%9A%84%E5%8D%80%E5%A1%8A%E9%8F%88%E9%9D%A9%E5%91%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>區塊鏈 - Gala Games : WEB3版本的Steam 遊戲平台</title>
      <link>https://gahgah147.github.io/2024/08/05/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Games-WEB3%E7%89%88%E6%9C%AC%E7%9A%84Steam-%E9%81%8A%E6%88%B2%E5%B9%B3%E5%8F%B0/</link>
      <guid>https://gahgah147.github.io/2024/08/05/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Games-WEB3%E7%89%88%E6%9C%AC%E7%9A%84Steam-%E9%81%8A%E6%88%B2%E5%B9%B3%E5%8F%B0/</guid>
      <pubDate>Mon, 05 Aug 2024 03:31:27 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Gala-Games-是什麼&quot;&gt;&lt;a href=&quot;#Gala-Games-是什麼&quot; class=&quot;headerlink&quot; title=&quot;Gala Games 是什麼?&quot;&gt;&lt;/a&gt;Gala Games 是什麼?&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ha</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Gala-Games-是什麼"><a href="#Gala-Games-是什麼" class="headerlink" title="Gala Games 是什麼?"></a>Gala Games 是什麼?</h1><p><img src="https://hackmd.io/_uploads/ByOs2hTY0.png" alt="image"></p><blockquote><p><a href="https://tinyurl.com/24ke97we">Gala Games </a></p></blockquote><p><a href="https://tinyurl.com/24ke97we">Gala Games</a> 是一個基於區塊鏈技術的遊戲平台，致力於讓玩家掌控他們的遊戲體驗。<a href="https://tinyurl.com/24ke97we">Gala Games</a> 的願景是將權力交還給玩家，讓他們不僅僅是遊戲的參與者，更是遊戲世界的創造者和擁有者。從 <a href="https://tinyurl.com/24ke97we">Gala Games 連結</a>進去可以看到畫面很像 Steam 一樣有很多款遊戲，但這些遊戲的特點就是都是跟Gala區塊鏈有關的區塊鏈遊戲。</p><h1 id="Gala-Games-的特色"><a href="#Gala-Games-的特色" class="headerlink" title="Gala Games 的特色"></a>Gala Games 的特色</h1><h2 id="1-真正的資產所有權"><a href="#1-真正的資產所有權" class="headerlink" title="1. 真正的資產所有權"></a>1. 真正的資產所有權</h2><p>在傳統遊戲中，玩家購買的物品和角色屬於遊戲公司，一旦遊戲關閉或玩家停止遊戲，這些資產就會消失。而在 <a href="https://tinyurl.com/24ke97we">Gala Games</a>，所有的遊戲內資產都是以 NFT（非同質化代幣）的形式存在於區塊鏈上，這意味著玩家真正擁有這些資產，並且可以在市場上自由交易。</p><p><img src="https://hackmd.io/_uploads/SJjzfa6KC.png" alt="image"></p><blockquote><p><a href="https://tinyurl.com/24ke97we">其中一個遊戲 Town Star販賣中的道具</a>  </p></blockquote><h2 id="2-去中心化的遊戲生態系統"><a href="#2-去中心化的遊戲生態系統" class="headerlink" title="2. 去中心化的遊戲生態系統"></a>2. 去中心化的遊戲生態系統</h2><p><a href="https://tinyurl.com/24ke97we">Gala Games</a> 採用了去中心化的架構，遊戲世界由玩家共同維護。這樣的設計不僅確保了遊戲的公平性，還能讓玩家參與到遊戲的開發和決策中。</p><p><img src="https://hackmd.io/_uploads/ryWfmTaKR.png" alt="image"></p><h2 id="3-Gala-Node-網絡"><a href="#3-Gala-Node-網絡" class="headerlink" title="3. Gala Node 網絡"></a>3. Gala Node 網絡</h2><p><a href="https://tinyurl.com/24ke97we">Gala Games</a> 依賴於一個去中心化的伺服器網絡，由玩家運行的 Gala Nodes 支持。這些節點確保了遊戲的運行穩定性，同時也讓玩家可以通過運行節點賺取 GALA 代幣。</p><p><img src="https://hackmd.io/_uploads/ByERl66Y0.png" alt="image"></p><h2 id="4-多樣化的遊戲"><a href="#4-多樣化的遊戲" class="headerlink" title="4. 多樣化的遊戲"></a>4. 多樣化的遊戲</h2><p><a href="https://tinyurl.com/24ke97we">Gala Games</a> 平台上有多款遊戲，涵蓋不同類型和風格，從策略遊戲到角色扮演遊戲應有盡有。無論你是喜歡建設自己的帝國，還是想要體驗冒險，<a href="https://tinyurl.com/24ke97we">Gala Games</a> 都能滿足你的需求。</p><p><img src="https://hackmd.io/_uploads/SJnnN6TK0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Bk6p4apYA.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/S1a0E6Tt0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SJ21BpaFR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SJAgBpaK0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SylGS6Tt0.png" alt="image"></p><p>目前看來 <a href="https://tinyurl.com/24ke97we">Gala Games</a> 上總共有18款遊戲，另外其中有3款式準備要推出的遊戲。</p><h1 id="如何開始？"><a href="#如何開始？" class="headerlink" title="如何開始？"></a>如何開始？</h1><p>加入 <a href="https://tinyurl.com/24ke97we">Gala Games</a> 的方式非常簡單：</p><ol><li>註冊 Gala Games 帳戶。</li></ol><p><img src="https://hackmd.io/_uploads/r1OKQ6aKA.png" alt="image"></p><blockquote><p>可以點選<a href="https://tinyurl.com/24ke97we">Gala Games</a> 畫面右上角的註冊</p></blockquote><p><img src="https://hackmd.io/_uploads/r1bnQ66tR.png" alt="image"></p><blockquote><p>這邊可以選擇綁定Google、 Apple或 Facebook也可以設定帳號密碼登入</p></blockquote><ol start="2"><li>選擇你感興趣的遊戲，開始遊玩並賺取資產。</li></ol><p>點擊這裡 <a href="https://tinyurl.com/24ke97we">Gala Games </a> 註冊並開始你的遊戲之旅！</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p><a href="https://tinyurl.com/24ke97we">Gala Games</a> 不僅僅是一個遊戲平台，更是一個玩家可以真正掌控自己遊戲命運的生態系統。無論你是遊戲愛好者還是區塊鏈技術的愛好者，<a href="https://tinyurl.com/24ke97we">Gala Games</a> 都能為你帶來全新的體驗。趕快加入我們，探索這個令人興奮的世界吧！</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Web3/">Web3</category>
      
      <category domain="https://gahgah147.github.io/tags/Block-Chain/">Block Chain</category>
      
      <category domain="https://gahgah147.github.io/tags/Gala/">Gala</category>
      
      <category domain="https://gahgah147.github.io/tags/Games/">Games</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/05/%E5%8D%80%E5%A1%8A%E9%8F%88-Gala-Games-WEB3%E7%89%88%E6%9C%AC%E7%9A%84Steam-%E9%81%8A%E6%88%B2%E5%B9%B3%E5%8F%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>毛好多：讓您的寵物享受極致呵護的最佳選擇</title>
      <link>https://gahgah147.github.io/2024/08/02/%E6%AF%9B%E5%A5%BD%E5%A4%9A%EF%BC%9A%E8%AE%93%E6%82%A8%E7%9A%84%E5%AF%B5%E7%89%A9%E4%BA%AB%E5%8F%97%E6%A5%B5%E8%87%B4%E5%91%B5%E8%AD%B7%E7%9A%84%E6%9C%80%E4%BD%B3%E9%81%B8%E6%93%87/</link>
      <guid>https://gahgah147.github.io/2024/08/02/%E6%AF%9B%E5%A5%BD%E5%A4%9A%EF%BC%9A%E8%AE%93%E6%82%A8%E7%9A%84%E5%AF%B5%E7%89%A9%E4%BA%AB%E5%8F%97%E6%A5%B5%E8%87%B4%E5%91%B5%E8%AD%B7%E7%9A%84%E6%9C%80%E4%BD%B3%E9%81%B8%E6%93%87/</guid>
      <pubDate>Fri, 02 Aug 2024 07:46:52 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;作為一名寵物主人，我們家養的瑪爾濟斯也常常會想吃一些零食，而且牠又那麼可愛，我們總是希望能夠為心愛的毛孩提供最好的生活品質。無論是食品、玩具，還是護理用品，每一樣都馬虎不得。今天，我們要為您推薦一個專門為毛孩設計的線上選物店——&lt;a href=&quot;https://tinyur</description>
        
      
      
      
      <content:encoded><![CDATA[<p>作為一名寵物主人，我們家養的瑪爾濟斯也常常會想吃一些零食，而且牠又那麼可愛，我們總是希望能夠為心愛的毛孩提供最好的生活品質。無論是食品、玩具，還是護理用品，每一樣都馬虎不得。今天，我們要為您推薦一個專門為毛孩設計的線上選物店——<a href="https://tinyurl.com/22l4rfwv">毛好多 - 毛比你多的毛孩選物店</a>。</p><p><img src="https://hackmd.io/_uploads/SkCsLZ5KR.png" alt="image"></p><p>立刻點選以下連結去逛逛^^<br><a href="https://tinyurl.com/22l4rfwv">https://tinyurl.com/22l4rfwv</a></p><h1 id="毛好多是什麼？"><a href="#毛好多是什麼？" class="headerlink" title="毛好多是什麼？"></a>毛好多是什麼？</h1><p>毛好多是一個專門為寵物主人打造的線上選物店，提供多種優質的寵物用品。無論您的寵物是狗狗、貓咪，還是其他小動物，毛好多都能夠滿足牠們的各種需求。平台上的所有產品均經過嚴格篩選，保證品質和安全，讓您的毛孩享受最好的照顧。</p><p>因為我們家養的是可愛馬爾濟斯，所以會想要常常去逛他們的狗狗專區<br><img src="https://hackmd.io/_uploads/H1g4Db9F0.png" alt="image"></p><h1 id="平台特色"><a href="#平台特色" class="headerlink" title="平台特色"></a>平台特色</h1><h2 id="1-多樣化的寵物用品"><a href="#1-多樣化的寵物用品" class="headerlink" title="1. 多樣化的寵物用品"></a>1. 多樣化的寵物用品</h2><p>毛好多提供豐富的寵物用品，包括高品質的食品、趣味玩具、健康護理產品等，讓您一站式購齊所有所需。</p><p><img src="https://hackmd.io/_uploads/SJ70wW5F0.png" alt="image"></p><h2 id="2-優質品牌保障"><a href="#2-優質品牌保障" class="headerlink" title="2. 優質品牌保障"></a>2. 優質品牌保障</h2><p>平台上所有商品均來自知名品牌，品質有保障。無論是食品還是護理用品，都經過專業檢驗，讓您購物無憂。</p><h2 id="3-專業養護建議"><a href="#3-專業養護建議" class="headerlink" title="3. 專業養護建議"></a>3. 專業養護建議</h2><p>毛好多不僅僅是一個購物平台，還提供豐富的寵物養護資訊和建議，幫助您更好地了解和照顧您的毛孩。</p><p><img src="https://hackmd.io/_uploads/S19kub9FR.png" alt="image"></p><h2 id="4-便捷的購物體驗"><a href="#4-便捷的購物體驗" class="headerlink" title="4. 便捷的購物體驗"></a>4. 便捷的購物體驗</h2><p>毛好多的線上平台設計簡潔，操作方便，讓您輕鬆找到所需產品，快速完成購買，享受無憂的購物體驗。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>現在就訪問 <a href="https://tinyurl.com/22l4rfwv">毛好多線上選物店</a>，探索更多優質產品，讓您的毛孩享受最好的生活品質。毛好多，毛比你多的毛孩選物店，為您的寵物提供最貼心的服務和最優質的產品。</p><p><img src="https://hackmd.io/_uploads/SyUyK-5F0.png" alt="image"></p><p>可以常常去挑我們家波比愛吃的零食</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7/">聯盟行銷</category>
      
      <category domain="https://gahgah147.github.io/tags/%E6%AF%9B%E5%A5%BD%E5%A4%9A/">毛好多</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%AF%B5%E7%89%A9%E8%B3%BC%E7%89%A9/">寵物購物</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/02/%E6%AF%9B%E5%A5%BD%E5%A4%9A%EF%BC%9A%E8%AE%93%E6%82%A8%E7%9A%84%E5%AF%B5%E7%89%A9%E4%BA%AB%E5%8F%97%E6%A5%B5%E8%87%B4%E5%91%B5%E8%AD%B7%E7%9A%84%E6%9C%80%E4%BD%B3%E9%81%B8%E6%93%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo部落格 - Butterfly 主題調整 第二天</title>
      <link>https://gahgah147.github.io/2024/08/01/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4-%E7%AC%AC%E4%BA%8C%E5%A4%A9/</link>
      <guid>https://gahgah147.github.io/2024/08/01/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4-%E7%AC%AC%E4%BA%8C%E5%A4%A9/</guid>
      <pubDate>Thu, 01 Aug 2024 07:31:26 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;設定語言&quot;&gt;&lt;a href=&quot;#設定語言&quot; class=&quot;headerlink&quot; title=&quot;設定語言&quot;&gt;&lt;/a&gt;設定語言&lt;/h1&gt;&lt;p&gt;修改網站配置文件 &lt;code&gt;_config.yml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;調整以下變數&lt;/p&gt;
&lt;figure cl</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="設定語言"><a href="#設定語言" class="headerlink" title="設定語言"></a>設定語言</h1><p>修改網站配置文件 <code>_config.yml</code></p><p>調整以下變數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language:</span><br></pre></td></tr></table></figure><p>默認語言是 en</p><p>主題支持三種語言</p><p>default(en)<br>zh-CN (簡體中文)<br>zh-TW (繁體中文)</p><p>我們這邊改為 zh-TW (繁體中文)</p><h1 id="網站資料"><a href="#網站資料" class="headerlink" title="網站資料"></a>網站資料</h1><p>修改網站各種資料，例如標題、副標題和電子信箱等個人資料，請修改部落格根目錄的<code>_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: &lt;部落格名稱&gt;</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: &#x27;&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: &lt;作者名稱&gt;</span><br><span class="line">language: zh-TW</span><br><span class="line">timezone: &#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這邊需要仔細想想keywords 要設定成什麼</p><h1 id="導航欄設置-Navigation-bar-settings"><a href="#導航欄設置-Navigation-bar-settings" class="headerlink" title="導航欄設置 (Navigation bar settings)"></a>導航欄設置 (Navigation bar settings)</h1><p>主題配置文件<code>_config.yml</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nav:</span><br><span class="line">  logo: #image</span><br><span class="line">  display_title: true</span><br><span class="line">  fixed: false # fixed navigation bar</span><br></pre></td></tr></table></figure><p>logo:網站的 logo，支持圖片，直接填入圖片鏈接<br>display_title:是否顯示網站標題，填寫 true 或者 false<br>fixed:是否固定狀態欄，填寫 true 或者 false</p><h1 id="菜單-目錄"><a href="#菜單-目錄" class="headerlink" title="菜單&#x2F;目錄"></a>菜單&#x2F;目錄</h1><p>修改 主題配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Home: / || fas fa-home</span><br><span class="line">Archives: /archives/ || fas fa-archive</span><br><span class="line">Tags: /tags/ || fas fa-tags</span><br><span class="line">Categories: /categories/ || fas fa-folder-open</span><br><span class="line">List||fas fa-list:</span><br><span class="line">  Music: /music/ || fas fa-music</span><br><span class="line">  Movie: /movies/ || fas fa-video</span><br><span class="line">Link: /link/ || fas fa-link</span><br><span class="line">About: /about/ || fas fa-heart</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  首頁: / || fas fa-home</span><br><span class="line">  時間軸: /archives/ || fas fa-archive</span><br><span class="line">  標籤: /tags/ || fas fa-tags</span><br><span class="line">  分類: /categories/ || fas fa-folder-open</span><br><span class="line">  清單||fa fa-heartbeat:</span><br><span class="line">    音樂: /music/ || fas fa-music</span><br><span class="line">    照片: /Gallery/ || fas fa-images</span><br><span class="line">    電影: /movies/ || fas fa-video</span><br><span class="line">  友鏈: /link/ || fas fa-link</span><br><span class="line">  關於: /about/ || fas fa-heart</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="代碼-Code-Blocks"><a href="#代碼-Code-Blocks" class="headerlink" title="代碼 (Code Blocks)"></a>代碼 (Code Blocks)</h1><p>Butterfly 支持6種代碼高亮樣式：</p><p>darker<br>pale night<br>light<br>ocean<br>mac<br>mac light<br>修改 主題配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_theme: light</span><br></pre></td></tr></table></figure><h1 id="設定搜尋功能"><a href="#設定搜尋功能" class="headerlink" title="設定搜尋功能"></a>設定搜尋功能</h1><p>採用本地搜尋功能，這邊我選用hexo-generator-search來實作搜尋功能<br><img src="https://hackmd.io/_uploads/H1qeGFutA.png" alt="image"></p><blockquote><p><a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a></p></blockquote><h2 id="安裝-hexo-generator-search"><a href="#安裝-hexo-generator-search" class="headerlink" title="安裝 hexo-generator-search"></a>安裝 hexo-generator-search</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h2 id="修改-主題配置文件-themes-butterfly-config-yml"><a href="#修改-主題配置文件-themes-butterfly-config-yml" class="headerlink" title="修改 主題配置文件  themes/butterfly/_config.yml"></a>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  CDN:</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>參數</th><th>解釋</th></tr></thead><tbody><tr><td>enable</td><td>是否開啟本地搜索</td></tr><tr><td>preload</td><td>預加載，開啟後，進入網頁後會自動加載搜索文件。關閉時，只有點擊搜索按鈕後，才會加載搜索文件</td></tr><tr><td>top_n_per_article</td><td>匹配的文章結果，默認顯示最開始的 1段結果</td></tr><tr><td>unescape</td><td>將 html 字符串解碼為可讀字符串</td></tr><tr><td>CDN</td><td>搜索文件的 CDN 地址（默認使用的本地鏈接）</td></tr></tbody></table><p>這邊實測設定後右上角會出現這個搜尋的圖案<br><img src="https://hackmd.io/_uploads/HJnYm2OFC.png" alt="image"></p><p>然後點擊就可以進行搜尋<br><img src="https://hackmd.io/_uploads/SJE2Q2dY0.png" alt="image"></p><p>測試真的可以搜尋到文章<br><img src="https://hackmd.io/_uploads/rkJb42dYC.png" alt="image"></p><h1 id="評論功能設定"><a href="#評論功能設定" class="headerlink" title="評論功能設定"></a>評論功能設定</h1><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">comments:</span><br><span class="line">  # Up to two comments system, the first will be shown as default</span><br><span class="line">  # Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo</span><br><span class="line">  use: Valine,Disqus</span><br><span class="line">  text: true # Display the comment name next to the button</span><br><span class="line">  # lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span><br><span class="line">  # If you set it to true, the comment count will be invalid</span><br><span class="line">  lazyload: true</span><br><span class="line">  count: true # Display comment count in top_img</span><br><span class="line">  card_post_count: false # Display comment count in Home Page</span><br></pre></td></tr></table></figure><table><thead><tr><th>參數</th><th>解釋</th></tr></thead><tbody><tr><td>use</td><td>使用的評論（請注意，最多支持兩個，如果不需要請留空）注意：雙評論不能是 Disqus 和 Disqusjs 一起，由於其共用同一個 ID，會出錯</td></tr><tr><td>text</td><td>是否顯示評論服務商的名字</td></tr><tr><td>lazyload</td><td>是否為評論開啟lazyload，開啟後，只有滾動到評論位置時才會加載評論所需要的資源（開啟 lazyload 後，評論數將不顯示）</td></tr><tr><td>count</td><td>是否在文章頂部顯示評論數</td></tr><tr><td>livere、Giscus 和 utterances 不支持評論數顯示</td><td></td></tr><tr><td>card_post_count</td><td>是否在首頁文章卡片顯示評論數</td></tr><tr><td>gitalk、livere 、Giscus 和 utterances 不支持評論數顯示</td><td></td></tr></tbody></table><p>以上變數是在 2024-08-01 參考 Butterfly 官方配置說明文件設定的，最新內容建議可以參考官方網站<a href="https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96">https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96</a></p><p>這邊修改過後實測真的有評論區可以留言了^^<br><img src="https://hackmd.io/_uploads/SyEFBn_t0.png" alt="image"></p><h1 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h1><h2 id="通用設置"><a href="#通用設置" class="headerlink" title="通用設置"></a>通用設置</h2><p>這邊Butterfly設定內建是使用 sharejs<br><img src="https://hackmd.io/_uploads/HynyBhdKA.png" alt="image"></p><blockquote><p><a href="https://github.com/overtrue/share.js/">https://github.com/overtrue/share.js/</a></p></blockquote><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sharejs:</span><br><span class="line">  enable: true</span><br><span class="line">  sites: facebook  #想要顯示的內容  ,twitter,wechat,weibo,qq</span><br></pre></td></tr></table></figure><p>這邊因為我只有facebook 所以這樣更改</p><p>目前暫時先設定通用設置，官網還有其他留言板設定像是Disqus、livere (來必力)、gitalk、 Valine、Waline、Utterances、Facebook Comments、Twikoo、Giscus、remark42、artalk 可以參考，有很多的選擇。</p><h1 id="在線聊天"><a href="#在線聊天" class="headerlink" title="在線聊天"></a>在線聊天</h1><h2 id="通用設置-1"><a href="#通用設置-1" class="headerlink" title="通用設置"></a>通用設置</h2><p>修改 主題配置文件  <code>themes/butterfly/_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Chat Button [recommend]</span><br><span class="line"># It will create a button in the bottom right corner of website, and hide the origin button</span><br><span class="line">chat_btn: true</span><br></pre></td></tr></table></figure><p>為了不影響訪客的體驗，主題提供一個<code>chat_hide_show</code>配置<br>設為<code>true</code>後，使用工具提供的按鈕時，只有向上滾動才會顯示聊天按鈕，向下滾動時會隱藏按鈕。</p><p>修改 <code>主題配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># The origin chat button is displayed when scrolling up, and the button is hidden when scrolling down</span><br><span class="line">chat_hide_show: true</span><br></pre></td></tr></table></figure><div class="note info simple"><p>如果使用工具自帶的聊天按鈕，按鈕位置可能會遮擋右下角圖標，請配置<code>rightside_bottom</code>調正右下角圖標位置</p></div><p>設定之後在這邊會顯示有聊天功能<br><img src="https://hackmd.io/_uploads/r1zpTnOKC.png" alt="image"></p><h2 id="設定crisp"><a href="#設定crisp" class="headerlink" title="設定crisp"></a>設定crisp</h2><p><img src="https://hackmd.io/_uploads/HyWykput0.png" alt="image"></p><blockquote><p><a href="https://crisp.chat/en/">https://crisp.chat/en/</a></p></blockquote><p>註冊 crisp 帳號<br><img src="https://hackmd.io/_uploads/Sk1zJauKA.png" alt="image"></p><p>設定樣式<br><img src="https://hackmd.io/_uploads/B1Xc1pdK0.png" alt="image"></p><p>註冊完成後可以取得這個資料<br><img src="https://hackmd.io/_uploads/SkxRJ6_KC.png" alt="image"></p><p>找到需要的網站ID 進行設定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># crisp</span><br><span class="line"># https://crisp.chat/en/</span><br><span class="line">crisp:</span><br><span class="line">  enable: true</span><br><span class="line">  website_id: xxxxxxxx</span><br></pre></td></tr></table></figure><p>實測設定完可以成功留言<br><img src="https://hackmd.io/_uploads/Sk-fMa_YR.png" alt="image"></p><p>也可以成功在後台看到這邊的訊息，也可以回應。<br><img src="https://hackmd.io/_uploads/HkC8fTOYA.png" alt="image"></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>今天設定了Butterfly 主題的代碼樣式、搜尋功能、評論功能、分享、跟在線聊天設定，官方網站還有好幾項，這部分我覺得之後再來找時間設定好了</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E6%9E%B6%E7%AB%99%E8%A8%98%E9%8C%84/">架站記錄</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Hexo/">Hexo</category>
      
      <category domain="https://gahgah147.github.io/tags/Butterfly/">Butterfly</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/01/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4-%E7%AC%AC%E4%BA%8C%E5%A4%A9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>發現家樂福的驚喜優惠：讓您的購物體驗更加美好</title>
      <link>https://gahgah147.github.io/2024/08/01/%E7%99%BC%E7%8F%BE%E5%AE%B6%E6%A8%82%E7%A6%8F%E7%9A%84%E9%A9%9A%E5%96%9C%E5%84%AA%E6%83%A0%EF%BC%9A%E8%AE%93%E6%82%A8%E7%9A%84%E8%B3%BC%E7%89%A9%E9%AB%94%E9%A9%97%E6%9B%B4%E5%8A%A0%E7%BE%8E%E5%A5%BD/</link>
      <guid>https://gahgah147.github.io/2024/08/01/%E7%99%BC%E7%8F%BE%E5%AE%B6%E6%A8%82%E7%A6%8F%E7%9A%84%E9%A9%9A%E5%96%9C%E5%84%AA%E6%83%A0%EF%BC%9A%E8%AE%93%E6%82%A8%E7%9A%84%E8%B3%BC%E7%89%A9%E9%AB%94%E9%A9%97%E6%9B%B4%E5%8A%A0%E7%BE%8E%E5%A5%BD/</guid>
      <pubDate>Thu, 01 Aug 2024 02:10:34 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;大家好，今天要跟大家分享家樂福的線上購物平台，其實之前有空都會跟家人一起去逛家樂福，都會看到很多特價商品而且有時候，不知不覺就會買很多東西導致每次都會都非常的重，辛辛苦苦搬回家之後要在一個一個塞進冰箱，這邊建議可以在家輕鬆地在家吹冷氣線上逛價樂福&lt;/p&gt;
&lt;p&gt;這邊是家樂福</description>
        
      
      
      
      <content:encoded><![CDATA[<p>大家好，今天要跟大家分享家樂福的線上購物平台，其實之前有空都會跟家人一起去逛家樂福，都會看到很多特價商品而且有時候，不知不覺就會買很多東西導致每次都會都非常的重，辛辛苦苦搬回家之後要在一個一個塞進冰箱，這邊建議可以在家輕鬆地在家吹冷氣線上逛價樂福</p><p>這邊是家樂福的線上購物平台<br><img src="https://hackmd.io/_uploads/HJ3qGwdF0.png" alt="image"></p><blockquote><p><a href="https://abzcoupon.com/track/clicks/4459/c627c2bc990927defa8aec35dc2e9753743940c172e5eff1113ff40863005ae7">https://abzcoupon.com/track/clicks/4459/c627c2bc990927defa8aec35dc2e9753743940c172e5eff1113ff40863005ae7</a></p></blockquote><h2 id="超讚的優惠券專區"><a href="#超讚的優惠券專區" class="headerlink" title="超讚的優惠券專區"></a>超讚的優惠券專區</h2><p><img src="https://hackmd.io/_uploads/SJP14vut0.png" alt="image"></p><blockquote><p><a href="https://tinyurl.com/2633nl84">https://tinyurl.com/2633nl84</a></p></blockquote><p>這邊的優惠券專區，就算是已經在現場逛了也可以看看有優惠哦。</p><h2 id="限時優惠區"><a href="#限時優惠區" class="headerlink" title="限時優惠區"></a>限時優惠區</h2><p><img src="https://hackmd.io/_uploads/SJOnNv_FC.png" alt="image"></p><h2 id="精選活動區"><a href="#精選活動區" class="headerlink" title="精選活動區"></a>精選活動區</h2><p><img src="https://hackmd.io/_uploads/Sk5-rwdKC.png" alt="image"></p><p>這邊也有很多的精選活動，比如周四固定會有7-11取貨299免運的活動</p><h2 id="銀行優惠活動"><a href="#銀行優惠活動" class="headerlink" title="銀行優惠活動"></a>銀行優惠活動</h2><p><img src="https://hackmd.io/_uploads/H10LSPuF0.png" alt="image"></p><p>這邊有玉山銀行的優惠活動哦</p><p><img src="https://hackmd.io/_uploads/SJD5LwuK0.png" alt="image"><br><a href="https://tinyurl.com/228rp6u2">https://tinyurl.com/228rp6u2</a></p><p>這邊是國泰世華銀行跟聯邦銀行的優惠<br><img src="https://hackmd.io/_uploads/r1aTLvutC.png" alt="image"></p><p>玉山銀行分期0利率的優惠還有樂天信用卡的優惠<br><img src="https://hackmd.io/_uploads/r18ZvvdYC.png" alt="image"></p><p>玉山銀新客新客家加碼200元優惠<br><img src="https://hackmd.io/_uploads/HJLqPvOt0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/ryFivPuKA.png" alt="image"></p><blockquote><p><a href="https://tinyurl.com/2aan4abw">https://tinyurl.com/2aan4abw</a></p></blockquote><h1 id="特價商品推薦"><a href="#特價商品推薦" class="headerlink" title="特價商品推薦"></a>特價商品推薦</h1><h2 id="廠商直送優惠"><a href="#廠商直送優惠" class="headerlink" title="廠商直送優惠"></a>廠商直送優惠</h2><p><img src="https://hackmd.io/_uploads/SknUuPdY0.png" alt="image"></p><h2 id="中元普渡優惠"><a href="#中元普渡優惠" class="headerlink" title="中元普渡優惠"></a>中元普渡優惠</h2><p>中元普渡拜拜用品<br><img src="https://hackmd.io/_uploads/HkEYuvdtR.png" alt="image"></p><p>中元普渡零食飲料<br><img src="https://hackmd.io/_uploads/BJhlcD_KR.png" alt="image"></p><p>可以使用<a href="https://tinyurl.com/286v4vyj">家樂福線上購物網址</a>進行挑選</p><h2 id="保健養生優惠"><a href="#保健養生優惠" class="headerlink" title="保健養生優惠"></a>保健養生優惠</h2><p>保健食品<br><img src="https://hackmd.io/_uploads/rJDcqvdYR.png" alt="image"></p><p>運動用品<br><img src="https://hackmd.io/_uploads/SJ96cv_t0.png" alt="image"></p><h2 id="冰鎮美食優惠"><a href="#冰鎮美食優惠" class="headerlink" title="冰鎮美食優惠"></a>冰鎮美食優惠</h2><p>冰品<br><img src="https://hackmd.io/_uploads/HkrkovdKR.png" alt="image"></p><h2 id="出國旅遊優惠"><a href="#出國旅遊優惠" class="headerlink" title="出國旅遊優惠"></a>出國旅遊優惠</h2><p>旅行用品<br><img src="https://hackmd.io/_uploads/Bkoxiv_FA.png" alt="image"></p><h2 id="出行防蟲利器"><a href="#出行防蟲利器" class="headerlink" title="出行防蟲利器"></a>出行防蟲利器</h2><p>防蚊液<br><img src="https://hackmd.io/_uploads/SyCbiDOF0.png" alt="image"></p><h2 id="夏日樂趣優惠"><a href="#夏日樂趣優惠" class="headerlink" title="夏日樂趣優惠"></a>夏日樂趣優惠</h2><p>戶外用品<br><img src="https://hackmd.io/_uploads/SkJQjD_F0.png" alt="image"></p><p>水上活動用品<br><img src="https://hackmd.io/_uploads/r1bNjPuFA.png" alt="image"></p><p>防曬用品<br><img src="https://hackmd.io/_uploads/ByQBiPOtC.png" alt="image"></p><h2 id="寵愛毛孩優惠"><a href="#寵愛毛孩優惠" class="headerlink" title="寵愛毛孩優惠"></a>寵愛毛孩優惠</h2><p>寵物用品<br><img src="https://hackmd.io/_uploads/BkY8ow_FA.png" alt="image"></p><h2 id="消暑對策"><a href="#消暑對策" class="headerlink" title="消暑對策"></a>消暑對策</h2><p>防曬用品<br><img src="https://hackmd.io/_uploads/BJ2PovdKC.png" alt="image"></p><p>電扇<br><img src="https://hackmd.io/_uploads/H1gKovdY0.png" alt="image"></p><p>飲料<br><img src="https://hackmd.io/_uploads/ryNqovuF0.png" alt="image"></p><h2 id="開學準備"><a href="#開學準備" class="headerlink" title="開學準備"></a>開學準備</h2><p>文具用品<br><img src="https://hackmd.io/_uploads/BkIjjDdFR.png" alt="image"></p><p>服飾配件<br><img src="https://hackmd.io/_uploads/BJt3jv_FA.png" alt="image"></p><p>電子產品<br><img src="https://hackmd.io/_uploads/Sy26iDdtC.png" alt="image"></p><h2 id="飲食新選擇"><a href="#飲食新選擇" class="headerlink" title="飲食新選擇"></a>飲食新選擇</h2><p>素食食品<br><img src="https://hackmd.io/_uploads/rJFlhv_YR.png" alt="image"></p><h1 id="節省購物的小技巧"><a href="#節省購物的小技巧" class="headerlink" title="節省購物的小技巧"></a>節省購物的小技巧</h1><p>為了讓大家能夠在家樂福購物時獲得更多優惠，我想分享一些小技巧：</p><ul><li>關注家樂福的官網和社群媒體：家樂福經常在官網和社群媒體上發布最新的優惠訊息，記得多多關注。</li><li>利用會員卡：辦理家樂福的會員卡，可以享受更多會員專屬的優惠和累積點數兌換好禮。</li><li>選擇特價時段購物：有些商品在特定時段會有額外折扣，可以根據這些時段來安排購物。</li></ul><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>家樂福的優惠活動總是充滿驚喜，這次的活動更是物超所值。希望這篇文章能夠幫助大家在購物時節省更多，享受更愉快的購物體驗。快去家樂福看看，發現更多超值優惠吧！</p><p>如果您有任何問題或購物心得，歡迎在下方留言與我們分享。期待您的回饋！<br>祝大家購物愉快！</p><p>有興趣可以到以下家樂福線上購物查看</p><p><a href="https://abzcoupon.com/track/clicks/4459/c627c2bc990927defa8aec35dc2e9753743940c172e5eff1113ff40863005ae7">https://abzcoupon.com/track/clicks/4459/c627c2bc990927defa8aec35dc2e9753743940c172e5eff1113ff40863005ae7</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%81%AF%E7%9B%9F%E8%A1%8C%E9%8A%B7/">聯盟行銷</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%AE%B6%E6%A8%82%E7%A6%8F%E5%84%AA%E6%83%A0/">家樂福優惠</category>
      
      
      <comments>https://gahgah147.github.io/2024/08/01/%E7%99%BC%E7%8F%BE%E5%AE%B6%E6%A8%82%E7%A6%8F%E7%9A%84%E9%A9%9A%E5%96%9C%E5%84%AA%E6%83%A0%EF%BC%9A%E8%AE%93%E6%82%A8%E7%9A%84%E8%B3%BC%E7%89%A9%E9%AB%94%E9%A9%97%E6%9B%B4%E5%8A%A0%E7%BE%8E%E5%A5%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Flutter 學習紀錄 - Day 3 – Dart Language 學習</title>
      <link>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-3-%E2%80%93-Dart-Language-%E5%AD%B8%E7%BF%92/</link>
      <guid>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-3-%E2%80%93-Dart-Language-%E5%AD%B8%E7%BF%92/</guid>
      <pubDate>Tue, 30 Jul 2024 08:39:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Flutter-學習紀錄-Day-3-–-Dart-Language-學習&quot;&gt;&lt;a href=&quot;#Flutter-學習紀錄-Day-3-–-Dart-Language-學習&quot; class=&quot;headerlink&quot; title=&quot;Flutter 學習紀錄 - Day</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Flutter-學習紀錄-Day-3-–-Dart-Language-學習"><a href="#Flutter-學習紀錄-Day-3-–-Dart-Language-學習" class="headerlink" title="Flutter 學習紀錄 - Day 3 – Dart Language 學習"></a>Flutter 學習紀錄 - Day 3 – Dart Language 學習</h1><h1 id="Dart-官方說明教學文件"><a href="#Dart-官方說明教學文件" class="headerlink" title="Dart 官方說明教學文件"></a>Dart 官方說明教學文件</h1><p><img src="https://hackmd.io/_uploads/Hy_5_z8K0.png" alt="image"></p><blockquote><p><a href="https://dart.dev.org.tw/overview">https://dart.dev.org.tw/overview</a></p></blockquote><h2 id="Dart：語言"><a href="#Dart：語言" class="headerlink" title="Dart：語言"></a>Dart：語言</h2><p>Dart 是一種類型安全的程式語言，設計用於確保變數的值始終與其靜態類型相符。這種方式稱為健全類型檢查。雖然 Dart 的類型是強制性的，但類型註解是可選的，因為 Dart 支援類型推論。這意味著即使你不明確指定類型，Dart 也能自動推斷出變數的類型。</p><p>Dart 的類型系統非常靈活，允許使用 <code>dynamic</code> 類型來結合執行時期檢查。這在需要編寫特別動態的程式碼或進行實驗時非常有用。</p><h3 id="健全的空安全"><a href="#健全的空安全" class="headerlink" title="健全的空安全"></a>健全的空安全</h3><p>Dart 內建了健全的空安全機制。這表示除非你明確允許變數為空，否則它們的值不能為空。這種空安全機制能夠透過靜態程式碼分析在執行時期保護你免於空例外。</p><p>與其他一些空安全語言不同的是，當 Dart 確定變數為非空時，該變數在執行時期將始終保持非空。如果你在偵錯器中檢查程式碼的執行情況，你會看到非空性在執行時期得到保留，這就是所謂的健全空安全。</p><p>這些特性使得 Dart 成為一個非常可靠和強大的語言，特別適合用於構建高效能且穩定的應用程式。</p><h2 id="Dart：函式庫"><a href="#Dart：函式庫" class="headerlink" title="Dart：函式庫"></a>Dart：函式庫</h2><p>Dart 有一個 豐富的核心函式庫集，提供許多日常程式設計任務的基本要素</p><ul><li>每個 Dart 程式（dart:core）的內建類型、集合和其他核心功能</li><li>更豐富的集合類型，例如佇列、連結串列、雜湊映射和二元樹（dart:collection）</li><li>用於在不同資料表示法之間轉換的編碼器和解碼器，包括 JSON 和 UTF-8（dart:convert）</li><li>數學常數和函數，以及隨機數字產生（dart:math）</li><li>支援非同步程式設計，使用 Future 和 Stream 等類別（dart:async）</li><li>有效處理固定大小資料（例如，未簽署的 8 位元組整數）和 SIMD 數值類型的清單（dart:typed_data）</li><li>檔案、socket、HTTP 和其他 I&#x2F;O 支援，適用於非網路應用程式（dart:io）</li><li>外國函數介面，用於與呈現 C 風格介面的其他程式碼進行互操作（dart:ffi）</li><li>使用隔離進行並行程式設計，獨立的工作人員類似於執行緒，但不會共用記憶體，僅透過訊息進行通訊（dart:isolate）</li><li>HTML 元素和其他資源，適用於需要與瀏覽器和文件物件模型 (DOM) 互動的基於網路的應用程式（dart:html）</li></ul><p>除了核心函式庫之外，許多 API 都透過全面的套件集提供。Dart 團隊發布許多有用的補充套件，例如</p><ul><li>字元</li><li>intl</li><li>http</li><li>加密</li><li>標記語言</li></ul><p>此外，第三方發行商和更廣大的社群會發布數千個套件，支援下列功能</p><ul><li>XML</li><li>Windows 整合</li><li>SQLite</li><li>壓縮</li></ul><p>若要查看一系列使用 Dart 核心函式庫的範例，請閱讀 <a href="https://dart.dev.org.tw/libraries">核心函式庫文件</a>。若要尋找其他 API，請參閱 <a href="https://dart.dev.org.tw/guides/libraries/useful-libraries">常用套件頁面</a>。</p><h2 id="Dart：平台"><a href="#Dart：平台" class="headerlink" title="Dart：平台"></a>Dart：平台</h2><p>Dart 的編譯器技術非常靈活，能夠讓您以不同的方式執行程式碼，適用於多種平台。</p><h3 id="原生平台"><a href="#原生平台" class="headerlink" title="原生平台"></a>原生平台</h3><p>針對行動裝置和桌上型電腦應用程式，Dart 提供了兩種編譯方式：</p><ul><li>**即時編譯 (JIT)**：在開發期間，Dart VM 可以即時編譯程式碼，讓開發者能夠快速測試和調整程式碼。</li><li>**提前編譯 (AOT)**：在發佈應用程式時，Dart 編譯器會將程式碼轉換為機器碼，確保應用程式在裝置上能夠高效執行。</li></ul><h3 id="網頁平台"><a href="#網頁平台" class="headerlink" title="網頁平台"></a>網頁平台</h3><p>針對網頁應用程式，Dart 可以編譯為 JavaScript，方便在各種瀏覽器上運行。這種編譯可以用於開發和生產環境，確保網頁應用的兼容性和效能。</p><p><img src="https://hackmd.io/_uploads/HkzO5f8KR.png" alt="image"></p><blockquote><p><a href="https://dart.dev.org.tw/overview#platform">https://dart.dev.org.tw/overview#platform</a></p></blockquote><h1 id="DartPad-練習平台"><a href="#DartPad-練習平台" class="headerlink" title="DartPad - 練習平台"></a>DartPad - 練習平台</h1><p><img src="https://hackmd.io/_uploads/H1oGjGUF0.png" alt="image"></p><blockquote><p><a href="https://dartpad.dev/">https://dartpad.dev/</a></p></blockquote><p>DartPad 是一個線上工具，能在瀏覽器中撰寫、執行和分享 Dart 程式碼，無需安裝任何軟體。</p><p>以下是一些 DartPad 的主要功能：</p><ul><li><p>即時編輯和執行：可以即時撰寫和執行 Dart 程式碼，立即看到結果，這對於學習和測試程式碼片段非常有用。</p></li><li><p>範例程式碼：DartPad 提供了豐富的範例程式碼，可以快速瞭解 Dart 語言和 Flutter 框架的各種功能和特性。</p></li><li><p>分享程式碼：可以輕鬆地分享您的程式碼片段和結果，方便與他人協作和討論。<br>使用 DartPad，您可以快速開始學習和探索 Dart 和 Flutter，而不需要進行任何設定或安裝。</p></li></ul><p>這邊可以參考Dart 官方簡介文件說明做完整的一個練習。</p><p><img src="https://hackmd.io/_uploads/r1M0iMIKR.png" alt="image"></p><blockquote><p><a href="https://dart.dev.org.tw/language">https://dart.dev.org.tw/language</a></p></blockquote><h1 id="資料型態"><a href="#資料型態" class="headerlink" title="資料型態"></a>資料型態</h1><table><thead><tr><th>資料型態</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td><strong>var</strong></td><td>類似於 JavaScript 的變數宣告，根據初始化的值自動推斷型別，但一旦賦值後型別不可更改</td><td><code>var myVar = 42;</code></td></tr><tr><td><strong>Object</strong></td><td>所有型別的根基礎類別。每個 Dart 型別都繼承自 <code>Object</code></td><td><code>Object myObject = &quot;Hello, Dart!&quot;;</code></td></tr><tr><td><strong>dynamic</strong></td><td>允許在編譯時期跳過型別檢查，明確表示可以在執行時期變更型別</td><td><code>dynamic myDynamic = 10; myDynamic = &quot;Now I&#39;m a string!&quot;;</code></td></tr><tr><td><strong>num</strong></td><td><code>int</code> 和 <code>double</code> 的父類別，表示數值型資料的抽象</td><td><code>num myNum = 3.14;</code></td></tr><tr><td><strong>int</strong></td><td>表示整數型別</td><td><code>int myInt = 123;</code></td></tr><tr><td><strong>double</strong></td><td>表示雙精度浮點數型別</td><td><code>double myDouble = 456.78;</code></td></tr><tr><td><strong>bool</strong></td><td>表示布林值型別，只有 <code>true</code> 和 <code>false</code> 兩個值</td><td><code>bool myBool = true;</code></td></tr><tr><td><strong>String</strong></td><td>表示字串型別</td><td><code>String myString = &quot;Dart is great!&quot;;</code></td></tr><tr><td><strong>Symbol</strong></td><td>表示 Dart 程式中的符號，用於反射（reflection）</td><td><code>Symbol mySymbol = #mySymbol;</code></td></tr><tr><td><strong>List<T></strong></td><td>類似於 Python 的列表，支持泛型，用於表示有序集合</td><td><code>List&lt;int&gt; myList = [1, 2, 3];</code></td></tr><tr><td><strong>Map&lt;K, V&gt;</strong></td><td>類似於 Python 的字典，支持泛型，用於表示鍵值對集合</td><td><code>Map&lt;String, int&gt; myMap = &#123;&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3&#125;;</code></td></tr></tbody></table><p>Dart擁有int、double、String、bool等常見的變數型態</p><p>在定義變數的時候可以選擇給他明確的型態或是用「var」讓Dart來幫忙決定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  var a = 1; //int 整數</span><br><span class="line">  var b = &quot;1&quot;; // String 字串</span><br><span class="line">  var c = 1.1; // double 浮點數</span><br><span class="line">  </span><br><span class="line">  if (a is int) &#123;</span><br><span class="line">    print(&#x27;a is int&#x27;); // Output： a is int</span><br><span class="line">  &#125;</span><br><span class="line">  if (b is String) &#123;</span><br><span class="line">    print(&#x27;b is String&#x27;); // Output： b is String</span><br><span class="line">  &#125;</span><br><span class="line">  if (c is double) &#123;</span><br><span class="line">    print(&#x27;c is double&#x27;); // Output： c is double</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkkmafUtR.png" alt="image"></p><p>需要注意的是假如用的是var在宣告賦值後就不能再賦予它其他型態的值了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  a = &quot;123&quot;; // Error: A value of type &#x27;String&#x27; can&#x27;t be assigned to a variable of type &#x27;int&#x27;.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BJbw6GLt0.png" alt="image"></p><p>如上圖所示會發生錯誤</p><p>也可以使用dynamic來做宣告，dynamic是所有物件的基礎類型，也就是說它可以代表任何物件。<br>換句話來說，Dart的「dynamic」和JavaScript的「var」非常相似，可以隨時替換不同型態的值給變數。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  dynamic a = 1;</span><br><span class="line">  a = &#x27;123&#x27;;  // no error</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1diaGItA.png" alt="image"></p><p>雖然這次也是使用var來宣告，但卻可以替換成不同型態的值，這是由於一開始並未給變數a初始值，因此var會給予變數a dynamic型態，所以就算替換了不同型態的值也不會報錯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  var a;</span><br><span class="line">  a = 1;</span><br><span class="line">  print(a); // Output：1</span><br><span class="line">  a = &quot;123&quot;;</span><br><span class="line">  print(a); // Output： 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Sk5JRM8t0.png" alt="image"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>定義 List 需要使用方括號 []。可以在宣告時定義儲存值的型態，或者使用 dynamic 來接受所有型態。如果希望 List 內的值不被更動，在宣告時可以使用 const 關鍵字來把值固定，這樣之後就無法對 List 做新增、修改、刪除操作。</p><p>List 可以儲存任意型態的資料。<br>使用 const 宣告的 List 是不可變的，無法修改其內容。<br>支持泛型，可以在宣告時指定儲存的值的型態。<br>透過這些特性，Dart 的 List 能夠提供靈活且強大的資料結構來管理和操作集合數據。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  List&lt;dynamic&gt; a = const [1, &#x27;123&#x27;, true];</span><br><span class="line">  print(a[1]); // Output：123</span><br><span class="line">  a.add(123); // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ByxgMQ8tC.png" alt="image"></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>最後要介紹的是Map，Map是使用key-value的方式來儲存的資料型態，Map是使用大括號{}，以Key:Value的方式定義。<br>之後在實作專案裡面會使用到Map來儲存從Youtube Api回傳過來的JSON Data，大家可以先去看一下JSON是怎麼樣的資料格式喔~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  var map = &#123;</span><br><span class="line">    &#x27;key1&#x27;: &#x27;value1&#x27;,</span><br><span class="line">    &#x27;key2&#x27;: &#x27;value2&#x27;,</span><br><span class="line">    &#x27;key3&#x27;: &#x27;value3&#x27;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  print(map[&#x27;key1&#x27;]);    // Output: value1</span><br><span class="line">  print(map[&#x27;test&#x27;]);    // Output: null</span><br><span class="line"> </span><br><span class="line">  map[&#x27;key4&#x27;] = &#x27;value4&#x27;;</span><br><span class="line">  </span><br><span class="line">  //Length  </span><br><span class="line">  print(map.length); //Output： 4</span><br><span class="line"> </span><br><span class="line">  print(map.containsKey(&#x27;value1&#x27;)); // Output： false</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  print(map.entries); // Output： (MapEntry(key1: value1), MapEntry(key2: value2), MapEntry(key3: value3), MapEntry(key4: value4))</span><br><span class="line">  print(map.values); // Output： (value1, value2, value3, value4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Sy-a77LFC.png" alt="image"></p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>今天整理了 Dart 語言的基本概念和特性，包括其類型系統、函式庫、平台支援以及一些常用的資料型態，還有Dart 語言特性跟DartPad 的練習平台。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Flutter/">Flutter</category>
      
      
      <comments>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-3-%E2%80%93-Dart-Language-%E5%AD%B8%E7%BF%92/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Flutter 學習紀錄 - Day 2 基礎概念</title>
      <link>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-2-%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5/</link>
      <guid>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-2-%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5/</guid>
      <pubDate>Tue, 30 Jul 2024 03:16:18 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Flutter-學習紀錄-Day-2-基礎概念&quot;&gt;&lt;a href=&quot;#Flutter-學習紀錄-Day-2-基礎概念&quot; class=&quot;headerlink&quot; title=&quot;Flutter 學習紀錄 - Day 2 基礎概念&quot;&gt;&lt;/a&gt;Flutter 學習紀錄 - </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Flutter-學習紀錄-Day-2-基礎概念"><a href="#Flutter-學習紀錄-Day-2-基礎概念" class="headerlink" title="Flutter 學習紀錄 - Day 2 基礎概念"></a>Flutter 學習紀錄 - Day 2 基礎概念</h1><h1 id="Flutter的架構"><a href="#Flutter的架構" class="headerlink" title="Flutter的架構"></a>Flutter的架構</h1><p>Flutter 是一個跨平台 UI 工具組，設計用於允許在作業系統（例如 iOS 和 Android）之間重複使用程式碼，同時也允許應用程式直接與底層平台服務介接。目標是讓開發人員能夠提供在不同平台上感覺自然的高效能應用程式，在它們存在差異的地方採用差異，同時盡可能共用程式碼。</p><p>在開發期間，Flutter 應用程式會在 VM 中執行，該 VM 提供狀態熱重載變更，而不需要完全重新編譯。對於發行，Flutter 應用程式會直接編譯成機器碼，無論是 Intel x64 或 ARM 指令，還是針對網路的 JavaScript。此架構是開放原始碼的，採用寬鬆的 BSD 授權，並擁有蓬勃發展的第三方套件生態系統，補充核心程式庫功能。</p><p>此概觀分為多個區段</p><ul><li>圖層模型：建構 Flutter 的部分。</li><li>反應式使用者介面：Flutter 使用者介面開發的核心概念。</li><li>小工具簡介：Flutter 使用者介面的基本建構區塊。</li><li>渲染處理：Flutter 如何將 UI 程式碼轉換成像素。</li><li>平台嵌入器概觀：讓行動和桌上型作業系統執行 Flutter 應用程式的程式碼。</li><li>將 Flutter 與其他程式碼整合：關於 Flutter 應用程式可用的不同技術的資訊。</li><li>支援網路：關於瀏覽器環境中 Flutter 特性的結論性說明。</li></ul><h2 id="架構圖層"><a href="#架構圖層" class="headerlink" title="架構圖層"></a>架構圖層</h2><p>Flutter 被設計為可擴充的圖層系統。它以一系列獨立的程式庫存在，每個程式庫都依賴於底層圖層。沒有任何圖層具有對下方圖層的特權存取權，而且架構層的每個部分都設計為可選和可替換的。<br><img src="https://hackmd.io/_uploads/S1WdXASF0.png" alt="image"></p><blockquote><p><a href="https://flutter.dev.org.tw/resources/architectural-overview">https://flutter.dev.org.tw/resources/architectural-overview</a></p></blockquote><p>Flutter的架構分成三層：</p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>Framework 層是 Flutter 的高層部分，主要是由 Dart 語言撰寫。這一層提供了構建應用程式的基本結構和工具。它包含了以下幾個子層：</p><ul><li><p>Widgets：Flutter 提供了豐富的 Widget 集合，用於構建複雜的 UI 元件。這些 Widget 是 Flutter 應用程式的核心，所有的視圖和互動都由這些 Widget 組成。</p></li><li><p>Rendering：這個子層負責將 Widget 渲染到螢幕上。它處理佈局、繪製和動畫等操作，確保 Widget 能夠正確顯示和互動。</p></li><li><p>Animation and Gestures：提供了動畫和手勢的支援，讓開發者能夠輕鬆地添加豐富的動畫效果和處理用戶的手勢輸入。</p></li></ul><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine 層是 Flutter 的核心，它由 C++ 編寫，並且負責低層次的渲染和輸入處理。這一層提供了跨平台的渲染和執行環境，使得 Flutter 應用能夠在不同的平台上運行。Engine 包含以下主要組件：</p><ul><li><p>Skia：一個開源的 2D 圖形庫，用於繪製所有的圖形元素。Skia 提供了高效的繪圖性能，確保 Flutter 應用能夠流暢運行。</p></li><li><p>Dart Runtime：運行 Dart 程式碼的執行環境，負責 Dart 程式碼的編譯和執行。</p></li><li><p>Text：提供了文字渲染的支援，包括複雜的文字佈局和渲染。</p></li></ul><h3 id="Embedder"><a href="#Embedder" class="headerlink" title="Embedder"></a>Embedder</h3><p>Embedder 層負責將 Flutter 應用嵌入到特定的操作系統中。這一層提供了與底層平台互動的介面，使得 Flutter 可以在不同的操作系統上運行。Embedder 包含以下功能：</p><ul><li><p>Platform Channels：用於 Dart 和原生平台代碼之間的通信。這使得 Flutter 應用能夠調用原生平台的 API，並且讓原生平台能夠調用 Dart 程式碼。</p></li><li><p>Event Loop：處理操作系統的事件，如輸入事件和畫面更新，並將這些事件傳遞給 Flutter 應用。</p></li><li><p>Window Management：管理應用的窗口和視窗，使得 Flutter 應用能夠在不同平台上以正確的大小和位置顯示。</p></li></ul><h1 id="跨平台開發工具比較"><a href="#跨平台開發工具比較" class="headerlink" title="跨平台開發工具比較"></a>跨平台開發工具比較</h1><p>與 APP 開發相關的主要跨平台開發框架和工具包括以下幾個：</p><h3 id="1-Flutter"><a href="#1-Flutter" class="headerlink" title="1. Flutter"></a>1. <strong>Flutter</strong></h3><p><img src="https://hackmd.io/_uploads/SkF5LCBKA.png" alt="image"></p><blockquote><p><a href="https://docs.flutter.dev/">https://docs.flutter.dev/</a></p></blockquote><ul><li><strong>語言</strong>：Dart</li><li><strong>描述</strong>：由 Google 開發的框架，可以構建高效能的原生應用。其特點包括豐富的 widget 庫和優秀的 Hot Reload 功能。</li><li><strong>特點</strong>：<ul><li>高效能，直接編譯成原生代碼。</li><li>擁有豐富的預設元件和插件。</li><li>支援 iOS、Android、Web 和桌面應用。</li></ul></li></ul><h3 id="2-React-Native"><a href="#2-React-Native" class="headerlink" title="2. React Native"></a>2. <strong>React Native</strong></h3><p><img src="https://hackmd.io/_uploads/SJ7i_CHtA.png" alt="image"></p><blockquote><p><a href="https://reactnative.dev/">https://reactnative.dev/</a></p></blockquote><ul><li><strong>語言</strong>：JavaScript</li><li><strong>描述</strong>：由 Facebook 開發，使用 JavaScript 和 React 來構建原生應用。具有廣大的社群和豐富的第三方資源。</li><li><strong>特點</strong>：<ul><li>使用 JavaScript 和 React 來開發。</li><li>可以共享大部分代碼於 iOS 和 Android 平台。</li><li>需要透過 JavaScript Bridge 與平台溝通。</li></ul></li></ul><h3 id="3-Ionic"><a href="#3-Ionic" class="headerlink" title="3. Ionic"></a>3. <strong>Ionic</strong></h3><p><img src="https://hackmd.io/_uploads/SysxFArYR.png" alt="image"></p><blockquote><p><a href="https://ionicframework.com/">https://ionicframework.com/</a></p></blockquote><ul><li><strong>語言</strong>：JavaScript (Angular, React, Vue)</li><li><strong>描述</strong>：基於 web 技術的框架，使用 HTML、CSS 和 JavaScript 來構建跨平台應用。依賴於 Cordova 和 Capacitor。</li><li><strong>特點</strong>：<ul><li>使用流行的 web 框架（如 Angular、React、Vue）。</li><li>可以通過 WebView 將應用包裝成原生應用。</li><li>支援廣泛的插件和原生功能訪問。</li></ul></li></ul><h3 id="4-Apache-Cordova-PhoneGap"><a href="#4-Apache-Cordova-PhoneGap" class="headerlink" title="4. Apache Cordova (PhoneGap)"></a>4. <strong>Apache Cordova (PhoneGap)</strong></h3><p><img src="https://hackmd.io/_uploads/B1oXtRSK0.png" alt="image"></p><blockquote><p><a href="https://cordova.apache.org/">https://cordova.apache.org/</a></p></blockquote><ul><li><strong>語言</strong>：HTML, CSS, JavaScript</li><li><strong>描述</strong>：使用 web 技術來構建移動應用，並包裝成原生應用在各種平台上運行。</li><li><strong>特點</strong>：<ul><li>通過 WebView 渲染應用內容。</li><li>支援多種平台（iOS、Android 等）。</li><li>插件系統豐富，能訪問各種原生功能。</li></ul></li></ul><h3 id="5-Kotlin-Multiplatform-Mobile-KMM"><a href="#5-Kotlin-Multiplatform-Mobile-KMM" class="headerlink" title="5. Kotlin Multiplatform Mobile (KMM)"></a>5. <strong>Kotlin Multiplatform Mobile (KMM)</strong></h3><p><img src="https://hackmd.io/_uploads/Byt8tRrY0.png" alt="image"></p><blockquote><p><a href="https://www.jetbrains.com/kotlin-multiplatform/">https://www.jetbrains.com/kotlin-multiplatform/</a></p></blockquote><ul><li><strong>語言</strong>：Kotlin</li><li><strong>描述</strong>：由 JetBrains 提供，允許使用 Kotlin 來共享業務邏輯代碼，同時在 Android 和 iOS 上運行。</li><li><strong>特點</strong>：<ul><li>專注於共享邏輯層，UI 層使用平台原生方式實現。</li><li>提供 Kotlin 語言的所有優勢和功能。</li><li>與 Android 原生開發無縫整合。</li></ul></li></ul><h3 id="6-Unity"><a href="#6-Unity" class="headerlink" title="6. Unity"></a>6. <strong>Unity</strong></h3><p><img src="https://hackmd.io/_uploads/SkSYYCBt0.png" alt="image"></p><blockquote><p><a href="https://unity.com/cn">https://unity.com/cn</a> </p></blockquote><ul><li><strong>語言</strong>：C#</li><li><strong>描述</strong>：主要用於遊戲開發，但也能用於構建各種跨平台的應用。</li><li><strong>特點</strong>：<ul><li>支援多種平台，包括 iOS、Android、Windows、macOS。</li><li>強大的 2D 和 3D 渲染能力。</li><li>擁有廣泛的插件和資源庫。</li></ul></li></ul><h3 id="8-NativeScript"><a href="#8-NativeScript" class="headerlink" title="8. NativeScript"></a>8. <strong>NativeScript</strong></h3><p><img src="https://hackmd.io/_uploads/Sk1vcCHKA.png" alt="image"></p><blockquote><p><a href="https://nativescript.org/">https://nativescript.org/</a></p></blockquote><ul><li><strong>語言</strong>：JavaScript, TypeScript</li><li><strong>描述</strong>：允許使用 JavaScript 或 TypeScript 來構建原生移動應用。</li><li><strong>特點</strong>：<ul><li>提供對原生 API 的直接訪問。</li><li>可以使用 Angular 或 Vue.js 來構建應用。</li><li>支援 iOS 和 Android。</li></ul></li></ul><p>當然可以，以下是調整後的比較表：</p><table><thead><tr><th>框架&#x2F;工具</th><th><strong>Flutter</strong></th><th><strong>React Native</strong></th><th><strong>.NET MAUI</strong></th><th><strong>Ionic</strong></th><th><strong>Apache Cordova (PhoneGap)</strong></th><th><strong>Kotlin Multiplatform Mobile (KMM)</strong></th><th><strong>Unity</strong></th><th><strong>NativeScript</strong></th></tr></thead><tbody><tr><td><strong>語言</strong></td><td>Dart</td><td>JavaScript</td><td>C#</td><td>JavaScript (Angular, React, Vue)</td><td>HTML, CSS, JavaScript</td><td>Kotlin</td><td>C#</td><td>JavaScript, TypeScript</td></tr><tr><td><strong>Hot Reload 支援</strong></td><td>支援</td><td>支援</td><td>支援</td><td>支援</td><td>支援</td><td>不支援</td><td>支援</td><td>支援</td></tr><tr><td><strong>發展時間</strong></td><td>2017年</td><td>2015年</td><td>2021年</td><td>2013年</td><td>2009年</td><td>2019年</td><td>2005年</td><td>2014年</td></tr><tr><td><strong>Component 支援</strong></td><td>由 Google 開發，預設豐富</td><td>需要第三方支援</td><td>由 Microsoft 支持，與 .NET 生態系統整合</td><td>需要第三方支援</td><td>需要第三方支援</td><td>需自行開發</td><td>豐富，針對遊戲開發</td><td>需要第三方支援</td></tr><tr><td><strong>文件品質</strong></td><td>詳細易讀</td><td>第三方 Library 文件品質不一</td><td>詳細易讀</td><td>第三方 Library 文件品質不一</td><td>第三方 Library 文件品質不一</td><td>詳細易讀</td><td>詳細易讀</td><td>詳細易讀</td></tr><tr><td><strong>社群成熟度</strong></td><td>發展中</td><td>成熟</td><td>發展中</td><td>成熟</td><td>成熟</td><td>發展中</td><td>成熟</td><td>發展中</td></tr><tr><td><strong>效能</strong></td><td>直接轉成 native code</td><td>需透過 Bridge 與平台溝通</td><td>直接訪問原生 API</td><td>基於 WebView</td><td>基於 WebView</td><td>直接訪問原生 API</td><td>高效能 2D 和 3D 渲染</td><td>直接訪問原生 API</td></tr><tr><td><strong>App 大小</strong></td><td>較小</td><td>較大</td><td>中等</td><td>中等</td><td>中等</td><td>中等</td><td>較大</td><td>中等</td></tr><tr><td><strong>特色與備註</strong></td><td>高效能，豐富的 widget 庫和 Hot Reload 功能</td><td>使用 JavaScript 和 React 開發，廣大的社群與資源</td><td>繼承自 Xamarin，與 Visual Studio 緊密整合</td><td>使用 web 技術構建應用，依賴於 Cordova 和 Capacitor</td><td>使用 web 技術構建應用，廣泛的平台支持</td><td>共享邏輯層，UI 層使用平台原生方式實現</td><td>遊戲開發為主，但可構建各種應用，支持多平台</td><td>使用 Angular 或 Vue.js 構建應用，支援 iOS 和 Android</td></tr></tbody></table><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><ul><li><strong>Flutter</strong> 是一個強大且高效的框架，適合構建高性能、原生體驗的跨平台應用。</li><li><strong>React Native</strong> 具有廣大的社群和資源，使用 JavaScript 和 React，是許多開發者的首選。</li><li><strong>.NET MAUI</strong> 繼承自 Xamarin，與 .NET 和 Visual Studio 緊密結合，適合已有 C# 技能的開發者。</li><li><strong>Ionic</strong> 和 <strong>Cordova</strong> 適合使用 web 技術開發應用的團隊，具有較好的跨平台支持。</li><li><strong>Kotlin Multiplatform Mobile (KMM)</strong> 提供共享業務邏輯的能力，適合 Android 和 iOS 原生開發者。</li><li><strong>Unity</strong> 適合需要高效能 2D&#x2F;3D 渲染的應用，尤其是遊戲開發。</li><li><strong>NativeScript</strong> 允許使用 Angular 或 Vue.js 構建應用，提供直接訪問原生 API 的能力。</li></ul><p>這些框架各有優勢和適用場景，選擇哪一個取決於你的具體需求和技術背景。希望這些比較能對你有所幫助。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Flutter/">Flutter</category>
      
      
      <comments>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-2-%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Flutter 學習紀錄 - Day 1 安裝與介紹</title>
      <link>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-1-%E5%AE%89%E8%A3%9D%E8%88%87%E4%BB%8B%E7%B4%B9/</link>
      <guid>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-1-%E5%AE%89%E8%A3%9D%E8%88%87%E4%BB%8B%E7%B4%B9/</guid>
      <pubDate>Tue, 30 Jul 2024 02:09:49 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Flutter-學習紀錄-Day-1-安裝與介紹&quot;&gt;&lt;a href=&quot;#Flutter-學習紀錄-Day-1-安裝與介紹&quot; class=&quot;headerlink&quot; title=&quot;Flutter 學習紀錄 - Day 1 安裝與介紹&quot;&gt;&lt;/a&gt;Flutter 學習紀錄</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Flutter-學習紀錄-Day-1-安裝與介紹"><a href="#Flutter-學習紀錄-Day-1-安裝與介紹" class="headerlink" title="Flutter 學習紀錄 - Day 1 安裝與介紹"></a>Flutter 學習紀錄 - Day 1 安裝與介紹</h1><h1 id="什麼是Flutter"><a href="#什麼是Flutter" class="headerlink" title="什麼是Flutter"></a>什麼是Flutter</h1><p><img src="https://hackmd.io/_uploads/SJY_aRlKA.png" alt="image"></p><blockquote><p><a href="https://flutter.dev/">https://flutter.dev/</a></p></blockquote><p>Flutter 是由 Google 開發的一個開源框架，使用 Dart 程式語言寫一份Code可以同時讓iOS與Android平台使用，也支援Web以及桌面應用程式。</p><p>主要特點如下：</p><h2 id="主要特點"><a href="#主要特點" class="headerlink" title="主要特點"></a>主要特點</h2><h3 id="跨平台："><a href="#跨平台：" class="headerlink" title="跨平台："></a>跨平台：</h3><p>Flutter 允許開發者使用單一代碼庫同時構建 Android 和 iOS 應用，甚至可以用於網頁和桌面應用的開發。</p><h3 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h3><p>由於 Flutter 直接編譯成原生代碼，因此性能優越，可以達到原生應用的流暢度。</p><h3 id="豐富的組件庫："><a href="#豐富的組件庫：" class="headerlink" title="豐富的組件庫："></a>豐富的組件庫：</h3><p>提供了大量的預製組件（Widgets），這些組件可以高度定制，滿足不同設計需求。</p><h3 id="熱重載："><a href="#熱重載：" class="headerlink" title="熱重載："></a>熱重載：</h3><p>Flutter 支持熱重載（Hot Reload），使得開發者可以快速查看代碼修改結果，大幅提升開發效率。</p><h3 id="單一代碼語言："><a href="#單一代碼語言：" class="headerlink" title="單一代碼語言："></a>單一代碼語言：</h3><p>使用 Dart 編程語言，簡化了開發過程，特別是對於那些需要同時支持多個平台的應用。</p><h2 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h2><h3 id="快速開發："><a href="#快速開發：" class="headerlink" title="快速開發："></a>快速開發：</h3><p>由於熱重載功能和豐富的組件庫，開發者可以更快更新和測試應用。</p><h3 id="一致的-UI-表現"><a href="#一致的-UI-表現" class="headerlink" title="一致的 UI 表現:"></a>一致的 UI 表現:</h3><p>Flutter 的組件是基於自己繪製的，因此無論在什麼平台上，UI 表現都一致。</p><h3 id="強大的社群支持："><a href="#強大的社群支持：" class="headerlink" title="強大的社群支持："></a>強大的社群支持：</h3><p>Flutter 擁有一個活躍且不斷增長的社群，提供了大量的資源和插件，幫助開發者解決各種問題。</p><h2 id="Fltter檔案構造"><a href="#Fltter檔案構造" class="headerlink" title="Fltter檔案構造"></a>Fltter檔案構造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flutter_project/</span><br><span class="line">│</span><br><span class="line">├── lib/</span><br><span class="line">├── test/</span><br><span class="line">│   └── widget_test.dart</span><br><span class="line">├── android/</span><br><span class="line">├── ios/</span><br><span class="line">├── assets/</span><br><span class="line">└── pubspec.yaml</span><br></pre></td></tr></table></figure><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>主要的 Dart 代碼存放處，包含應用程式的主要邏輯和功能。</p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>用於存放測試代碼的地方。在這個資料夾中，你可以編寫單元測試和集成測試。</p><h3 id="android"><a href="#android" class="headerlink" title="android"></a>android</h3><p>Android 平台的原生代碼存放處。通常你不太需要直接操作這個資料夾，除非你有特定的 Android 平台需求。</p><h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><p>iOS 平台的原生代碼存放處。與 android 資料夾一樣，大多數情況下你不需要直接處理這個資料夾。</p><h3 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h3><p>存放應用程式資源檔案的地方，如圖片、字體文件等。在 Dart 代碼中，你可以使用 AssetImage 或類似的類來訪問這些資源。</p><h3 id="test中的-widget-test-dart-文件（可選）"><a href="#test中的-widget-test-dart-文件（可選）" class="headerlink" title="test中的 widget_test.dart 文件（可選）"></a>test中的 widget_test.dart 文件（可選）</h3><p>默認的測試文件，用於測試應用程式的 Widget。你可以在這裡添加和擴展測試。</p><h1 id="Fltter教學資源"><a href="#Fltter教學資源" class="headerlink" title="Fltter教學資源"></a>Fltter教學資源</h1><p>以下是網路上參考的學習資源</p><h2 id="HKT-線上教室-Flutter-程式設計入門實戰-30-天"><a href="#HKT-線上教室-Flutter-程式設計入門實戰-30-天" class="headerlink" title="HKT 線上教室 Flutter 程式設計入門實戰 30 天"></a>HKT 線上教室 Flutter 程式設計入門實戰 30 天</h2><p><img src="https://hackmd.io/_uploads/ByjVuYEFA.png" alt="image"></p><blockquote><p><a href="https://ithelp.ithome.com.tw/users/20096484/ironman/2699">https://ithelp.ithome.com.tw/users/20096484/ironman/2699</a></p></blockquote><h2 id="猫哥-—-Flutter-零基础入门中文教学"><a href="#猫哥-—-Flutter-零基础入门中文教学" class="headerlink" title="猫哥 — Flutter 零基础入门中文教学"></a>猫哥 — Flutter 零基础入门中文教学</h2><p><img src="https://hackmd.io/_uploads/ry2zdKEFA.png" alt="image"></p><blockquote><p><a href="https://www.youtube.com/watch?v=C1emOeteMmc&list=PL274L1n86T839P6Bqd3M2knHhLjU0wRMG">https://www.youtube.com/watch?v=C1emOeteMmc&amp;list=PL274L1n86T839P6Bqd3M2knHhLjU0wRMG</a></p></blockquote><h2 id="Flutter中文网"><a href="#Flutter中文网" class="headerlink" title="Flutter中文网"></a>Flutter中文网</h2><p><img src="https://hackmd.io/_uploads/HJBy_tNF0.png" alt="image"></p><blockquote><p><a href="https://doc.flutterchina.club/tutorials/">https://doc.flutterchina.club/tutorials/</a></p></blockquote><h2 id="Flutter—Google推出的跨平台框架，Android、iOS一起搞定"><a href="#Flutter—Google推出的跨平台框架，Android、iOS一起搞定" class="headerlink" title="Flutter—Google推出的跨平台框架，Android、iOS一起搞定"></a>Flutter—Google推出的跨平台框架，Android、iOS一起搞定</h2><p><img src="https://hackmd.io/_uploads/Skp73p4tA.png" alt="image"></p><blockquote><p><a href="https://ithelp.ithome.com.tw/users/20119550/ironman/2221">https://ithelp.ithome.com.tw/users/20119550/ironman/2221</a></p></blockquote><h1 id="下載-Flutter"><a href="#下載-Flutter" class="headerlink" title="下載 Flutter"></a>下載 Flutter</h1><h2 id="方法一-推薦"><a href="#方法一-推薦" class="headerlink" title="方法一 (推薦)"></a>方法一 (推薦)</h2><h3 id="安裝Git-for-Windows-https-git-scm-com-download-win"><a href="#安裝Git-for-Windows-https-git-scm-com-download-win" class="headerlink" title="安裝Git for Windows(https://git-scm.com/download/win)"></a>安裝Git for Windows(<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>)</h3><h3 id="下載Flutter-SDK"><a href="#下載Flutter-SDK" class="headerlink" title="下載Flutter SDK"></a>下載Flutter SDK</h3><p>在C槽點滑鼠右鍵「Git bash here」，便會開啟git bash，你就可以在裡面下git command。<br><img src="https://hackmd.io/_uploads/rJhvkyZFC.png" alt="image"></p><p>接著輸入git clone -b stable <a href="https://github.com/flutter/flutter.git">https://github.com/flutter/flutter.git</a><br>電腦就會自己去找Flutter官方發布的最新穩定版本並下載到當前資料夾。</p><h1 id="安裝Flutter"><a href="#安裝Flutter" class="headerlink" title="安裝Flutter"></a>安裝Flutter</h1><h2 id="進到flutter資料夾，執行flutter-console-bat"><a href="#進到flutter資料夾，執行flutter-console-bat" class="headerlink" title="進到flutter資料夾，執行flutter_console.bat"></a>進到flutter資料夾，執行flutter_console.bat</h2><p><img src="https://hackmd.io/_uploads/HJ7XeJbF0.png" alt="image"></p><p>執行後會跳出以下畫面<br><img src="https://hackmd.io/_uploads/B1V8lkWtR.png" alt="image"></p><p>輸入以下指令 檢查電腦環境，並下載Dart的SDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkojgJ-FC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/rkY1Q1WK0.png" alt="image"></p><div class="note warning simple"><p>最後會產生一個簡易的報表，這時會看到一些錯誤或警告。<br>別緊張，後面的步驟會一步一步處理它們。</p><p>先看一下有哪些錯誤</p><p>[X] Android toolchain - develop for Android devices<br>    X Unable to locate Android SDK.</p><p>[X] Visual Studio - develop Windows apps<br>    X Visual Studio not installed; this is necessary to develop Windows apps.</p><p>[!] Android Studio (not installed) </p></div><h2 id="設定安裝"><a href="#設定安裝" class="headerlink" title="設定安裝"></a>設定安裝</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/sdkmanager --sdk_root=&quot;C:\Android\Sdk&quot; --install &quot;cmdline-tools;latest&quot;</span><br></pre></td></tr></table></figure><h2 id="接受-Android-SDK-授權協議"><a href="#接受-Android-SDK-授權協議" class="headerlink" title="接受 Android SDK 授權協議"></a>接受 Android SDK 授權協議</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor --android-licenses</span><br></pre></td></tr></table></figure><h2 id="設定環境變數"><a href="#設定環境變數" class="headerlink" title="設定環境變數"></a>設定環境變數</h2><p>搜尋環境變數<br><img src="https://hackmd.io/_uploads/HkflEkWYR.png" alt="image"></p><p>點選環境變數<br><img src="https://hackmd.io/_uploads/HyqNE1-FC.png" alt="image"></p><p>在使用者變數區域找到「path」變數<br><img src="https://hackmd.io/_uploads/HyVIVy-FC.png" alt="image"></p><p>新增一個路徑到C:\flutter\bin<br><img src="https://hackmd.io/_uploads/H1ytVybYR.png" alt="image"></p><p>完成這個步驟之後就可以直接在cmd或powershell使用flutter commands，</p><h2 id="下載安裝Android-Studio"><a href="#下載安裝Android-Studio" class="headerlink" title="下載安裝Android Studio"></a>下載安裝Android Studio</h2><p><img src="https://hackmd.io/_uploads/ByVdrk-FC.png" alt="image"></p><blockquote><p><a href="https://developer.android.com/studio?hl=zh-tw#get-android-studio">https://developer.android.com/studio?hl=zh-tw#get-android-studio</a></p></blockquote><p>這邊發現好像改版成 Android Studio Koala了</p><p><img src="https://hackmd.io/_uploads/ryySFFNY0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SJ3UFF4YC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/rJYutYEFC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HJO5tKEYA.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/r15Q9FVFC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HJPV5FEYC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BkIDctNFC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Sk7FcY4tA.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/H1ljqYEY0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SJLC5FNKR.png" alt="image"></p><h3 id="設定模擬器"><a href="#設定模擬器" class="headerlink" title="設定模擬器"></a>設定模擬器</h3><h3 id="設定-C-C-for-Visual-Studio-Code"><a href="#設定-C-C-for-Visual-Studio-Code" class="headerlink" title="設定 C&#x2F;C++ for Visual Studio Code"></a>設定 C&#x2F;C++ for Visual Studio Code</h3><p>參考文件:<a href="https://code.visualstudio.com/docs/languages/cpp">https://code.visualstudio.com/docs/languages/cpp</a></p><p><img src="https://hackmd.io/_uploads/S1jkS9NY0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/ryMWr9EYR.png" alt="image"></p><p>後來發現這個操作沒有效，還是要直接安裝 Visual Studio</p><h2 id="安裝visual-studio"><a href="#安裝visual-studio" class="headerlink" title="安裝visual studio"></a>安裝visual studio</h2><p>選擇 Desktop development with C++<br><img src="https://hackmd.io/_uploads/BySy66VK0.png" alt="image"><br>因為以上這個問題，所以需要安裝visual studio 的 C++  workload</p><p><img src="https://hackmd.io/_uploads/SJkcYarYC.png" alt="image"></p><blockquote><p>目前遇到這個問題，不知道如何處理，暫時忽略</p></blockquote><h2 id="安裝-cmdline-tools-組件"><a href="#安裝-cmdline-tools-組件" class="headerlink" title="安裝 cmdline-tools 組件"></a>安裝 cmdline-tools 組件</h2><p>1.使用 SDK Manager 安裝 cmdline-tools<br>打開命令提示符或 PowerShell。</p><p>2.導航到你的 Android SDK 安裝目錄下的 cmdline-tools&#x2F;bin 目錄。例如，如果你的 SDK 安裝在 C:\Users&lt;你的用戶名&gt;\AppData\Local\Android\Sdk，那麼命令應該是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\&lt;你的用戶名&gt;\AppData\Local\Android\Sdk\cmdline-tools\latest\bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.執行以下命令來安裝最新的 cmdline-tools：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdkmanager --install &quot;cmdline-tools;latest&quot;</span><br></pre></td></tr></table></figure><p>接受 Android SDK 許可<br>在命令提示符中輸入以下命令來接受所有 Android SDK 許可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor --android-licenses</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJGTw5EtC.png" alt="image"></p><h3 id="安裝Flutter和dart-plugin"><a href="#安裝Flutter和dart-plugin" class="headerlink" title="安裝Flutter和dart plugin"></a>安裝Flutter和dart plugin</h3><p><img src="https://hackmd.io/_uploads/HyYgAKEKR.png" alt="image"></p><h2 id="目前實測操作結果如下"><a href="#目前實測操作結果如下" class="headerlink" title="目前實測操作結果如下"></a>目前實測操作結果如下</h2><p><img src="https://hackmd.io/_uploads/r1oEYpBtC.png" alt="image"></p><h2 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h2><p>今天實際操作了 Flutter 的安裝，後續的Java 需要設定環境變數跟 android studio 安裝都花了比較多的時間，另外 安裝 Visual Studio 也是花了很久的時間特別麻煩，而且很佔空間，另外遇到以下錯誤</p><p>錯誤碼 1310: 拒絕存取<br>Window Installer 服務要安裝 Visual Studio 所需封裝時，無法存取這部電腦的登錄或檔案系統。如果 Windows Defender 或其他防毒軟體會限制存取，就可能發生這種情況。</p><p>修正方式: 請檢查您的防毒設定，並確認 Windows Installer 服務對登錄和檔案系統有不受限制的存取權。</p><p>這部分目前打算暫時先略過，之後再來處理。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Flutter/">Flutter</category>
      
      
      <comments>https://gahgah147.github.io/2024/07/30/Flutter-%E5%AD%B8%E7%BF%92%E7%B4%80%E9%8C%84-Day-1-%E5%AE%89%E8%A3%9D%E8%88%87%E4%BB%8B%E7%B4%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我想要再去當救生員</title>
      <link>https://gahgah147.github.io/2024/07/26/%E6%88%91%E6%83%B3%E8%A6%81%E5%86%8D%E5%8E%BB%E7%95%B6%E6%95%91%E7%94%9F%E5%93%A1/</link>
      <guid>https://gahgah147.github.io/2024/07/26/%E6%88%91%E6%83%B3%E8%A6%81%E5%86%8D%E5%8E%BB%E7%95%B6%E6%95%91%E7%94%9F%E5%93%A1/</guid>
      <pubDate>Fri, 26 Jul 2024 07:23:56 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;我想要再去當救生員&quot;&gt;&lt;a href=&quot;#我想要再去當救生員&quot; class=&quot;headerlink&quot; title=&quot;我想要再去當救生員&quot;&gt;&lt;/a&gt;我想要再去當救生員&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="我想要再去當救生員"><a href="#我想要再去當救生員" class="headerlink" title="我想要再去當救生員"></a>我想要再去當救生員</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我之前大學的時候有當過救生員，那時候是因為學校有救生員社團，所以那時候去參加就有跟著社團訓練有拿到水協的救生員證，也有在一段時間課間時間去學校泳池站救生，那時候覺得救生訓練很有趣，除了每周二跟周四晚上的泳池訓練以外，周末還有海訓、溪訓跟深水泳池，我記得海訓的時候是在白沙灣太陽很大超好玩，溪訓的時候是在坪林親水公園溪水超冰的很涼快而且要記得防曬，深水泳池是在松山運動中心跳水很刺激不過那時候很怕猶豫很久不敢跳，這週六去白沙灣玩sup的時候覺得周末如果我自己有時間可以安排來站救生感覺也不錯，所以想再來去考一下體委的救生證。</p><h1 id="怎麼報名"><a href="#怎麼報名" class="headerlink" title="怎麼報名?"></a>怎麼報名?</h1><p>現在報名要到<a href="https://isports.sa.gov.tw/apps/LGM/LGM09/LGM0967Q_01V1.aspx?MENU_PRG_CD=4&ITEM_PRG_CD=2">i運動資訊平台</a>查詢離自己比較近的訓練泳池訓練單位跟日期，因為要完成50個小時的新訓，且其中包含8小時的基本救命術訓練，才能取得體育署救生員執照的「報考」資格。</p><p><img src="https://hackmd.io/_uploads/ryUZmlYIA.png" alt="image"></p><blockquote><p>i運動資訊平台</p></blockquote><p>今天是 2024年7月4號，我在這邊找到了離我比較近的士林前港泳池有辦新訓，所以就有報名7月份的新訓了，希望一切順利。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E6%95%91%E7%94%9F%E5%93%A1/">救生員</category>
      
      
      <comments>https://gahgah147.github.io/2024/07/26/%E6%88%91%E6%83%B3%E8%A6%81%E5%86%8D%E5%8E%BB%E7%95%B6%E6%95%91%E7%94%9F%E5%93%A1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GCP 學習 - Moniter 官方教學課程紀錄</title>
      <link>https://gahgah147.github.io/2024/06/17/GCP-%E5%AD%B8%E7%BF%92-Moniter-%E5%AE%98%E6%96%B9%E6%95%99%E5%AD%B8%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84/</link>
      <guid>https://gahgah147.github.io/2024/06/17/GCP-%E5%AD%B8%E7%BF%92-Moniter-%E5%AE%98%E6%96%B9%E6%95%99%E5%AD%B8%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84/</guid>
      <pubDate>Mon, 17 Jun 2024 03:06:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;GCP-學習-Moniter-官方教學課程紀錄&quot;&gt;&lt;a href=&quot;#GCP-學習-Moniter-官方教學課程紀錄&quot; class=&quot;headerlink&quot; title=&quot;GCP 學習 - Moniter 官方教學課程紀錄&quot;&gt;&lt;/a&gt;GCP 學習 - Monite</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="GCP-學習-Moniter-官方教學課程紀錄"><a href="#GCP-學習-Moniter-官方教學課程紀錄" class="headerlink" title="GCP 學習 - Moniter 官方教學課程紀錄"></a>GCP 學習 - Moniter 官方教學課程紀錄</h1><p>這邊是 Google Cloud Platform (GCP) 的 Moniter介面<br><img src="https://hackmd.io/_uploads/HkY6NvtSC.png" alt="image"></p><blockquote><p><a href="https://console.cloud.google.com/logs/query">https://console.cloud.google.com/logs/query</a></p></blockquote><p>GCP 這邊在使用上都會有一個這樣的了解詳情按紐<br><img src="https://hackmd.io/_uploads/ry_1rmar0.png" alt="image"></p><p>點擊下去之後就會有詳細的教學文件，我覺得很實用，但是這邊有個問題就是界面都會一直隨著時間改動，可能我現在紀錄的內容過了一年之後就更新了需要重新學習，不過我覺得還是可以做一個參考使用。</p><h1 id="教學項目"><a href="#教學項目" class="headerlink" title="教學項目"></a>教學項目</h1><p>一開始右邊可以看到教學項目，有以下內容</p><h2 id="說明文件-使用記錄檔探索工具"><a href="#說明文件-使用記錄檔探索工具" class="headerlink" title="說明文件: 使用記錄檔探索工具"></a>說明文件: 使用記錄檔探索工具</h2><p>您可以使用 Cloud Logging，有效率地擷取、檢視及分析查詢的記錄檔。</p><p><img src="https://hackmd.io/_uploads/SyfQsz6HA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/view/logs-explorer-interface">https://cloud.google.com/logging/docs/view/logs-explorer-interface</a></p></blockquote><h2 id="教學課程-快速入門導覽課程：Cloud-Logging-導覽與簡介"><a href="#教學課程-快速入門導覽課程：Cloud-Logging-導覽與簡介" class="headerlink" title="教學課程: 快速入門導覽課程：Cloud Logging 導覽與簡介"></a>教學課程: 快速入門導覽課程：Cloud Logging 導覽與簡介</h2><p>課程時間: 20 分鐘<br>開始使用 Cloud Logging，追蹤應用程式中的問題。<br><img src="https://hackmd.io/_uploads/SyUa3f6H0.png" alt="image"></p><h2 id="教學課程-快速入門導覽課程：運用作業套件代理程式，從-Apache-網路伺服器收集記錄檔"><a href="#教學課程-快速入門導覽課程：運用作業套件代理程式，從-Apache-網路伺服器收集記錄檔" class="headerlink" title="教學課程:快速入門導覽課程：運用作業套件代理程式，從 Apache 網路伺服器收集記錄檔"></a>教學課程:快速入門導覽課程：運用作業套件代理程式，從 Apache 網路伺服器收集記錄檔</h2><p>使用作業套件代理程式，從 Apache 網路伺服器收集記錄檔，再透過記錄檔探索工具查看這些檔案。</p><p><img src="https://hackmd.io/_uploads/BJDCnGpBR.png" alt="image"></p><h2 id="說明文件-Logging-用途"><a href="#說明文件-Logging-用途" class="headerlink" title="說明文件: Logging 用途"></a>說明文件: Logging 用途</h2><p>瞭解用途、最佳做法和產業解決方案。<br>監控與記錄的架構指南</p><p>探索監控與記錄的最佳做法和參考架構。</p><p><img src="https://hackmd.io/_uploads/B1mOjG6r0.png" alt="image"></p><h2 id="說明文件-透過記錄檔探索工具建構查詢"><a href="#說明文件-透過記錄檔探索工具建構查詢" class="headerlink" title="說明文件: 透過記錄檔探索工具建構查詢"></a>說明文件: 透過記錄檔探索工具建構查詢</h2><p>在記錄檔探索工具中建構查詢，以便擷取、修正及分析記錄檔。</p><p><img src="https://hackmd.io/_uploads/BkohsMaBR.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/view/building-queries">https://cloud.google.com/logging/docs/view/building-queries</a></p></blockquote><h2 id="說明文件-Logging-查詢語言"><a href="#說明文件-Logging-查詢語言" class="headerlink" title="說明文件: Logging 查詢語言"></a>說明文件: Logging 查詢語言</h2><p>瞭解用來查詢記錄檔資料及建立記錄檔接收器的 Logging 查詢語言。</p><p><img src="https://hackmd.io/_uploads/rJMghzTHC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/view/logging-query-language">https://cloud.google.com/logging/docs/view/logging-query-language</a></p></blockquote><h2 id="說明文件-使用記錄檔探索工具的查詢範例"><a href="#說明文件-使用記錄檔探索工具的查詢範例" class="headerlink" title="說明文件: 使用記錄檔探索工具的查詢範例"></a>說明文件: 使用記錄檔探索工具的查詢範例</h2><p>查看建議的查詢，讓您輕鬆使用記錄檔探索工具找出重要記錄檔。</p><p><img src="https://hackmd.io/_uploads/SJlr3z6BA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/view/query-library">https://cloud.google.com/logging/docs/view/query-library</a></p></blockquote><h2 id="說明文件-使用-gcloud-CLI-寫入及查詢記錄項目"><a href="#說明文件-使用-gcloud-CLI-寫入及查詢記錄項目" class="headerlink" title="說明文件: 使用 gcloud CLI 寫入及查詢記錄項目"></a>說明文件: 使用 gcloud CLI 寫入及查詢記錄項目</h2><p>運用記錄工具試用一些 Cloud Logging 的基本功能。</p><p><img src="https://hackmd.io/_uploads/HJQ_3G6SC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/write-query-log-entries-gcloud">https://cloud.google.com/logging/docs/write-query-log-entries-gcloud</a></p></blockquote><p>以下是個別細項的介紹</p><h2 id="使用記錄檔探索工具-View-logs-by-using-the-Logs-Explorer"><a href="#使用記錄檔探索工具-View-logs-by-using-the-Logs-Explorer" class="headerlink" title="使用記錄檔探索工具 - View logs by using the Logs Explorer"></a>使用記錄檔探索工具 - View logs by using the Logs Explorer</h2><p>使用記錄檔探索工具</p><p><img src="https://hackmd.io/_uploads/S1DiUPYHC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/view/logs-explorer-interface">https://cloud.google.com/logging/docs/view/logs-explorer-interface</a></p></blockquote><p>可以使用 Cloud Logging，有效率地擷取、檢視及分析查詢的記錄檔。<br>這邊的文件寫得非常的詳細</p><h2 id="快速入門導覽課程：Cloud-Logging-導覽與簡介"><a href="#快速入門導覽課程：Cloud-Logging-導覽與簡介" class="headerlink" title="快速入門導覽課程：Cloud Logging 導覽與簡介"></a>快速入門導覽課程：Cloud Logging 導覽與簡介</h2><p>這邊是一個教學課程20 分鐘，是有關 Cloud Logging，追蹤應用程式中的問題。</p><p><img src="https://hackmd.io/_uploads/rJAlKDKr0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Bk0MtvYBR.png" alt="image"></p><h3 id="步驟1-專案設定"><a href="#步驟1-專案設定" class="headerlink" title="步驟1. 專案設定"></a>步驟1. 專案設定</h3><p><img src="https://hackmd.io/_uploads/HJXBYDtSR.png" alt="image"></p><h3 id="步驟2-探索-Cloud-Logging-介面"><a href="#步驟2-探索-Cloud-Logging-介面" class="headerlink" title="步驟2. 探索 Cloud Logging 介面"></a>步驟2. 探索 Cloud Logging 介面</h3><p><img src="https://hackmd.io/_uploads/SJx_tvFSC.png" alt="image"></p><p>如要輸入篩選條件來限制顯示的記錄檔，請使用「Query Builder」(查詢建立工具) 窗格。</p><p><img src="https://hackmd.io/_uploads/B1RIqDYBR.png" alt="image"></p><p>如要查看查詢結果，請使用「Query Results」(查詢結果) 窗格。</p><p><img src="https://hackmd.io/_uploads/ByENZuKBC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BkdY5DtBC.png" alt="image"></p><p>如要查看不同欄位對應的記錄項目數量，請使用「Log Fields」(記錄檔欄位) 窗格。</p><p>舉例來說，這個窗格會列出嚴重性為 Critical 的記錄檔數量。這個窗格中的資料可做為欄位參考清單，撰寫查詢時可派上用場。</p><p><img src="https://hackmd.io/_uploads/r1Yp5DtSR.png" alt="image"></p><p>如要查看錯誤率，請使用「Histogram」(直方圖) 圖表。這張圖表不僅可協助您找出值得關注的事件發生的時間點，還可用來做為依時間和日期篩選記錄結果的介面。</p><p><img src="https://hackmd.io/_uploads/HyOgjDKSA.png" alt="image"></p><p>如要取得查詢的連結，點選「Share Link」(共用連結) 按鈕，即可針對目前顯示的這組記錄檔複製安全的深層連結。</p><p><img src="https://hackmd.io/_uploads/BkLDjvYSC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BJ7KivKB0.png" alt="image"></p><p>如要針對顯示或查詢的記錄檔設定時間範圍，請使用時間範圍選取器按鈕。</p><p><img src="https://hackmd.io/_uploads/B1hnjDFH0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SkupguFB0.png" alt="image"></p><h3 id="步驟3-建立-GKE-叢集"><a href="#步驟3-建立-GKE-叢集" class="headerlink" title="步驟3. 建立 GKE 叢集"></a>步驟3. 建立 GKE 叢集</h3><p><img src="https://hackmd.io/_uploads/Skw7MdKBC.png" alt="image"></p><p>在工具列中按一下  <img src="https://hackmd.io/_uploads/HyzvfuFrR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/rJS_fuKH0.png" alt="image"></p><blockquote><p>這邊會開始佈建 Cloud Shell 機器</p></blockquote><p>在下列指令中，將 PROJECT_ID 替換成您的專案 ID，然後在 Cloud Shell 中執行指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters create \</span><br><span class="line">    &quot;logcluster&quot; --project PROJECT_ID \</span><br><span class="line">    --zone us-central1-c --scopes \</span><br><span class="line">    &quot;gke-default&quot; --num-nodes &quot;3&quot; \</span><br><span class="line">    --enable-stackdriver-kubernetes</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Sk0dm_trA.png" alt="image"></p><p>這邊系統題式要啟用 Kubernetese Engine API<br><img src="https://hackmd.io/_uploads/HJ514_Yr0.png" alt="image"></p><blockquote><p>點選啟用</p></blockquote><p>花了一點時間後就成功了<br><img src="https://hackmd.io/_uploads/Hyt6EdtHA.png" alt="image"></p><p>執行上一個指令後，系統就會建立名為 logcluster 的叢集。這項作業會在幾分鐘內完成。建立叢集時，GKE 會佈建虛擬機器、載入機器映像檔，並設定要執行的 GKE 叢集。</p><p>如要安裝會產生記錄的應用程式，請按「Next」(下一步)。</p><h3 id="步驟4-安裝應用程式"><a href="#步驟4-安裝應用程式" class="headerlink" title="步驟4. 安裝應用程式"></a>步驟4. 安裝應用程式</h3><p><img src="https://hackmd.io/_uploads/SyT9LOtrC.png" alt="image"></p><p>執行下列指令，連線至 GKE 叢集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters \</span><br><span class="line">    get-credentials logcluster \</span><br><span class="line">    --zone us-central1-c --project \</span><br><span class="line">    PROJECT_ID</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HymbwOYHC.png" alt="image"></p><p>提取 Container Registry 中的應用程式，並部署至叢集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl run chatty \</span><br><span class="line">    --image=gcr.io/cloud-logging-generator/cloud-logging-log-creator</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Hy-wPOtB0.png" alt="image"></p><p>部署應用程式需要一些時間。部署完成後，應用程式就會產生記錄檔。</p><p>如要查看應用程式，請參考 GitHub 中的 <a href="https://github.com/GoogleCloudPlatform/cloud-logging-log-creator?hl=zh-TW">cloud-logging-log-creator</a> 應用程式。</p><p>如要瞭解如何查看 GKE 記錄檔，請按「Next」(下一步)。</p><h3 id="步驟5-查看-GKE-記錄檔"><a href="#步驟5-查看-GKE-記錄檔" class="headerlink" title="步驟5. 查看 GKE 記錄檔"></a>步驟5. 查看 GKE 記錄檔</h3><p><img src="https://hackmd.io/_uploads/rkLi_OYS0.png" alt="image"></p><p>在「Logs Explorer」(記錄檔探索工具) 頁面中，前往「Log Fields」(記錄檔欄位) 專區。</p><p><img src="https://hackmd.io/_uploads/B1JNKOYBA.png" alt="image"></p><p>「Resource Type」(資源類型)</p><p><img src="https://hackmd.io/_uploads/SyA3KuKH0.png" alt="image"><br> 專區中應該會列出幾個不同的實體，例如「Kubernetes Node」(Kubernetes 節點) 或「Kubernetes Pod」。</p><p>按一下「Kubernetes Cluster」(Kubernetes 叢集)。</p><p>選取「Kubernetes Cluster」(Kubernetes 叢集) 資源類型後，會發生以下情況：</p><p><img src="https://hackmd.io/_uploads/r1hRquKHA.png" alt="image"></p><p>「Query results」(查詢結果) 窗格中顯示的所有記錄，資源類型都設為「Kubernetes Cluster」(Kubernetes 叢集)。<br>「Query builder」(查詢建立工具) 窗格中的查詢會變更為 resource.type&#x3D;”k8s_cluster”<br>新類別會出現在「Log fields」(記錄欄位) 窗格中。這些類別包括：</p><ul><li>記錄檔名稱</li><li>專案 ID</li><li>位置</li></ul><p>在「Query builder」(查詢建立工具) 工具列中，按一下「Clear Query」(清除查詢)。<br><img src="https://hackmd.io/_uploads/BkqfjOtSA.png" alt="image"></p><h3 id="步驟6-尋找含有-chattylogs-的記錄檔"><a href="#步驟6-尋找含有-chattylogs-的記錄檔" class="headerlink" title="步驟6. 尋找含有 chattylogs 的記錄檔"></a>步驟6. 尋找含有 chattylogs 的記錄檔</h3><p>1.在「Query Builder」(查詢建立工具) 中輸入 chattylogs。</p><p><img src="https://hackmd.io/_uploads/rkh76OtS0.png" alt="image"></p><p>在「Query Builder」(查詢建立工具) 中輸入單一字詞時，該查詢會搜尋各個記錄檔的所有欄位，確認是否有相符項目。這類查詢的效率較低。</p><p>在先前的範例中，查詢只會搜尋每個記錄項目的 resource.type 這個欄位。</p><p>2.按一下 [執行查詢]。</p><p>結果會列出您安裝的應用程式產生的所有記錄檔。</p><p>3.請花幾分鐘的時間探索資料。舉例來說，只要前往「Query」(查詢) 窗格中的某個記錄檔，然後按下「Expand」(展開)按鈕，即可探索該記錄檔的各個欄位。<br><img src="https://hackmd.io/_uploads/ByMLadYSC.png" alt="image"></p><p>4.在「Query builder」(查詢建立工具) 工具列中，按一下「Clear Query」(清除查詢)。<br><img src="https://hackmd.io/_uploads/HJYup_YS0.png" alt="image"></p><h3 id="步驟7-依嚴重性和記錄檔名稱篩選"><a href="#步驟7-依嚴重性和記錄檔名稱篩選" class="headerlink" title="步驟7. 依嚴重性和記錄檔名稱篩選"></a>步驟7. 依嚴重性和記錄檔名稱篩選</h3><p>1.依嚴重性等級篩選：</p><p>按一下「Severity」(嚴重性)。<br><img src="https://hackmd.io/_uploads/HyxiTOYBR.png" alt="image"></p><p>選取「Critical」(重要)。<br><img src="https://hackmd.io/_uploads/S1X2adYSR.png" alt="image"></p><p>「Query results」(查詢結果) 窗格會顯示嚴重性等級為 Critical 的記錄。</p><p>2.依記錄檔名稱篩選：</p><ul><li>找到任一項目，然後按一下展開符號。</li><li>找出 logName 項目，在記錄檔名稱上按一下，然後點選「Show matching items」(顯示相符的項目)。</li></ul><p><img src="https://hackmd.io/_uploads/HyXbkYYHC.png" alt="image"></p><p>查詢傳回的結果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">severity=CRITICAL</span><br><span class="line">logName=&quot;projects/PROJECT_ID/logs/chattylogs&quot;</span><br></pre></td></tr></table></figure><p>系統只會顯示符合 severity 和 logName 篩選條件的記錄檔。</p><p>3.探索錯誤直方圖：</p><ul><li>從查詢建立工具中移除 severity&#x3D;Critical 這一行，然後按一下「Run Query」(執行查詢)。</li></ul><p><img src="https://hackmd.io/_uploads/B1aAlFKSR.png" alt="image"></p><ul><li><p>前往「Histogram」(直方圖) 窗格，找出直方圖顯示紅色長條的時間範圍，然後透過滑桿將時間範圍限縮到該直方圖項目附近。<br><img src="https://hackmd.io/_uploads/rycyGYKSC.png" alt="image"></p></li><li><p>移動滑桿後，按一下「Run Query」(執行查詢)。<br><img src="https://hackmd.io/_uploads/BkQDMKYHC.png" alt="image"></p></li></ul><p>直方圖會顯示，嚴重性為 Critical 的各個記錄項目前面，會有狀態為 Informational 或 Warning 的其他記錄檔。這些時間較早的記錄檔提供的資訊為，在系統寫入嚴重性為 Critical 的記錄項目前，應用程式處於何種狀態。</p><h3 id="步驟8-串流記錄"><a href="#步驟8-串流記錄" class="headerlink" title="步驟8. 串流記錄"></a>步驟8. 串流記錄</h3><p>根據預設，系統會停用記錄檔串流功能，記錄檔探索工具不會直接顯示這些內容。</p><p>如要即時查看記錄檔，請按一下「Stream logs」(串流記錄)。</p><p><img src="https://hackmd.io/_uploads/BJ_pMFYBC.png" alt="image"></p><p>查看完畢之後，請按一下「Stop streaming」(停止串流)。<br><img src="https://hackmd.io/_uploads/H16RGtFHA.png" alt="image"></p><p>如要進一步瞭解 Logging，請按「Next」(下一步)。</p><h3 id="步驟9-進一步瞭解-Cloud-Logging"><a href="#步驟9-進一步瞭解-Cloud-Logging" class="headerlink" title="步驟9. 進一步瞭解 Cloud Logging"></a>步驟9. 進一步瞭解 Cloud Logging</h3><p>「Log-based metrics」(記錄指標) 頁面可讓您從記錄項目的內容中取得指標資料。舉例來說，您可以建立指標來計算專案中的 Compute Engine VM 發生了多少 Warning 事件。詳情請參閱「<a href="https://cloud.google.com/logging/docs/logs-based-metrics">記錄指標總覽</a>」的說明。</p><p>「Logs Router」(記錄檔路由器) 頁面可讓您將記錄檔導向不同的目的地，包括 Cloud Logging 記錄檔值區、Cloud Storage 值區、Pub&#x2F;Sub 主題和 BigQuery 資料集。您可以使用這項功能設定要將哪些記錄檔轉送至特定目的地。詳情請參閱「<a href="https://cloud.google.com/logging/docs/routing/overview">轉送和儲存空間總覽</a>」的說明。</p><p>本快速入門導覽課程需使用資源，如要瞭解如何避免系統向您的 Google Cloud 帳戶收取相關費用，請按「Next」(下一步)。</p><h3 id="步驟10-後續步驟-避免產生帳單費用"><a href="#步驟10-後續步驟-避免產生帳單費用" class="headerlink" title="步驟10. 後續步驟 避免產生帳單費用"></a>步驟10. 後續步驟 避免產生帳單費用</h3><p>保留已建立的資源並運用 Logging 執行更多工作，或是清除所用資源來避免產生帳單費用。</p><p>運用 Logging 執行更多工作</p><ul><li>進一步瞭解 Logging 查詢語言：<ul><li>常見查詢。</li><li>建構查詢。</li></ul></li><li>瞭解如何查詢及查看記錄檔。<br>清除所用資源<br>此逐步操作說明需使用資源，如要避免系統向您的 Google Cloud 帳戶收取相關費用，請按照下列步驟操作。</li></ul><p>執行下列指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters delete \</span><br><span class="line">    logcluster --zone \</span><br><span class="line">    us-central1-c --project PROJECT_ID \</span><br><span class="line">    -q</span><br></pre></td></tr></table></figure><h2 id="快速入門導覽課程：運用作業套件代理程式，從-Apache-網路伺服器收集記錄檔"><a href="#快速入門導覽課程：運用作業套件代理程式，從-Apache-網路伺服器收集記錄檔" class="headerlink" title="快速入門導覽課程：運用作業套件代理程式，從 Apache 網路伺服器收集記錄檔"></a>快速入門導覽課程：運用作業套件代理程式，從 Apache 網路伺服器收集記錄檔</h2><p>使用作業套件代理程式，從 Apache 網路伺服器收集記錄檔，再透過記錄檔探索工具查看這些檔案。</p><h3 id="步驟1-運用作業套件代理程式收集來自-Apache-的記錄檔"><a href="#步驟1-運用作業套件代理程式收集來自-Apache-的記錄檔" class="headerlink" title="步驟1. 運用作業套件代理程式收集來自 Apache 的記錄檔"></a>步驟1. 運用作業套件代理程式收集來自 Apache 的記錄檔</h3><p><img src="https://hackmd.io/_uploads/Bk9O9ttBC.png" alt="image"><br>瞭解如何使用作業套件代理程式，收集及查看 <code>syslog</code> 記錄檔。這些記錄檔是由安裝在 Compute Engine 虛擬機器 (VM) 執行個體上的 Apache 網路伺服器所收集。您可以使用類似本快速入門導覽課程中的程序，<a href="https://cloud.google.com/logging/docs/agent/ops-agent/third-party">監控其他第三方應用程式</a>。</p><p>在本快速入門導覽課程中，執行以下操作：</p><ol><li>建立 Compute Engine VM 執行個體，並安裝<a href="https://cloud.google.com/logging/docs/agent/ops-agent">作業套件代理程式</a>。</li><li>安裝 Apache 網路伺服器。</li><li>針對 Apache 網路伺服器設定作業套件代理程式。</li><li>在記錄檔探索工具中查看記錄檔。</li><li>建立記錄式快訊。</li><li>測試快訊。</li><li>清除所用資源。</li></ol><p>預計時間：<br>15 分鐘</p><h3 id="步驟2-建立-VM-執行個體"><a href="#步驟2-建立-VM-執行個體" class="headerlink" title="步驟2.  建立 VM 執行個體"></a>步驟2.  建立 VM 執行個體</h3><p><img src="https://hackmd.io/_uploads/SyCtcFtSR.png" alt="image"></p><p>1.前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：</p><p>前往「VM instances」(VM 執行個體) 頁面<br><img src="https://hackmd.io/_uploads/HJneotKHR.png" alt="image"></p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。</p><p>2.點選「Create instance」(建立執行個體) 建立 VM。<br><img src="https://hackmd.io/_uploads/r13bsYYr0.png" alt="image"></p><p>如要查看位置，請點選下列按鈕：顯示<br><img src="https://hackmd.io/_uploads/HJgVitFBC.png" alt="image"></p><p>3.在<code>「Name」(名稱)</code> 欄位中，輸入描述性名稱。</p><p><img src="https://hackmd.io/_uploads/HkwujFtB0.png" alt="image"></p><p>4.在<code>「Machine type」(機器類型)</code> 欄位中，選取「e2-small」。<br><img src="https://hackmd.io/_uploads/B11ssYtS0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SkRToFtHR.png" alt="image"></p><p>5.在<code>「Boot disk」(開機磁碟)</code> 區段中，保留預設設定「Debian GNU&#x2F;Linux」。<br><img src="https://hackmd.io/_uploads/HJtAoKtSA.png" alt="image"></p><p>6.在<code>「Firewall」(防火牆)</code> 區段中，選取「Allow HTTP traffic」(允許 HTTP 流量) 和「Allow HTTPS traffic」(允許 HTTPS 流量)。<br><img src="https://hackmd.io/_uploads/rynehFKHA.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Byst2tKr0.png" alt="image"></p><p>7.在「Observability - Ops Agent」(觀測能力 - 作業套件代理程式)區段中，選取「Install Ops Agent for Monitoring and Logging」(安裝作業套件代理程式來處理監控和記錄工作)。</p><p><img src="https://hackmd.io/_uploads/B18shKFBR.png" alt="image"></p><p>8.按一下「Create」(建立)。<br><img src="https://hackmd.io/_uploads/Hks32FtBR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/H1VEpKtHA.png" alt="image"></p><h3 id="步驟3-安裝-Apache-網路伺服器"><a href="#步驟3-安裝-Apache-網路伺服器" class="headerlink" title="步驟3.  安裝 Apache 網路伺服器"></a>步驟3.  安裝 Apache 網路伺服器</h3><p>1.在「VM instances」(VM 執行個體) 頁面上找到新的 VM，前往「Connect」(連線) 欄，然後點選「SSH」。</p><p><img src="https://hackmd.io/_uploads/HkdgCttHR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SkOWCKKr0.png" alt="image"></p><p>點選授權<br><img src="https://hackmd.io/_uploads/ByCmAttS0.png" alt="image"></p><p>2.如要更新套件清單，請將下列指令複製到剪貼簿，貼到 SSH 終端機，然後按下 Enter 鍵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HyBIAFYHA.png" alt="image"></p><p>3.看到「Reading package lists… Done」(正在讀取套件清單… 完成) 訊息後，請在 SSH 終端機中執行下列指令，安裝 Apache2 網路伺服器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2 php7.0</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1nuAFYrC.png" alt="image"></p><p>系統詢問是否繼續安裝時，請輸入 Y。如果安裝指令失敗，請使用 sudo apt-get install apache2 php。</p><p>4.命令提示字元傳回後，請前往「VM instances」(VM 執行個體) 頁面，然後將 VM 的外部 IP 位址複製到下列網址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://EXTERNAL_IP</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/B1w5O-6HC.png" alt="image"></p><blockquote><p>這邊說的 外部IP 就是這個</p></blockquote><p>5.如要連線至 Apache 網路伺服器，請開啟新的瀏覽器分頁，然後輸入上一步中的網址。</p><p>網路伺服器安裝成功後，瀏覽器分頁就會顯示 Apache2 Debian 預設頁面。</p><p><img src="https://hackmd.io/_uploads/H1NTdZpS0.png" alt="image"></p><blockquote><p><a href="http://34.69.206.231/">http://34.69.206.231/</a></p></blockquote><p>如要瞭解如何透過作業套件代理程式收集 Apache 記錄檔和指標，請點選「Next」(下一步)。</p><h3 id="步驟4-收集-Apache-網路伺服器記錄檔和指標"><a href="#步驟4-收集-Apache-網路伺服器記錄檔和指標" class="headerlink" title="步驟4.  收集 Apache 網路伺服器記錄檔和指標"></a>步驟4.  收集 Apache 網路伺服器記錄檔和指標</h3><p><img src="https://hackmd.io/_uploads/B14OYZaS0.png" alt="image"></p><ol><li>前往 VM 執行個體的 SSH 終端機。如果尚未開啟終端機，請執行下列步驟：</li></ol><p>a. 前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：</p><p>前往「VM instances」(VM 執行個體) 頁面<br><img src="https://hackmd.io/_uploads/Byneqbar0.png" alt="image"></p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。</p><p>b. 找到新的 VM，然後點選「SSH」。</p><ol start="2"><li>複製下列指令，貼到執行個體的終端機，然後按下 Enter 鍵：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># Configures Ops Agent to collect telemetry from the app and restart Ops Agent.</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"># Create a back up of the existing file so existing configurations are not lost.</span><br><span class="line">sudo cp /etc/google-cloud-ops-agent/config.yaml /etc/google-cloud-ops-agent/config.yaml.bak</span><br><span class="line"></span><br><span class="line"># Configure the Ops Agent.</span><br><span class="line">sudo tee /etc/google-cloud-ops-agent/config.yaml &gt; /dev/null &lt;&lt; EOF</span><br><span class="line">metrics:</span><br><span class="line">  receivers:</span><br><span class="line">    apache:</span><br><span class="line">      type: apache</span><br><span class="line">  service:</span><br><span class="line">    pipelines:</span><br><span class="line">      apache:</span><br><span class="line">        receivers:</span><br><span class="line">          - apache</span><br><span class="line">logging:</span><br><span class="line">  receivers:</span><br><span class="line">    apache_access:</span><br><span class="line">      type: apache_access</span><br><span class="line">    apache_error:</span><br><span class="line">      type: apache_error</span><br><span class="line">  service:</span><br><span class="line">    pipelines:</span><br><span class="line">      apache:</span><br><span class="line">        receivers:</span><br><span class="line">          - apache_access</span><br><span class="line">          - apache_error</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo service google-cloud-ops-agent restart</span><br><span class="line">sleep 60</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/SysGi-aS0.png" alt="image"></p><p>先前的指令會建立設定，收集和擷取 Apache 網路伺服器中的記錄檔和指標。詳情請參閱「<a href="https://cloud.google.com/monitoring/agent/ops-agent/third-party/apache?hl=zh-TW">針對 Apache 網路伺服器設定作業套件代理程式</a>」一節。</p><ol start="3"><li>等候命令提示字元顯示，這至少需要 60 秒。</li></ol><p>如要瞭解如何查看 Apache 網路伺服器的 syslog 記錄檔，請點選「Next」(下一步)。</p><h3 id="步驟5-查看-Apache-網路伺服器記錄檔"><a href="#步驟5-查看-Apache-網路伺服器記錄檔" class="headerlink" title="步驟5. 查看 Apache 網路伺服器記錄檔"></a>步驟5. 查看 Apache 網路伺服器記錄檔</h3><p><img src="https://hackmd.io/_uploads/rk12AbTBA.png" alt="image"></p><ol><li>前往 Google Cloud 控制台的「Logs Explorer」(記錄檔探索工具) 頁面：</li></ol><p>前往「Logs Explorer」(記錄檔探索工具)</p><p><img src="https://hackmd.io/_uploads/Syh_sZpSC.png" alt="image"></p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Logging」的結果。</p><p>「Query results」(查詢結果) 窗格會顯示最近的記錄檔。</p><ol start="2"><li>確認工具列中的「Show query」(顯示查詢) 已啟用。</li></ol><p><img src="https://hackmd.io/_uploads/SJkCs-6SC.png" alt="image"></p><ol start="3"><li>如要查看 Apache 網路伺服器記錄檔，請建立並執行查詢：</li></ol><p>a. 從「Google Cloud project」(Google Cloud 專案) 選取器展開 Google Cloud 專案清單，然後將 Google Cloud 專案 ID 複製到剪貼簿。</p><p>在下列運算式中，將複製的 ID 貼到 PROJECT_ID 欄位中，然後將運算式複製到查詢編輯器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resource.type=&quot;gce_instance&quot;</span><br><span class="line">logName=(&quot;projects/PROJECT_ID/logs/apache_access&quot; OR &quot;projects/PROJECT_ID/logs/apache_error&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkHNT-6B0.png" alt="image"></p><p>執行先前的查詢時，只會顯示 apache_access 和 apache_error 記錄項目。</p><p>c.點選「Run query」(執行查詢)。<br><img src="https://hackmd.io/_uploads/BJNS0WpSR.png" alt="image"><br>「Query results」(查詢結果) 窗格會顯示查詢結果。</p><p><img src="https://hackmd.io/_uploads/r1YORWTHC.png" alt="image"></p><p>如要在記錄檔中出現特定模式時收到通知，請建立快訊政策。</p><p>如要瞭解如何建立快訊政策要使用的通知管道，請點選「Next」(下一步)。</p><h3 id="步驟6-建立電子郵件通知管道"><a href="#步驟6-建立電子郵件通知管道" class="headerlink" title="步驟6. 建立電子郵件通知管道"></a>步驟6. 建立電子郵件通知管道</h3><p><img src="https://hackmd.io/_uploads/Hyt0RbaBA.png" alt="image"></p><ol><li>前往 Google Cloud 控制台的「Alerting」(快訊) 頁面notifications：</li></ol><p>前往「Alerting」(快訊)</p><p><img src="https://hackmd.io/_uploads/BJFMyMaB0.png" alt="image"></p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Monitoring」的結果。</p><ol start="2"><li><p>點選工具列中的「Edit Notification Channels」(編輯通知管道)。</p></li><li><p>在「Notification channels」(通知管道) 頁面中，捲動至「Email」(電子郵件)，然後點選「Add new」(新增)。</p></li></ol><p><img src="https://hackmd.io/_uploads/BJ_L1zar0.png" alt="image"></p><ol start="4"><li>輸入您的電子郵件地址和顯示名稱 (例如 My email)，然後點選「Save」(儲存)。</li></ol><p><img src="https://hackmd.io/_uploads/rJsOeM6rC.png" alt="image"></p><p>如要瞭解如何在記錄檔中出現特定模式時收到通知，請點選「Next」(下一步)。</p><h3 id="步驟7-建立記錄式快訊"><a href="#步驟7-建立記錄式快訊" class="headerlink" title="步驟7. 建立記錄式快訊"></a>步驟7. 建立記錄式快訊</h3><p><img src="https://hackmd.io/_uploads/BJscxzaBA.png" alt="image"></p><ol><li>前往 Google Cloud 控制台的「Logs Explorer」(記錄檔探索工具) 頁面：</li></ol><p>前往「Logs Explorer」(記錄檔探索工具)</p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Logging」的結果。</p><p><img src="https://hackmd.io/_uploads/Syn1ZMTrA.png" alt="image"></p><ol start="2"><li>在「Query results」(查詢結果) 工具列中，點選「Create alert」(建立快訊) add_alert。記錄檔快訊政策窗格會隨即開啟。</li></ol><p><img src="https://hackmd.io/_uploads/ByJ4-GpBR.png" alt="image"></p><ol start="3"><li>在「Alert details」(快訊詳細資料) 的「Alert Policy Name」(快訊政策名稱) 欄位中，輸入 404 Not Found。</li></ol><p><img src="https://hackmd.io/_uploads/rJTL-zTHC.png" alt="image"></p><ol start="4"><li>在「Choose logs to include in this alert」(選擇要包含在這則快訊中的記錄檔)中，執行下列操作：</li></ol><p>a. 移除記錄檔篩選器文字方塊中的任何內容。<br>b. 複製下列查詢並貼到記錄檔篩選器文字方塊中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">severity&gt;=DEFAULT /help httpRequest.status=404</span><br></pre></td></tr></table></figure><p>先前的記錄檔篩選器會搜尋 severity 等級至少為 DEFAULT 的記錄項目，包含 &#x2F;help 文字且 httpRequest 狀態為 404。</p><p><img src="https://hackmd.io/_uploads/BJ20ffTSR.png" alt="image"></p><ol start="5"><li>在「Set notification frequency and autoclose duration」(設定通知頻率和自動關閉期限) 區段中，執行下列操作：</li></ol><p>a. 將「Time between notifications」(通知傳送間隔時間) 欄位設為「5 min」(5 分鐘)。</p><p>b. 將「Incident autoclose duration」(事件自動關閉期限) 欄位設為「30 min」(30 分鐘)。</p><p><img src="https://hackmd.io/_uploads/BJecQMaH0.png" alt="image"></p><ol start="6"><li>在「Who should be notified?」(應該通知誰？) 中，從「Notification Channels」(通知管道) 選單中選取您的電子郵件，然後點選「Save」(儲存)。</li></ol><p><img src="https://hackmd.io/_uploads/HkfAmG6HA.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HkEk4fTHR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/rJHxNMprC.png" alt="image"></p><p>如要瞭解如何測試快訊政策，請按「Next」(下一步)。</p><h3 id="步驟8-測試快訊政策"><a href="#步驟8-測試快訊政策" class="headerlink" title="步驟8. 測試快訊政策"></a>步驟8. 測試快訊政策</h3><p><img src="https://hackmd.io/_uploads/BJh_EMarR.png" alt="image"></p><ol><li>前往 VM 執行個體的 SSH 終端機。如果尚未開啟終端機，請執行下列步驟：</li></ol><p>a. 前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：</p><p><img src="https://hackmd.io/_uploads/Sk5REfaB0.png" alt="image"></p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。</p><p>b. 找到新的 VM，然後點選「SSH」。</p><ol start="2"><li>如要在伺服器上搜尋虛構頁面 <code>localhost/help</code>，請執行下列指令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost/help</span><br></pre></td></tr></table></figure><p>終端機顯示「404 Not Found」訊息後，系統會傳送電子郵件通知。這項程序會在幾分鐘內完成。</p><p><img src="https://hackmd.io/_uploads/r12QLz6H0.png" alt="image"></p><ol start="3"><li>如要查看新的記錄項目，請執行下列操作：<br>a. 前往 Google Cloud 控制台的「Logs Explorer」(記錄檔探索工具) 頁面：</li></ol><p>前往「Logs Explorer」(記錄檔探索工具)</p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Logging」的結果。</p><p><img src="https://hackmd.io/_uploads/BJBxPfpHR.png" alt="image"></p><p>b. 點選工具列中的「Jump to now」(跳到現在時間)。<br><img src="https://hackmd.io/_uploads/BkSSDGTB0.png" alt="image"></p><p>如要查看後續步驟並避免系統向帳戶收費，請點選「Next」(下一步)。</p><h3 id="步驟9-避免系統向帳戶收費"><a href="#步驟9-避免系統向帳戶收費" class="headerlink" title="步驟9. 避免系統向帳戶收費"></a>步驟9. 避免系統向帳戶收費</h3><p><img src="https://hackmd.io/_uploads/SylMnPGaHC.png" alt="image"></p><p>保留已建立的資源並運用 Monitoring 執行更多工作，或是清除所用資源來避免產生帳單費用。</p><p>運用 Monitoring 執行更多工作</p><h4 id="教學課程-透過作業套件代理程式收集-Apache-指標"><a href="#教學課程-透過作業套件代理程式收集-Apache-指標" class="headerlink" title="教學課程: 透過作業套件代理程式收集 Apache 指標"></a>教學課程: 透過作業套件代理程式收集 Apache 指標</h4><p>瞭解如何透過作業套件代理程式，收集 Apache 網路伺服器指標。</p><p><img src="https://hackmd.io/_uploads/Byhx_zTr0.png" alt="image"></p><h4 id="說明文件-使用記錄檔探索工具查看記錄檔"><a href="#說明文件-使用記錄檔探索工具查看記錄檔" class="headerlink" title="說明文件: 使用記錄檔探索工具查看記錄檔"></a>說明文件: 使用記錄檔探索工具查看記錄檔</h4><p>進一步瞭解 Cloud Monitoring。<br><img src="https://hackmd.io/_uploads/ByJv_G6BC.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/view/logs-explorer-interface">https://cloud.google.com/logging/docs/view/logs-explorer-interface</a></p></blockquote><h4 id="說明文件-透過記錄檔探索工具建構查詢-1"><a href="#說明文件-透過記錄檔探索工具建構查詢-1" class="headerlink" title="說明文件: 透過記錄檔探索工具建構查詢"></a>說明文件: 透過記錄檔探索工具建構查詢</h4><p>進一步瞭解 Cloud Monitoring。</p><p><img src="https://hackmd.io/_uploads/HJOoOM6HA.png" alt="image"></p><blockquote><p><a href="https://cloud.google.com/logging/docs/view/building-queries">https://cloud.google.com/logging/docs/view/building-queries</a></p></blockquote><h4 id="清除所用資源"><a href="#清除所用資源" class="headerlink" title="清除所用資源"></a>清除所用資源</h4><p>此逐步操作說明需使用資源，如要避免系統向您的 Google Cloud 帳戶收取相關費用，請按照下列步驟操作。</p><ol><li>如果您已建立 VM，請刪除該 VM：</li></ol><p>a. 前往 Google Cloud 控制台的「VM instances」(VM 執行個體) 頁面：</p><p>前往「VM instances」(VM 執行個體) 頁面</p><p><img src="https://hackmd.io/_uploads/HkXqtzTrR.png" alt="image"></p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Compute Engine」的結果。</p><p>b. 針對您建立的 VM，點選<br>「Actions」(動作)，然後選取「Delete」(刪除)。<br><img src="https://hackmd.io/_uploads/BklTYMprC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HyKpYMTrC.png" alt="image"></p><ol start="2"><li>刪除您建立的快訊政策：</li></ol><p>a. 前往 Google Cloud 控制台的「Alerting」(快訊) 頁面notifications：</p><p>前往「Alerting」(快訊)</p><p>如果您是使用搜尋列尋找這個頁面，請選取子標題為「Monitoring」的結果。</p><p>b. 選取您建立的快訊政策，然後點選「Delete」(刪除)。<br><img src="https://hackmd.io/_uploads/SyIm9zTB0.png" alt="image"></p><h1 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h1><p>以上就是設定Google Cloud Platform (GCP) 的 Moniter介面官方教學課程操作的步驟紀錄，官方的教學介紹課程內容蠻多的，希望能幫助到你，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GCP/">GCP</category>
      
      <category domain="https://gahgah147.github.io/tags/Google/">Google</category>
      
      <category domain="https://gahgah147.github.io/tags/GCP-Moniter/">GCP Moniter</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/17/GCP-%E5%AD%B8%E7%BF%92-Moniter-%E5%AE%98%E6%96%B9%E6%95%99%E5%AD%B8%E8%AA%B2%E7%A8%8B%E7%B4%80%E9%8C%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Google 帳號預設語言改為中文</title>
      <link>https://gahgah147.github.io/2024/06/14/Google-%E5%B8%B3%E8%99%9F%E9%A0%90%E8%A8%AD%E8%AA%9E%E8%A8%80%E6%94%B9%E7%82%BA%E4%B8%AD%E6%96%87/</link>
      <guid>https://gahgah147.github.io/2024/06/14/Google-%E5%B8%B3%E8%99%9F%E9%A0%90%E8%A8%AD%E8%AA%9E%E8%A8%80%E6%94%B9%E7%82%BA%E4%B8%AD%E6%96%87/</guid>
      <pubDate>Fri, 14 Jun 2024 06:29:43 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Google-帳號預設語言改為中文&quot;&gt;&lt;a href=&quot;#Google-帳號預設語言改為中文&quot; class=&quot;headerlink&quot; title=&quot;Google 帳號預設語言改為中文&quot;&gt;&lt;/a&gt;Google 帳號預設語言改為中文&lt;/h1&gt;&lt;p&gt;在工作時候，常常會需</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Google-帳號預設語言改為中文"><a href="#Google-帳號預設語言改為中文" class="headerlink" title="Google 帳號預設語言改為中文"></a>Google 帳號預設語言改為中文</h1><p>在工作時候，常常會需要使用公司的Google 帳號，新的Google 帳號常常預設會是英文，這時候會需要更改預設語言可以參考以下官方頁面<br><img src="https://hackmd.io/_uploads/SkacXDKBC.png" alt="image"></p><blockquote><p><a href="https://support.google.com/accounts/answer/32047?hl=zh-Hant&co=GENIE.Platform=Desktop">https://support.google.com/accounts/answer/32047?hl=zh-Hant&amp;co=GENIE.Platform%3DDesktop</a></p></blockquote><h1 id="操作步驟"><a href="#操作步驟" class="headerlink" title="操作步驟"></a>操作步驟</h1><h2 id="進入-google-管理介面"><a href="#進入-google-管理介面" class="headerlink" title="進入 google 管理介面"></a>進入 google 管理介面</h2><p>點擊 <a href="https://myaccount.google.com/">https://myaccount.google.com/</a></p><p>畫面如下<br><img src="https://hackmd.io/_uploads/HkszgwFHR.png" alt="image"></p><h2 id="進入語言設定"><a href="#進入語言設定" class="headerlink" title="進入語言設定"></a>進入語言設定</h2><p>切換到Personal Info -&gt; 點選 Language<br><img src="https://hackmd.io/_uploads/B1bngwYBA.png" alt="image"></p><p>查詢中文-&gt; 點選繁體中文<br><img src="https://hackmd.io/_uploads/rkzybPKBA.png" alt="image"></p><p>選擇台灣<br><img src="https://hackmd.io/_uploads/rkozbPFBR.png" alt="image"></p><p>這樣就成功設定了<br><img src="https://hackmd.io/_uploads/r10UWvtSC.png" alt="image"></p><h1 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h1><p>以上就是設定 Google 帳號預設語言的步驟，希望能幫助到你，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E8%BE%A6%E5%85%AC%E5%B0%8F%E6%8A%80%E5%B7%A7/">辦公小技巧</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Google/">Google</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%BE%A6%E5%85%AC%E5%B0%8F%E6%8A%80%E5%B7%A7/">辦公小技巧</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/14/Google-%E5%B8%B3%E8%99%9F%E9%A0%90%E8%A8%AD%E8%AA%9E%E8%A8%80%E6%94%B9%E7%82%BA%E4%B8%AD%E6%96%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 學習筆記 Day3 - 建立自己的Docker 映像檔</title>
      <link>https://gahgah147.github.io/2024/06/14/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day3-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84Docker-%E6%98%A0%E5%83%8F%E6%AA%94/</link>
      <guid>https://gahgah147.github.io/2024/06/14/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day3-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84Docker-%E6%98%A0%E5%83%8F%E6%AA%94/</guid>
      <pubDate>Fri, 14 Jun 2024 05:25:57 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Docker-學習筆記-Day3-建立自己的Docker-映像檔&quot;&gt;&lt;a href=&quot;#Docker-學習筆記-Day3-建立自己的Docker-映像檔&quot; class=&quot;headerlink&quot; title=&quot;Docker 學習筆記 Day3 - 建立自己的Dock</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Docker-學習筆記-Day3-建立自己的Docker-映像檔"><a href="#Docker-學習筆記-Day3-建立自己的Docker-映像檔" class="headerlink" title="Docker 學習筆記 Day3 - 建立自己的Docker 映像檔"></a>Docker 學習筆記 Day3 - 建立自己的Docker 映像檔</h1><h1 id="Docker-Hub-是什麼？"><a href="#Docker-Hub-是什麼？" class="headerlink" title="Docker Hub 是什麼？"></a>Docker Hub 是什麼？</h1><p><img src="https://hackmd.io/_uploads/rJL5dXYHC.png" alt="image"></p><blockquote><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p></blockquote><p>Docker Hub 是一個線上託管服務，專門用來存儲和分發 Docker 映像檔。它提供了一個集中式平台，讓開發者能夠輕鬆分享、搜尋和下載各種應用程式的 Docker 映像檔。Docker Hub 提供了多種功能，例如公共和私有儲存庫、自動建置、Webhooks 及其他整合服務。以下是 Docker Hub 的一些主要功能：</p><ol><li><p><strong>公共和私有儲存庫</strong>：你可以選擇將映像檔設為公共或私有。公共儲存庫可供所有人自由訪問，而私有儲存庫則只有你指定的用戶才能存取。</p></li><li><p><strong>自動建置</strong>：你可以將 Docker Hub 與 GitHub 或 Bitbucket 等原始碼儲存庫連接，當你的程式碼有變動時，Docker Hub 可以自動建置映像檔。</p></li><li><p><strong>Webhooks</strong>：當映像檔有更新時，Webhooks 可以通知你指定的應用程式或服務，方便進行自動化流程。</p></li><li><p><strong>團隊和組織管理</strong>：你可以創建和管理團隊，設定不同成員的訪問權限，適合協作開發和大型專案管理。</p></li></ol><p>像是昨天就有在 Docker Hub 上面查詢到範例的映像檔</p><h2 id="如何使用-Docker-Hub"><a href="#如何使用-Docker-Hub" class="headerlink" title="如何使用 Docker Hub"></a>如何使用 Docker Hub</h2><h3 id="1-註冊-Docker-Hub-帳號"><a href="#1-註冊-Docker-Hub-帳號" class="headerlink" title="1. 註冊 Docker Hub 帳號"></a>1. 註冊 Docker Hub 帳號</h3><p>首先，你需要一個 Docker Hub 帳號，可以到 <a href="https://hub.docker.com/">Docker Hub 官方網站</a> 註冊。</p><p>Docker Hub 註冊頁面<br><img src="https://hackmd.io/_uploads/ryd75QYSR.png" alt="image"></p><blockquote><p><a href="https://hub.docker.com/signup">https://hub.docker.com/signup</a></p></blockquote><h3 id="2-登入-Docker-Hub"><a href="#2-登入-Docker-Hub" class="headerlink" title="2. 登入 Docker Hub"></a>2. 登入 Docker Hub</h3><p>使用以下命令在終端機中登入 Docker Hub：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p>輸入你的 Docker Hub 使用者名稱和密碼。</p><h3 id="3-上傳映像檔到-Docker-Hub"><a href="#3-上傳映像檔到-Docker-Hub" class="headerlink" title="3. 上傳映像檔到 Docker Hub"></a>3. 上傳映像檔到 Docker Hub</h3><p>假設你已經有一個本地的 Docker 映像檔，你可以使用以下命令將映像檔推送到 Docker Hub：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag your-image-name your-dockerhub-username/your-repository-name:tag</span><br><span class="line">docker push your-dockerhub-username/your-repository-name:tag</span><br></pre></td></tr></table></figure><h3 id="4-從-Docker-Hub-下載映像檔"><a href="#4-從-Docker-Hub-下載映像檔" class="headerlink" title="4. 從 Docker Hub 下載映像檔"></a>4. 從 Docker Hub 下載映像檔</h3><p>你可以使用以下命令從 Docker Hub 下載並運行映像檔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull your-dockerhub-username/your-repository-name:tag</span><br><span class="line">docker run -d your-dockerhub-username/your-repository-name:tag</span><br></pre></td></tr></table></figure><h3 id="實例：建立並上傳自己的-Docker-映像檔"><a href="#實例：建立並上傳自己的-Docker-映像檔" class="headerlink" title="實例：建立並上傳自己的 Docker 映像檔"></a>實例：建立並上傳自己的 Docker 映像檔</h3><ol><li><p><strong>建立 Dockerfile</strong><br>在專案目錄中建立一個 <code>Dockerfile</code>，內容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的 Node.js 映像檔作為基礎映像檔</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立應用目錄</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製 package.json 和 package-lock.json</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝應用程式依賴</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製所有檔案到工作目錄</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露應用埠</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義啟動指令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建置 Docker 映像檔</strong><br>在終端機中執行以下命令來建置映像檔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t your-dockerhub-username/your-repository-name:tag .</span><br></pre></td></tr></table></figure></li><li><p><strong>推送映像檔到 Docker Hub</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push your-dockerhub-username/your-repository-name:tag</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用來自-Docker-Hub-的映像檔"><a href="#使用來自-Docker-Hub-的映像檔" class="headerlink" title="使用來自 Docker Hub 的映像檔"></a>使用來自 Docker Hub 的映像檔</h2><p>使用以下指令抓取 web-ping 應用程式的容器映像檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull diamol/ch03-web-ping</span><br></pre></td></tr></table></figure><p>像是<code>diamol/ch03-web-ping</code>這個映像檔就可以在 Docker Hub 上面看到<br><img src="https://hackmd.io/_uploads/HyELj7FB0.png" alt="image"></p><blockquote><p><a href="https://hub.docker.com/r/diamol/ch03-web-ping">https://hub.docker.com/r/diamol/ch03-web-ping</a></p></blockquote><p>執行結果 如下<br><img src="https://hackmd.io/_uploads/H1NzsXYS0.png" alt="image"></p><p>依照結果這邊來看，會發現這邊有很多個檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from diamol/ch03-web-ping</span><br><span class="line">e7c96db7181b: Pull complete</span><br><span class="line">bbec46749066: Pull complete</span><br><span class="line">89e5cf82282d: Pull complete</span><br><span class="line">5de6895db72f: Pull complete</span><br><span class="line">f5cca017994f: Pull complete</span><br><span class="line">78b9b6c949f8: Pull complete</span><br><span class="line">Digest: sha256:2f2dce710a7f287afc2d7bbd0d68d024bab5ee37a1f658cef46c64b1a69affd2</span><br><span class="line">Status: Downloaded newer image for diamol/ch03-web-ping:latest</span><br><span class="line">docker.io/diamol/ch03-web-ping:latest</span><br></pre></td></tr></table></figure><p>這個機制稱為 映像層(image layers)。 也就是每個image 映像黨都是由很多個映像層組合而成的。</p><h2 id="利用映像檔執行一個容器"><a href="#利用映像檔執行一個容器" class="headerlink" title="利用映像檔執行一個容器"></a>利用映像檔執行一個容器</h2><p>當你執行以下命令時：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --name web-ping diamol/ch03-web-ping</span><br></pre></td></tr></table></figure><p>這行命令的目的是啟動一個新的 Docker 容器，並且有以下幾個特點：</p><ol><li><p>**<code>docker container run</code>**：</p><ul><li>這是 Docker 的一個命令，用於運行一個新的容器。</li></ul></li><li><p>**<code>-d</code>**：</p><ul><li><code>-d</code> 代表 “detached mode”，這表示容器會在後台執行，不會鎖定終端機。</li></ul></li><li><p>**<code>--name web-ping</code>**：</p><ul><li><code>--name</code> 參數用來給容器指定一個名稱。在這個例子中，容器的名稱被設為 <code>web-ping</code>。這樣在未來的操作中，你可以通過這個名稱來引用這個容器，而不是使用自動生成的容器 ID。</li></ul></li><li><p>**<code>diamol/ch03-web-ping</code>**：</p><ul><li>這是要運行的映像檔的名稱。<code>diamol</code> 是映像檔的名稱空間或組織名稱，<code>ch03-web-ping</code> 是具體的映像檔名稱。這個映像檔可能已經在你的本地系統上，如果沒有，Docker 會從 Docker Hub 或其他配置的映像檔庫拉取這個映像檔。</li></ul></li></ol><p>總結來說，這行命令會在後台啟動一個名為 <code>web-ping</code> 的容器，該容器基於 <code>diamol/ch03-web-ping</code> 映像檔。這使得你可以在不影響當前終端機工作的情況下執行並管理這個容器。</p><p><img src="https://hackmd.io/_uploads/r1dXkNtB0.png" alt="image"></p><blockquote><p>執行結果</p></blockquote><p>這個容器開啟後會反覆不斷的ping 作者的部落格(blog.sixeyed.com)<br><img src="https://hackmd.io/_uploads/S1yJe4KrA.png" alt="image"></p><blockquote><p>可以在 Docker desktop 上觀察</p></blockquote><p>另外也可以使用以下指令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs web-ping</span><br></pre></td></tr></table></figure><h2 id="刪除現有容器"><a href="#刪除現有容器" class="headerlink" title="刪除現有容器"></a>刪除現有容器</h2><p>使用以下指令刪除剛剛練習的 <code>web-ping</code> 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f web-ping</span><br></pre></td></tr></table></figure><h2 id="設定環境變數-–env"><a href="#設定環境變數-–env" class="headerlink" title="設定環境變數: –env"></a>設定環境變數: –env</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --<span class="built_in">env</span> TARGET=google.com diamol/ch03-web-ping</span><br></pre></td></tr></table></figure><p>這行命令的目的是啟動一個新的 Docker 容器，並且有以下幾個特點：</p><ol><li><p>**<code>docker container run</code>**：</p><ul><li>這是 Docker 的一個命令，用於運行一個新的容器。</li></ul></li><li><p>**<code>--env TARGET=google.com</code>**：</p><ul><li><code>--env</code> 參數用來設置環境變數。在這個例子中，<code>TARGET</code> 是環境變數的名稱，而 <code>google.com</code> 是這個變數的值。這個環境變數會傳遞給容器內運行的應用程式，應用程式可以根據這個環境變數來決定其行為。例如，這裡假設應用程式會針對 <code>google.com</code> 執行一些操作。</li></ul></li><li><p>**<code>diamol/ch03-web-ping</code>**：</p><ul><li>這是要運行的映像檔的名稱。<code>diamol</code> 是映像檔的名稱空間或組織名稱，<code>ch03-web-ping</code> 是具體的映像檔名稱。這個映像檔可能已經在你的本地系統上，如果沒有，Docker 會從 Docker Hub 或其他配置的映像檔庫拉取這個映像檔。</li></ul></li></ol><p>總結來說，這行命令會啟動一個基於 <code>diamol/ch03-web-ping</code> 映像檔的容器，並且將 <code>TARGET</code> 環境變數設置為 <code>google.com</code>。這使得容器內的應用程式可以利用這個環境變數來決定它要針對 <code>google.com</code> 執行的操作。</p><p><img src="https://hackmd.io/_uploads/BJYQmNtS0.png" alt="image"></p><blockquote><p>執行結果</p></blockquote><p>程式會一直執行，按 <code>Ctrl</code> + <code>C</code> 可以結束應用程式。</p><p>環境變數對於Docker而言來說是一個非常重要的機制，能夠視情況朴整不同的設定值，例如<br>在專案開發中的開發環境(DEV)、測試環境(QAT)、正式環境(PRD)</p><p><img src="https://hackmd.io/_uploads/r1ssNEFrA.png" alt="image"></p><blockquote><p>圖片來源:<a href="https://ryanisagoodguy.blogspot.com/2020/02/devteststageprod.html">https://ryanisagoodguy.blogspot.com/2020/02/devteststageprod.html</a></p></blockquote><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>到 <code>diamol/ch03/exercises/web-ping</code> 資料夾中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd diamol/ch03/exercises/web-ping</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BytkL4YHR.png" alt="image"></p><p>可以看到 <code>Dockerfile</code>範例內容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM diamol/node</span><br><span class="line"></span><br><span class="line">ENV TARGET=&quot;blog.sixeyed.com&quot;</span><br><span class="line">ENV METHOD=&quot;HEAD&quot;</span><br><span class="line">ENV INTERVAL=&quot;3000&quot;</span><br><span class="line"></span><br><span class="line">WORKDIR /web-ping</span><br><span class="line">COPY app.js .</span><br><span class="line"></span><br><span class="line">CMD [&quot;node&quot;, &quot;/web-ping/app.js&quot;]</span><br></pre></td></tr></table></figure><p>這個 Dockerfile 目的是建立一個自訂的 Docker 映像檔，該映像檔基於 <code>diamol/node</code> 映像檔，並設定一些環境變數、工作目錄、複製應用程式檔案以及設定容器啟動時的指令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> diamol/node</span><br></pre></td></tr></table></figure><p>這行指令指定了基礎映像檔，<code>diamol/node</code>。這表示你的自訂映像檔將基於這個映像檔來構建，繼承其所有的內容和設置。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> TARGET=<span class="string">&quot;blog.sixeyed.com&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> METHOD=<span class="string">&quot;HEAD&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> INTERVAL=<span class="string">&quot;3000&quot;</span></span><br></pre></td></tr></table></figure><p>這些指令設置了三個環境變數：</p><ul><li><code>TARGET</code>：指定要 Ping 的目標 URL，預設值為 <code>blog.sixeyed.com</code>。</li><li><code>METHOD</code>：指定 HTTP 請求的方法，預設值為 <code>HEAD</code>。</li><li><code>INTERVAL</code>：指定 Ping 的間隔時間，單位為毫秒，預設值為 <code>3000</code> (3秒)。<br>  這些環境變數可以在容器內的應用程式中使用，允許你在不修改程式碼的情況下更改這些設置。</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /web-ping</span></span><br></pre></td></tr></table></figure><p>這行指令設置了容器內的工作目錄為 <code>/web-ping</code>。接下來的所有指令（如 <code>COPY</code> 和 <code>CMD</code>）都會相對於這個目錄進行操作。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.js .</span></span><br></pre></td></tr></table></figure><p>這行指令將本地檔案系統中的 <code>app.js</code> 檔案複製到容器內的當前工作目錄 (<code>/web-ping</code>) 中。這樣做是為了確保 <code>app.js</code> 在容器運行時可以被訪問和執行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;/web-ping/app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>這行指令指定了當容器啟動時要執行的命令。這裡使用 <code>node</code> 命令來運行 <code>app.js</code> 檔案。<code>CMD</code> 指令會在容器啟動時執行一次，並保持容器運行。</p><h1 id="建立映像檔"><a href="#建立映像檔" class="headerlink" title="建立映像檔"></a>建立映像檔</h1><p>使用以下命令來建立一個 Docker 映像檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build --tag web-ping .</span><br></pre></td></tr></table></figure><p><code>docker image build</code>：這是 Docker 的一個命令，用來建立 Docker 映像檔。</p><p><code>--tag web-ping</code>：這個參數用來為建立的映像檔指定一個標籤。在這個例子中，映像檔的標籤被設置為 <code>web-ping</code>。這個標籤可以用來識別這個映像檔，後續可以使用這個標籤來運行容器或者上傳到 Docker Hub 等映像檔庫中。</p><p><code>.</code>：這表示 Docker 命令應該在當前目錄下查找 Dockerfile。Dockerfile 是一個包含了建立映像檔所需指令的文本文件，通常放在項目的根目錄下。</p><p>總結來說，這個命令的目的是在當前目錄下的 Dockerfile 中定義的指令基礎上建立一個名為 web-ping 的 Docker 映像檔。這個映像檔可以通過標籤 web-ping 來識別。</p><p><img src="https://hackmd.io/_uploads/Hkzs_VYHC.png" alt="image"></p><blockquote><p>成功建立畫面</p></blockquote><h1 id="列出映像檔"><a href="#列出映像檔" class="headerlink" title="列出映像檔"></a>列出映像檔</h1><p>使用以下指令來列出所有w字母開頭的映像檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls &#x27;w*&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HytGY4KHA.png" alt="image"></p><blockquote><p>執行結果</p></blockquote><h1 id="Docker-映像層是什麼"><a href="#Docker-映像層是什麼" class="headerlink" title="Docker 映像層是什麼?"></a>Docker 映像層是什麼?</h1><p>在 Docker 中，映像檔（Image）是一種輕量、可執行的環境打包方式，它可以包含應用程式運行所需的所有資源，如程式碼、執行環境、庫文件、設定檔等。一個 Docker 映像檔由多個層（Layer）組成，每一層都是對映像檔系統的一次修改。</p><h2 id="分層結構"><a href="#分層結構" class="headerlink" title="分層結構"></a>分層結構</h2><p>當你建立一個新的 Docker 映像檔時，每一個指令（如 <code>RUN</code>、<code>COPY</code>、<code>ADD</code>）都會產生一個新的層。這種分層結構有幾個重要的優勢：</p><ol><li><p><strong>節省空間</strong>：如果兩個映像檔共用相同的層，這些層只會在硬碟上存儲一次，因此節省了空間。</p></li><li><p><strong>容易分享</strong>：每個層都是獨立的，因此可以更容易地共享和重複使用這些層。這也是 Docker 映像檔如此輕量級和易於傳播的原因之一。</p></li><li><p><strong>快速構建</strong>：當你修改了一個映像檔並重新構建時，Docker 可以快速地重新使用先前建立的層，只重新建立修改過的部分，從而加快了構建速度。</p></li></ol><h2 id="實際應用"><a href="#實際應用" class="headerlink" title="實際應用"></a>實際應用</h2><p>例如，假設你有一個基於 Ubuntu 的映像檔，並且對其進行了一些自定義配置和安裝，這些操作會生成一個新的層。當你使用這個映像檔建立容器時，Docker 會將這些層堆疊在一起，最終形成一個完整的運行環境。</p><h2 id="查看看Docker映像檔的metadata"><a href="#查看看Docker映像檔的metadata" class="headerlink" title="查看看Docker映像檔的metadata"></a>查看看Docker映像檔的metadata</h2><p>可以使用以下指令來看 web-ping 的映像檔metadata:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image history web-ping</span><br></pre></td></tr></table></figure><p>可以看到每一個映像層都有輸出<br><img src="https://hackmd.io/_uploads/ryPYsEYH0.png" alt="image"></p><p>CREATED BY 這一欄紀錄的是Dockerfile執行的命令</p><h1 id="映像層快取"><a href="#映像層快取" class="headerlink" title="映像層快取"></a>映像層快取</h1><p>修改一下 app.js 檔案，例如加入空白後執行以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t web-ping:v2 .</span><br></pre></td></tr></table></figure><p>調整 Dockerfile 內容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM diamol/node</span><br><span class="line"></span><br><span class="line">CMD [&quot;node&quot;, &quot;/web-ping/app.js&quot;]    # CMD 往前放了</span><br><span class="line"></span><br><span class="line">ENV TARGET=&quot;blog.sixeyed.com&quot; \     # 3個 ENV 合併在一起</span><br><span class="line">    METHOD=&quot;HEAD&quot; \</span><br><span class="line">    NTERVAL=&quot;3000&quot;</span><br><span class="line"></span><br><span class="line">WORKDIR /web-ping</span><br><span class="line">COPY app.js .</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">cd web-ping-optimized/</span><br><span class="line">docker image build -t web-ping:v3 .</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Hy2cM8FHR.png" alt="image"></p><p>這一段其實有點看不太懂書中說到的優化在哪裡，我只看到有調整了寫法</p><h1 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h1><p>以上就是第三天的練習內容，今天介紹了Docker Hub、Dockerfile、Docker Image還有Image Layer 相關的知識，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/">Docker 學習筆記</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/14/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day3-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84Docker-%E6%98%A0%E5%83%8F%E6%AA%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo部落格 - Butterfly 主題調整</title>
      <link>https://gahgah147.github.io/2024/06/13/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4/</link>
      <guid>https://gahgah147.github.io/2024/06/13/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4/</guid>
      <pubDate>Thu, 13 Jun 2024 07:33:01 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Hexo部落格-Butterfly-主題調整&quot;&gt;&lt;a href=&quot;#Hexo部落格-Butterfly-主題調整&quot; class=&quot;headerlink&quot; title=&quot;Hexo部落格 - Butterfly 主題調整&quot;&gt;&lt;/a&gt;Hexo部落格 - Butterfl</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Hexo部落格-Butterfly-主題調整"><a href="#Hexo部落格-Butterfly-主題調整" class="headerlink" title="Hexo部落格 - Butterfly 主題調整"></a>Hexo部落格 - Butterfly 主題調整</h1><p>本文介紹如何在 Hexo 部落格中使用 Butterfly 主題，以及如何進行一些常見的調整。包括檔案結構介紹、主題顏色調整、樣式修改、Tags位置調整等。</p><h2 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h2><ul><li><a href="#%E6%AA%94%E6%A1%88%E7%B5%90%E6%A7%8B%E4%BB%8B%E7%B4%B9">檔案結構介紹</a></li><li><a href="#%E4%B8%BB%E9%A1%8C%E9%A1%8F%E8%89%B2%E8%AA%BF%E6%95%B4">主題顏色調整</a></li><li><a href="#%E6%A8%A3%E5%BC%8F-css%E7%9B%B8%E9%97%9C%E7%9A%84%E9%A0%85%E7%9B%AE">樣式 (css相關的項目)</a></li><li><a href="#tags%E7%A7%BB%E8%87%B3%E6%96%87%E7%AB%A0%E4%B8%8A%E6%96%B9">Tags：移至文章上方</a></li><li><a href="#%E7%89%88%E6%AC%8A%E6%A1%86%E5%85%A7%E7%9A%84%E5%AD%97%E5%8F%A5">版權框內的字句</a></li><li><a href="#%E7%82%BA%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86">為文章加密</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li></ul></li><li><a href="#%E5%8F%B3%E4%B8%8B%E8%A7%92%E6%8C%89%E9%88%95%E6%94%B9%E7%82%BA%E9%BB%98%E8%AA%8D%E9%A1%AF%E7%A4%BA%E6%8C%89%E6%89%8D%E9%9A%B1%E8%97%8F">右下角按鈕：改為默認顯示，按才隱藏</a></li><li><a href="#%E5%8F%B3%E4%B8%8B%E8%A7%92%E6%96%B0%E5%A2%9E%E5%88%B0%E6%9C%80%E5%BA%95%E9%83%A8%E6%8C%89%E9%88%95">右下角新增【到最底部】按鈕</a></li><li><a href="#%E6%96%87%E7%AB%A0%E7%B6%B2%E5%9D%80%E5%90%8D%E7%A8%B1%E6%96%87%E7%AB%A0%E4%BD%8D%E7%BD%AE%E6%95%B4%E7%90%86">文章網址名稱、文章位置整理</a></li><li><a href="#%E7%94%9F%E6%88%90-sitemap---atomxml">生成 sitemap - atom.xml</a></li><li><a href="#%E8%A3%BD%E4%BD%9C-404-page">製作 404 page</a></li></ul><h2 id="檔案結構介紹"><a href="#檔案結構介紹" class="headerlink" title="檔案結構介紹"></a>檔案結構介紹</h2><h3 id="Hexo-相關檔案"><a href="#Hexo-相關檔案" class="headerlink" title="Hexo 相關檔案"></a>Hexo 相關檔案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── public            // 執行 hexo generate 後，輸出的靜態網頁</span><br><span class="line">├── scaffolds         // 模板。Hexo會根據scaffold來建立新文章/新頁面</span><br><span class="line">├── scripts           // 存放自定義 js 文件</span><br><span class="line">├── source        </span><br><span class="line">|   ├── _drafts       // 草稿文章</span><br><span class="line">|   ├── _posts        // 發佈文章</span><br><span class="line">|   ├── link          // 友情連結</span><br><span class="line">|   ├── categories    // 分類頁面</span><br><span class="line">|   └── tags          // 標籤頁面</span><br><span class="line">├── themes            // Hexo 主題文件，Butterfly 主題的檔案就在裡面</span><br><span class="line">├── _config.yml       // 整個 Blog 的配置</span><br><span class="line">└── package.json      // 已下載的插件及其版本 version no.</span><br></pre></td></tr></table></figure><h3 id="Butterfly-主題的檔案"><a href="#Butterfly-主題的檔案" class="headerlink" title="Butterfly 主題的檔案"></a>Butterfly 主題的檔案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└──themes</span><br><span class="line">   └── Butterfly</span><br><span class="line">       ├── languages    // 主題語言字眼</span><br><span class="line">       ├── layout       // pug 文件，後會渲染成 html</span><br><span class="line">       ├── scripts      // js 文件</span><br><span class="line">       ├── source        </span><br><span class="line">       |   ├── css      // styl 文件，後會渲染成 css</span><br><span class="line">       |   ├── img      // 主題配置用到的圖片</span><br><span class="line">       |   └── js       // js 文件</span><br><span class="line">       └── _config.yml  // Butterfly 主題配置</span><br></pre></td></tr></table></figure><h2 id="主題顏色調整"><a href="#主題顏色調整" class="headerlink" title="主題顏色調整"></a>主題顏色調整</h2><p>如果想進階修改主題顏色的話，可以修改 <code>.\themes\Butterfly\source\css\var.styl</code> 文件。</p><h2 id="樣式-css相關的項目"><a href="#樣式-css相關的項目" class="headerlink" title="樣式 (css相關的項目)"></a>樣式 (css相關的項目)</h2><p>如果想修改特定元素的樣式，例如字體大小、字體顏色、背景顏色、tag 外觀樣式、border style 、button、動畫效果等等，可以修改 layout 檔案 <code>.\themes\Butterfly\source\css\_layout</code>。</p><p>例如想修改黑夜模式的顏色組合，就到這裡修改： <code>.\themes\Butterfly\source\css\_mode\darkmode.styl</code>。</p><h2 id="Tags：移至文章上方"><a href="#Tags：移至文章上方" class="headerlink" title="Tags：移至文章上方"></a>Tags：移至文章上方</h2><p>在 <code>.\themes\Butterfly\layout\post.pug</code> 這個文件中，搜尋下面這段，把它移到至 <code>block content</code> 的下一行插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tag_share</span><br><span class="line">  if (theme.post_meta.tags)</span><br><span class="line">    .post-meta__tag-list</span><br><span class="line">      each item, index in page.tags.data</span><br><span class="line">        a(href=url_for(item.path)).post-meta__tags #[=item.name]</span><br></pre></td></tr></table></figure><h2 id="版權框內的字句"><a href="#版權框內的字句" class="headerlink" title="版權框內的字句"></a>版權框內的字句</h2><p>在 <code>.\themes\Butterfly\languages</code> 這裡面的 yml 檔裡進行修改。</p><h2 id="為文章加密"><a href="#為文章加密" class="headerlink" title="為文章加密"></a>為文章加密</h2><p>在 GitBash 中輸入以下命令來安裝插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在需要加密的文章頭加上 <code>password</code> 和 <code>message</code> (可選):</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title: 測試 - 為文章加密</span><br><span class="line">date: 2024-06-13 14:05:02</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    -</span> Hexo</span><br><span class="line"><span class="bullet">    -</span> 架站</span><br><span class="line">categories: [架站記錄, 技巧]</span><br><span class="line">password: test123</span><br><span class="line"><span class="section">message: 試試加密，這篇的密碼是 test123</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">恭喜成功解密！</span><br><span class="line"></span><br><span class="line">這裡是文章內容。</span><br></pre></td></tr></table></figure><h2 id="右下角按鈕：改為默認顯示，按才隱藏"><a href="#右下角按鈕：改為默認顯示，按才隱藏" class="headerlink" title="右下角按鈕：改為默認顯示，按才隱藏"></a>右下角按鈕：改為默認顯示，按才隱藏</h2><p>右下角的黑夜模式、繁簡轉換、字體大小按鈕原本是默認隱藏的，需按設定按鈕才會顯示。想要改成默認顯示，按設定按鈕收起來，再按再彈出來。</p><p>修改 <code>.\themes\Butterfly\source\css\_layout\rightside.styl</code> 文件：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#rightside</span></span><br><span class="line">  <span class="attribute">position</span>: fixed</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">38px</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">40px</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">5s</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#rightside-config-hide</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.rightside-in</span></span><br><span class="line">    <span class="attribute">animation</span>: rightsideIn .<span class="number">3s</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.rightside-out</span></span><br><span class="line">    <span class="attribute">animation</span>: rightsideOut .<span class="number">3s</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">30px</span>, <span class="number">0</span>) <span class="meta">!important</span></span><br><span class="line"></span><br><span class="line">  &amp; &gt; <span class="selector-tag">div</span></span><br><span class="line">    &amp; &gt; <span class="selector-tag">i</span>,</span><br><span class="line">    &amp; &gt; <span class="selector-tag">a</span>,</span><br><span class="line">    &amp; &gt; <span class="selector-tag">div</span></span><br><span class="line">      <span class="attribute">display</span>: block</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="number">2px</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">30px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">30px</span></span><br><span class="line">      <span class="attribute">background-color</span>: <span class="variable">$light</span>-blue</span><br><span class="line">      <span class="attribute">color</span>: <span class="variable">$white</span></span><br><span class="line">      <span class="attribute">text-align</span>: center</span><br><span class="line">      <span class="attribute">text-decoration</span>: none</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">29px</span></span><br><span class="line">      <span class="attribute">cursor</span>: pointer</span><br><span class="line"></span><br><span class="line">      <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">        <span class="attribute">background-color</span>: <span class="variable">$ruby</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#rightside_config</span></span><br><span class="line">    <span class="selector-tag">i</span></span><br><span class="line">      <span class="attribute">animation</span>: avatar_turn_around <span class="number">2s</span> linear infinite</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#mobile-toc-button</span></span><br><span class="line">    <span class="attribute">display</span>: none</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: $bg)</span><br><span class="line">  #rightside</span><br><span class="line">    #mobile-toc-button</span><br><span class="line">      display: block</span><br><span class="line"></span><br><span class="line">@keyframes rightsideOut</span><br><span class="line">  <span class="number">0%</span></span><br><span class="line">    transform: translate(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">100%</span></span><br><span class="line">    transform: translate(<span class="number">30px</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">@keyframes rightsideIn</span><br><span class="line">  <span class="number">0%</span></span><br><span class="line">    transform: translate(<span class="number">30px</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">100%</span></span><br><span class="line">    transform: translate(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="右下角新增【到最底部】按鈕"><a href="#右下角新增【到最底部】按鈕" class="headerlink" title="右下角新增【到最底部】按鈕"></a>右下角新增【到最底部】按鈕</h2><p>除了文章 (post) 頁面，其他頁面都加上【到最底部】按鈕在最</p><p>右下方。</p><ol><li>在 <code>.\themes\Butterfly\layout\includes\rightside.pug</code> 中，於最底添加這兩行：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if !is_post()</span><br><span class="line">  i.fa.fa-arrow-down#go-down(title=_p(&quot;rightside.back_to_bottom&quot;) aria-hidden=&quot;true&quot;)</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <code>.\themes\Butterfly\source\js\main.js</code> 中，添加以下代碼：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go down smooth scroll</span></span><br><span class="line">$(<span class="string">&#x27;#go-down&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">scrollTo</span>(<span class="string">&#x27;footer&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="文章網址名稱、文章位置整理"><a href="#文章網址名稱、文章位置整理" class="headerlink" title="文章網址名稱、文章位置整理"></a>文章網址名稱、文章位置整理</h2><p>所有發佈的文章自動生成在 <code>.\source\_posts</code> 這個資料夾。但排序雜亂無章，而且部署到 GitHub 後，所有文章都散佈在第一層，很亂。希望文章原檔案按照日期排序，但不影響文章網址名稱（在網址中不顯示日期），並且在 GitHub 自動生成一個名叫 post 的資料夾裝放所有文章原檔案。</p><p>方法是在 <code>./config.yml</code> 裡，把這兩選項更改成以下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:title/</span>  <span class="comment"># 在 GitHub 自動生成一個名叫 post 的資料夾裝放所有文章原檔案</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">post/:year-:month-:day-:title/:title.md</span>  <span class="comment"># 在你的電腦儲存位置，會達成以上 tree structure 那樣</span></span><br></pre></td></tr></table></figure><h2 id="生成-sitemap-atom-xml"><a href="#生成-sitemap-atom-xml" class="headerlink" title="生成 sitemap - atom.xml"></a>生成 sitemap - atom.xml</h2><p>在 bash 中輸入以下命令來安裝插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>在 <code>./config.yml</code> 裡，添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">250</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br><span class="line">  <span class="attr">autodiscovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span></span><br></pre></td></tr></table></figure><h2 id="製作-404-page"><a href="#製作-404-page" class="headerlink" title="製作 404 page"></a>製作 404 page</h2><p>把你想遇到 404 時轉跳的頁面命名為 <code>404.html</code>，放在 <code>.\source</code> 資料夾裡。</p><p>然後在 <code>./config.yml</code> 裡，設定以下內容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">404.</span><span class="string">html</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">README.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">robots.txt</span></span><br></pre></td></tr></table></figure><p>由於還創建了不需渲染的 <code>README.md</code> 和 <code>robots.txt</code>，所以把它們也設定在 skip_render 底下。</p><h2 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h2><p>以上就是進階Butterfly相關設定，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E6%9E%B6%E7%AB%99%E8%A8%98%E9%8C%84/">架站記錄</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Hexo/">Hexo</category>
      
      <category domain="https://gahgah147.github.io/tags/Butterfly/">Butterfly</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/13/Hexo%E9%83%A8%E8%90%BD%E6%A0%BC-Butterfly-%E4%B8%BB%E9%A1%8C%E8%AA%BF%E6%95%B4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>測試 - 為文章加密</title>
      <link>https://gahgah147.github.io/2024/06/13/%E6%B8%AC%E8%A9%A6-%E7%82%BA%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</link>
      <guid>https://gahgah147.github.io/2024/06/13/%E6%B8%AC%E8%A9%A6-%E7%82%BA%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</guid>
      <pubDate>Thu, 13 Jun 2024 06:05:02 GMT</pubDate>
      
      <description>Here&#39;s something encrypted, password is required to continue reading.</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="17614095d6645dc6acef3630e3ec3e0c783f4556e905d923c23556855e737e1e">a81b18b76326989181327cf554748c52d1d24dd4e6f6d50bde7ef5827e02be4b7a99e6222c1e396eaebb9518151ff913bdb0344562ecc3db274cf69192f05328d1ae9ef1f80352e7d43f145ad489c15231ab22bb8f4e58d2cdf0fc6069a90fba</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">試試加密，這篇的密碼是 test123</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E6%9E%B6%E7%AB%99%E8%A8%98%E9%8C%84/">架站記錄</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Hexo/">Hexo</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%83%A8%E8%90%BD%E6%A0%BC/">部落格</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%8A%A0%E5%AF%86/">加密</category>
      
      <category domain="https://gahgah147.github.io/tags/%E6%9E%B6%E7%AB%99/">架站</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/13/%E6%B8%AC%E8%A9%A6-%E7%82%BA%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 學習筆記 Day2 - 操作流程與基礎指令</title>
      <link>https://gahgah147.github.io/2024/06/11/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day2-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%88%87%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/</link>
      <guid>https://gahgah147.github.io/2024/06/11/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day2-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%88%87%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/</guid>
      <pubDate>Tue, 11 Jun 2024 09:43:37 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Docker-學習筆記-Day2-操作流程與基礎指令&quot;&gt;&lt;a href=&quot;#Docker-學習筆記-Day2-操作流程與基礎指令&quot; class=&quot;headerlink&quot; title=&quot;Docker 學習筆記 Day2 - 操作流程與基礎指令&quot;&gt;&lt;/a&gt;Docker</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Docker-學習筆記-Day2-操作流程與基礎指令"><a href="#Docker-學習筆記-Day2-操作流程與基礎指令" class="headerlink" title="Docker 學習筆記 Day2 - 操作流程與基礎指令"></a>Docker 學習筆記 Day2 - 操作流程與基礎指令</h1><h1 id="執行範例"><a href="#執行範例" class="headerlink" title="執行範例"></a>執行範例</h1><h2 id="複製練習專案檔案"><a href="#複製練習專案檔案" class="headerlink" title="複製練習專案檔案"></a>複製練習專案檔案</h2><p>練習專案程式碼:<a href="https://github.com/sixeyed/diamol">https://github.com/sixeyed/diamol</a><br><img src="https://hackmd.io/_uploads/BktHImSrA.png" alt="image"></p><p>使用以下指令進行複製檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sixeyed/diamol.git</span><br></pre></td></tr></table></figure><h2 id="執行-Hello-World-Docker-範例"><a href="#執行-Hello-World-Docker-範例" class="headerlink" title="執行 Hello World Docker 範例"></a>執行 Hello World Docker 範例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run diamol/ch02-hello-diamol</span><br></pre></td></tr></table></figure><p>這邊我遇到這個問題<br><img src="https://hackmd.io/_uploads/B13mwQBBC.png" alt="image"></p><p>這邊代表要啟用WSL2，要在 Docker desktop 的 Setting -&gt; Resources 把<br>Enable integration with additional distros: 這邊的 Ubuntu 選項打開，<br>然後按 Apply &amp; restart<br><img src="https://hackmd.io/_uploads/r11KvXSBC.png" alt="image"></p><p>調整過後執行成功的畫面<br><img src="https://hackmd.io/_uploads/H1swMVrHR.png" alt="image"></p><h1 id="容器是什麼"><a href="#容器是什麼" class="headerlink" title="容器是什麼?"></a>容器是什麼?</h1><p>容器（Container）是一種虛擬化技術，用於將應用程式及其依賴環境打包在一起，以確保應用程式可以在任何計算環境中一致地運行。容器利用操作系統的虛擬化功能，提供輕量級、便攜且獨立的運行環境。</p><h2 id="容器的優點"><a href="#容器的優點" class="headerlink" title="容器的優點"></a>容器的優點</h2><ol><li><strong>輕量化</strong>：容器與傳統虛擬機相比，更加輕量，不需要啟動一個完整的操作系統，因此啟動速度快，占用資源少。</li><li><strong>可移植性</strong>：容器打包了應用程式及其所有依賴，確保應用程式在開發、測試和生產環境中運行一致。</li><li><strong>隔離性</strong>：容器之間相互隔離，確保一個容器內的問題不會影響其他容器，提升應用程式的安全性和穩定性。</li><li><strong>高效性</strong>：容器利用操作系統的共享資源功能，比虛擬機更加高效，適合高密度部署。</li></ol><h1 id="透過-Docker-互動模式執行容器"><a href="#透過-Docker-互動模式執行容器" class="headerlink" title="透過 Docker 互動模式執行容器"></a>透過 Docker 互動模式執行容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --interactive --tty diamol/base</span><br></pre></td></tr></table></figure><ul><li><code>docker container run</code>: 告訴 Docker 執行一個容器。</li><li><code>--interactive</code> 或 <code>-i</code>: 表示在容器中啟動互動模式，使得可以與容器中的應用進行互動。</li><li><code>--tty</code> 或 <code>-t</code>: 分配一個 pseudo-TTY（虛擬終端），這樣就可以在容器內進行命令行操作。</li><li><code>diamol/base</code>: 是要運行的 Docker 映像的名稱。在這個例子中，指定了一個名為 <code>diamol/base</code> 的映像。</li></ul><p><img src="https://hackmd.io/_uploads/ryOskqrSC.png" alt="image"></p><blockquote><p>執行後對連接到容器中的終端對話視窗</p></blockquote><h1 id="在容器中託管-host-一個網站"><a href="#在容器中託管-host-一個網站" class="headerlink" title="在容器中託管 (host) 一個網站"></a>在容器中託管 (host) 一個網站</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web</span><br></pre></td></tr></table></figure><ul><li><code>--detach</code> 或 <code>-d</code>: 表示在背景運行容器，即使容器啟動後，終端仍然可用。</li><li><code>--publish 8088:80</code> 或 <code>-p 8088:80</code>: 將容器的端口 80 映射到主機的端口 8088。這樣，當您訪問主機的 8088 端口時，流量將被轉發到容器的 80 端口。</li><li><code>diamol/ch02-hello-diamol-web</code>: 是要運行的 Docker 映像的名稱。在這個例子中，指定了一個名為 <code>diamol/ch02-hello-diamol-web</code> 的映像。</li></ul><p>若不確定是否有這個映像檔可以到  <a href="https://hub.docker.com/">https://hub.docker.com/</a> 查詢</p><p><img src="https://hackmd.io/_uploads/r18d_9HBA.png" alt="image"></p><blockquote><p>這邊可以發現 diamol&#x2F;ch02-hello-diamol-web 跟書本範例上的名稱不太一樣</p></blockquote><p><img src="https://hackmd.io/_uploads/rkaXF9HBA.png" alt="image"><br>成功執行結果</p><p><img src="https://hackmd.io/_uploads/ryMst5rr0.png" alt="image"></p><p>點選畫面中的 8088:80 可以看到網頁結果</p><p><img src="https://hackmd.io/_uploads/rkVkc5rrR.png" alt="image"></p><blockquote><p><a href="http://localhost:8088/">http://localhost:8088/</a></p></blockquote><h1 id="Docker-基本指令"><a href="#Docker-基本指令" class="headerlink" title="Docker 基本指令"></a>Docker 基本指令</h1><p><strong><code>docker run</code></strong>: 執行一個容器。<br><strong><code>docker build</code></strong>: 使用 Dockerfile 構建一個新的映像。<br><strong><code>docker pull</code></strong>: 從 Docker 鏡像倉庫下載一個映像。<br><strong><code>docker push</code></strong>: 將一個映像推送到 Docker 鏡像倉庫。<br><strong><code>docker start</code></strong>: 啟動一個停止的容器。<br><strong><code>docker stop</code></strong>: 停止正在運行的容器。<br><strong><code>docker restart</code></strong>: 重啟一個容器。<br><strong><code>docker rm</code></strong>: 刪除一個或多個容器。<br><strong><code>docker rmi</code></strong>: 刪除一個或多個映像。<br><strong><code>docker ps</code></strong>: 列出正在運行的容器。<br><strong><code>docker ps -a</code></strong>: 列出所有的容器，包括停止的容器。<br><strong><code>docker images</code></strong>: 列出本地的所有映像。<br><strong><code>docker exec</code></strong>: 在正在運行的容器中執行命令。<br><strong><code>docker logs</code></strong>: 查看容器的日誌。<br><strong><code>docker inspect</code></strong>: 查看容器或映像的詳細信息。<br><strong><code>docker-compose</code></strong>: 使用 Docker Compose 管理多容器應用程序。</p><p>這些是 Docker 中的一些基本指令，用於管理容器、映像和其他相關資源。</p><h2 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h2><p>以上就是第二天的練習內容，今天實際執行了Hello World的範例跟host一個網站、另外還有一些Docker 基本指令，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/">Docker 學習筆記</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/11/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day2-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%88%87%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>區塊鏈學習 - Day 1 區塊鏈錢包介紹與 Metamask小狐狸安裝方式</title>
      <link>https://gahgah147.github.io/2024/06/07/%E5%8D%80%E5%A1%8A%E9%8F%88%E5%AD%B8%E7%BF%92-Day-1-%E5%8D%80%E5%A1%8A%E9%8F%88%E9%8C%A2%E5%8C%85%E4%BB%8B%E7%B4%B9%E8%88%87-Metamask%E5%B0%8F%E7%8B%90%E7%8B%B8%E5%AE%89%E8%A3%9D%E6%96%B9%E5%BC%8F/</link>
      <guid>https://gahgah147.github.io/2024/06/07/%E5%8D%80%E5%A1%8A%E9%8F%88%E5%AD%B8%E7%BF%92-Day-1-%E5%8D%80%E5%A1%8A%E9%8F%88%E9%8C%A2%E5%8C%85%E4%BB%8B%E7%B4%B9%E8%88%87-Metamask%E5%B0%8F%E7%8B%90%E7%8B%B8%E5%AE%89%E8%A3%9D%E6%96%B9%E5%BC%8F/</guid>
      <pubDate>Fri, 07 Jun 2024 07:49:08 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;區塊鏈學習-Day-1-區塊鏈錢包介紹與-Metamask小狐狸安裝方式&quot;&gt;&lt;a href=&quot;#區塊鏈學習-Day-1-區塊鏈錢包介紹與-Metamask小狐狸安裝方式&quot; class=&quot;headerlink&quot; title=&quot;區塊鏈學習 - Day 1 區塊鏈錢包介</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="區塊鏈學習-Day-1-區塊鏈錢包介紹與-Metamask小狐狸安裝方式"><a href="#區塊鏈學習-Day-1-區塊鏈錢包介紹與-Metamask小狐狸安裝方式" class="headerlink" title="區塊鏈學習 - Day 1 區塊鏈錢包介紹與 Metamask小狐狸安裝方式"></a>區塊鏈學習 - Day 1 區塊鏈錢包介紹與 Metamask小狐狸安裝方式</h1><p><img src="https://hackmd.io/_uploads/SkSeMeeSR.png" alt="image"></p><blockquote><p><a href="https://ethereum.org/zh-tw/">https://ethereum.org/zh-tw/</a></p></blockquote><p>今天想要來學習Web3 區塊鏈相關技術，另外在查詢的時候看到了etherum 這麼完整的教學文件，所以想來整理記錄一下這個學習的過程。</p><h1 id="什麼是區塊鏈錢包"><a href="#什麼是區塊鏈錢包" class="headerlink" title="什麼是區塊鏈錢包?"></a>什麼是區塊鏈錢包?</h1><p>區塊鏈錢包（Blockchain Wallet）是一種數位錢包，用於存儲、管理和交易加密貨幣，如比特幣、以太幣等。區塊鏈錢包的核心功能是讓用戶能夠安全地儲存和使用其加密貨幣。</p><h2 id="區塊鏈錢包的基本特點"><a href="#區塊鏈錢包的基本特點" class="headerlink" title="區塊鏈錢包的基本特點"></a>區塊鏈錢包的基本特點</h2><h3 id="1-公鑰與私鑰"><a href="#1-公鑰與私鑰" class="headerlink" title="1. 公鑰與私鑰"></a>1. 公鑰與私鑰</h3><p>區塊鏈錢包使用公鑰（Public Key）和私鑰（Private Key）來管理資產：</p><ul><li><strong>公鑰</strong>：相當於你的銀行賬號，用來接收加密貨幣，可以公開分享。</li><li><strong>私鑰</strong>：相當於你的密碼，用來簽署交易和訪問你的資產，必須保密。</li></ul><h3 id="2-熱錢包與冷錢包"><a href="#2-熱錢包與冷錢包" class="headerlink" title="2. 熱錢包與冷錢包"></a>2. 熱錢包與冷錢包</h3><p>區塊鏈錢包分為熱錢包和冷錢包：</p><ul><li><strong>熱錢包（Hot Wallet）</strong>：連接互聯網，方便隨時交易，但相對較不安全，易受黑客攻擊。</li><li><strong>冷錢包（Cold Wallet）</strong>：不連接互聯網，通常以硬體錢包形式存在，如Trezor或Ledger，更安全但較不便捷。</li></ul><h3 id="3-去中心化"><a href="#3-去中心化" class="headerlink" title="3. 去中心化"></a>3. 去中心化</h3><p>區塊鏈錢包通常是去中心化的，不依賴於單一機構。這意味著用戶擁有對自己資產的完全控制權，無需經由第三方機構進行交易。</p><h3 id="4-多幣種支持"><a href="#4-多幣種支持" class="headerlink" title="4. 多幣種支持"></a>4. 多幣種支持</h3><p>許多現代區塊鏈錢包支持多種加密貨幣，方便用戶管理不同的數位資產。</p><h3 id="5-智慧型合約型錢包"><a href="#5-智慧型合約型錢包" class="headerlink" title="5. 智慧型合約型錢包"></a>5. 智慧型合約型錢包</h3><p>需要多重簽名來授權交易的錢包，若是多人使用的錢包可以用來加強錢包的安全性。</p><h2 id="使用區塊鏈錢包的好處"><a href="#使用區塊鏈錢包的好處" class="headerlink" title="使用區塊鏈錢包的好處"></a>使用區塊鏈錢包的好處</h2><h3 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1. 安全性"></a>1. 安全性</h3><p>區塊鏈技術本身具有高度的安全性，加上錢包的加密保護，使得資產不易被盜。</p><h3 id="2-自主性"><a href="#2-自主性" class="headerlink" title="2. 自主性"></a>2. 自主性</h3><p>用戶完全掌控自己的資產和交易，不需要依賴銀行或支付平台。</p><h3 id="3-全球性"><a href="#3-全球性" class="headerlink" title="3. 全球性"></a>3. 全球性</h3><p>加密貨幣交易不受地理位置限制，可以在全球範圍內快速進行。</p><h2 id="區塊鏈錢包的使用案例"><a href="#區塊鏈錢包的使用案例" class="headerlink" title="區塊鏈錢包的使用案例"></a>區塊鏈錢包的使用案例</h2><h3 id="1-投資與交易"><a href="#1-投資與交易" class="headerlink" title="1. 投資與交易"></a>1. 投資與交易</h3><p>投資者使用區塊鏈錢包進行加密貨幣買賣，或長期持有以期望價值增長。</p><h3 id="2-支付與轉賬"><a href="#2-支付與轉賬" class="headerlink" title="2. 支付與轉賬"></a>2. 支付與轉賬</h3><p>使用加密貨幣進行線上購物或轉賬，特別是在國際支付中，可以避開高額手續費和匯率波動。</p><h3 id="3-DApps互動"><a href="#3-DApps互動" class="headerlink" title="3. DApps互動"></a>3. DApps互動</h3><p>區塊鏈錢包可以用來與去中心化應用（DApps）互動，如去中心化交易所（DEX）、借貸平台等。</p><h1 id="如何選擇合適的區塊鏈錢包"><a href="#如何選擇合適的區塊鏈錢包" class="headerlink" title="如何選擇合適的區塊鏈錢包?"></a>如何選擇合適的區塊鏈錢包?</h1><p>其實現在的區塊鏈錢包越來越多了，如果想要選擇合適的區塊鏈錢包可以參考ethereum 官方的區塊鏈錢包選擇參考頁面。</p><p><img src="https://hackmd.io/_uploads/ByOJDJgBC.png" alt="image"></p><blockquote><p><a href="https://ethereum.org/zh-tw/wallets/find-wallet/">https://ethereum.org/zh-tw/wallets/find-wallet/</a></p></blockquote><h2 id="依照使用角色來選擇"><a href="#依照使用角色來選擇" class="headerlink" title="依照使用角色來選擇"></a>依照使用角色來選擇</h2><p><img src="https://hackmd.io/_uploads/H1Rd5ylrC.png" alt="image"></p><p>1.加密貨幣新手:初次使用者尋找適合新手的錢包。<br>2.非同質化代幣:專注於支援非同質化代幣的錢包。<br>3.長期:使用硬體錢包被動持有代幣。<br>4.金融:專為頻繁使用去中心化金融應用程式的使用者打造的錢包。<br>5.開發者:幫助開發並測試去中心化應用程式的錢包。</p><h2 id="依照裝置支援性來選擇"><a href="#依照裝置支援性來選擇" class="headerlink" title="依照裝置支援性來選擇"></a>依照裝置支援性來選擇</h2><p><img src="https://hackmd.io/_uploads/SJhPo1gS0.png" alt="image"></p><p>1.行動裝置<br>2.桌上型電腦<br>3.瀏覽器<br>4.硬體</p><h2 id="依照語言支援來選擇"><a href="#依照語言支援來選擇" class="headerlink" title="依照語言支援來選擇"></a>依照語言支援來選擇</h2><p><img src="https://hackmd.io/_uploads/S1Zl2ylS0.png" alt="image"></p><h2 id="依照是否可以兌換加密貨幣-法定貨幣來選擇"><a href="#依照是否可以兌換加密貨幣-法定貨幣來選擇" class="headerlink" title="依照是否可以兌換加密貨幣&#x2F;法定貨幣來選擇"></a>依照是否可以兌換加密貨幣&#x2F;法定貨幣來選擇</h2><p><img src="https://hackmd.io/_uploads/BJ4NTkxHA.png" alt="image"></p><p>1.購買加密貨幣:在錢包中直接使用法定貨幣購買加密貨幣<br>2.出售換取法定貨幣:直接在錢包中出售加密貨幣換取法定貨幣 </p><h2 id="依照功能來選擇"><a href="#依照功能來選擇" class="headerlink" title="依照功能來選擇"></a>依照功能來選擇</h2><p><img src="https://hackmd.io/_uploads/rJ-cpkxSA.png" alt="image"></p><p>1.連結至去中心化應用程式:你可以連接至支援 WalletConnet 或替代協議的應用程式<br>2.支援非同質化代幣:支援檢視非同質化代幣並與之互動的錢包<br>3.質押:從錢包中直接質押以太幣<br>4.二層網路:支援以太坊二層網路的錢包<br>5.交換:在錢包中直接交換 ERC-20 代幣<br>6.支援硬體錢包:可連結至硬體錢包以增強安全性的錢包<br>7.支援以太坊名稱服務:支援以太坊名稱服務 (ENS) 的錢包</p><p>這邊開始出現很多新的名詞了像是質押、二層網路看到這些詞一開始看不懂先不用緊張，先從基礎的學習起來，後面會慢慢了解</p><h2 id="依照安全性來選擇"><a href="#依照安全性來選擇" class="headerlink" title="依照安全性來選擇"></a>依照安全性來選擇</h2><p><img src="https://hackmd.io/_uploads/H1hWlggH0.png" alt="image"></p><p>1.開放原始碼:讓任何人都可以稽核應用程式的完整性和安全性的開源軟體<br>2.個人擁有權:不控制使用者私密金鑰的錢包</p><h2 id="依照是否是智能合約錢包來選擇"><a href="#依照是否是智能合約錢包來選擇" class="headerlink" title="依照是否是智能合約錢包來選擇"></a>依照是否是智能合約錢包來選擇</h2><p><img src="https://hackmd.io/_uploads/SJILgglSA.png" alt="image"><br>1.多簽:需要多重簽名來授權交易的錢包<br>2.社交恢復:允許監護人變更智慧型合約錢包簽署金鑰的錢包</p><h2 id="進階更多條件來選擇"><a href="#進階更多條件來選擇" class="headerlink" title="進階更多條件來選擇"></a>進階更多條件來選擇</h2><p><img src="https://hackmd.io/_uploads/SJmmZgerR.png" alt="image"></p><p>1.遠端程序呼叫協定匯入:支援自訂遠端程序呼叫協定端點，以連結至不同節點或網路的錢包<br>2.代幣匯入:匯入任何 ERC-20 代幣以便於錢包內使用<br>3.燃料費自訂:自訂你的燃料用量（基本費用、優先費與最高費用）</p><h1 id="MetaMask"><a href="#MetaMask" class="headerlink" title="MetaMask"></a>MetaMask</h1><p><img src="https://hackmd.io/_uploads/SkpIQeeSR.png" alt="image"></p><p>這邊建議使用一開始學習的錢包MetaMask也叫做小狐狸錢包，是目前最多人使用的區塊鏈錢包，j最適合新手入門使用。</p><p>點選造訪網頁，會到MetaMask 官網<br><img src="https://hackmd.io/_uploads/BJ80VxxHC.png" alt="image"></p><blockquote><p><a href="https://metamask.io/">https://metamask.io/</a></p></blockquote><p>點選<img src="https://hackmd.io/_uploads/rJMgBlxHR.png" alt="image"> 進入Chrome插件畫面</p><p>再來點選加到Chrome 開始安裝<br><img src="https://hackmd.io/_uploads/BkkHregB0.png" alt="image"></p><p>點選新增擴充功能<br><img src="https://hackmd.io/_uploads/H12vSxeSA.png" alt="image"></p><p>如果還沒有用過 Metamask 可以直接點選 Create a new Wallet ，若是有用過則可以點選Import an existing wallet 來匯入MetaMask錢包<br><img src="https://hackmd.io/_uploads/Hy9crgxr0.png" alt="image"></p><p>接下來會顯示 MetaMask 詢問訊息，確認沒有問題可以點選I agree<br><img src="https://hackmd.io/_uploads/SJLwLeeS0.png" alt="image"></p><blockquote><p><strong>幫助我們改進 MetaMask</strong></p><p>MetaMask 希望收集使用數據，以更好地了解用戶如何使用 MetaMask。這些數據將用於改&gt;進服務，包括基於您的使用情況進行改進。</p><p>MetaMask 將會…</p><ul><li>永遠允許您通過設置選擇退出</li><li>發送匿名化的點擊和頁面瀏覽事件</li><li><strong>絕不</strong>收集我們不需要提供服務的信息（如密鑰、地址、交易哈希或餘額）</li><li><strong>絕不</strong>收集您的完整 IP 地址</li><li><strong>絕不</strong>出售數據</li></ul><p>這些數據是匯總的，因此根據《一般數據保護條例（EU）2016&#x2F;679》對於數據是匿名的。</p><p><em>當您使用 Infura 作為 MetaMask 中的默認 RPC 提供商時，Infura 將會在您發送交易時收集您的 IP 地址和以太坊錢包地址。我們不會以使我們的系統能夠將這兩個數據關聯的方式存儲這些信息。更多關於 MetaMask 和 Infura 如何從數據收集的角度進行互動的信息，請參閱我們的更新。更多關於我們隱私實踐的一般信息，請參閱我們的<a href="https://metamask.io/privacy.html">隱私政策</a>。</em></p><hr></blockquote><blockquote><p>這個窗口有兩個按鈕：</p><ul><li>“I agree”（我同意）：表示您同意 MetaMask 收集和使用這些數據。</li><li>“No thanks”（不，謝謝）：表示您不願意參與數據收集。</li></ul></blockquote><p>再來會顯示設定密碼畫面，輸入密碼後點選Create a new wallet<br><img src="https://hackmd.io/_uploads/HJ7Fr4lHC.png" alt="image"></p><p>接下來會介紹「助記詞」，並且詢問是否要備份註記詞<br><img src="https://hackmd.io/_uploads/SyOxUEgB0.png" alt="image"></p><p>在來會顯示「助記詞」，要記得這個助記詞很重要，因為這些助記詞就代表你的MetaMask錢包，要妥善記錄下來保存在安全的地方。<br><img src="https://hackmd.io/_uploads/HJQYUVeSC.png" alt="image"></p><p>再來正確輸入存起來的助記詞後點選下一步就完成創建錢包了<br><img src="https://hackmd.io/_uploads/HJKQO4lH0.png" alt="image"></p><p>成功登入畫面<br><img src="https://hackmd.io/_uploads/HyS5dEgr0.png" alt="image"></p><blockquote><p>以下是該介面的主要內容和功能說明：<br><strong>帳戶信息</strong>：</p><ul><li>帳戶名稱：<code>Account 1</code></li><li>錢包地址：<code>0x8753...1b2D4</code>（已部分隱藏）</li></ul><p><strong>以太幣餘額</strong>：</p><ul><li>餘額：<code>0 ETH</code></li><li>美元價值：<code>$0.00 USD</code></li></ul><p><strong>操作選項</strong>：</p><ul><li><strong>Buy &amp; Sell</strong>（購買和出售）：購買和出售加密貨幣。</li><li><strong>Swap</strong>（交換）：在錢包中交換 ERC-20 代幣。</li><li><strong>Bridge</strong>（跨鏈橋）：將資產從一條鏈轉移到另一條鏈。</li><li><strong>Portfolio</strong>（投資組合）：查看和管理你的加密資產組合。</li></ul><p><strong>資金提示</strong>：</p><ul><li><strong>Fund your wallet</strong>：提示用戶為錢包添加資金，並提供購買以太幣（ETH）的選項。</li><li>按鈕：<code>Buy ETH</code>（購買 ETH）</li></ul><p><strong>代幣選項</strong>：</p><ul><li><strong>ETH</strong>（以太幣）：<ul><li><strong>Stake</strong>（質押）：選項來質押以太幣。</li></ul></li><li><strong>Receive tokens</strong>（接收代幣）：提供地址來接收其他人發送的代幣。</li><li><strong>Import Tokens</strong>（導入代幣）：添加和顯示其他代幣。</li><li><strong>Refresh list</strong>（刷新列表）：刷新代幣列表以顯示最新的餘額和代幣。</li></ul><p><strong>支持和幫助</strong>：</p><ul><li><strong>MetaMask 支援</strong>：連接到 MetaMask 支援服務，以獲得幫助和解答問題。</li></ul><p><strong>切換網域功能</strong>：右上角顯示網域預設是以太坊（Ethereum），點進去可以看到不同的區塊鏈 </p><p><img src="https://hackmd.io/_uploads/r1yRtEgS0.png" alt="image"></p></blockquote><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這篇文章介紹了區塊鏈錢包的基本功能和分類，並詳細說明了如何安裝和使用最受歡迎的 MetaMask 小狐狸錢包。隨著區塊鏈技術的發展，錢包的種類和功能也越來越多，官方文件也變得越來越詳細和友好。</p><p>希望這篇文章能夠幫助大家對區塊鏈錢包有一個初步的了解和掌握。如果有任何問題或需要進一步的幫助，歡迎在留言區提出。未來，我們將繼續探索更多區塊鏈技術的應用和實踐，讓我們一起在這條學習之路上不斷進步吧！</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/">區塊鏈</category>
      
      <category domain="https://gahgah147.github.io/tags/ETH/">ETH</category>
      
      <category domain="https://gahgah147.github.io/tags/Metamask/">Metamask</category>
      
      <category domain="https://gahgah147.github.io/tags/ethereum/">ethereum</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/07/%E5%8D%80%E5%A1%8A%E9%8F%88%E5%AD%B8%E7%BF%92-Day-1-%E5%8D%80%E5%A1%8A%E9%8F%88%E9%8C%A2%E5%8C%85%E4%BB%8B%E7%B4%B9%E8%88%87-Metamask%E5%B0%8F%E7%8B%90%E7%8B%B8%E5%AE%89%E8%A3%9D%E6%96%B9%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 學習筆記 Day1 - Docker 介紹與安裝步驟</title>
      <link>https://gahgah147.github.io/2024/06/07/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day1-Docker-%E4%BB%8B%E7%B4%B9%E8%88%87%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/</link>
      <guid>https://gahgah147.github.io/2024/06/07/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day1-Docker-%E4%BB%8B%E7%B4%B9%E8%88%87%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/</guid>
      <pubDate>Fri, 07 Jun 2024 01:34:24 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Docker-學習筆記-Day1-Docker-介紹與安裝步驟&quot;&gt;&lt;a href=&quot;#Docker-學習筆記-Day1-Docker-介紹與安裝步驟&quot; class=&quot;headerlink&quot; title=&quot;Docker 學習筆記 Day1 - Docker 介紹與安</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Docker-學習筆記-Day1-Docker-介紹與安裝步驟"><a href="#Docker-學習筆記-Day1-Docker-介紹與安裝步驟" class="headerlink" title="Docker 學習筆記 Day1 - Docker 介紹與安裝步驟"></a>Docker 學習筆記 Day1 - Docker 介紹與安裝步驟</h1><p>Docker官網<br><img src="https://hackmd.io/_uploads/Sk6e3xJrR.png" alt="image"></p><blockquote><p><a href="https://www.docker.com/">https://www.docker.com/</a></p></blockquote><p>docker官方教學文件<br><img src="https://hackmd.io/_uploads/SJwtCgkSA.png" alt="image"><br><a href="https://docs.docker.com/">https://docs.docker.com/</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我是在看這本書 跟著 Docker 隊長，修練 22 天就精通(<a href="https://www.books.com.tw/products/0010903691">這邊是購書連結</a>)</p><p>來學習Docker 的，另外還有以下資源可以參考</p><p>1.書本中提供的練習專案程式碼:<a href="https://github.com/sixeyed/diamol">https://github.com/sixeyed/diamol</a><br>2.書籍作者提供的Youtube 系列影片: <a href="https://www.youtube.com/playlist?list=PLXl_isu8qxvmDOAnUkG5x16LzBzGzY_Ww">https://www.youtube.com/playlist?list=PLXl_isu8qxvmDOAnUkG5x16LzBzGzY_Ww</a><br>我覺得書的內容很紮實，但是有時候沒有紀錄很快就會忘記了，所以我就練習寫下操作紀錄跟重點，更多詳細的細節可以直接去查看這本書的內容。</p><h2 id="什麼是-Docker？"><a href="#什麼是-Docker？" class="headerlink" title="什麼是 Docker？"></a>什麼是 Docker？</h2><p>Docker 是一個開源的應用程式打包和部署工具，它允許您在容器中打包應用程式及其所有相依性，並確保其將在任何環境中都能運行。這使得應用程式的部署變得更加容易且可靠。</p><p>簡單來說有了Docker很多專案部屬的步驟就能夠簡化，且在windows、Linux等系統都能夠快速運行。所以現在很多的github 專案都有dockerfile 且部署流程都會很簡單</p><h2 id="Docker-的優點"><a href="#Docker-的優點" class="headerlink" title="Docker 的優點"></a>Docker 的優點</h2><ul><li><strong>輕量級</strong>：容器共享主機的核心，並運行於一個單獨的進程中，因此比虛擬機更輕量級。</li><li><strong>快速啟動</strong>：容器可以快速啟動，因為它們不需要像虛擬機一樣啟動整個作業系統。</li><li><strong>跨平台</strong>：Docker 容器可以在任何支援 Docker 的平台上運行，而不用擔心環境的不同。</li></ul><h1 id="Docker-的使用情境"><a href="#Docker-的使用情境" class="headerlink" title="Docker 的使用情境"></a>Docker 的使用情境</h1><p><strong>應用程式開發與測試</strong>：開發人員可以使用 Docker 將應用程式及其相依性打包成容器，在開發環境中運行，確保開發環境與生產環境一致性。同時，測試人員也可以使用相同的容器運行測試，確保程式碼的正常運作。</p><p><strong>微服務架構</strong>：Docker 可以幫助組織實現微服務架構，將應用程式拆分為多個獨立的服務，每個服務運行在自己的容器中。這樣可以提高應用程式的彈性和可擴展性。</p><p><strong>持續集成和持續部署</strong>：Docker 可以與持續集成和持續部署（CI&#x2F;CD）工具集成，幫助自動化構建、測試和部署流程，加快軟體交付速度。</p><p><strong>多雲端部署</strong>：Docker 可以在不同的雲端平台上運行，並提供一致的運行環境，從而實現跨雲端的應用程式部署和移植。</p><p><strong>快速擴展</strong>：使用 Docker 可以快速擴展應用程式，只需在需要時啟動新的容器即可，無需等待長時間的部署和配置。</p><h2 id="在-Windows-上安裝-Docker"><a href="#在-Windows-上安裝-Docker" class="headerlink" title="在 Windows 上安裝 Docker"></a>在 Windows 上安裝 Docker</h2><p>因為我目前使用的是Windows，所以我這邊示範Windows安裝的流程，另外我嘗試安裝的經驗來看建議最少都要有 Win11 使用docker起來才不會有問題，因為docker 要求要使用到WSL2。 一般來說電腦太老舊不能升級到win11 的跑docker都會容易出錯。</p><h3 id="安裝Docker-Desktop。"><a href="#安裝Docker-Desktop。" class="headerlink" title="安裝Docker Desktop。"></a>安裝Docker Desktop。</h3><p><img src="https://hackmd.io/_uploads/HydWxZySC.png" alt="image"></p><blockquote><p><a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a></p></blockquote><p>點選Docker Desktop for Windows 開始安裝<br><img src="https://hackmd.io/_uploads/BJbEg-JBR.png" alt="image"></p><p>安裝完成後，啟動 Docker Desktop Installer<br><img src="https://hackmd.io/_uploads/r1QLWWkrC.png" alt="image"></p><p>點選OK<br><img src="https://hackmd.io/_uploads/H1SRZZ1rC.png" alt="image"></p><p>開始安裝<br><img src="https://hackmd.io/_uploads/BJTZGbJrR.png" alt="image"></p><p>安裝成功<br><img src="https://hackmd.io/_uploads/Hyo97-1HC.png" alt="image"></p><p>接下來會重新開機，開機完成後會看到以下畫面<br><img src="https://hackmd.io/_uploads/Bkq8_AkHA.png" alt="image"></p><blockquote><p>這是 Docker 的訂閱服務協議。當你選擇接受時，你同意了以下幾個條款：</p><ol><li><strong>Subscription Service Agreement</strong> (訂閱服務協議): 這是你與 Docker 之間的主要協議，規範了你如何使用 Docker 的訂閱服務。</li><li><strong>Docker Data Processing Agreement</strong> (數據處理協議): 這個協議涉及 Docker 如何處理和保護你的數據。</li><li><strong>Data Privacy Policy</strong> (數據隱私政策): 這個政策描述了 Docker 如何收集、使用、分享和保護你的個人數據。</li></ol><p>另外，這段文字還提到了一些關於 Docker Desktop 使用條件的資訊：</p><ul><li>Docker Desktop 對於小型企業（少於 250 名員工且年收入少於 1000 萬美元）、個人使用、教育和非商業的開源項目是免費的。</li><li>對於專業用途，需要付費訂閱。</li><li>政府機構也需要付費訂閱。</li></ul><p>你可以閱讀 FAQ 以了解更多詳細資訊。</p></blockquote><p>確認沒有問題後按 “Accept” 同意訂閱服務協議</p><p>接下來是 Docker Desktop 的歡迎畫面，提示你登錄以連接你的 Docker Desktop 訂閱或訪問在線功能。<br><img src="https://hackmd.io/_uploads/HJvitAkSC.png" alt="image"></p><p>這裡有三個選項：</p><ol><li><strong>Sign up</strong> (註冊): 如果你還沒有帳戶，可以點擊這裡註冊一個新的 Docker 帳戶。</li><li><strong>Sign in</strong> (登入): 如果你已經有帳戶，可以點擊這裡登入。</li><li><strong>Continue without signing in</strong> (繼續無需登入): 如果你不想登入，可以選擇這個選項繼續使用 Docker Desktop。</li></ol><p>這個畫面主要是讓你選擇是否要使用 Docker 的訂閱服務和在線功能。</p><p>接下來填完相關問卷後會進入Docker desktop 的畫面<br><img src="https://hackmd.io/_uploads/rycR5AJHA.png" alt="image"></p><p>這樣就成功安裝並啟動了 Docker Desktop</p><h2 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h2><p>以上就是第一天學習Docker的內容，今天介紹了Docker還有使用情境跟安裝步驟，如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/">Docker 學習筆記</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      <category domain="https://gahgah147.github.io/tags/Docker-Desktop/">Docker Desktop</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/07/Docker-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-Day1-Docker-%E4%BB%8B%E7%B4%B9%E8%88%87%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>隱私權條款</title>
      <link>https://gahgah147.github.io/2024/06/06/%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE/</link>
      <guid>https://gahgah147.github.io/2024/06/06/%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE/</guid>
      <pubDate>Thu, 06 Jun 2024 08:53:54 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;隱私權條款&quot;&gt;&lt;a href=&quot;#隱私權條款&quot; class=&quot;headerlink&quot; title=&quot;隱私權條款&quot;&gt;&lt;/a&gt;隱私權條款&lt;/h1&gt;&lt;p&gt;歡迎使用「拿樂橙部落格」(以下簡稱本站)。本站尊重並保護所有使用者的隱私權。請在使用本站前仔細閱讀本隱私權條款。&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="隱私權條款"><a href="#隱私權條款" class="headerlink" title="隱私權條款"></a>隱私權條款</h1><p>歡迎使用「拿樂橙部落格」(以下簡稱本站)。本站尊重並保護所有使用者的隱私權。請在使用本站前仔細閱讀本隱私權條款。</p><h3 id="收集的個人資訊"><a href="#收集的個人資訊" class="headerlink" title="收集的個人資訊"></a>收集的個人資訊</h3><ol><li><p><strong>訪問資訊</strong>：當您訪問本站時，我們可能會收集您的IP位址、瀏覽器類型、訪問時間和所瀏覽的頁面等資訊，用於統計分析和網站優化。</p></li><li><p><strong>其他資訊</strong>：在您使用本站的過程中，您還可能會提供其他個人資訊，例如留言、填寫問卷調查等。</p></li></ol><h3 id="資訊的使用和分享"><a href="#資訊的使用和分享" class="headerlink" title="資訊的使用和分享"></a>資訊的使用和分享</h3><ol><li><p><strong>個人資訊使用</strong>：我們僅會在提供服務或維護本站運營所必需的範圍內使用您的個人資訊。</p></li><li><p><strong>資訊分享</strong>：除非經您同意或符合法律規定，否則我們不會向第三方分享您的個人資訊。</p></li></ol><h3 id="資訊安全"><a href="#資訊安全" class="headerlink" title="資訊安全"></a>資訊安全</h3><ol><li><p><strong>安全措施</strong>：我們會採取合理的安全措施來保護您的個人資訊，防止未經授權的訪問、使用或泄露。</p></li><li><p><strong>資料備份</strong>：我們會定期備份資料，以保護您的資訊安全。</p></li></ol><h3 id="隱私權政策的修改"><a href="#隱私權政策的修改" class="headerlink" title="隱私權政策的修改"></a>隱私權政策的修改</h3><ol><li><strong>政策修改</strong>：我們保留隨時修改本隱私權政策的權利。修改後的政策將在本站上公佈，並生效。請定期查閱本隱私權政策以獲取最新信息。</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%83%A8%E8%90%BD%E6%A0%BC/">部落格</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE/">隱私權條款</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/06/%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>免責聲明與使用條款</title>
      <link>https://gahgah147.github.io/2024/06/06/%E5%85%8D%E8%B2%AC%E8%81%B2%E6%98%8E%E8%88%87%E4%BD%BF%E7%94%A8%E6%A2%9D%E6%AC%BE/</link>
      <guid>https://gahgah147.github.io/2024/06/06/%E5%85%8D%E8%B2%AC%E8%81%B2%E6%98%8E%E8%88%87%E4%BD%BF%E7%94%A8%E6%A2%9D%E6%AC%BE/</guid>
      <pubDate>Thu, 06 Jun 2024 08:23:08 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;免責聲明與使用條款&quot;&gt;&lt;a href=&quot;#免責聲明與使用條款&quot; class=&quot;headerlink&quot; title=&quot;免責聲明與使用條款&quot;&gt;&lt;/a&gt;免責聲明與使用條款&lt;/h1&gt;&lt;p&gt;歡迎使用本站。以下條款和條件將規範您對本站的使用，請仔細閱讀：&lt;/p&gt;
&lt;p&gt;&lt;st</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="免責聲明與使用條款"><a href="#免責聲明與使用條款" class="headerlink" title="免責聲明與使用條款"></a>免責聲明與使用條款</h1><p>歡迎使用本站。以下條款和條件將規範您對本站的使用，請仔細閱讀：</p><p><strong>合作關係</strong>：根據FTC規定，本站中推薦的商家或產品可能存在合作關係，當使用者透過本站連結到第三方商家並進行消費時，本站可能獲得相應的傭金作為營運維持費用。這不會影響您購買商品的價格，本站也不會多收您任何費用。</p><p><strong>交易責任</strong>：本站不承擔任何讀者與商家之間的交易責任。任何取消、更改訂單或其他交易問題應直接與商家客服聯絡。本站不參與及協助任何消費者與商家之間的糾紛。</p><p><strong>隱私權</strong>：本站尊重並保護讀者的隱私權。您提供給本站的任何個人資訊將僅供本站與您聯繫，不會轉發給其他方或商家。</p><p><strong>免責聲明</strong>：本站的內容僅供參考，不構成專業建議。使用本站所提供的信息時，您必須自行承擔相應的風險。所有來信諮詢的信件我們不會將資料轉發給其他方或商家，信箱及個人資訊僅供本站與讀者聯繫。</p><p><strong>變更條款</strong>：本站保留隨時更改條款的權利，我們建議您定期查看以獲取最新信息。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E5%85%8D%E8%B2%AC%E8%81%B2%E6%98%8E/">免責聲明</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%83%A8%E8%90%BD%E6%A0%BC/">部落格</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/06/%E5%85%8D%E8%B2%AC%E8%81%B2%E6%98%8E%E8%88%87%E4%BD%BF%E7%94%A8%E6%A2%9D%E6%AC%BE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>關於我</title>
      <link>https://gahgah147.github.io/2024/06/06/%E9%97%9C%E6%96%BC%E6%88%91/</link>
      <guid>https://gahgah147.github.io/2024/06/06/%E9%97%9C%E6%96%BC%E6%88%91/</guid>
      <pubDate>Thu, 06 Jun 2024 07:10:58 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;關於我&quot;&gt;&lt;a href=&quot;#關於我&quot; class=&quot;headerlink&quot; title=&quot;關於我&quot;&gt;&lt;/a&gt;關於我&lt;/h1&gt;&lt;p&gt;Hello，我是拿樂橙。&lt;br&gt;這裡記錄了我在日常生活中的學習記錄，還有程式工作學習上遇到的問題。希望藉由我的分享，能幫助來到這裡的</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="關於我"><a href="#關於我" class="headerlink" title="關於我"></a>關於我</h1><p>Hello，我是拿樂橙。<br>這裡記錄了我在日常生活中的學習記錄，還有程式工作學習上遇到的問題。希望藉由我的分享，能幫助來到這裡的你。而若有任何合作邀約，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E9%83%A8%E8%90%BD%E6%A0%BC/">部落格</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%97%9C%E6%96%BC%E6%88%91/">關於我</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/06/%E9%97%9C%E6%96%BC%E6%88%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DISC 性格模式溝通四部曲</title>
      <link>https://gahgah147.github.io/2024/06/05/DISC-%E6%80%A7%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%BA%9D%E9%80%9A%E5%9B%9B%E9%83%A8%E6%9B%B2/</link>
      <guid>https://gahgah147.github.io/2024/06/05/DISC-%E6%80%A7%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%BA%9D%E9%80%9A%E5%9B%9B%E9%83%A8%E6%9B%B2/</guid>
      <pubDate>Wed, 05 Jun 2024 06:17:26 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;DISC-性格模式溝通四部曲&quot;&gt;&lt;a href=&quot;#DISC-性格模式溝通四部曲&quot; class=&quot;headerlink&quot; title=&quot;DISC 性格模式溝通四部曲&quot;&gt;&lt;/a&gt;DISC 性格模式溝通四部曲&lt;/h1&gt;&lt;p&gt;「先識人、再溝通」才能讓溝通產生效果！接下來</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="DISC-性格模式溝通四部曲"><a href="#DISC-性格模式溝通四部曲" class="headerlink" title="DISC 性格模式溝通四部曲"></a>DISC 性格模式溝通四部曲</h1><p>「先識人、再溝通」才能讓溝通產生效果！接下來會介紹近百年歷史的企業人力管理系統「美國DISC性格模式」作為識人工具，後續可以在最短的時間內，摸清對方的性格、特質、想法、行為、需求，再搭配「四套溝通劇本」，在溝通上能對症下藥、順暢無比！</p><h2 id="DISC-性格模式是什麼"><a href="#DISC-性格模式是什麼" class="headerlink" title="DISC 性格模式是什麼?"></a>DISC 性格模式是什麼?</h2><p>DISC 是一個性格分析工具，用於了解和分類人的行為特徵和性格特質。它由心理學家威廉·馬斯頓（William Marston）於1928年提出，並廣泛應用於企業管理、人際溝通和個人成長等領域。</p><p>DISC將人分類成4種不同的性格，包括：掌控型（Dominance）、影響型（Influence）、穩定型（Steadiness）和分析型（Compliance）。</p><ol><li><p><strong>D 型（Dominance，支配型）</strong>：</p><ul><li><strong>特徵</strong>：果斷、直接、目標導向、競爭性強</li><li><strong>動機</strong>：結果和成功</li><li><strong>溝通風格</strong>：喜歡簡潔明瞭的溝通，注重效率和成果</li></ul></li><li><p><strong>I 型（Influence，影響型）</strong>：</p><ul><li><strong>特徵</strong>：外向、樂觀、熱情、善於溝通</li><li><strong>動機</strong>：社交互動和認可</li><li><strong>溝通風格</strong>：喜歡互動和故事，注重情感和氣氛</li></ul></li><li><p><strong>S 型（Steadiness，穩定型）</strong>：</p><ul><li><strong>特徵</strong>：耐心、可靠、支持性強、重視穩定</li><li><strong>動機</strong>：和諧和合作</li><li><strong>溝通風格</strong>：注重關係和同理心，喜歡和善的交流</li></ul></li><li><p><strong>C 型（Conscientiousness，謹慎型）</strong>：</p><ul><li><strong>特徵</strong>：分析性強、謹慎、系統化、精確</li><li><strong>動機</strong>：正確性和品質</li><li><strong>溝通風格</strong>：喜歡條理清晰、細節豐富的溝通，注重事實和數據</li></ul></li></ol><h2 id="DISC-性格測試"><a href="#DISC-性格測試" class="headerlink" title="DISC 性格測試"></a>DISC 性格測試</h2><p>您可以通過一系列簡單的問題測試來了解自己的 DISC 性格類型，例如：</p><table><thead><tr><th>問題</th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>你覺得你的特色比較像？</td><td>大膽果決，接受挑戰</td><td>幽默風趣，人緣不錯</td><td>溫和內向，樂於傾聽</td><td>彬彬有禮，謹慎仔細</td></tr><tr><td>平常與他人的相處，你比較傾向？</td><td>工作為主，很少談到個人生活</td><td>重視氣氛並帶動團體活力</td><td>常傾聽並對他人態度和善友好</td><td>較不會主動與人建立關係</td></tr><tr><td>你希望別人如何與你溝通？</td><td>直接講重點，不要拐彎抹角</td><td>輕鬆愉快，不要太嚴肅或一板一眼</td><td>不要一次說太多，明確指示細節</td><td>條例式說明，並解釋其原因</td></tr><tr><td>哪一個是別人最常說你的小缺點？</td><td>容易沒有耐性</td><td>容易缺乏細心</td><td>容易沒有主見</td><td>容易缺乏幽默</td></tr></tbody></table><p>透過這些問題，您可以快速了解自己的性格特質，進而選擇適合的溝通和行為策略。</p><h3 id="分析結果"><a href="#分析結果" class="headerlink" title="分析結果"></a>分析結果</h3><ul><li><strong>A 選項多 → 支配型 D</strong></li><li><strong>B 選項多 → 影響型 I</strong></li><li><strong>C 選項多 → 穩定型 S</strong></li><li><strong>D 選項多 → 謹慎型 C</strong></li></ul><h2 id="如何應用-DISC-模型？"><a href="#如何應用-DISC-模型？" class="headerlink" title="如何應用 DISC 模型？"></a>如何應用 DISC 模型？</h2><p>在職場和人際交往中，理解和應用 DISC 模型可以幫助我們更好地與不同性格的人相處。以下是一些應用場景：</p><ul><li><strong>招聘和團隊建設</strong>：根據性格特徵安排合適的崗位和團隊角色，提高工作效率和團隊協作。</li><li><strong>個人發展</strong>：了解自己的性格優勢和改進點，制定針對性的成長計劃。</li><li><strong>溝通和說服</strong>：根據對方的性格特徵選擇合適的溝通方式，提高溝通效果和說服力。</li></ul><h2 id="溝通對象的關注點"><a href="#溝通對象的關注點" class="headerlink" title="溝通對象的關注點"></a>溝通對象的關注點</h2><ul><li><strong>D 型人</strong>：最在意的是結果，想獲得的是好處。適合用選擇題溝通法。</li><li><strong>I 型人</strong>：最在意的是感覺，想獲得的是肯定與讚美。適合用說故事溝通法。</li><li><strong>S 型人</strong>：最在意的是關係，想獲得的是情感。適合用同理心溝通法。</li><li><strong>C 型人</strong>：最在意的是合理，想獲得的是策略。適合用表格式溝通法。</li></ul><p>以下是整理的比較表格</p><table><thead><tr><th>型格</th><th>最在意</th><th>想獲得</th><th>溝通方式</th></tr></thead><tbody><tr><td>D 型人</td><td>結果</td><td>好處</td><td>選擇題溝通法</td></tr><tr><td>I 型人</td><td>感覺</td><td>肯定與讚美</td><td>說故事溝通法</td></tr><tr><td>S 型人</td><td>關係</td><td>情感</td><td>同理心溝通法</td></tr><tr><td>C 型人</td><td>合理</td><td>策略</td><td>表格式溝通法</td></tr></tbody></table><h2 id="四套溝通劇本"><a href="#四套溝通劇本" class="headerlink" title="四套溝通劇本"></a>四套溝通劇本</h2><p>根據對方的性格特質和需求，選擇適合的溝通劇本，可以讓你的溝通更加有效：</p><ol><li><p><strong>選擇題溝通法（D 型人）</strong></p><ul><li>提供多個選擇，讓對方決定，以滿足他們對結果和好處的需求。</li></ul></li><li><p><strong>說故事溝通法（I 型人）</strong></p><ul><li>通過生動有趣的故事引起對方的興趣，並在故事中傳達你的觀點。</li></ul></li><li><p><strong>同理心溝通法（S 型人）</strong></p><ul><li>表達對對方情感和關係的重視，讓對方感受到你的關心和理解。</li></ul></li><li><p><strong>表格式溝通法（C 型人）</strong></p><ul><li>以條例式的方式，清晰明確地解釋事情的原因和策略，滿足他們對合理性的需求。</li></ul></li></ol><h2 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h2><p>以上是DISC 性格介紹的內容，得知這個分類後開始思考人的性格來調整溝通方式，但這邊我也認為這類的分析需要避免濫用，像是亂貼標籤或是合理化自身缺點與盲點，或是急於評論他人特質與行為等等的缺點還是要盡量避免，這個方式也可以讓我比較了解自己的性格，還有應對不同個性的人該如何選擇合適的溝通方式。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/DISC/">DISC</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%BF%83%E7%90%86%E6%B8%AC%E9%A9%97/">心理測驗</category>
      
      <category domain="https://gahgah147.github.io/tags/%E6%BA%9D%E9%80%9A%E6%A8%A1%E5%BC%8F/">溝通模式</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/05/DISC-%E6%80%A7%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%BA%9D%E9%80%9A%E5%9B%9B%E9%83%A8%E6%9B%B2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何讓筆電蓋上螢幕後不自動關機或休眠</title>
      <link>https://gahgah147.github.io/2024/06/05/%E5%A6%82%E4%BD%95%E8%AE%93%E7%AD%86%E9%9B%BB%E8%93%8B%E4%B8%8A%E8%9E%A2%E5%B9%95%E5%BE%8C%E4%B8%8D%E8%87%AA%E5%8B%95%E9%97%9C%E6%A9%9F%E6%88%96%E4%BC%91%E7%9C%A0/</link>
      <guid>https://gahgah147.github.io/2024/06/05/%E5%A6%82%E4%BD%95%E8%AE%93%E7%AD%86%E9%9B%BB%E8%93%8B%E4%B8%8A%E8%9E%A2%E5%B9%95%E5%BE%8C%E4%B8%8D%E8%87%AA%E5%8B%95%E9%97%9C%E6%A9%9F%E6%88%96%E4%BC%91%E7%9C%A0/</guid>
      <pubDate>Wed, 05 Jun 2024 03:16:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;如何讓筆電蓋上螢幕後不自動關機或休眠&quot;&gt;&lt;a href=&quot;#如何讓筆電蓋上螢幕後不自動關機或休眠&quot; class=&quot;headerlink&quot; title=&quot;如何讓筆電蓋上螢幕後不自動關機或休眠&quot;&gt;&lt;/a&gt;如何讓筆電蓋上螢幕後不自動關機或休眠&lt;/h1&gt;&lt;p&gt;在工作時，通</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="如何讓筆電蓋上螢幕後不自動關機或休眠"><a href="#如何讓筆電蓋上螢幕後不自動關機或休眠" class="headerlink" title="如何讓筆電蓋上螢幕後不自動關機或休眠"></a>如何讓筆電蓋上螢幕後不自動關機或休眠</h1><p>在工作時，通常會使用到筆電與外接電源。有時候會想要只使用外接螢幕來進行開發工作，但這時候經常會遇到一個問題：筆電蓋上後，外接螢幕的畫面也會跟著休眠。如果希望蓋上筆電後外接螢幕依然可以使用，可以依照以下步驟進行設定。</p><h2 id="為什麼筆電蓋上螢幕會進入睡眠？"><a href="#為什麼筆電蓋上螢幕會進入睡眠？" class="headerlink" title="為什麼筆電蓋上螢幕會進入睡眠？"></a>為什麼筆電蓋上螢幕會進入睡眠？</h2><p>筆電蓋上螢幕後會進入睡眠模式是為了節省電力並保護電腦硬體。以下是一些具體原因：</p><ol><li><p><strong>節省電力</strong>：睡眠模式可以顯著減少電力消耗，這對於延長電池壽命非常重要。當筆電在電池供電時，進入睡眠模式可以最大限度地保留電量。</p></li><li><p><strong>保護硬體</strong>：筆電在運行時，硬碟和處理器等硬體部件會發熱。如果長時間在蓋上螢幕的狀態下持續運行，可能會導致散熱不良，從而縮短硬體壽命。</p></li><li><p><strong>安全性</strong>：當筆電進入睡眠模式時，通常會自動鎖屏，這可以防止未經授權的訪問，保護用戶的數據和隱私。</p></li><li><p><strong>防止意外操作</strong>：當螢幕蓋上時，鍵盤和觸控板仍然可能被無意識地觸發。睡眠模式可以防止這些無意識的操作干擾正在進行的工作。</p></li><li><p><strong>使用習慣</strong>：大多數筆電預設在蓋上螢幕時進入睡眠模式，以符合大多數用戶的使用習慣和期望。如果用戶希望蓋上螢幕後筆電繼續運行，可以在電源選項中進行相應的設置。</p></li></ol><h2 id="設定步驟"><a href="#設定步驟" class="headerlink" title="設定步驟"></a>設定步驟</h2><h3 id="1-進入電源選項設定"><a href="#1-進入電源選項設定" class="headerlink" title="1. 進入電源選項設定"></a>1. 進入電源選項設定</h3><p>首先，在系統搜尋「蓋上」，找到「變更蓋上螢幕時的行為」後打開進入。</p><p><img src="https://hackmd.io/_uploads/ryMmE8hER.png" alt="image"></p><h3 id="2-設定蓋上螢幕時的行為"><a href="#2-設定蓋上螢幕時的行為" class="headerlink" title="2. 設定蓋上螢幕時的行為"></a>2. 設定蓋上螢幕時的行為</h3><p>在「當我關閉筆記電腦螢幕時」的選項中，我們可以看到「一般電源」和「電池使用中」兩個設定。</p><ul><li><strong>一般電源</strong>：指的是當筆電連接電源時的行為。這裡選擇「不進行動作」。</li></ul><p><img src="https://hackmd.io/_uploads/ryta4LhVR.png" alt="image"></p><ul><li><strong>電池使用中</strong>：指的是當筆電使用電池時的行為。如果希望拔掉電源時也讓筆電蓋上螢幕不自動關機，這裡也選擇「不進行動作」。</li></ul><h2 id="測試設定"><a href="#測試設定" class="headerlink" title="測試設定"></a>測試設定</h2><p>設定完成後，可以測試看看蓋上筆電螢幕是否會進入休眠或關機。只需將筆電蓋上，並觀察外接螢幕是否依然顯示畫面。如果一切正常，外接螢幕應該會保持運行。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>通過上述簡單的設定，我們可以在蓋上筆電螢幕後依然使用外接螢幕進行工作，這樣既方便又能提高工作效率。希望這篇文章能幫助你解決筆電蓋上螢幕後自動關機或休眠的問題。如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Win11/">Win11</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%BB%E8%85%A6%E6%93%8D%E4%BD%9C/">電腦操作</category>
      
      <category domain="https://gahgah147.github.io/tags/%E7%AD%86%E9%9B%BB/">筆電</category>
      
      <category domain="https://gahgah147.github.io/tags/Windows/">Windows</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/05/%E5%A6%82%E4%BD%95%E8%AE%93%E7%AD%86%E9%9B%BB%E8%93%8B%E4%B8%8A%E8%9E%A2%E5%B9%95%E5%BE%8C%E4%B8%8D%E8%87%AA%E5%8B%95%E9%97%9C%E6%A9%9F%E6%88%96%E4%BC%91%E7%9C%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Node.js 學習筆記 - NVM 版本控制器介紹及其安裝步驟</title>
      <link>https://gahgah147.github.io/2024/06/05/Node-js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-NVM-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BB%8B%E7%B4%B9%E5%8F%8A%E5%85%B6%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/</link>
      <guid>https://gahgah147.github.io/2024/06/05/Node-js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-NVM-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BB%8B%E7%B4%B9%E5%8F%8A%E5%85%B6%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/</guid>
      <pubDate>Wed, 05 Jun 2024 02:52:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Node-js-學習筆記-NVM-版本控制器介紹及其安裝步驟&quot;&gt;&lt;a href=&quot;#Node-js-學習筆記-NVM-版本控制器介紹及其安裝步驟&quot; class=&quot;headerlink&quot; title=&quot;Node.js 學習筆記 - NVM 版本控制器介紹及其安裝步驟</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Node-js-學習筆記-NVM-版本控制器介紹及其安裝步驟"><a href="#Node-js-學習筆記-NVM-版本控制器介紹及其安裝步驟" class="headerlink" title="Node.js 學習筆記 - NVM 版本控制器介紹及其安裝步驟"></a>Node.js 學習筆記 - NVM 版本控制器介紹及其安裝步驟</h1><p><img src="https://hackmd.io/_uploads/r1jyf86EC.png" alt="image"></p><h2 id="什麼是-NVM？"><a href="#什麼是-NVM？" class="headerlink" title="什麼是 NVM？"></a>什麼是 NVM？</h2><p>NVM (Node Version Manager) 是一個管理 Node.js 版本的工具。它允許開發者在多個 Node.js 版本之間輕鬆切換，這對於需要同時維護多個專案或測試新版本功能的開發者來說非常方便。</p><p>以下是NVM 的官方Github連結</p><p><img src="https://hackmd.io/_uploads/SJVyWU640.png" alt="image"></p><blockquote><p><a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p></blockquote><h2 id="NVM-的優點"><a href="#NVM-的優點" class="headerlink" title="NVM 的優點"></a>NVM 的優點</h2><ol><li><strong>輕鬆管理多個 Node.js 版本</strong>：可以隨時切換、安裝或移除不同的 Node.js 版本。</li><li><strong>環境隔離</strong>：不同專案可以使用不同的 Node.js 版本，避免版本衝突。</li><li><strong>簡單易用</strong>：安裝和使用都非常直觀，幾條命令即可完成操作。</li></ol><h2 id="NVM-的安裝步驟"><a href="#NVM-的安裝步驟" class="headerlink" title="NVM 的安裝步驟"></a>NVM 的安裝步驟</h2><h3 id="1-安裝-NVM"><a href="#1-安裝-NVM" class="headerlink" title="1. 安裝 NVM"></a>1. 安裝 NVM</h3><p>要安裝 NVM，請執行以下步驟：</p><ol><li>打開終端機 (Terminal)。</li></ol><p><img src="https://hackmd.io/_uploads/HyeuY0SaVR.png" alt="image"></p><ol start="3"><li><p>使用 curl 或 wget 下載並安裝 NVM：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 curl</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 wget</span></span><br><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/H1woRHTNA.png" alt="image"></p><ol start="3"><li><p>安裝完成後，重新啟動終端機或運行以下命令來使 NVM 生效：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.nvm/nvm.sh</span><br></pre></td></tr></table></figure></li></ol><p>因為我不想重新開機所以用這個指令<br><img src="https://hackmd.io/_uploads/SkECCBp4R.png" alt="image"></p><h3 id="2-驗證安裝"><a href="#2-驗證安裝" class="headerlink" title="2. 驗證安裝"></a>2. 驗證安裝</h3><p>要確認 NVM 是否安裝成功，可以運行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm --version</span><br></pre></td></tr></table></figure><p>如果安裝成功，會顯示 NVM 的版本號。</p><p><img src="https://hackmd.io/_uploads/ryAgy86NR.png" alt="image"></p><blockquote><p>這邊成功顯示版本編號為0.39.2</p></blockquote><h3 id="3-安裝-Node-js-版本"><a href="#3-安裝-Node-js-版本" class="headerlink" title="3. 安裝 Node.js 版本"></a>3. 安裝 Node.js 版本</h3><p>安裝 NVM 後，可以使用 NVM 來安裝和管理不同的 Node.js 版本。</p><ol><li><p>安裝最新的 LTS 版本：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install --lts</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/BJnrJ8aER.png" alt="image"></p><blockquote><p>目前安裝最新版本為20.14.0</p></blockquote><ol start="2"><li><p>安裝特定版本，例如 14.17.0：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 14.17.0</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/SkEK1Up4R.png" alt="image"></p><blockquote><p>成功安裝畫面</p></blockquote><ol start="3"><li><p>切換到特定版本：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 14.17.0</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/B1-ikU6VR.png" alt="image"></p><blockquote><p>成功切換版本畫面</p></blockquote><ol start="4"><li><p>查看已安裝的所有 Node.js 版本：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://hackmd.io/_uploads/HJfpyLa4C.png" alt="image"></p><blockquote><p>成功列出所有版本的畫面</p></blockquote><h3 id="4-設定默認版本"><a href="#4-設定默認版本" class="headerlink" title="4. 設定默認版本"></a>4. 設定默認版本</h3><p>如果希望某個版本作為默認版本，可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">alias</span> default 14.17.0</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BJBXeLaEA.png" alt="image"></p><blockquote><p>設定預設版本成功畫面</p></blockquote><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>NVM 是一個非常實用的工具，尤其適合需要同時管理多個 Node.js 版本的開發者。通過簡單的幾條命令，我們可以輕鬆地安裝、移除或切換不同的 Node.js 版本，從而提高開發效率。</p><p>建議一開始安裝node.js 就這樣安裝比較簡單，更詳細的操作指令建議去官方的github網址查看(<a href="https://github.com/nvm-sh/nvm)%E3%80%82">https://github.com/nvm-sh/nvm)。</a></p><p>希望這篇文章能幫助你了解 NVM 並順利安裝和使用它。如果你有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Node-js/">Node.js</category>
      
      <category domain="https://gahgah147.github.io/tags/NVM/">NVM</category>
      
      
      <comments>https://gahgah147.github.io/2024/06/05/Node-js-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-NVM-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BB%8B%E7%B4%B9%E5%8F%8A%E5%85%B6%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>區塊鏈 - 區塊鏈節點商</title>
      <link>https://gahgah147.github.io/2024/05/29/%E5%8D%80%E5%A1%8A%E9%8F%88-%E5%8D%80%E5%A1%8A%E9%8F%88%E7%AF%80%E9%BB%9E%E5%95%86/</link>
      <guid>https://gahgah147.github.io/2024/05/29/%E5%8D%80%E5%A1%8A%E9%8F%88-%E5%8D%80%E5%A1%8A%E9%8F%88%E7%AF%80%E9%BB%9E%E5%95%86/</guid>
      <pubDate>Wed, 29 May 2024 04:02:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;區塊鏈-區塊鏈節點商&quot;&gt;&lt;a href=&quot;#區塊鏈-區塊鏈節點商&quot; class=&quot;headerlink&quot; title=&quot;區塊鏈 - 區塊鏈節點商&quot;&gt;&lt;/a&gt;區塊鏈 - 區塊鏈節點商&lt;/h1&gt;&lt;p&gt;由於在開發使用智能合約時，後端程式會需要透過節點連結到智能合約作互動</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="區塊鏈-區塊鏈節點商"><a href="#區塊鏈-區塊鏈節點商" class="headerlink" title="區塊鏈 - 區塊鏈節點商"></a>區塊鏈 - 區塊鏈節點商</h1><p>由於在開發使用智能合約時，後端程式會需要透過節點連結到智能合約作互動，所以我們會來介紹節點商跟比較，然後簡單介紹如何註冊申請API Key 來使用節點。</p><h1 id="什麼是區塊鏈節點商"><a href="#什麼是區塊鏈節點商" class="headerlink" title="什麼是區塊鏈節點商"></a>什麼是區塊鏈節點商</h1><p>區塊鏈節點商（Blockchain Node Provider）是專門提供區塊鏈節點服務的公司或平台，使開發者和企業能夠輕鬆地連接和使用區塊鏈網絡，而無需自行運行和維護節點。這些節點商提供的服務包括節點托管、API訪問、數據查詢、交易發送和智能合約部署等。</p><h2 id="區塊鏈節點商的功能"><a href="#區塊鏈節點商的功能" class="headerlink" title="區塊鏈節點商的功能"></a>區塊鏈節點商的功能</h2><ol><li><p><strong>節點托管</strong>：<br>節點商為客戶運行和管理區塊鏈節點，這樣開發者和企業無需自行處理節點的運行和維護，減少了技術負擔和成本。</p></li><li><p><strong>API 訪問</strong>：<br>節點商提供簡單易用的API，使開發者能夠通過HTTP請求與區塊鏈網絡互動。這些API支持各種區塊鏈操作，如查詢賬戶餘額、發送交易、部署和調用智能合約等。</p></li><li><p><strong>高可用性</strong>：<br>節點商通常會提供高可用性的服務，確保客戶的應用能夠穩定地連接到區塊鏈網絡。這些服務通常有全球分佈的伺服器和冗餘設計，以提高可靠性。</p></li><li><p><strong>安全性</strong>：<br>節點商會實施多層次的安全措施來保護客戶的數據和API請求，包括加密通信、API密鑰管理和訪問控制等。</p></li><li><p><strong>實時數據和監控</strong>：<br>許多節點商提供實時數據訪問和監控工具，使客戶能夠即時了解區塊鏈網絡的狀態和活動。</p></li></ol><p>也就是不需要再自己架設節點，維護節點了。</p><h2 id="為什麼選擇區塊鏈節點商"><a href="#為什麼選擇區塊鏈節點商" class="headerlink" title="為什麼選擇區塊鏈節點商"></a>為什麼選擇區塊鏈節點商</h2><ol><li><p><strong>節省成本</strong>：<br>自行運行和維護區塊鏈節點需要高昂的硬體成本和技術資源。使用節點商的服務，可以顯著降低這些成本。</p></li><li><p><strong>減少技術負擔</strong>：<br>節點商處理節點的運行、維護和升級，讓開發者專注於應用的開發和創新。</p></li><li><p><strong>提高可靠性</strong>：<br>節點商提供高可用性和冗餘設計，確保區塊鏈網絡連接的穩定性和可靠性。</p></li><li><p><strong>加快開發進程</strong>：<br>節點商提供簡單易用的API和豐富的開發工具，使開發者能夠更快速地構建和部署區塊鏈應用。</p></li></ol><h2 id="有哪幾種節點"><a href="#有哪幾種節點" class="headerlink" title="有哪幾種節點?"></a>有哪幾種節點?</h2><p>區塊鏈節點商（Blockchain Node Provider) 通常包含以下幾種節點：</p><ol><li><p><strong>完整節點（Full Node）</strong>：這些節點儲存區塊鏈的完整歷史紀錄，並參與區塊鏈網路的共識過程。完整節點可以驗證交易和區塊，確保區塊鏈的完整性和安全性。</p></li><li><p><strong>輕量節點（Light Node）</strong>：這些節點只儲存區塊鏈的一部分數據，通常是最新的區塊和一些必要的數據，用來簡化運行和減少儲存需求。輕量節點不參與完整的共識過程，但可以快速同步和驗證交易。</p></li><li><p><strong>挖礦節點（Mining Node）</strong>：這些節點專門用於進行挖礦活動，通過計算來驗證交易並創建新區塊。挖礦節點通常需要高效能的硬體設備和大量的電力資源。</p></li><li><p><strong>驗證節點（Validator Node）</strong>：在某些共識機制（如權益證明（PoS））中，驗證節點負責檢查和驗證交易，並確保區塊的有效性。驗證節點通常需要持有一定數量的代幣以參與共識過程。</p></li></ol><p>這些節點服務可以用來幫助開發者、企業和個人快速且可靠地接入區塊鏈網路，無需自己管理和維護節點，從而節省資源和精力。</p><h2 id="常見的區塊鏈節點商"><a href="#常見的區塊鏈節點商" class="headerlink" title="常見的區塊鏈節點商"></a>常見的區塊鏈節點商</h2><ol><li><strong>Infura</strong>：<br>提供高可用性的API端點，支持以太坊、IPFS和多個測試網。Infura 的服務器分佈在全球，能夠處理大量的API請求，適合需要穩定連接的應用。</li></ol><p><img src="https://hackmd.io/_uploads/S1Gesq-EA.png" alt="image"></p><blockquote><p><a href="https://www.infura.io/zh">https://www.infura.io/zh</a></p></blockquote><ol start="2"><li><strong>Alchemy</strong>：<br>Alchemy 提供優化的API性能和豐富的開發工具，支持以太坊、Polygon、Arbitrum等多個區塊鏈網絡。Alchemy 專注於高效和低延遲的服務，適合大型dApp和企業應用。</li></ol><p><img src="https://hackmd.io/_uploads/B1VVoqbER.png" alt="image"></p><blockquote><p><a href="https://www.alchemy.com/">https://www.alchemy.com/</a></p></blockquote><ol start="3"><li><strong>QuickNode</strong>：<br>QuickNode 提供高速且可擴展的API服務，支持以太坊、Polygon、Binance Smart Chain等多個區塊鏈網絡。QuickNode 的服務強調低延遲和高吞吐量。</li></ol><p><img src="https://hackmd.io/_uploads/Hk9-o9ZN0.png" alt="image"></p><blockquote><p><a href="https://www.quicknode.com/">https://www.quicknode.com</a></p></blockquote><ol start="4"><li><strong>Chainstack</strong>：<br>Chainstack 提供企業級的區塊鏈基礎設施服務，支持以太坊、Polygon、BSC、Hyperledger Fabric等多個區塊鏈網絡。Chainstack 強調簡單的部署和管理工具，適合企業應用。</li></ol><p><img src="https://hackmd.io/_uploads/SyJ8jc-VA.png" alt="image"></p><blockquote><p><a href="https://chainstack.com/">https://chainstack.com/</a></p></blockquote><p>以下是包含支援的節點類型的表格：</p><table><thead><tr><th>特點</th><th><strong>Infura</strong></th><th><strong>Alchemy</strong></th><th><strong>QuickNode</strong></th><th><strong>Chainstack</strong></th></tr></thead><tbody><tr><td><strong>支持的網絡</strong></td><td>以太坊、IPFS、多個測試網</td><td>以太坊、Polygon、Arbitrum、多個測試網</td><td>以太坊、Polygon、BSC、多個測試網</td><td>以太坊、Polygon、BSC、Hyperledger Fabric、多個測試網</td></tr><tr><td><strong>API 性能</strong></td><td>高可用性和可靠性</td><td>優化的API性能，高速和低延遲</td><td>高速API服務，低延遲</td><td>高效數據處理，企業級性能</td></tr><tr><td><strong>開發者工具</strong></td><td>支持Web3.js、ethers.js、Python、PHP</td><td>全面支持多種語言和框架，豐富的開發工具</td><td>支持多種語言和框架，實時數據和監控</td><td>簡單的部署和管理工具，支持多種協議</td></tr><tr><td><strong>安全性</strong></td><td>多層次安全措施，API密鑰管理</td><td>高級安全功能和數據保護</td><td>高安全性，實時監控和告警</td><td>高安全性，企業級保護</td></tr><tr><td><strong>通知功能</strong></td><td>即時交易和事件通知</td><td>即時交易和事件通知，高級分析工具</td><td>實時數據通知，API性能分析</td><td>實時通知和監控</td></tr><tr><td><strong>免費和付費方案</strong></td><td>免費層級及多種付費方案</td><td>免費層級及多種付費方案</td><td>免費層級及多種付費方案</td><td>免費層級及多種付費方案</td></tr><tr><td><strong>支持企業級應用</strong></td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td><strong>支援的節點類型</strong></td><td>完整節點、輕量節點、驗證節點</td><td>完整節點、輕量節點、驗證節點、挖礦節點</td><td>完整節點、輕量節點、驗證節點、挖礦節點</td><td>完整節點、輕量節點、驗證節點、挖礦節點</td></tr></tbody></table><h1 id="實際操作使用"><a href="#實際操作使用" class="headerlink" title="實際操作使用"></a>實際操作使用</h1><h2 id="註冊-Alchemy-帳戶"><a href="#註冊-Alchemy-帳戶" class="headerlink" title="註冊 Alchemy 帳戶"></a>註冊 Alchemy 帳戶</h2><h3 id="步驟一-進入-Alchemy-官網，點選-Get-your-API-key"><a href="#步驟一-進入-Alchemy-官網，點選-Get-your-API-key" class="headerlink" title="步驟一: 進入 Alchemy 官網，點選 Get your API key"></a>步驟一: 進入 Alchemy 官網，點選 Get your API key</h3><p><img src="https://hackmd.io/_uploads/r1navs-ER.png" alt="image"></p><blockquote><p><a href="https://www.alchemy.com/">https://www.alchemy.com/</a></p></blockquote><h3 id="步驟二-填入名字、電子郵件、密碼-也可以選擇連結-Google-或是-SSO-，後，按-Sign-Up"><a href="#步驟二-填入名字、電子郵件、密碼-也可以選擇連結-Google-或是-SSO-，後，按-Sign-Up" class="headerlink" title="步驟二:填入名字、電子郵件、密碼(也可以選擇連結 Google 或是 SSO)，後，按 Sign Up"></a>步驟二:填入名字、電子郵件、密碼(也可以選擇連結 Google 或是 SSO)，後，按 Sign Up</h3><p><img src="https://hackmd.io/_uploads/ByUGdjWEA.png" alt="image"></p><blockquote><p><a href="https://auth.alchemy.com/signup">https://auth.alchemy.com/signup</a></p></blockquote><p>若是選擇 連結google帳號，會需要授權<br><img src="https://hackmd.io/_uploads/B16nusWEA.png" alt="image"></p><h3 id="步驟三-填寫相關表單"><a href="#步驟三-填寫相關表單" class="headerlink" title="步驟三: 填寫相關表單"></a>步驟三: 填寫相關表單</h3><p>這邊可以選擇團隊或是個人</p><p><img src="https://hackmd.io/_uploads/ByR9Fs-NR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/H17LFsbVA.png" alt="image"></p><p>這邊可以選擇要建立的產品方向<br><img src="https://hackmd.io/_uploads/r1nRtsZNR.png" alt="image"></p><p>在來是選擇網域，最多可以選擇4個<br><img src="https://hackmd.io/_uploads/rJdXqoW4R.png" alt="image"></p><p>再來是設定收費方案，這邊我選擇免費的方案<br><img src="https://hackmd.io/_uploads/Skbqqj-V0.png" alt="image"></p><p>這邊填入付費方式<br><img src="https://hackmd.io/_uploads/H1ZejiWE0.png" alt="image"></p><p>是如何知道Alchemy的? (選填)<br><img src="https://hackmd.io/_uploads/ByYY3iWEA.png" alt="image"></p><p>看到這個畫面就代表完成註冊了<br><img src="https://hackmd.io/_uploads/H1yTajZ4A.png" alt="image"></p><h3 id="建立-取得-API-Key"><a href="#建立-取得-API-Key" class="headerlink" title="建立 取得 API Key"></a>建立 取得 API Key</h3><h3 id="步驟一-點選後台的Apps畫面，按右上方的-Create-new-app"><a href="#步驟一-點選後台的Apps畫面，按右上方的-Create-new-app" class="headerlink" title="步驟一: 點選後台的Apps畫面，按右上方的 +Create new app"></a>步驟一: 點選後台的Apps畫面，按右上方的 +Create new app</h3><p><img src="https://hackmd.io/_uploads/S1S50jZV0.png" alt="image"></p><h3 id="步驟二-輸入名稱跟描述後按-Create-app-開始建立"><a href="#步驟二-輸入名稱跟描述後按-Create-app-開始建立" class="headerlink" title="步驟二: 輸入名稱跟描述後按 Create app 開始建立"></a>步驟二: 輸入名稱跟描述後按 Create app 開始建立</h3><p><img src="https://hackmd.io/_uploads/ryoCRsb40.png" alt="image"></p><h3 id="步驟三-建立成功後點選右上方的-API-Key"><a href="#步驟三-建立成功後點選右上方的-API-Key" class="headerlink" title="步驟三: 建立成功後點選右上方的 API Key"></a>步驟三: 建立成功後點選右上方的 API Key</h3><p><img src="https://hackmd.io/_uploads/rky4k2ZVC.png" alt="image"></p><p>可以取得API Key、HTTPS連線網址、WebSocket連線網址跟程式範例 </p><p><img src="https://hackmd.io/_uploads/ByMGgnWV0.png" alt="image"></p><h2 id="註冊infura帳戶"><a href="#註冊infura帳戶" class="headerlink" title="註冊infura帳戶"></a>註冊infura帳戶</h2><h3 id="步驟1-進入infura-官網，點選-Singn-UP-進行註冊"><a href="#步驟1-進入infura-官網，點選-Singn-UP-進行註冊" class="headerlink" title="步驟1 :進入infura 官網，點選 Singn UP 進行註冊"></a>步驟1 :進入infura 官網，點選 Singn UP 進行註冊</h3><p><img src="https://hackmd.io/_uploads/r1zqGFbE0.png" alt="image"></p><blockquote><p><a href="https://www.infura.io/zh">https://www.infura.io/zh</a></p></blockquote><h3 id="步驟二：填入名字、電子郵件、密碼後，按-CREATE-A-FREE-ACCOUNT-按鈕。"><a href="#步驟二：填入名字、電子郵件、密碼後，按-CREATE-A-FREE-ACCOUNT-按鈕。" class="headerlink" title="步驟二：填入名字、電子郵件、密碼後，按 CREATE A FREE ACCOUNT 按鈕。"></a>步驟二：填入名字、電子郵件、密碼後，按 CREATE A FREE ACCOUNT 按鈕。</h3><p><img src="https://hackmd.io/_uploads/HJDaGFZVA.png" alt="image"></p><blockquote><p><a href="https://app.infura.io/register">https://app.infura.io/register</a></p></blockquote><p>這邊的密碼要包含大小寫跟特殊符號</p><h3 id="步驟三-驗證Email，infura-會寄送一封驗證信到你的email"><a href="#步驟三-驗證Email，infura-會寄送一封驗證信到你的email" class="headerlink" title="步驟三: 驗證Email，infura 會寄送一封驗證信到你的email"></a>步驟三: 驗證Email，infura 會寄送一封驗證信到你的email</h3><p><img src="https://hackmd.io/_uploads/SkvuQYbVR.png" alt="image"></p><p>會收到像這樣一封信件<br><img src="https://hackmd.io/_uploads/B1ZYue7E0.png" alt="image"></p><h3 id="步驟四-完成驗證後填寫資料"><a href="#步驟四-完成驗證後填寫資料" class="headerlink" title="步驟四: 完成驗證後填寫資料"></a>步驟四: 完成驗證後填寫資料</h3><p>填寫一些資料像是 角色是什麼、是個人還是團隊使用<br><img src="https://hackmd.io/_uploads/rJfztl7NA.png" alt="image"></p><p>再來是填寫創造什麼樣的產品<br><img src="https://hackmd.io/_uploads/S1eIKlQ4R.png" alt="image"></p><p>選擇網域<br><img src="https://hackmd.io/_uploads/ryTdteX4R.png" alt="image"></p><p>選擇收費方案，這邊選擇免費方案<br><img src="https://hackmd.io/_uploads/HJ1otemEA.png" alt="image"></p><p>都填寫完成後會進入後台畫面<br><img src="https://hackmd.io/_uploads/rJk-cl7EA.png" alt="image"></p><h3 id="步驟五-取得-API-Key"><a href="#步驟五-取得-API-Key" class="headerlink" title="步驟五: 取得 API Key"></a>步驟五: 取得 API Key</h3><p>這邊點擊 My First Key 就可以看到 API Key<br><img src="https://hackmd.io/_uploads/B1S4ngXE0.png" alt="image"></p><h2 id="註冊-QuickNode-帳戶"><a href="#註冊-QuickNode-帳戶" class="headerlink" title="註冊 QuickNode 帳戶"></a>註冊 QuickNode 帳戶</h2><h3 id="步驟一-進入-QuickNode-官網，點選-Get-started"><a href="#步驟一-進入-QuickNode-官網，點選-Get-started" class="headerlink" title="步驟一: 進入 QuickNode 官網，點選 Get started"></a>步驟一: 進入 QuickNode 官網，點選 Get started</h3><p><img src="https://hackmd.io/_uploads/B1hstQ7VC.png" alt="image"></p><blockquote><p><a href="https://www.quicknode.com/">https://www.quicknode.com/</a></p></blockquote><h3 id="步驟二-填入姓名、email、密碼-或是選擇連結Google-帳號按Create-a-free-account"><a href="#步驟二-填入姓名、email、密碼-或是選擇連結Google-帳號按Create-a-free-account" class="headerlink" title="步驟二: 填入姓名、email、密碼 或是選擇連結Google 帳號按Create a free account"></a>步驟二: 填入姓名、email、密碼 或是選擇連結Google 帳號按Create a free account</h3><p><img src="https://hackmd.io/_uploads/rys25XQNA.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SkQ0qXmNR.png" alt="image"></p><h3 id="步驟三-驗證Email-信箱"><a href="#步驟三-驗證Email-信箱" class="headerlink" title="步驟三: 驗證Email 信箱"></a>步驟三: 驗證Email 信箱</h3><p><img src="https://hackmd.io/_uploads/HJRwvz4NA.png" alt="image"></p><p>會收到這樣一封驗證信件，點擊 Verify Your Account 進行驗證<br><img src="https://hackmd.io/_uploads/B1mqPz4V0.png" alt="image"></p><h3 id="步驟四-填寫相關資料"><a href="#步驟四-填寫相關資料" class="headerlink" title="步驟四: 填寫相關資料"></a>步驟四: 填寫相關資料</h3><p>想要開發什麼樣的產品?<br><img src="https://hackmd.io/_uploads/rJmkuMEER.png" alt="image"></p><p>填寫完成後就可以進入後團管理畫面<br><img src="https://hackmd.io/_uploads/BJT-dGV4C.png" alt="image"></p><h3 id="步驟五-取得-API-KEY"><a href="#步驟五-取得-API-KEY" class="headerlink" title="步驟五: 取得 API KEY"></a>步驟五: 取得 API KEY</h3><p>點選 Get started<br><img src="https://hackmd.io/_uploads/SkV5KfV4R.png" alt="image"></p><p>選擇要使用的網域後按 Continue<br><img src="https://hackmd.io/_uploads/rJBnKM4EA.png" alt="image"></p><p>這邊可以選擇 Sepolia 測試鏈<br><img src="https://hackmd.io/_uploads/BJ4gcG4EC.png" alt="image"></p><p>選擇方案<br><img src="https://hackmd.io/_uploads/rJerqzN4R.png" alt="image"></p><p>這邊我選擇免費的方案<br><img src="https://hackmd.io/_uploads/ryxQjfEVA.png" alt="image"></p><p>選擇是個人使用還是商用<br><img src="https://hackmd.io/_uploads/HJd4izNVC.png" alt="image"></p><p>商用需要填入公司資訊<br><img src="https://hackmd.io/_uploads/ByynozE4C.png" alt="image"></p><p>個人使用需要填入個人姓名地址<br><img src="https://hackmd.io/_uploads/H1p12GVER.png" alt="image"></p><p>填入信用卡資料<br><img src="https://hackmd.io/_uploads/H1l7pfEE0.png" alt="image"></p><p>完成後按Create endpoint<br><img src="https://hackmd.io/_uploads/BkCO6fEVC.png" alt="image"></p><p>完成後就能取得 Api Key<br><img src="https://hackmd.io/_uploads/BJbkAfEE0.png" alt="image"></p><h2 id="註冊-Chainstack-帳戶"><a href="#註冊-Chainstack-帳戶" class="headerlink" title="註冊 Chainstack 帳戶"></a>註冊 Chainstack 帳戶</h2><h3 id="步驟一-進入-Chainstack-官網，點選-Start-now-for-free"><a href="#步驟一-進入-Chainstack-官網，點選-Start-now-for-free" class="headerlink" title="步驟一: 進入 Chainstack 官網，點選 Start now for free"></a>步驟一: 進入 Chainstack 官網，點選 Start now for free</h3><p><img src="https://hackmd.io/_uploads/B1Qj1XVE0.png" alt="image"></p><blockquote><p><a href="https://chainstack.com/">https://chainstack.com/</a></p></blockquote><h3 id="步驟二-填入名字、電子郵件、密碼-也可以選擇連結-Google-或是-github-等等-，後，按-Sign-Up"><a href="#步驟二-填入名字、電子郵件、密碼-也可以選擇連結-Google-或是-github-等等-，後，按-Sign-Up" class="headerlink" title="步驟二:填入名字、電子郵件、密碼(也可以選擇連結 Google 或是 github 等等)，後，按 Sign Up"></a>步驟二:填入名字、電子郵件、密碼(也可以選擇連結 Google 或是 github 等等)，後，按 Sign Up</h3><p><img src="https://hackmd.io/_uploads/HJmzxQNNC.png" alt="image"></p><h3 id="步驟三-填寫相關資料"><a href="#步驟三-填寫相關資料" class="headerlink" title="步驟三: 填寫相關資料"></a>步驟三: 填寫相關資料</h3><p>填入開發的產品是什麼<br><img src="https://hackmd.io/_uploads/SJ1IxXV4R.png" alt="image"></p><p>填入團隊規模<br><img src="https://hackmd.io/_uploads/By9Kx7EEA.png" alt="image"></p><p>填入開發角色<br><img src="https://hackmd.io/_uploads/SkWjg7V40.png" alt="image"></p><h3 id="步驟四-取得API-Key"><a href="#步驟四-取得API-Key" class="headerlink" title="步驟四: 取得API Key"></a>步驟四: 取得API Key</h3><p>點選專案<br><img src="https://hackmd.io/_uploads/H1p1WQVEC.png" alt="image"></p><p>點選 Explore all node options<br><img src="https://hackmd.io/_uploads/SkYLZXEEA.png" alt="image"></p><p>選擇 Ethereum<br><img src="https://hackmd.io/_uploads/Skn9b7E4C.png" alt="image"></p><p>再點選Ethereum Sepolia Testnet 後按Next 創建<br><img src="https://hackmd.io/_uploads/BksaWQE4C.png" alt="image"></p><p>可以填入節點名稱，這邊我先使用預設的名稱然後按Next<br><img src="https://hackmd.io/_uploads/S1--fQVEA.png" alt="image"></p><p>再來確認後沒問題按 Join network<br><img src="https://hackmd.io/_uploads/SyvIfQNV0.png" alt="image"></p><p>成功創建的節點<br><img src="https://hackmd.io/_uploads/rJk9fXE40.png" alt="image"></p><p>點選進去可以看到詳細資訊<br><img src="https://hackmd.io/_uploads/Bkg2QXE4C.png" alt="image"></p><p>往下滑到 Access and credentials 可以看到 API KEY<br><img src="https://hackmd.io/_uploads/Sk5yN7NVA.png" alt="image"></p><h3 id="步驟五-連結到MetaMask小狐狸"><a href="#步驟五-連結到MetaMask小狐狸" class="headerlink" title="步驟五: 連結到MetaMask小狐狸"></a>步驟五: 連結到MetaMask小狐狸</h3><p>點擊 Add to MetaMask 可以連結到小狐狸，小狐狸會挑出來<br><img src="https://hackmd.io/_uploads/Sk5yN7NVA.png" alt="image"></p><p>按下一頁<br><img src="https://hackmd.io/_uploads/SyGzNXVE0.png" alt="image"></p><p>點選連線<br><img src="https://hackmd.io/_uploads/r1im4mEN0.png" alt="image"></p><p>點選批准<br><img src="https://hackmd.io/_uploads/B1MUVmNNC.png" alt="image"></p><p>點選切換網路<br><img src="https://hackmd.io/_uploads/rkNDNmEVC.png" alt="image"></p><h1 id="結尾"><a href="#結尾" class="headerlink" title="結尾"></a>結尾</h1><p>以上就是目前較熱門區塊鏈結點商的介紹與比較還有完整的註冊與取得API Key 方式，目前看使用教學都是infura 比較多所以感覺Infura 是最熱門的，有興趣大家也可以自己嘗試註冊使用看看，開發區塊鏈應用時可以使用得到。</p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="https://infura.io/">Infura</a></li><li><a href="https://www.alchemy.com/">Alchemy</a></li><li><a href="https://www.quicknode.com/">QuickNode</a></li><li><a href="https://chainstack.com/">Chainstack</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Web3/">Web3</category>
      
      <category domain="https://gahgah147.github.io/tags/Block-Chain/">Block Chain</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88%E7%AF%80%E9%BB%9E%E5%95%86/">區塊鏈節點商</category>
      
      <category domain="https://gahgah147.github.io/tags/Infura/">Infura</category>
      
      <category domain="https://gahgah147.github.io/tags/Alchemy/">Alchemy</category>
      
      <category domain="https://gahgah147.github.io/tags/QuickNode/">QuickNode</category>
      
      <category domain="https://gahgah147.github.io/tags/Chainstack/">Chainstack</category>
      
      
      <comments>https://gahgah147.github.io/2024/05/29/%E5%8D%80%E5%A1%8A%E9%8F%88-%E5%8D%80%E5%A1%8A%E9%8F%88%E7%AF%80%E9%BB%9E%E5%95%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>區塊鏈 - ERC20 介紹</title>
      <link>https://gahgah147.github.io/2024/05/21/%E5%8D%80%E5%A1%8A%E9%8F%88-ERC20-%E4%BB%8B%E7%B4%B9/</link>
      <guid>https://gahgah147.github.io/2024/05/21/%E5%8D%80%E5%A1%8A%E9%8F%88-ERC20-%E4%BB%8B%E7%B4%B9/</guid>
      <pubDate>Tue, 21 May 2024 02:34:57 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;區塊鏈-ERC20-介紹&quot;&gt;&lt;a href=&quot;#區塊鏈-ERC20-介紹&quot; class=&quot;headerlink&quot; title=&quot;區塊鏈 - ERC20 介紹&quot;&gt;&lt;/a&gt;區塊鏈 - ERC20 介紹&lt;/h1&gt;&lt;h1 id=&quot;ERC-20-是什麼&quot;&gt;&lt;a href=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="區塊鏈-ERC20-介紹"><a href="#區塊鏈-ERC20-介紹" class="headerlink" title="區塊鏈 - ERC20 介紹"></a>區塊鏈 - ERC20 介紹</h1><h1 id="ERC-20-是什麼"><a href="#ERC-20-是什麼" class="headerlink" title="ERC 20 是什麼?"></a>ERC 20 是什麼?</h1><p>ERC20 是以太坊區塊鏈上代幣標準的一種協議，為智能合約提供了統一的介面，使得各種代幣能夠在不同的去中心化應用（DApps）中互操作。這個標準包含了一組必要的方法，使得代幣的創建和交易變得一致且容易。</p><p>“ERC” 的全名是 “Ethereum Request for Comment”，中文翻譯是 “以太坊徵集修正意見書”。ERC 是以太坊社群用來提出和討論改進提案的標準。這些提案通常涉及智能合約標準、應用程序介面（API）或協議的改進。</p><p>其中，ERC20 是最著名的一個標準，定義了在以太坊區塊鏈上實現可互操作的代幣所需的基本介面。這個標準使得各種代幣能夠在不同的去中心化應用中方便地進行交易和互操作。</p><p>此外，還有其他一些常見的 ERC 標準，例如：</p><p>ERC721：非同質化代幣（NFT）的標準，適用於獨特的資產如收藏品、遊戲內物品等。<br>ERC1155：多代幣標準，允許單一合約中管理多種代幣，包括同質化代幣和非同質化代幣。</p><h2 id="ERC20-標準的關鍵方法"><a href="#ERC20-標準的關鍵方法" class="headerlink" title="ERC20 標準的關鍵方法"></a>ERC20 標準的關鍵方法</h2><ol><li><p><strong>totalSupply</strong>:  在不需要支付 ETH 礦工費的情況下查詢代幣的總供應量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function totalSupply() external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p><strong>balanceOf</strong>: 查詢指定地址擁有的代幣數量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address account) external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p><strong>transfer</strong>: 從調用者的賬戶轉移指定數量的代幣到目標地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address recipient, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li><li><p><strong>allowance</strong>: 查詢代幣所有者允許花費者花費的剩餘代幣數量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function allowance(address owner, address spender) external view returns (uint256);</span><br></pre></td></tr></table></figure></li><li><p><strong>approve</strong>: 允許指定的花費者從調用者的賬戶中提取代幣。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function approve(address spender, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li><li><p><strong>transferFrom</strong>: 從一個賬戶轉移指定數量的代幣到另一個賬戶，這個操作由有花費權限的賬戶調用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span><br></pre></td></tr></table></figure></li></ol><h2 id="ERC20-標準的事件"><a href="#ERC20-標準的事件" class="headerlink" title="ERC20 標準的事件"></a>ERC20 標準的事件</h2><ol><li><p><strong>Transfer</strong>: 在代幣轉移時觸發。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br></pre></td></tr></table></figure></li><li><p><strong>Approval</strong>: 在代幣所有者批准花費者可以花費的代幣數量變更時觸發。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Approval(address indexed owner, address indexed spender, uint256 value);</span><br></pre></td></tr></table></figure></li></ol><h1 id="實作練習"><a href="#實作練習" class="headerlink" title="實作練習"></a>實作練習</h1><h2 id="開發-ERC20-Metadata-sol"><a href="#開發-ERC20-Metadata-sol" class="headerlink" title="開發 ERC20_Metadata.sol"></a>開發 ERC20_Metadata.sol</h2><p>這個練習是可以讓我們部屬自己的ERC20 代幣，可以自己取代幣名字、跟代幣簡稱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20Metadata &#123;</span><br><span class="line">    function name() external view returns (string memory); // 代幣名稱</span><br><span class="line">    function symbol() external view returns (string memory); // 代幣符號</span><br><span class="line">    function decimals() external view returns (uint8); // 代幣小數點位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20Metadata &#123;</span><br><span class="line">    string _name;</span><br><span class="line">    string _symbol;</span><br><span class="line"></span><br><span class="line">    constructor(string memory name_, string memory symbol_) &#123;</span><br><span class="line">        _name = name_;</span><br><span class="line">        _symbol = symbol_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查詢代幣名稱</span><br><span class="line">    function name() public view returns (string memory) &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查詢代幣符號</span><br><span class="line">    function symbol() public view returns (string memory) &#123;</span><br><span class="line">        return _symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 代幣小數點位置</span><br><span class="line">    function decimals() public pure returns (uint8) &#123;</span><br><span class="line">        return 18;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Sy141FFQ0.png" alt="image"></p><h3 id="部屬"><a href="#部屬" class="headerlink" title="部屬"></a>部屬</h3><p><img src="https://hackmd.io/_uploads/r1yOkFtmC.png" alt="image"></p><p>在部屬的時候填入name、symbol可以進行部屬</p><p><img src="https://hackmd.io/_uploads/rkU3ytYmA.png" alt="image"></p><p>成功部屬結果</p><h2 id="鑄造-Mint-和燒毀-Burn-新代幣"><a href="#鑄造-Mint-和燒毀-Burn-新代幣" class="headerlink" title="鑄造(Mint)和燒毀(Burn)新代幣"></a>鑄造(Mint)和燒毀(Burn)新代幣</h2><p><img src="https://hackmd.io/_uploads/SyhpcaKXA.png" alt="image"></p><p>這個實作例子我們可以鑄造新代幣跟燒毀新代幣，並且有以下功能</p><ul><li>只有部屬合約的人才可以鑄造&#x2F;燃燒代幣</li><li>轉帳的合約不能是address(0)</li><li>鑄造&#x2F;燃燒代幣時，總發行量也會增加&#x2F;減少。</li><li>指定某帳戶增加&#x2F;銷毀代幣</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool);</span><br><span class="line">    function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line">    function approve(address spender, uint256 value) external returns (bool);</span><br><span class="line">    function transferFrom(address from, address to, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">    function mint(address account, uint256 value) external;</span><br><span class="line">    function burn(address account, uint256 value) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line">    address private _owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        _totalSupply = 10000;  // 總發行量: 10000 個token</span><br><span class="line">        _balances[msg.sender] = 10000;  // 將以太幣持有者的賬戶新增10000 顆token</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier checkOwner() &#123;</span><br><span class="line">        require(_owner == msg.sender, unicode&quot;不是合約擁有者&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() external view override returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) external view override returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) external override returns (bool) &#123;</span><br><span class="line">        require(_balances[msg.sender] &gt;= value, unicode&quot;餘額不足&quot;);</span><br><span class="line">        _balances[msg.sender] -= value;</span><br><span class="line">        _balances[to] += value;</span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) external view override returns (uint256) &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) external override returns (bool) &#123;</span><br><span class="line">        _allowances[msg.sender][spender] = value;</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) external override returns (bool) &#123;</span><br><span class="line">        require(_balances[from] &gt;= value, unicode&quot;餘額不足&quot;);</span><br><span class="line">        require(_allowances[from][msg.sender] &gt;= value, unicode&quot;許可權不足&quot;);</span><br><span class="line">        _balances[from] -= value;</span><br><span class="line">        _balances[to] += value;</span><br><span class="line">        _allowances[from][msg.sender] -= value;</span><br><span class="line">        emit Transfer(from, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address account, uint256 value) external override checkOwner &#123;</span><br><span class="line">        require(account != address(0), unicode&quot;address不能是0x0&quot;);  // 檢查帳戶不能是0x0</span><br><span class="line">        _totalSupply += value;  // 增加總發行量</span><br><span class="line">        _balances[account] += value;  // 增加目標賬戶餘額</span><br><span class="line">        emit Transfer(address(0), account, value);  // 無中生有(address(0)=&gt;account): (address(0), 指定帳戶, 多少代幣)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(address account, uint256 value) external override checkOwner &#123;</span><br><span class="line">        uint256 accountBalance = _balances[account];  // 確認賬戶餘額</span><br><span class="line">        require(account != address(0), unicode&quot;address不能是0x0&quot;);  // 檢查帳戶不能是0x0</span><br><span class="line">        require(accountBalance &gt;= value, unicode&quot;餘額不足&quot;);  // 檢查餘額夠不夠燒毀</span><br><span class="line">        _balances[account] = accountBalance - value;  // 指定賬戶銷毀代幣</span><br><span class="line">        _totalSupply = _totalSupply - value;  // 總發行量也會跟著減少</span><br><span class="line">        emit Transfer(account, address(0), value);  // 回歸虛無(account=&gt;address(0)): (指定賬戶, address(0), 多少代幣)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rJxuSpt70.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SyrKSTF7R.png" alt="image"></p><h3 id="部屬-1"><a href="#部屬-1" class="headerlink" title="部屬"></a>部屬</h3><p>測試鑄造 10000<br><img src="https://hackmd.io/_uploads/SkZbzpKXC.png" alt="image"></p><p>測試查詢餘額會增加<br><img src="https://hackmd.io/_uploads/HJ6hzptQ0.png" alt="image"></p><p>測試燒毀 1000<br><img src="https://hackmd.io/_uploads/SkcbHaYmA.png" alt="image"></p><p>測試查詢餘額會減少<br><img src="https://hackmd.io/_uploads/r1_QBpK70.png" alt="image"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/ETH/">ETH</category>
      
      <category domain="https://gahgah147.github.io/tags/Solidity/">Solidity</category>
      
      <category domain="https://gahgah147.github.io/tags/ERC20/">ERC20</category>
      
      <category domain="https://gahgah147.github.io/tags/Web3/">Web3</category>
      
      
      <comments>https://gahgah147.github.io/2024/05/21/%E5%8D%80%E5%A1%8A%E9%8F%88-ERC20-%E4%BB%8B%E7%B4%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Gnosis Safe 多簽核錢包使用紀錄</title>
      <link>https://gahgah147.github.io/2024/05/17/Gnosis-Safe-%E5%A4%9A%E7%B0%BD%E6%A0%B8%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E7%B4%80%E9%8C%84/</link>
      <guid>https://gahgah147.github.io/2024/05/17/Gnosis-Safe-%E5%A4%9A%E7%B0%BD%E6%A0%B8%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E7%B4%80%E9%8C%84/</guid>
      <pubDate>Fri, 17 May 2024 07:08:07 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Gnosis-Safe-多簽核錢包使用紀錄&quot;&gt;&lt;a href=&quot;#Gnosis-Safe-多簽核錢包使用紀錄&quot; class=&quot;headerlink&quot; title=&quot;Gnosis Safe 多簽核錢包使用紀錄&quot;&gt;&lt;/a&gt;Gnosis Safe 多簽核錢包使用紀錄&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Gnosis-Safe-多簽核錢包使用紀錄"><a href="#Gnosis-Safe-多簽核錢包使用紀錄" class="headerlink" title="Gnosis Safe 多簽核錢包使用紀錄"></a>Gnosis Safe 多簽核錢包使用紀錄</h1><p><img src="https://hackmd.io/_uploads/BJLUKwNmA.png" alt="image"></p><h2 id="什麼是-多簽核錢包-Multi-sig-Wallet"><a href="#什麼是-多簽核錢包-Multi-sig-Wallet" class="headerlink" title="什麼是 多簽核錢包 - Multi-sig Wallet"></a>什麼是 多簽核錢包 - Multi-sig Wallet</h2><p>多簽核錢包（Multi-sig Wallet）是一種加密貨幣錢包，它需要多個簽名（多個人或設備的授權）才能執行交易。<br>這樣的設計提高了資金的安全性和管理的靈活性。簡單來說，這種錢包類似於銀行的聯名帳戶，需要多方同意(例如公司老闆、會計同意後)才能使用資金。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>多重簽名：交易需要多個授權（如2個或3個）才能完成，而不是單一的私鑰。</li><li>增加安全性：即使某一個私鑰被盜，黑客無法單獨轉移資金。</li><li>協作管理：適合團隊或公司共同管理資金，防止單人濫用權力。</li></ul><h3 id="應用情境"><a href="#應用情境" class="headerlink" title="應用情境"></a>應用情境</h3><ul><li>家庭理財：夫妻共同管理，避免單方面亂花錢。</li><li>公司財務：需要多個主管批准，確保每筆開支都經過審核。</li><li>合作投資：投資者共同管理資金，確保透明和安全。</li></ul><h2 id="Multi-sig-Wallet-的用途"><a href="#Multi-sig-Wallet-的用途" class="headerlink" title="Multi-sig Wallet 的用途"></a>Multi-sig Wallet 的用途</h2><p>多簽核錢包（Multi-sig Wallet）的用途主要是提高資金的安全性和管理的靈活性。這種錢包需要多個簽名（多方授權）才能執行交易，確保資金不會被單一個人或設備濫用。</p><p>這樣的設計讓資金管理更安全、更透明，同時也降低了單一個人私鑰洩漏的風險。</p><h3 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h3><ul><li>防止盜竊：即使黑客獲得了一個私鑰，也無法單獨轉移資金，因為需要多個簽名。</li><li>分散風險：多個私鑰存放在不同地方或由不同人管理，減少單點故障風險。</li></ul><h3 id="團隊管理"><a href="#團隊管理" class="headerlink" title="團隊管理"></a>團隊管理</h3><ul><li>公司財務：公司可以設置多個主管需要共同批准才能執行資金轉移，確保每筆開支都經過審核。</li><li>合作投資：投資者可以共同管理投資資金，確保每筆交易都透明且經過多方同意。</li></ul><h3 id="家庭理財"><a href="#家庭理財" class="headerlink" title="家庭理財"></a>家庭理財</h3><ul><li>聯名帳戶：夫妻或家庭成員共同管理家庭資金，防止單方濫用。</li></ul><h3 id="智能合約"><a href="#智能合約" class="headerlink" title="智能合約"></a>智能合約</h3><ul><li>去中心化應用：在區塊鏈上的智能合約可以利用多簽核機制來確保合約執行的安全性和可靠性。</li></ul><h2 id="什麼是-Gnosis-Safe"><a href="#什麼是-Gnosis-Safe" class="headerlink" title="什麼是 Gnosis Safe"></a>什麼是 Gnosis Safe</h2><p>Gnosis Safe 是支援多條 EVM chains，也是目前市佔率最大，最受信任的一款智能合約錢包。<br><img src="https://hackmd.io/_uploads/BkgjKwEmR.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/B1KjYDN7A.png" alt="image"></p><blockquote><p>參考來源:<a href="https://johnny-chuang.medium.com/gnosis-safe-%E5%A4%9A%E7%B0%BD%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-aeed1b9b36bd">https://johnny-chuang.medium.com/gnosis-safe-%E5%A4%9A%E7%B0%BD%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-aeed1b9b36bd</a></p></blockquote><p>Gnosis Safe 是一種多簽錢包，提供高安全性並與多種硬件錢包和熱錢包相容。其核心功能之一是使用多簽名機制，例如常見的 2&#x2F;3 簽名機制。</p><p>這意味著在三個錢包中，至少需要兩個簽名才能執行交易。</p><p>這種設置顯著提高了安全性，即使其中一個熱錢包的私鑰被盜，駭客仍需要再取得一個冷錢包的私鑰才能完成交易，增加了攻擊難度。</p><p>此外，Gnosis Safe 可以輕鬆與 DeFi 協議交互，支援 ERC-721 和 ERC-1155 標準的 NFT tokens，使用戶在享有高安全性的同時，能順暢地進行鏈上交互和資產儲存。</p><p>這樣的設計確保了用戶資產的安全性和靈活性，非常適合需要高安全性的個人和團體使用。</p><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><h3 id="創建-Gnosis-Safe-Wallet"><a href="#創建-Gnosis-Safe-Wallet" class="headerlink" title="創建 Gnosis Safe Wallet"></a>創建 Gnosis Safe Wallet</h3><p>首先，先到 Gnosis Safe 的網站<br><img src="https://hackmd.io/_uploads/HyvpFv4QC.png" alt="image"></p><blockquote><p><a href="https://safe.global/wallet">https://safe.global/wallet</a></p></blockquote><p>點選 Launch Wallet<br><img src="https://hackmd.io/_uploads/SkKCFP4XR.png" alt="image"></p><p>點選 Connect wallet<br><img src="https://hackmd.io/_uploads/B1SJcv4XA.png" alt="image"></p><p>選擇 MetaMask<br><img src="https://hackmd.io/_uploads/rJpe9vE7A.png" alt="image"></p><p>接下來小狐狸會跳出來<br><img src="https://hackmd.io/_uploads/ryc5qDEQA.png" alt="image"></p><blockquote><p>點選下一頁</p></blockquote><p>選擇連線<br><img src="https://hackmd.io/_uploads/HkOJjPE70.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/B1BuiDNmR.png" alt="image"></p><p>這邊選擇好錢包名稱後按 Next<br><img src="https://hackmd.io/_uploads/HJX2iP4XA.png" alt="image"></p><p>這邊的 Signer 代表多簽核人員<br>Threshold 代表設定一筆交易需要多少個 confirmation 才會上到鏈上</p><p><img src="https://hackmd.io/_uploads/BkG_hw4m0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/H1y0hP4Q0.png" alt="image"></p><blockquote><p>小狐狸連動確認畫面</p></blockquote><p><img src="https://hackmd.io/_uploads/H1V-avE7C.png" alt="image"></p><blockquote><p>創建成功的畫面</p></blockquote><h1 id="這邊就是一個多簽核錢包"><a href="#這邊就是一個多簽核錢包" class="headerlink" title="這邊就是一個多簽核錢包"></a>這邊就是一個多簽核錢包</h1><p><img src="https://hackmd.io/_uploads/SyP8aPEQA.png" alt="image"></p><h1 id="測試出金"><a href="#測試出金" class="headerlink" title="測試出金"></a>測試出金</h1><p><img src="https://hackmd.io/_uploads/r1DeetEX0.png" alt="image"></p><blockquote><p>點選 Send 發起一筆出金</p></blockquote><p><img src="https://hackmd.io/_uploads/HyGNeYN7R.png" alt="image"></p><blockquote><p>這邊選擇Send Tokens</p></blockquote><p><img src="https://hackmd.io/_uploads/S19PeKVXA.png" alt="image"></p><blockquote><p>輸入地址與金額後點擊Sign發起出金</p></blockquote><p><img src="https://hackmd.io/_uploads/H1XaeKE70.png" alt="image"></p><blockquote><p>會跳出小狐狸確認畫面，選擇簽屬</p></blockquote><p><img src="https://hackmd.io/_uploads/HkVM-KE7C.png" alt="image"></p><blockquote><p>這邊可以看到簽核過程</p></blockquote><p><img src="https://hackmd.io/_uploads/r1_Bbt4mA.png" alt="image"></p><blockquote><p>滿足簽核條件後會進入交易流程</p></blockquote><p><img src="https://hackmd.io/_uploads/B1BFbFEXA.png" alt="image"></p><blockquote><p>交易成功可以瀏覽當時的交易紀錄</p></blockquote><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="https://johnny-chuang.medium.com/gnosis-safe-%E5%A4%9A%E7%B0%BD%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-aeed1b9b36bd">Gnosis Safe 多簽錢包使用教學</a></li><li><a href="https://nextrope.com/how-to-create-a-multisig-wallet-using-gnosis-safe/">Gnosis Safe 教程</a></li><li><a href="https://safe.global/">Gnosis Safe 官方網站</a></li><li><a href="https://www.coingecko.com/">CoinGecko 關於 Gnosis Safe 的介紹</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Gnosis-Safe/">Gnosis Safe</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%A4%9A%E7%B0%BD%E6%A0%B8/">多簽核</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/">區塊鏈</category>
      
      <category domain="https://gahgah147.github.io/tags/MetaMask/">MetaMask</category>
      
      
      <comments>https://gahgah147.github.io/2024/05/17/Gnosis-Safe-%E5%A4%9A%E7%B0%BD%E6%A0%B8%E9%8C%A2%E5%8C%85%E4%BD%BF%E7%94%A8%E7%B4%80%E9%8C%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IPFS介紹 - 星際檔案系統</title>
      <link>https://gahgah147.github.io/2024/05/16/IPFS%E4%BB%8B%E7%B4%B9-%E6%98%9F%E9%9A%9B%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1/</link>
      <guid>https://gahgah147.github.io/2024/05/16/IPFS%E4%BB%8B%E7%B4%B9-%E6%98%9F%E9%9A%9B%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1/</guid>
      <pubDate>Thu, 16 May 2024 08:15:34 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;IPFS介紹-星際檔案系統&quot;&gt;&lt;a href=&quot;#IPFS介紹-星際檔案系統&quot; class=&quot;headerlink&quot; title=&quot;IPFS介紹 - 星際檔案系統&quot;&gt;&lt;/a&gt;IPFS介紹 - 星際檔案系統&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://hack</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="IPFS介紹-星際檔案系統"><a href="#IPFS介紹-星際檔案系統" class="headerlink" title="IPFS介紹 - 星際檔案系統"></a>IPFS介紹 - 星際檔案系統</h1><p><img src="https://hackmd.io/_uploads/rkqS8qbmC.png" alt="image"></p><blockquote><p><a href="https://ipfs.tech/">https://ipfs.tech/</a></p></blockquote><p>IPFS（InterPlanetary File System）是一種分佈式的文件系統，旨在建立一個更快、更安全和更開放的互聯網。</p><p><a href="https://youtu.be/5Uj6uR3fp-U?si=LLShkmZ5JBewmt6Q">https://youtu.be/5Uj6uR3fp-U?si=LLShkmZ5JBewmt6Q</a></p><h2 id="IPFS的主要特點"><a href="#IPFS的主要特點" class="headerlink" title="IPFS的主要特點"></a>IPFS的主要特點</h2><h3 id="分佈式存儲"><a href="#分佈式存儲" class="headerlink" title="分佈式存儲"></a>分佈式存儲</h3><p>資料不是儲存在單一的伺服器上，而是分佈在全球許多節點上。這種方法提高了資料的冗餘度和可靠性。</p><h3 id="內容尋址"><a href="#內容尋址" class="headerlink" title="內容尋址"></a>內容尋址</h3><p>IPFS 使用內容尋址（Content Addressing）來存取資料，而不是傳統的基於位置的尋址方法。每個文件都有一個唯一的哈希值作為其地址。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>類似於Git，IPFS 支援資料的版本控制，這意味著每個文件的更改都可以被跟蹤和還原。</p><h3 id="點對點網絡"><a href="#點對點網絡" class="headerlink" title="點對點網絡"></a>點對點網絡</h3><p>IPFS 使用點對點（P2P）技術，允許用戶直接連接並共享資源，而不需要依賴中央伺服器。</p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>IPFS 的架構去除了對中心化伺服器的依賴，減少了單點故障的風險，並且提高了資料的可用性和抗審查性。</p><h2 id="IPFS-的主要用途"><a href="#IPFS-的主要用途" class="headerlink" title="IPFS 的主要用途"></a>IPFS 的主要用途</h2><h3 id="網站託管"><a href="#網站託管" class="headerlink" title="網站託管"></a>網站託管</h3><p>通過IPFS，網站可以以去中心化的方式託管，不再依賴單一伺服器，從而提高網站的穩定性和安全性。</p><h3 id="分佈式應用程式（dApps）"><a href="#分佈式應用程式（dApps）" class="headerlink" title="分佈式應用程式（dApps）"></a>分佈式應用程式（dApps）</h3><p>IPFS 常被用於支援去中心化應用程式，這些應用程式需要一個可靠的分佈式存儲解決方案。</p><h3 id="大文件共享"><a href="#大文件共享" class="headerlink" title="大文件共享"></a>大文件共享</h3><p>由於其高效的分塊和分發機制，IPFS 非常適合用來共享和存儲大文件。</p><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><h3 id="設定與啟動"><a href="#設定與啟動" class="headerlink" title="設定與啟動"></a>設定與啟動</h3><p>建立一個ipfs_test資料夾，結構如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipfs_test</span><br><span class="line">|_ staging</span><br><span class="line">|_ data</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/H18n2qW7A.png" alt="image"></p><p>staging 是準備要放即將要 export 出去的檔案的地方。</p><p>使用 docker 拉go-ipfs image 啟動，並指定檔案 export 的路徑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ipfs_staging=/absolute/path/to/&lt;staging的資料夾&gt;/</span><br><span class="line">export ipfs_data=/absolute/path/to/&lt;data的資料夾&gt;/</span><br><span class="line">docker run -d --name ipfs_host -v $ipfs_staging:/export -v $ipfs_data:/data/ipfs -p 4001:4001 -p 4001:4001/udp -p 127.0.0.1:8080:8080 -p 127.0.0.1:5001:5001 ipfs/go-ipfs:latest</span><br></pre></td></tr></table></figure><div class="note warning simple"><p>這邊我有遇到錯誤訊息<br><img src="https://hackmd.io/_uploads/SJLDPXQ7A.png" alt="image"></p><p>這個錯誤訊息表明在WSL 2中無法找到docker命令，這可能是因為Docker Desktop尚未與WSL 2整合或安裝。</p><p>要在WSL 2中使用Docker Desktop，需要先啟用WSL整合。請按照以下步驟操作：</p><p>1.打開Docker Desktop。<br><img src="https://hackmd.io/_uploads/B1ScPXmQR.png" alt="image"></p><p>2.點擊左上角的Docker圖標，選擇”Settings”。<br><img src="https://hackmd.io/_uploads/BkxjPXXQ0.png" alt="image"></p><p>3.在”Resources”-&gt;”WSL integration”部分，勾選”Enable integration with my default WSL distro” 並且也把”Ubuntu-20.04”這邊的開關打開。<br><img src="https://hackmd.io/_uploads/r15pPXQ7A.png" alt="image"></p><p>4.點擊”Apply &amp; Restart”來應用更改。<br>完成這些步驟後，Docker Desktop將啟用WSL 2整合並重啟。然後，你應該能夠在WSL 2中使用docker命令來運行容器。</p></div><p>如果要監看 logs，可以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f ipfs_host</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SkKaT7Qm0.png" alt="image"></p><p>進入 container 做事：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ipfs_host /bin/sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1Yy0Qm70.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HkqbRXmQR.png" alt="image"><br>這邊可以發現開啟了3個docker</p><p>啟動後可以查看介面<br><img src="https://hackmd.io/_uploads/BkFO0QQ7R.png" alt="image"></p><blockquote><p><a href="http://localhost:5001/webui">http://localhost:5001/webui</a></p></blockquote><h3 id="將檔案上傳至-IPFS"><a href="#將檔案上傳至-IPFS" class="headerlink" title="將檔案上傳至 IPFS"></a>將檔案上傳至 IPFS</h3><p>進入 container 後，把檔案（這裡以 測試檔案 xlsx 為例）丟到本地的 staging 資料夾，下 export指令把它上傳到 ipfs 並取得 hash 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ipfs_host /bin/sh</span><br><span class="line">ipfs add -r /export/</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/H1GC7Vm7A.png" alt="image"></p><p>上傳完後會取得 ipfs-hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">added QmaEa7JhzR6qpFZpRNRecKsAsf1tqzAJKktXxQ6tE4iTPf export/test0050.xlsx</span><br><span class="line">added QmUELrk81uAbSsEj4r9XHUtUov7GDLMnTyiVXeCSSoK98o export</span><br></pre></td></tr></table></figure><h3 id="用-ipfs-hash-去查看檔案"><a href="#用-ipfs-hash-去查看檔案" class="headerlink" title="用 ipfs-hash 去查看檔案"></a>用 ipfs-hash 去查看檔案</h3><p>查看剛剛丟的檔案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs cat /ipfs/QmaEa7JhzR6qpFZpRNRecKsAsf1tqzAJKktXxQ6tE4iTPf</span><br></pre></td></tr></table></figure><p>也可以從這邊查看 <a href="http://127.0.0.1:8080/ipfs/QmaEa7JhzR6qpFZpRNRecKsAsf1tqzAJKktXxQ6tE4iTPf">http://127.0.0.1:8080/ipfs/QmaEa7JhzR6qpFZpRNRecKsAsf1tqzAJKktXxQ6tE4iTPf</a></p><blockquote><p>這邊會直接下載下來</p></blockquote><h3 id="其他常用指令"><a href="#其他常用指令" class="headerlink" title="其他常用指令"></a>其他常用指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看 log</span><br><span class="line">docker logs -f ipfs_host</span><br><span class="line"></span><br><span class="line"># 停止容器</span><br><span class="line">docker stop ipfs_host</span><br><span class="line"></span><br><span class="line"># 查看內容</span><br><span class="line">ipfs cat /ipfs/QmV3LyHokfUH1kp94Nrxn8q1E8p95Kt9kfKfJSUpXsGc6Q</span><br><span class="line"></span><br><span class="line"># docker exec ipfs_host [指令]</span><br><span class="line">docker exec ipfs_host ipfs add -r /export/</span><br></pre></td></tr></table></figure><h2 id="把-node-連結到-IPFS-network"><a href="#把-node-連結到-IPFS-network" class="headerlink" title="把 node 連結到 IPFS network"></a>把 node 連結到 IPFS network</h2><p>查詢自己的 id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs id</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BJfg84QQC.png" alt="image"></p><p>介面這邊也可以查看到節點ID<br><img src="https://hackmd.io/_uploads/rJ0fUVQ7R.png" alt="image"></p><p>尋找其他的 peers</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs swarm peers</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJO5L4m7R.png" alt="image"></p><p>圖形化介面查看方式:<br><img src="https://hackmd.io/_uploads/HynoLV77C.png" alt="image"></p><h2 id="查看別人的檔案"><a href="#查看別人的檔案" class="headerlink" title="查看別人的檔案"></a>查看別人的檔案</h2><p>可以透過自己的 IPFS 節點造訪別人的檔案內容。我們來看看被 IPFS 團隊放上 IPFS 網絡的土耳其文維基百科 snapshot！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs cat Qme2sLfe9ZMdiuWsEtajWMDzx6B7VbjzpSC2VWhtB6GoB1/wiki/Peer-to-peer.html </span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rJp-v47m0.png" alt="image"></p><p>查看土耳其文維基百科部分的檔案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs ls Qme2sLfe9ZMdiuWsEtajWMDzx6B7VbjzpSC2VWhtB6GoB1/wiki/Anasayfa.html</span><br></pre></td></tr></table></figure><h2 id="IPFS-操作介面"><a href="#IPFS-操作介面" class="headerlink" title="IPFS 操作介面"></a>IPFS 操作介面</h2><h3 id="首頁"><a href="#首頁" class="headerlink" title="首頁"></a>首頁</h3><p><img src="https://hackmd.io/_uploads/r1vU_EXmC.png" alt="image"></p><h3 id="檔案"><a href="#檔案" class="headerlink" title="檔案"></a>檔案</h3><p><img src="https://hackmd.io/_uploads/H1vDu4m7R.png" alt="image"></p><h3 id="瀏覽"><a href="#瀏覽" class="headerlink" title="瀏覽"></a>瀏覽</h3><p><img src="https://hackmd.io/_uploads/ByVddVmX0.png" alt="image"></p><h3 id="用戶群"><a href="#用戶群" class="headerlink" title="用戶群"></a>用戶群</h3><p><img src="https://hackmd.io/_uploads/S1wYuV7X0.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/By0q_VXmA.png" alt="image"></p><h3 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h3><p><img src="https://hackmd.io/_uploads/Hk53u47mC.png" alt="image"></p><p>這邊我發現實際操作已經跟教學文章比較起來有更新很多畫面了。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這一篇是我在網路上看到這篇教學文章<br><a href="https://medium.com/wenchin-rolls-around/%E8%A9%A6%E7%8E%A9-ipfs-a69a52abb954">https://medium.com/wenchin-rolls-around/%E8%A9%A6%E7%8E%A9-ipfs-a69a52abb954</a></p><p>跟著實際操作的紀錄，這邊有官方介紹文件 <a href="https://docs.ipfs.tech/concepts/usage-ideas-examples/">https://docs.ipfs.tech/concepts/usage-ideas-examples/</a> 有興趣可以繼續研究，另外還有其他人開發的 IPFS 相關應用 <a href="https://github.com/ipfs/awesome-ipfs">https://github.com/ipfs/awesome-ipfs</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/">區塊鏈</category>
      
      <category domain="https://gahgah147.github.io/tags/IPFS/">IPFS</category>
      
      <category domain="https://gahgah147.github.io/tags/%E6%98%9F%E9%9A%9B%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1/">星際檔案系統</category>
      
      <category domain="https://gahgah147.github.io/tags/Filecoin/">Filecoin</category>
      
      
      <comments>https://gahgah147.github.io/2024/05/16/IPFS%E4%BB%8B%E7%B4%B9-%E6%98%9F%E9%9A%9B%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Amazon Lightsail + Wordpress自架站教學</title>
      <link>https://gahgah147.github.io/2024/05/10/Amazon-Lightsail-Wordpress%E8%87%AA%E6%9E%B6%E7%AB%99%E6%95%99%E5%AD%B8/</link>
      <guid>https://gahgah147.github.io/2024/05/10/Amazon-Lightsail-Wordpress%E8%87%AA%E6%9E%B6%E7%AB%99%E6%95%99%E5%AD%B8/</guid>
      <pubDate>Fri, 10 May 2024 07:42:22 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Amazon-Lightsail-Wordpress自架站教學&quot;&gt;&lt;a href=&quot;#Amazon-Lightsail-Wordpress自架站教學&quot; class=&quot;headerlink&quot; title=&quot;Amazon Lightsail + Wordpress自架</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Amazon-Lightsail-Wordpress自架站教學"><a href="#Amazon-Lightsail-Wordpress自架站教學" class="headerlink" title="Amazon Lightsail + Wordpress自架站教學"></a>Amazon Lightsail + Wordpress自架站教學</h1><p>這篇是我看到youtube 毛巾的教學影片跟著操作的紀錄<br><a href="https://youtu.be/ufmCi7pMgKU?si=DG0bd_pwWzb20Lj5">https://youtu.be/ufmCi7pMgKU?si=DG0bd_pwWzb20Lj5</a></p><h1 id="Amazon"><a href="#Amazon" class="headerlink" title="Amazon"></a>Amazon</h1><p>註冊AWS 帳號</p><h1 id="Amazon-Lightsail"><a href="#Amazon-Lightsail" class="headerlink" title="Amazon Lightsail"></a>Amazon Lightsail</h1><p><img src="https://hackmd.io/_uploads/rJDljZsfR.png" alt="image"></p><blockquote><p>點選Create Instance 創建 instance</p></blockquote><p><img src="https://hackmd.io/_uploads/rkvLoZszA.png" alt="image"></p><blockquote><p>伺服器地區選擇比較近的東京</p></blockquote><p><img src="https://hackmd.io/_uploads/SkrjobiGA.png" alt="image"></p><blockquote><p>選擇Wordpress</p></blockquote><p><img src="https://hackmd.io/_uploads/SylBn-ozC.png" alt="image"></p><blockquote><p>這邊選擇最便宜的5塊錢方案</p></blockquote><p><img src="https://hackmd.io/_uploads/S1FdnZofC.png" alt="image"></p><blockquote><p>取名 這邊我取NalsonBlog</p></blockquote><p>大概等個兩分鐘就建置好了</p><p><img src="https://hackmd.io/_uploads/Bk2anbizR.png" alt="image"></p><blockquote><p>建置完成的畫面</p></blockquote><p><img src="https://hackmd.io/_uploads/rywaTZifC.png" alt="image"></p><blockquote><p>這邊可以看到我們成功建立好的WordPress 網頁模板</p></blockquote><h1 id="進入WordPress-更改後台設定"><a href="#進入WordPress-更改後台設定" class="headerlink" title="進入WordPress 更改後台設定"></a>進入WordPress 更改後台設定</h1><p><a href="https://docs.aws.amazon.com/zh_tw/lightsail/latest/userguide/log-in-to-your-bitnami-application-running-on-amazon-lightsail.html">https://docs.aws.amazon.com/zh_tw/lightsail/latest/userguide/log-in-to-your-bitnami-application-running-on-amazon-lightsail.html</a></p><p>上面這篇文章教學很詳細</p><p><img src="https://hackmd.io/_uploads/SkaRezozR.png" alt="image"><br>點選 連結圖示 SSH 用戶端視窗會開啟，如以下範例所示。</p><p><img src="https://hackmd.io/_uploads/H1xmWfiGA.png" alt="image"></p><p>請輸入如下命令以擷取預設應用程式密碼：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bitnami_application_password</span><br></pre></td></tr></table></figure><h2 id="登入WordPress後台管理"><a href="#登入WordPress後台管理" class="headerlink" title="登入WordPress後台管理"></a>登入WordPress後台管理</h2><p><img src="https://hackmd.io/_uploads/ryNaWMsM0.png" alt="image"></p><p>可以先將語言改成中文<br><img src="https://hackmd.io/_uploads/By9mzMoGR.png" alt="image"></p><p>再來可以選擇喜歡的佈景主題<br><img src="https://hackmd.io/_uploads/HkfvfMiz0.png" alt="image"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/AWS/">AWS</category>
      
      <category domain="https://gahgah147.github.io/tags/AWS-Lightsail/">AWS Lightsail</category>
      
      <category domain="https://gahgah147.github.io/tags/Wordpress/">Wordpress</category>
      
      
      <comments>https://gahgah147.github.io/2024/05/10/Amazon-Lightsail-Wordpress%E8%87%AA%E6%9E%B6%E7%AB%99%E6%95%99%E5%AD%B8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker-compose 問題排除: version is obsolete </title>
      <link>https://gahgah147.github.io/2024/04/19/Docker-compose-%E5%95%8F%E9%A1%8C%E6%8E%92%E9%99%A4-is-obsolete/</link>
      <guid>https://gahgah147.github.io/2024/04/19/Docker-compose-%E5%95%8F%E9%A1%8C%E6%8E%92%E9%99%A4-is-obsolete/</guid>
      <pubDate>Fri, 19 Apr 2024 03:43:09 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Docker-compose-問題排除-version-is-obsolete&quot;&gt;&lt;a href=&quot;#Docker-compose-問題排除-version-is-obsolete&quot; class=&quot;headerlink&quot; title=&quot;Docker-compose</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Docker-compose-問題排除-version-is-obsolete"><a href="#Docker-compose-問題排除-version-is-obsolete" class="headerlink" title="Docker-compose 問題排除:  version is obsolete"></a>Docker-compose 問題排除:  <code>version</code> is obsolete</h1><p>我在使用 docker-compose build 時遇到以下問題</p><p>WARN[0000] &#x2F;home&#x2F;docker-compose.yml: <code>version</code> is obsolete </p><h1 id="問題原因"><a href="#問題原因" class="headerlink" title="問題原因:"></a>問題原因:</h1><p>從提供的錯誤訊息來看，表示使用的 docker-compose.yml 文件中的 version 字段已經過時。</p><p>這通常表示您正在使用的 Docker Compose CLI (Command Line Interface) 已經升級到更高版本，而該版本可能不再需要或不支持 version 字段。</p><h1 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法:"></a>解決方法:</h1><p>移除 version 行<br>編輯您的 docker-compose.yml 文件，刪除或註釋掉 version: ‘3’ 這一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># version: &#x27;3&#x27;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Docker-compose/">Docker-compose</category>
      
      <category domain="https://gahgah147.github.io/tags/version-is-obsolete/">version is obsolete</category>
      
      
      <comments>https://gahgah147.github.io/2024/04/19/Docker-compose-%E5%95%8F%E9%A1%8C%E6%8E%92%E9%99%A4-is-obsolete/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何在Windows 10上將Ubuntu從WSL1升級到WSL2</title>
      <link>https://gahgah147.github.io/2024/04/10/%E5%A6%82%E4%BD%95%E5%9C%A8Windows-10%E4%B8%8A%E5%B0%87Ubuntu%E5%BE%9EWSL1%E5%8D%87%E7%B4%9A%E5%88%B0WSL2/</link>
      <guid>https://gahgah147.github.io/2024/04/10/%E5%A6%82%E4%BD%95%E5%9C%A8Windows-10%E4%B8%8A%E5%B0%87Ubuntu%E5%BE%9EWSL1%E5%8D%87%E7%B4%9A%E5%88%B0WSL2/</guid>
      <pubDate>Wed, 10 Apr 2024 03:05:22 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;如何在Windows-10上將Ubuntu從WSL1升級到WSL2&quot;&gt;&lt;a href=&quot;#如何在Windows-10上將Ubuntu從WSL1升級到WSL2&quot; class=&quot;headerlink&quot; title=&quot;如何在Windows 10上將Ubuntu從WSL1</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="如何在Windows-10上將Ubuntu從WSL1升級到WSL2"><a href="#如何在Windows-10上將Ubuntu從WSL1升級到WSL2" class="headerlink" title="如何在Windows 10上將Ubuntu從WSL1升級到WSL2"></a>如何在Windows 10上將Ubuntu從WSL1升級到WSL2</h1><p>我是使用 win10 的 ubuntu  出現這個問題 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><p>win 10 舊版本電腦在使用WSL 上會遇到比較多問題需要排除</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>在Windows 10上，Windows Subsystem for Linux (WSL) 提供了一個運行Linux二進制執行檔案的兼容層，無需使用傳統的虛擬機或雙重啟動設置。WSL有兩個版本：WSL1和WSL2。WSL2相較於WSL1提供了更完整的Linux內核支持和改進的性能。本教程將指導您如何將Ubuntu從WSL1升級到WSL2。</p><h1 id="前提條件"><a href="#前提條件" class="headerlink" title="前提條件"></a>前提條件</h1><ul><li>確保您的Windows 10版本至少是2004（組建號19041）或更高版本。</li><li>確保您已安裝了Windows Subsystem for Linux (WSL)。</li></ul><h1 id="操作步驟"><a href="#操作步驟" class="headerlink" title="操作步驟"></a>操作步驟</h1><h2 id="步驟1：檢查您的WSL版本"><a href="#步驟1：檢查您的WSL版本" class="headerlink" title="步驟1：檢查您的WSL版本"></a>步驟1：檢查您的WSL版本</h2><p>1.打開Windows的命令提示符或PowerShell。<br>2.輸入以下命令，然後按下Enter鍵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure><p>3.檢查您的Ubuntu發行版旁邊的版本號。如果它顯示的是1，那麼您需要進行升級。</p><h2 id="步驟2：啟用WSL2功能"><a href="#步驟2：啟用WSL2功能" class="headerlink" title="步驟2：啟用WSL2功能"></a>步驟2：啟用WSL2功能</h2><p>1.打開PowerShell作為管理員。<br>2.執行以下命令來啟用WSL2功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-version Ubuntu 2</span><br></pre></td></tr></table></figure><p>請確保將Ubuntu替換成您的實際發行版名稱，如果它與顯示的不同。</p><p>等待升級過程完成。這可能需要一些時間，具體取決於您的系統配置和存儲的文件量。</p><h2 id="步驟3：驗證升級"><a href="#步驟3：驗證升級" class="headerlink" title="步驟3：驗證升級"></a>步驟3：驗證升級</h2><p>再次執行步驟1中的命令來檢查WSL版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      <category domain="https://gahgah147.github.io/tags/Windows-10/">Windows 10</category>
      
      <category domain="https://gahgah147.github.io/tags/WSL/">WSL</category>
      
      <category domain="https://gahgah147.github.io/tags/Ubuntu/">Ubuntu</category>
      
      
      <comments>https://gahgah147.github.io/2024/04/10/%E5%A6%82%E4%BD%95%E5%9C%A8Windows-10%E4%B8%8A%E5%B0%87Ubuntu%E5%BE%9EWSL1%E5%8D%87%E7%B4%9A%E5%88%B0WSL2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RTSP 透過OBS直播到 youtube</title>
      <link>https://gahgah147.github.io/2024/04/09/RTSP-%E9%80%8F%E9%81%8EOBS%E7%9B%B4%E6%92%AD%E5%88%B0-youtube/</link>
      <guid>https://gahgah147.github.io/2024/04/09/RTSP-%E9%80%8F%E9%81%8EOBS%E7%9B%B4%E6%92%AD%E5%88%B0-youtube/</guid>
      <pubDate>Tue, 09 Apr 2024 06:42:21 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;RTSP-透過OBS直播到-youtube&quot;&gt;&lt;a href=&quot;#RTSP-透過OBS直播到-youtube&quot; class=&quot;headerlink&quot; title=&quot;RTSP 透過OBS直播到 youtube&quot;&gt;&lt;/a&gt;RTSP 透過OBS直播到 youtube&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="RTSP-透過OBS直播到-youtube"><a href="#RTSP-透過OBS直播到-youtube" class="headerlink" title="RTSP 透過OBS直播到 youtube"></a>RTSP 透過OBS直播到 youtube</h1><p>我一開始是看到這篇教學<br><a href="https://www.jinwei.tw/youtube-obs-rtsp/">https://www.jinwei.tw/youtube-obs-rtsp/</a></p><p>但是來源一直吃不到rtsp</p><p>後來看到這一篇<br><a href="https://www.mylumens.com/Download/OBS%20Plugin%20and%20Dockable%20Controller-User%20Manual-Chinese-2021-0823.pdf">https://www.mylumens.com/Download/OBS%20Plugin%20and%20Dockable%20Controller-User%20Manual-Chinese-2021-0823.pdf</a></p><p>的設定可以選擇VLC</p><p>但是我的OBS　沒有VLC選項，找到這一篇<br><a href="https://youtu.be/Gr3XIo7exSg?si=Oe9xsCckZhZtYqn2">https://youtu.be/Gr3XIo7exSg?si=Oe9xsCckZhZtYqn2</a></p><p>提到 OBS 跟VLC 要安裝同樣bit版本 (64 或是 32)</p><p><img src="https://hackmd.io/_uploads/Skwrv8zlR.png" alt="image"><br>像這樣就能夠成功選擇了</p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料:"></a>參考資料:</h1><p><a href="https://www.jinwei.tw/youtube-obs-rtsp/">https://www.jinwei.tw/youtube-obs-rtsp/</a><br><a href="https://www.mylumens.com/Download/OBS%20Plugin%20and%20Dockable%20Controller-User%20Manual-Chinese-2021-0823.pdf">https://www.mylumens.com/Download/OBS%20Plugin%20and%20Dockable%20Controller-User%20Manual-Chinese-2021-0823.pdf</a><br><a href="https://youtu.be/Gr3XIo7exSg?si=Oe9xsCckZhZtYqn2">https://youtu.be/Gr3XIo7exSg?si=Oe9xsCckZhZtYqn2</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/RTSP/">RTSP</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%BD%B1%E5%83%8F%E4%B8%B2%E6%B5%81/">影像串流</category>
      
      <category domain="https://gahgah147.github.io/tags/OBS/">OBS</category>
      
      
      <comments>https://gahgah147.github.io/2024/04/09/RTSP-%E9%80%8F%E9%81%8EOBS%E7%9B%B4%E6%92%AD%E5%88%B0-youtube/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用Go與Gin框架串接Modbus TCP的完整指南</title>
      <link>https://gahgah147.github.io/2024/04/02/%E4%BD%BF%E7%94%A8Go%E8%88%87Gin%E6%A1%86%E6%9E%B6%E4%B8%B2%E6%8E%A5Modbus-TCP%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</link>
      <guid>https://gahgah147.github.io/2024/04/02/%E4%BD%BF%E7%94%A8Go%E8%88%87Gin%E6%A1%86%E6%9E%B6%E4%B8%B2%E6%8E%A5Modbus-TCP%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Tue, 02 Apr 2024 06:27:48 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;使用Go與Gin框架串接Modbus-TCP的完整指南&quot;&gt;&lt;a href=&quot;#使用Go與Gin框架串接Modbus-TCP的完整指南&quot; class=&quot;headerlink&quot; title=&quot;使用Go與Gin框架串接Modbus TCP的完整指南&quot;&gt;&lt;/a&gt;使用Go與</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="使用Go與Gin框架串接Modbus-TCP的完整指南"><a href="#使用Go與Gin框架串接Modbus-TCP的完整指南" class="headerlink" title="使用Go與Gin框架串接Modbus TCP的完整指南"></a>使用Go與Gin框架串接Modbus TCP的完整指南</h1><p>最近在著手開發一個跟漁農業相關的專案，需要透過 Modbus TCP 協定來取得設備上的資訊，這篇文章會紀錄一下 Modbus TCP 的基本概念及協定規格。</p><p>我們將探討如何使用Go語言和Gin框架來實現與Modbus TCP裝置的通信。這個主題對於需要在網頁應用中集成實時裝置控制和監控的開發者特別有用。我們會從基本原理開始，介紹測試工具，提供程式碼示例，並探討如何以MVC架構進行切分，以實現更好的代碼組織和維護性。</p><h1 id="什麼是Modbus-TCP"><a href="#什麼是Modbus-TCP" class="headerlink" title="什麼是Modbus TCP?"></a>什麼是Modbus TCP?</h1><p><img src="https://hackmd.io/_uploads/SJcatxFyR.png" alt="image"></p><p>Modbus 是在工業領域中廣泛使用的訊息交換規範，而 Modbus TCP 則是 Modbus 的一種實現，它使用 TCP&#x2F;IP 作為傳輸層協定，因此可以透過網路傳輸。</p><p>Modbus是一種廣泛使用的串行通信協議，被用於連接工業電子裝置。Modbus TCP則是其基於TCP&#x2F;IP的變種，允許這些裝置通過網路進行通信。Go語言擁有出色的網路處理能力，配合Gin框架的高效率和簡潔性，可以輕鬆搭建出一個用於與Modbus裝置通信的後端服務。</p><h1 id="關於-Modbus"><a href="#關於-Modbus" class="headerlink" title="關於 Modbus"></a>關於 Modbus</h1><p>Modbus 本身就是一種訊息交換的規範，而 Modbus TCP 則是透過 TCP&#x2F;IP 來實現 Modbus 的一種方式，因此所有的訊息都是透過 TCP&#x2F;IP 來傳輸。</p><p>Modbus 屬於 Client&#x2F;Server 架構，在工業上會有一個 Server 來存放所有要被讀取的工業設備數據，如溫度、濕度、距離等資料；而 Client 則會傳送一定的訊息格式當做指令，來讀取設備資料（讀），或是叫設備去做些什麼事情（寫）。</p><p>無論是對 Modbus Server 發送讀或寫的指令，Server 都會回傳一個確認訊息，讓 Client 知道指令是否成功。整個 Modbus 的溝通就是建構在這個一來一回的訊息交換上。</p><p><img src="https://hackmd.io/_uploads/SJi89etyR.png" alt="image"></p><blockquote><p><a href="https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/">https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/</a></p></blockquote><p>在傳輸過程中，Client 與 Server 的訊息最少會有「Function Code」與「Data」兩個部分：</p><p>Function Code：代表要執行的動作代碼，如讀取或寫入。<br>Data：代表執行動作代碼的相關參數，例如讀取某個位址上的資料，或是回傳某個位址上的資料作為結果。<br>Function Code 和 Data 是整個 Modbus 溝通最基本的單元，也稱為 Protocol Data Unit (PDU)。</p><p>除此之外，根據傳輸方式不同可能還會再頭尾加上一些附加資訊，附加後的整個訊息稱為 Application Data Unit (ADU)。</p><p><img src="https://hackmd.io/_uploads/ByEFqlF1C.png" alt="image"></p><blockquote><p><a href="https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/">https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/</a></p></blockquote><p>Modbus 定義了許多的內建的 Function Code，每個 Function Code 伴隨著特定規則的 Data，在閱讀文件時，可以跟具我們要處理的 Function Code 找到對應的 Data 規則。</p><p><img src="https://hackmd.io/_uploads/H1V59etJA.png" alt="image"></p><blockquote><p><a href="https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/">https://fullstackladder.dev/blog/2022/11/07/introduction-modbustcp/</a></p></blockquote><h1 id="測試工具"><a href="#測試工具" class="headerlink" title="測試工具"></a>測試工具</h1><p>在開發和測試Modbus TCP通信過程中，你可能會需要以下工具：</p><ul><li>Modbus模擬器（如Modsim）：模擬Modbus服務器（Slave），方便開發和測試。</li><li>Modbus客戶端測試工具（如Modscan或QModMaster）：用於測試和調試與Modbus裝置的通信。</li></ul><p>這些工具可以幫助你模擬實際的Modbus環境，進行開發和測試，無需實際的硬件裝置。</p><h2 id="Modbus-Slave模擬器"><a href="#Modbus-Slave模擬器" class="headerlink" title="Modbus Slave模擬器"></a>Modbus Slave模擬器</h2><p><img src="https://hackmd.io/_uploads/Sy0LoxF1C.png" alt="image"></p><blockquote><p><a href="https://www.azofreeware.com/2019/12/modbus-slave.html">https://www.azofreeware.com/2019/12/modbus-slave.html</a></p></blockquote><h2 id="MODSCAN"><a href="#MODSCAN" class="headerlink" title="MODSCAN"></a>MODSCAN</h2><p><img src="https://hackmd.io/_uploads/H1w6sxF1C.png" alt="image"></p><blockquote><p><a href="https://kknews.cc/zh-tw/news/ga4b86l.html">https://kknews.cc/zh-tw/news/ga4b86l.html</a></p></blockquote><h2 id="QModMaster"><a href="#QModMaster" class="headerlink" title="QModMaster"></a>QModMaster</h2><p><img src="https://hackmd.io/_uploads/SyyGngYkA.png" alt="image"></p><blockquote><p><a href="https://sourceforge.net/projects/qmodmaster/">https://sourceforge.net/projects/qmodmaster/</a></p></blockquote><h2 id="Modbus-TCP-Master"><a href="#Modbus-TCP-Master" class="headerlink" title="Modbus&#x2F;TCP Master"></a>Modbus&#x2F;TCP Master</h2><p><img src="https://hackmd.io/_uploads/H1zUheYkC.png" alt="image"></p><h1 id="程式實作"><a href="#程式實作" class="headerlink" title="程式實作"></a>程式實作</h1><p>以下是使用Go語言和Gin框架來實現Modbus TCP通信的簡單示例。首先，我們需要安裝必要的Go包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin</span><br><span class="line">go get github.com/goburrow/modbus</span><br></pre></td></tr></table></figure><p>然後，我們可以創建一個簡單的Gin後端服務，用於處理Modbus TCP請求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">    &quot;github.com/goburrow/modbus&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    </span><br><span class="line">    r.GET(&quot;/read&quot;, func(c *gin.Context) &#123;</span><br><span class="line">        handler := modbus.NewTCPClientHandler(&quot;192.168.1.1:502&quot;)</span><br><span class="line">        defer handler.Close()</span><br><span class="line">        client := modbus.NewClient(handler)</span><br><span class="line">        </span><br><span class="line">        results, err := client.ReadHoldingRegisters(1, 1)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            c.JSON(500, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        c.JSON(200, gin.H&#123;&quot;data&quot;: results&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run() // listen and serve on 0.0.0.0:8080</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="進階MVC架構切分"><a href="#進階MVC架構切分" class="headerlink" title="進階MVC架構切分"></a>進階MVC架構切分</h1><p>在一個較大的項目中，為了保持代碼的清晰和可維護性，我們可以將應用劃分為模型（Model）、視圖（View）和控制器（Controller）三個部分，即所謂的MVC架構。</p><p>模型（Model）：與Modbus裝置的通信邏輯，例如讀寫寄存器的功能。<br>視圖（View）：在這個上下文中，視圖可以是返回給客戶端的JSON數據格式。<br>控制器（Controller）：處理HTTP請求，調用模型執行操作，並決定返回哪個視圖。<br>這樣的結構使得代碼更加模組化，易於測試和維護。控制器負責路由和請求處理，模型實現具體的業務邏輯，視圖則是數據的表示。</p><h2 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型 (Model)"></a>模型 (Model)</h2><p>模型層封裝了與Modbus裝置通信的邏輯。這裡，我們定義一個ModbusService來處理與Modbus裝置的通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// modbusService.go</span><br><span class="line">package service</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/goburrow/modbus&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type ModbusService struct &#123;</span><br><span class="line">    Client modbus.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewModbusService(address string) *ModbusService &#123;</span><br><span class="line">    handler := modbus.NewTCPClientHandler(address)</span><br><span class="line">    handler.Connect()</span><br><span class="line">    return &amp;ModbusService&#123;</span><br><span class="line">        Client: modbus.NewClient(handler),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ModbusService) ReadRegister(address, quantity uint16) ([]byte, error) &#123;</span><br><span class="line">    return m.Client.ReadHoldingRegisters(address-1, quantity)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器 (Controller)"></a>控制器 (Controller)</h2><p>控制器層負責處理HTTP請求，調用模型來執行操作，並返回視圖。在這個例子中，我們創建一個控制器來處理讀取請求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// modbusController.go</span><br><span class="line">package controller</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line"></span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">    &quot;your_project/service&quot; // 替換成你的專案名稱</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type ModbusController struct &#123;</span><br><span class="line">    Service *service.ModbusService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewModbusController(service *service.ModbusService) *ModbusController &#123;</span><br><span class="line">    return &amp;ModbusController&#123;</span><br><span class="line">        Service: service,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *ModbusController) ReadRegister(c *gin.Context) &#123;</span><br><span class="line">    address, _ := strconv.ParseUint(c.Query(&quot;address&quot;), 10, 16)</span><br><span class="line">    quantity, _ := strconv.ParseUint(c.Query(&quot;quantity&quot;), 10, 16)</span><br><span class="line"></span><br><span class="line">    data, err := mc.Service.ReadRegister(uint16(address), uint16(quantity))</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;&quot;data&quot;: data&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="路由設定-Routing"><a href="#路由設定-Routing" class="headerlink" title="路由設定 (Routing)"></a>路由設定 (Routing)</h2><p>最後，在main.go中設定路由並初始化控制器和模型。這裡我們將路由、控制器和模型結合起來：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">    &quot;your_project/controller&quot; // 替換成你的專案名稱</span><br><span class="line">    &quot;your_project/service&quot;    // 替換成你的專案名稱</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    modbusService := service.NewModbusService(&quot;192.168.1.1:502&quot;)</span><br><span class="line">    modbusController := controller.NewModbusController(modbusService)</span><br><span class="line"></span><br><span class="line">    r.GET(&quot;/read&quot;, modbusController.ReadRegister)</span><br><span class="line"></span><br><span class="line">    r.Run() // listen and serve on 0.0.0.0:8080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣，我們就完成了一個基於MVC架構的應用，這個應用可以通過Gin框架處理HTTP請求，並通過Modbus TCP與裝置進行通信。這個架構使得代碼更加清晰且易於維護，特別適合於較大型的項目。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>通過使用Go語言和Gin框架，我們可以構建一個強大的後端應用，用於實現與Modbus TCP裝置的通信。這篇指南僅僅是一個起點，Modbus TCP的實際應用場景非常廣泛，從簡單的數據讀取到復雜的自動化控制系統都有可能。希望這篇文章能夠幫助你開始這樣的項目，並為你提供一些有用的工具和概念。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Go/">Go</category>
      
      <category domain="https://gahgah147.github.io/tags/Modbus-TCP/">Modbus TCP</category>
      
      
      <comments>https://gahgah147.github.io/2024/04/02/%E4%BD%BF%E7%94%A8Go%E8%88%87Gin%E6%A1%86%E6%9E%B6%E4%B8%B2%E6%8E%A5Modbus-TCP%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go 接收 RTSP 即時影像</title>
      <link>https://gahgah147.github.io/2024/03/29/Go-%E6%8E%A5%E6%94%B6-RTSP-%E5%8D%B3%E6%99%82%E5%BD%B1%E5%83%8F/</link>
      <guid>https://gahgah147.github.io/2024/03/29/Go-%E6%8E%A5%E6%94%B6-RTSP-%E5%8D%B3%E6%99%82%E5%BD%B1%E5%83%8F/</guid>
      <pubDate>Fri, 29 Mar 2024 03:19:44 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Go-接收-RTSP-即時影像&quot;&gt;&lt;a href=&quot;#Go-接收-RTSP-即時影像&quot; class=&quot;headerlink&quot; title=&quot;Go 接收 RTSP 即時影像&quot;&gt;&lt;/a&gt;Go 接收 RTSP 即時影像&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Go-接收-RTSP-即時影像"><a href="#Go-接收-RTSP-即時影像" class="headerlink" title="Go 接收 RTSP 即時影像"></a>Go 接收 RTSP 即時影像</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前因為工作需求要接收RTSP即時影像，並且顯示在前端網頁</p><h1 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h1><p>RTSPtoWebRTC:<br><a href="https://github.com/deepch/RTSPtoWebRTC">https://github.com/deepch/RTSPtoWebRTC</a></p><h1 id="RTSP-測試地址"><a href="#RTSP-測試地址" class="headerlink" title="RTSP 測試地址"></a>RTSP 測試地址</h1><table><thead><tr><th>來源</th><th>RTSP</th><th>延遲</th></tr></thead><tbody><tr><td>Nordland</td><td>rtsp:&#x2F;&#x2F;77.110.228.219&#x2F;axis-media&#x2F;media.amp</td><td>200ms</td></tr><tr><td>Norwich</td><td>rtsp:&#x2F;&#x2F;37.157.51.30&#x2F;axis-media&#x2F;media.amp</td><td>250ms</td></tr><tr><td>Orlando</td><td>rtsp:&#x2F;&#x2F;97.68.104.34&#x2F;axis-media&#x2F;media.amp</td><td>350ms</td></tr><tr><td>PriceCenterPlaza</td><td>rtsp:&#x2F;&#x2F;132.239.12.145:554&#x2F;axis-media&#x2F;media.amp</td><td>280ms</td></tr><tr><td>Vaison-La-Romaine</td><td>rtsp:&#x2F;&#x2F;176.139.87.16&#x2F;axis-media&#x2F;media.amp</td><td>差</td></tr><tr><td>VyhladJazero</td><td>rtsp:&#x2F;&#x2F;stream.strba.sk:1935&#x2F;strba&#x2F;VYHLAD_JAZERO.stream</td><td>160ms</td></tr><tr><td>Western Cape</td><td>rtsp:&#x2F;&#x2F;196.21.92.82&#x2F;axis-media&#x2F;media.amp</td><td>450ms</td></tr><tr><td>Zeeland</td><td>rtsp:&#x2F;&#x2F;213.34.225.97&#x2F;axis-media&#x2F;media.amp</td><td>270ms</td></tr><tr><td>Allendale</td><td>rtsp:&#x2F;&#x2F;71.83.5.156&#x2F;axis-media&#x2F;media.amp</td><td>270ms</td></tr><tr><td>Bedford Hills</td><td>rtsp:&#x2F;&#x2F;73.114.177.111&#x2F;axis-media&#x2F;media.amp</td><td>340ms</td></tr></tbody></table><blockquote><p>也可以參考 <a href="https://timetickme.com/stream-a-video-over-rtsp-using-live555mediaserver">https://timetickme.com/stream-a-video-over-rtsp-using-live555mediaserver</a> 本地搭建RTSP服務器進行測試</p></blockquote><h1 id="測試流程"><a href="#測試流程" class="headerlink" title="測試流程"></a>測試流程</h1><h2 id="下載程式碼"><a href="#下載程式碼" class="headerlink" title="下載程式碼"></a>下載程式碼</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/deepch/RTSPtoWebRTC  </span><br></pre></td></tr></table></figure><h2 id="到資料夾底下"><a href="#到資料夾底下" class="headerlink" title="到資料夾底下"></a>到資料夾底下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd RTSPtoWebRTC/</span><br></pre></td></tr></table></figure><h1 id="調整config-json"><a href="#調整config-json" class="headerlink" title="調整config.json"></a>調整config.json</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;: &#123;</span><br><span class="line">    &quot;http_port&quot;: &quot;:8083&quot;,</span><br><span class="line">    &quot;ice_servers&quot;: [&quot;stun:stun.l.google.com:19302&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;streams&quot;: &#123;</span><br><span class="line">      &quot;01&quot;: &#123;</span><br><span class="line">        &quot;on_demand&quot; : false,</span><br><span class="line">        &quot;disable_audio&quot;: true,</span><br><span class="line">        &quot;url&quot;: &quot;rtsp://77.110.228.219/axis-media/media.amp&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;02&quot;: &#123;</span><br><span class="line">        &quot;on_demand&quot; : true,</span><br><span class="line">        &quot;disable_audio&quot;: true,</span><br><span class="line">        &quot;url&quot;: &quot;rtsp://37.157.51.30/axis-media/media.amp&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;03&quot;: &#123;</span><br><span class="line">        &quot;on_demand&quot; : false,</span><br><span class="line">        &quot;disable_audio&quot;: true,</span><br><span class="line">        &quot;url&quot;: &quot;rtsp://97.68.104.34/axis-media/media.amp&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;04&quot;: &#123;</span><br><span class="line">        &quot;on_demand&quot; : false,</span><br><span class="line">        &quot;disable_audio&quot;: true,</span><br><span class="line">        &quot;url&quot;: &quot;rtsp://132.239.12.145:554/axis-media/media.amp&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;05&quot;: &#123;</span><br><span class="line">        &quot;on_demand&quot; : false,</span><br><span class="line">        &quot;disable_audio&quot;: true,</span><br><span class="line">        &quot;url&quot;: &quot;rtsp://176.139.87.16/axis-media/media.amp&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;06&quot;: &#123;</span><br><span class="line">        &quot;on_demand&quot; : false,</span><br><span class="line">        &quot;disable_audio&quot;: true,</span><br><span class="line">        &quot;url&quot;: &quot;rtsp://stream.strba.sk:1935/strba/VYHLAD_JAZERO.stream&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="測試部屬"><a href="#測試部屬" class="headerlink" title="測試部屬"></a>測試部屬</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go run *.go</span><br></pre></td></tr></table></figure><h1 id="透過瀏覽器打開網頁"><a href="#透過瀏覽器打開網頁" class="headerlink" title="透過瀏覽器打開網頁"></a>透過瀏覽器打開網頁</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8083</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ByLZznQk0.png" alt="image"></p><blockquote><p>這邊找到測試用RTSP 就可以看到攝影機畫面</p></blockquote><p>參考資料:<a href="https://timetickme.com/rtsp%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80/">https://timetickme.com/rtsp%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80/</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GO/">GO</category>
      
      <category domain="https://gahgah147.github.io/tags/RTSP/">RTSP</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%8D%B3%E6%99%82%E5%BD%B1%E5%83%8F/">即時影像</category>
      
      
      <comments>https://gahgah147.github.io/2024/03/29/Go-%E6%8E%A5%E6%94%B6-RTSP-%E5%8D%B3%E6%99%82%E5%BD%B1%E5%83%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GVM：Go 版本管理器的基本介紹</title>
      <link>https://gahgah147.github.io/2024/03/27/GVM%EF%BC%9AGo-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/</link>
      <guid>https://gahgah147.github.io/2024/03/27/GVM%EF%BC%9AGo-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/</guid>
      <pubDate>Wed, 27 Mar 2024 09:07:18 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;GVM：Go-版本管理器的基本介紹&quot;&gt;&lt;a href=&quot;#GVM：Go-版本管理器的基本介紹&quot; class=&quot;headerlink&quot; title=&quot;GVM：Go 版本管理器的基本介紹&quot;&gt;&lt;/a&gt;GVM：Go 版本管理器的基本介紹&lt;/h1&gt;&lt;h1 id=&quot;GVM-是</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="GVM：Go-版本管理器的基本介紹"><a href="#GVM：Go-版本管理器的基本介紹" class="headerlink" title="GVM：Go 版本管理器的基本介紹"></a>GVM：Go 版本管理器的基本介紹</h1><h1 id="GVM-是什麼"><a href="#GVM-是什麼" class="headerlink" title="GVM 是什麼?"></a>GVM 是什麼?</h1><p><img src="https://hackmd.io/_uploads/B1I3TIZJR.png" alt="image"></p><blockquote><p><a href="https://github.com/moovweb/gvm">https://github.com/moovweb/gvm</a><br>GVM 是 Go 版本管理器，是一個用於管理多個 Go 版本的命令行工具。允許開發者輕鬆切換、安裝和使用不同版本的 Go，從而提高了開發效率並幫助保持項目環境的一致性。</p></blockquote><h1 id="GVM-的特點"><a href="#GVM-的特點" class="headerlink" title="GVM 的特點"></a>GVM 的特點</h1><p>版本切換：GVM 允許您在不同版本的 Go 之間快速切換，方便您在多個項目間工作，每個可能需要不同版本的 Go。<br>易於安裝：通過 GVM，安裝新版本的 Go 變得非常容易，只需一條簡單的命令。<br>版本隔離：GVM 為每個版本的 Go 提供了隔離的環境，確保了不同項目的依賴和配置不會互相干擾。</p><h1 id="如何安裝-GVM"><a href="#如何安裝-GVM" class="headerlink" title="如何安裝 GVM"></a>如何安裝 GVM</h1><p>在大多數 Unix-like 系統（如 Linux 和 macOS）上，可以使用以下命令安裝 GVM：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br></pre></td></tr></table></figure><p>安裝完成後，可能需要重啟您的終端或者重新加載配置檔案（例如 .bashrc 或 .bash_profile）來使 GVM 的設定生效。</p><h1 id="使用-GVM-管理-Go-版本"><a href="#使用-GVM-管理-Go-版本" class="headerlink" title="使用 GVM 管理 Go 版本"></a>使用 GVM 管理 Go 版本</h1><p>以下是使用 GVM 的一些基本命令：</p><p>列出可用的 Go 版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gvm listall</span><br></pre></td></tr></table></figure><p>安裝特定版本的 Go：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gvm install go1.18.1 -B</span><br></pre></td></tr></table></figure><p>使用特定版本的 Go：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gvm use go1.18.1</span><br></pre></td></tr></table></figure><p>設定預設使用的 Go 版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gvm use go1.18.1 --default</span><br></pre></td></tr></table></figure><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>GVM 是一個強大的工具，對於需要在多個 Go 項目中工作的開發者來說，它提供了極大的便利。通過使用 GVM，開發者可以輕鬆切換 Go 版本，保持項目間的環境一致性，從而提升開發效率。無論您是 Go 語言的新手還是有經驗的開發者，GVM 都是您工具箱中不可或缺的一部分。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GO/">GO</category>
      
      <category domain="https://gahgah147.github.io/tags/GVM/">GVM</category>
      
      
      <comments>https://gahgah147.github.io/2024/03/27/GVM%EF%BC%9AGo-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Termius: 跨平台SSH客戶端的終極指南</title>
      <link>https://gahgah147.github.io/2024/03/14/Termius-%E8%B7%A8%E5%B9%B3%E5%8F%B0SSH%E5%AE%A2%E6%88%B6%E7%AB%AF%E7%9A%84%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</link>
      <guid>https://gahgah147.github.io/2024/03/14/Termius-%E8%B7%A8%E5%B9%B3%E5%8F%B0SSH%E5%AE%A2%E6%88%B6%E7%AB%AF%E7%9A%84%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Thu, 14 Mar 2024 05:51:23 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在當今快速變化的技術環境中，遠程管理伺服器變得越來越重要。無論你是一名系統管理員、開發人員還是IT專業人士，都需要一款強大且可靠的工具來管理</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在當今快速變化的技術環境中，遠程管理伺服器變得越來越重要。無論你是一名系統管理員、開發人員還是IT專業人士，都需要一款強大且可靠的工具來管理你的遠程伺服器。這就是Termius發揮作用的地方。</p><h1 id="什麼是Termius？"><a href="#什麼是Termius？" class="headerlink" title="什麼是Termius？"></a>什麼是Termius？</h1><p><img src="https://hackmd.io/_uploads/ryq9YZg0T.png" alt="image"></p><blockquote><p><a href="https://termius.com/">https://termius.com/</a></p></blockquote><p>Termius是一款現代化的SSH客戶端，支持跨平台操作，允許用戶從任何地方安全地訪問和管理遠程系統。它不僅支持SSH，還支持Telnet、Mosh和SFTP協定，提供了一個統一的平台來管理所有的遠程任務。</p><h1 id="主要特點"><a href="#主要特點" class="headerlink" title="主要特點"></a>主要特點</h1><ul><li>跨平台支持：Termius提供了Windows、macOS、Linux以及iOS和Android的客戶端。</li><li>多標籤界面：輕鬆管理多個同時連接。</li><li>密鑰管理：內建密鑰生成和管理功能，提高安全性。</li><li>數據同步：通過Termius雲服務在多個設備間同步配置。</li><li>端口轉發：支援本地和遠程端口轉發，保障數據傳輸的安全。</li><li>自動化腳本：使用SNIPPETS自動化重複的任務。</li></ul><p><img src="https://hackmd.io/_uploads/r1KWp-xRp.png" alt="image"></p><blockquote><p>多標籤界面</p></blockquote><p><img src="https://hackmd.io/_uploads/HkYzpWgRa.png" alt="image"></p><blockquote><p>自動化腳本</p></blockquote><p><img src="https://hackmd.io/_uploads/HJrIpZlAT.png" alt="image"></p><blockquote><p>Termius提供了Windows、macOS、Linux以及iOS和Android的客戶端。</p></blockquote><h1 id="如何開始使用Termius"><a href="#如何開始使用Termius" class="headerlink" title="如何開始使用Termius"></a>如何開始使用Termius</h1><h2 id="下載並安裝Termius"><a href="#下載並安裝Termius" class="headerlink" title="下載並安裝Termius"></a>下載並安裝Termius</h2><p>首先，前往Termius官網下載適合你操作系統的Termius版本，然後按照指示完成安裝。<br><img src="https://hackmd.io/_uploads/rkKls-xA6.png" alt="image"></p><h2 id="創建和配置連接"><a href="#創建和配置連接" class="headerlink" title="創建和配置連接"></a>創建和配置連接</h2><p>打開Termius，你需要創建新的SSH連接。</p><p>點擊左側菜單的”New Host”。<br><img src="https://hackmd.io/_uploads/rkcFibgCp.png" alt="image"></p><p>輸入主機名稱、地址和你的SSH登錄憑證。<br><img src="https://hackmd.io/_uploads/Skrx3bx0p.png" alt="image"></p><p>(可選)配置高級設置，如端口轉發規則。<br><img src="https://hackmd.io/_uploads/rJRW2bxC6.png" alt="image"></p><p>點擊”Save”保存配置。</p><h2 id="開始遠程連線"><a href="#開始遠程連線" class="headerlink" title="開始遠程連線"></a>開始遠程連線</h2><p><img src="https://hackmd.io/_uploads/Byc43WgCT.png" alt="image"><br>選擇你剛才創建的連接，點擊”Connect”開始你的遠程SSH會話。就這麼簡單！</p><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><ul><li>同步你的設置：通過註冊Termius賬戶，你可以同步你的設置到雲端，從任何設備訪問你的連接。</li><li>利用SNIPPETS：為常見任務創建SNIPPETS，如更新軟件包或檢查系統狀態，以提高效率。</li></ul><p>希望這篇文章能夠幫助你瞭解Termius的基本功能和如何開始使用它來管理你的遠程系統。隨著技術的發展，保持靈活和高效的遠程管理變得越來越重要，而Termius正是這樣一款適合現代IT專業人士的工具。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/SSH/">SSH</category>
      
      <category domain="https://gahgah147.github.io/tags/Termius/">Termius</category>
      
      
      <comments>https://gahgah147.github.io/2024/03/14/Termius-%E8%B7%A8%E5%B9%B3%E5%8F%B0SSH%E5%AE%A2%E6%88%B6%E7%AB%AF%E7%9A%84%E7%B5%82%E6%A5%B5%E6%8C%87%E5%8D%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Next JS 和開放式 AI / GPT：下一代 Next JS 和 AI 應用程式</title>
      <link>https://gahgah147.github.io/2024/02/27/Next-JS-%E5%92%8C%E9%96%8B%E6%94%BE%E5%BC%8F-AI-GPT%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3-Next-JS-%E5%92%8C-AI-%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</link>
      <guid>https://gahgah147.github.io/2024/02/27/Next-JS-%E5%92%8C%E9%96%8B%E6%94%BE%E5%BC%8F-AI-GPT%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3-Next-JS-%E5%92%8C-AI-%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</guid>
      <pubDate>Tue, 27 Feb 2024 08:30:43 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Next-JS-和開放式-AI-GPT：下一代-Next-JS-和-AI-應用程式&quot;&gt;&lt;a href=&quot;#Next-JS-和開放式-AI-GPT：下一代-Next-JS-和-AI-應用程式&quot; class=&quot;headerlink&quot; title=&quot;Next JS 和開</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Next-JS-和開放式-AI-GPT：下一代-Next-JS-和-AI-應用程式"><a href="#Next-JS-和開放式-AI-GPT：下一代-Next-JS-和-AI-應用程式" class="headerlink" title="Next JS 和開放式 AI &#x2F; GPT：下一代 Next JS 和 AI 應用程式"></a><a href="https://softnshare.com/next-js-ai/?fbclid=IwAR2pwxtLQNCUgwpeKvYi23Ge1N7Svcmi7h_mgp-jJhs41r4znT9m4Ctq1yg">Next JS 和開放式 AI &#x2F; GPT：下一代 Next JS 和 AI 應用程式</a></h1><h1 id="這篇是學習Next-JS-和開放式-AI-GPT：下一代-Next-JS-和-AI-應用程式-課程的紀錄，"><a href="#這篇是學習Next-JS-和開放式-AI-GPT：下一代-Next-JS-和-AI-應用程式-課程的紀錄，" class="headerlink" title="這篇是學習Next JS 和開放式 AI &#x2F; GPT：下一代 Next JS 和 AI 應用程式 課程的紀錄，"></a>這篇是學習Next JS 和開放式 AI &#x2F; GPT：下一代 Next JS 和 AI 應用程式 課程的紀錄，</h1><p>課程上有使用到以下工具</p><ol><li>OpenAI 的 GPT 在應用程式中實現 AI 生成的內容</li><li>Auth0 驗證 Next JS 應用程式</li><li>Tailwind CSS 設計 Next JS 應用程式</li><li>MongoDB 儲存 Next JS 應用程式的資料</li><li>Stripe 向客戶收費</li></ol><p>其中發現台灣沒辦法使用 Stripe 收費這邊比較困擾一點，另外其他功能都有成功設定。</p><h2 id="第一堂課程"><a href="#第一堂課程" class="headerlink" title="第一堂課程"></a>第一堂課程</h2><p>課程教學Github: <a href="https://github.com/tomphill/blog-standard-course">https://github.com/tomphill/blog-standard-course</a><br>React基礎課程: <a href="https://youtu.be/HVFSgIVXcD4">https://youtu.be/HVFSgIVXcD4</a><br>第一堂Github連結: <a href="https://github.com/tomphill/nextjs-openai-starter">https://github.com/tomphill/nextjs-openai-starter</a><br>課程連結: <a href="https://www.udemy.com/course/next-js-ai/learn/lecture/36192386?LSNPUBID=BoHFIyu6APU&components=add_to_cart,available_coupons,base_purchase_section,buy_button,buy_for_team,cacheable_buy_button,cacheable_deal_badge,cacheable_discount_expiration,cacheable_price_text,cacheable_purchase_text,curated_for_ufb_notice_context,curriculum_context,deal_badge,discount_expiration,gift_this_course,incentives,instructor_links,lifetime_access_context,money_back_guarantee,price_text,purchase_tabs_context,purchase,recommendation,redeem_coupon,sidebar_container,purchase_body_container&ranEAID=BoHFIyu6APU&ranMID=39197&ranSiteID=BoHFIyu6APU-xOeQldV1zZ53.eDHqBvJfQ&utm_medium=udemyads&utm_source=aff-campaign#reviews">https://www.udemy.com/course/next-js-ai/learn/lecture/36192386?LSNPUBID=BoHFIyu6APU&amp;components=add_to_cart%2Cavailable_coupons%2Cbase_purchase_section%2Cbuy_button%2Cbuy_for_team%2Ccacheable_buy_button%2Ccacheable_deal_badge%2Ccacheable_discount_expiration%2Ccacheable_price_text%2Ccacheable_purchase_text%2Ccurated_for_ufb_notice_context%2Ccurriculum_context%2Cdeal_badge%2Cdiscount_expiration%2Cgift_this_course%2Cincentives%2Cinstructor_links%2Clifetime_access_context%2Cmoney_back_guarantee%2Cprice_text%2Cpurchase_tabs_context%2Cpurchase%2Crecommendation%2Credeem_coupon%2Csidebar_container%2Cpurchase_body_container&amp;ranEAID=BoHFIyu6APU&amp;ranMID=39197&amp;ranSiteID=BoHFIyu6APU-xOeQldV1zZ53.eDHqBvJfQ&amp;utm_medium=udemyads&amp;utm_source=aff-campaign#reviews</a></p><h1 id="auth0-設定"><a href="#auth0-設定" class="headerlink" title="auth0 設定"></a>auth0 設定</h1><p><img src="https://hackmd.io/_uploads/ByWTukRo6.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/rkHSYyRs6.png" alt="image"></p><blockquote><p>設定 auth0 API</p></blockquote><h2 id="產生-AUTH0-SECRET-方式"><a href="#產生-AUTH0-SECRET-方式" class="headerlink" title="產生 AUTH0_SECRET 方式"></a>產生 AUTH0_SECRET 方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -hex 32</span><br></pre></td></tr></table></figure><h2 id="調整-env-local-設定檔案如下"><a href="#調整-env-local-設定檔案如下" class="headerlink" title="調整.env.local 設定檔案如下"></a>調整.env.local 設定檔案如下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUTH0_SECRET=&lt;AUTH0_SECRET&gt;</span><br><span class="line">AUTH0_BASE_URL=&lt;AUTH0_BASE_URL&gt;</span><br><span class="line">AUTH0_ISSUER_BASE_URL=&lt;AUTH0_ISSUER_BASE_URL&gt;</span><br><span class="line">AUTH0_CLIENT_ID=&lt;AUTH0_CLIENT_ID&gt;</span><br><span class="line">AUTH0_CLIENT_SECRET=&lt;AUTH0_CLIENT_SECRET&gt;</span><br></pre></td></tr></table></figure><h2 id="新增-Application-URI-設定"><a href="#新增-Application-URI-設定" class="headerlink" title="新增 Application URI 設定"></a>新增 Application URI 設定</h2><p><img src="https://hackmd.io/_uploads/Hko7ATxja.png" alt="image"></p><h2 id="設定auth0-登入身分驗證頁面"><a href="#設定auth0-登入身分驗證頁面" class="headerlink" title="設定auth0 登入身分驗證頁面"></a>設定auth0 登入身分驗證頁面</h2><p>新增 pages&#x2F;api&#x2F;auth&#x2F;[…auth0].js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; handleAuth &#125; from &#x27;@auth0/nextjs-auth0&#x27;;</span><br><span class="line"></span><br><span class="line">export default handleAuth();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="調整-pages-index-js-檔案"><a href="#調整-pages-index-js-檔案" class="headerlink" title="調整 pages&#x2F;index.js 檔案"></a>調整 pages&#x2F;index.js 檔案</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#x27;next/link&#x27;</span><br><span class="line">export default function Home() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;this is the homepage&lt;/h1&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link href=&quot;/api/auth/login&quot;&gt;Login&lt;/Link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行 npm run dev 後打開  <a href="http://localhost:3001/">http://localhost:3001/</a><br><img src="https://hackmd.io/_uploads/SyitcyAjp.png" alt="image"></p><p>點擊login 後可以看到身分驗證畫面<br><img src="https://hackmd.io/_uploads/Syt1okAsa.png" alt="image"></p><p>註冊頁面<br><img src="https://hackmd.io/_uploads/r1lIokCi6.png" alt="image"></p><p>詢問授權<br><img src="https://hackmd.io/_uploads/ryWvqJRia.png" alt="image"></p><h2 id="設定頁面必須要登入才能瀏覽"><a href="#設定頁面必須要登入才能瀏覽" class="headerlink" title="設定頁面必須要登入才能瀏覽"></a>設定頁面必須要登入才能瀏覽</h2><p>舉例來說 pages&#x2F;post&#x2F;new.js 檔案內容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; withPageAuthRequired &#125; from &quot;@auth0/nextjs-auth0&quot;;</span><br><span class="line"></span><br><span class="line">export default function NewPost(props)&#123;</span><br><span class="line">    console.log(&#x27;New Post Props:&#x27;,props);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;</span><br><span class="line">                this is the new post page</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const getServerSideProps = withPageAuthRequired(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        props:&#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這邊的 withPageAuthRequired 就是限定使用者一定要登入才能看到這一頁的內容</p><p>repo紀錄: <a href="https://github.com/gahgah147/nextjs-openai-starter/tree/Day1-Auth0%E7%99%BB%E5%85%A5%E9%A9%97%E8%AD%89">https://github.com/gahgah147/nextjs-openai-starter/tree/Day1-Auth0%E7%99%BB%E5%85%A5%E9%A9%97%E8%AD%89</a></p><h1 id="透過Tailwind-CSS設定外觀"><a href="#透過Tailwind-CSS設定外觀" class="headerlink" title="透過Tailwind CSS設定外觀"></a>透過Tailwind CSS設定外觀</h1><p><img src="https://hackmd.io/_uploads/r1OLCBx2T.png" alt="image"></p><blockquote><p><a href="https://tailwindcss.com/">https://tailwindcss.com/</a></p></blockquote><p><a href="https://medium.com/@Kelly_CHI/tailwind-css-introduction-and-tools-68e770b2bf7f">Tailwind CSS 新手上路：概念、安裝與工具推薦</a></p><p>Tailwind CSS 是一個採用了「Utility First」理念的 CSS 框架。</p><p>練習Repo: <a href="https://github.com/gahgah147/nextjs-openai-starter/tree/Day2-%E9%80%8F%E9%81%8ETailwind-CSS%E8%A8%AD%E5%AE%9A%E5%A4%96%E8%A7%80">https://github.com/gahgah147/nextjs-openai-starter/tree/Day2-%E9%80%8F%E9%81%8ETailwind-CSS%E8%A8%AD%E5%AE%9A%E5%A4%96%E8%A7%80</a></p><h1 id="透過-OpenAI’s-GPT-API-自動產生Blog-文章"><a href="#透過-OpenAI’s-GPT-API-自動產生Blog-文章" class="headerlink" title="透過 OpenAI’s GPT API 自動產生Blog 文章"></a>透過 OpenAI’s GPT API 自動產生Blog 文章</h1><p>首先到 Openai 平台<br><img src="https://hackmd.io/_uploads/SyjwaFg36.png" alt="image"></p><blockquote><p><a href="https://platform.openai.com/">https://platform.openai.com/</a></p></blockquote><p>登入後可以點選 Usage 查看用量<br><img src="https://hackmd.io/_uploads/Sk9aRtgh6.png" alt="image"></p><blockquote><p>像是這樣就是用完了</p></blockquote><p><img src="https://hackmd.io/_uploads/BJufJcln6.png" alt="image"></p><blockquote><p>這樣是還有用量可以使用</p></blockquote><h2 id="產生-API-Keys"><a href="#產生-API-Keys" class="headerlink" title="產生 API Keys"></a>產生 API Keys</h2><p>點選 API keys 後點擊 Create new secret key 按鈕<br><img src="https://hackmd.io/_uploads/HyRHeclhT.png" alt="image"></p><p>這邊可以設定API key的名稱<br><img src="https://hackmd.io/_uploads/ryfn-5ehT.png" alt="image"></p><p>成功產生API KEY<br><img src="https://hackmd.io/_uploads/BkPdzqxnp.png" alt="image"></p><h2 id="設定環境變數"><a href="#設定環境變數" class="headerlink" title="設定環境變數"></a>設定環境變數</h2><p>修改 .env.local 檔新增以下內容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPENAI_API_KEY=&lt;剛剛產生的 API KEY&gt;</span><br></pre></td></tr></table></figure><h2 id="安裝-react-markdown套件"><a href="#安裝-react-markdown套件" class="headerlink" title="安裝 react-markdown套件"></a>安裝 react-markdown套件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-markdown</span><br></pre></td></tr></table></figure><p>在程式碼中引用<br>例如:postContent 是 markdown 的內容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import Markdown from &quot;react-markdown&quot;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;Markdown&gt;</span><br><span class="line">    &#123;postContent&#125;</span><br><span class="line">&lt;/Markdown&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="設定MongoDB"><a href="#設定MongoDB" class="headerlink" title="設定MongoDB"></a>設定MongoDB</h2><p><img src="https://hackmd.io/_uploads/H1-poJ72p.png" alt="image"></p><blockquote><p><a href="https://www.mongodb.com/atlas/database">https://www.mongodb.com/atlas/database</a></p></blockquote><p>註冊後登入<br><img src="https://hackmd.io/_uploads/BkfW3ymhT.png" alt="image"></p><blockquote><p><a href="https://cloud.mongodb.com/v2/64a3c968e3797d3fc1796726#/clusters">https://cloud.mongodb.com/v2/64a3c968e3797d3fc1796726#/clusters</a></p></blockquote><h3 id="設定IP-ADDRESS"><a href="#設定IP-ADDRESS" class="headerlink" title="設定IP ADDRESS"></a>設定IP ADDRESS</h3><p>因為一開始如果沒有設定IP Address會無法連線到<br>點選 Network Access</p><p><img src="https://hackmd.io/_uploads/ByVPmx7nT.png" alt="image"></p><p>點選 ADD IP ADDRESS</p><p><img src="https://hackmd.io/_uploads/SJk37gX2T.png" alt="image"></p><p>選擇 ALLOW ACCESS FROM ANYWHERE</p><h3 id="創建資料庫"><a href="#創建資料庫" class="headerlink" title="創建資料庫"></a>創建資料庫</h3><p>點選DataBase </p><p><img src="https://hackmd.io/_uploads/HylDVxQn6.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/B1hq0Zmh6.png" alt="image"></p><p>建立新的資料庫<br><img src="https://hackmd.io/_uploads/BJRGyfQha.png" alt="image"></p><p>再新增一個posts table<br><img src="https://hackmd.io/_uploads/SyNU1z7ha.png" alt="image"></p><p>點選 Connect<br><img src="https://hackmd.io/_uploads/SJRcJf72T.png" alt="image"></p><p>產生使用者<br><img src="https://hackmd.io/_uploads/Bk1beGm2T.png" alt="image"></p><p>設定選擇 Connect to your application<br><img src="https://hackmd.io/_uploads/H1xHxMX3p.png" alt="image"></p><p>複製這段程式碼<br><img src="https://hackmd.io/_uploads/rylnefm2p.png" alt="image"></p><p>修改 .env.local 檔案新增以下這一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MONGODB_URI=mongodb+srv://user:&lt;password&gt;@cluster0.biiwahu.mongodb.net/?retryWrites=true&amp;w=majority</span><br></pre></td></tr></table></figure><p>這樣就能成功建立連線</p><h1 id="設定-Stripe-收費功能"><a href="#設定-Stripe-收費功能" class="headerlink" title="設定 Stripe 收費功能"></a>設定 Stripe 收費功能</h1><div class="note warning simple"><p>這邊我發現一個問題 Stripe並不支援在台灣開立商戶帳戶 </p></div><p><img src="https://hackmd.io/_uploads/ryq1DtV26.png" alt="image"></p><blockquote><p><a href="https://stripe.com/">https://stripe.com/</a></p></blockquote><p>登入後創建帳號<br><img src="https://hackmd.io/_uploads/ry7kYtEha.png" alt="image"></p><p>點選開發人員 &gt; API 密鑰 複製 Secret key<br><img src="https://hackmd.io/_uploads/SkQ4KK4np.png" alt="image"></p><p>修改 .env.local 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRIPE_SECRET_KEY=&lt;剛剛的Secret key&gt;</span><br></pre></td></tr></table></figure><p>點選添加產品</p><p><img src="https://hackmd.io/_uploads/H1gkTKNnT.png" alt="image"></p><p>新增一個 10 tokens 的產品<br><img src="https://hackmd.io/_uploads/SJghz6K43p.png" alt="image"></p><p>複製這邊的 API ID<br><img src="https://hackmd.io/_uploads/BJMvaFNhT.png" alt="image"></p><p>修改 .env.local 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRIPE_PRODUCT_PRICE_ID=&lt;API ID&gt;</span><br></pre></td></tr></table></figure><h2 id="設定Webhooks"><a href="#設定Webhooks" class="headerlink" title="設定Webhooks"></a>設定Webhooks</h2><p>點選 Webhooks<br><img src="https://hackmd.io/_uploads/SJyIOFS3p.png" alt="image"></p><p>點擊 在本地環境中測試<br><img src="https://hackmd.io/_uploads/SJq__FB2T.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HkifYFrhp.png" alt="image"></p><p>下載CLI<br>這邊後來是選擇用apt 下載<br>Add Stripe CLI’s GPG key to the apt sources keyring:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg</span><br></pre></td></tr></table></figure><p>Add CLI’s apt repository to the apt sources list:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [signed-by=/usr/share/keyrings/stripe.gpg] https://packages.stripe.dev/stripe-cli-debian-local stable main&quot; | sudo tee -a /etc/apt/sources.list.d/stripe.list</span><br></pre></td></tr></table></figure><p>Update the package list:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>Install the CLI:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install stripe</span><br></pre></td></tr></table></figure><p>這邊會需要登入 stripe<br><img src="https://hackmd.io/_uploads/HkRfW5r26.png" alt="image"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stripe listen --forward-to localhost:3000/api/webhooks/stripe</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HJrgr9B2T.png" alt="image"></p><p>這樣可以取得 webhook signing secret </p><p>修改 .env.local 檔案 新增 STRIPE_WEBHOOK_SECRET 內容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRIPE_WEBHOOK_SECRET=&lt;webhook signing secret &gt;</span><br></pre></td></tr></table></figure><p>repo紀錄: <a href="https://github.com/gahgah147/nextjs-openai-starter/tree/Day4-%E8%A8%AD%E5%AE%9AStripe%E6%94%B6%E8%B2%BB%E5%8A%9F%E8%83%BD">https://github.com/gahgah147/nextjs-openai-starter/tree/Day4-%E8%A8%AD%E5%AE%9AStripe%E6%94%B6%E8%B2%BB%E5%8A%9F%E8%83%BD</a></p><h1 id="部屬"><a href="#部屬" class="headerlink" title="部屬"></a>部屬</h1><h2 id="建立新的repository"><a href="#建立新的repository" class="headerlink" title="建立新的repository"></a>建立新的repository</h2><p>點選新增<br><img src="https://hackmd.io/_uploads/rkLKtsK36.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/ryJ0YiKha.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BkPJ5jKnp.png" alt="image"></p><h2 id="設定-digitalocean"><a href="#設定-digitalocean" class="headerlink" title="設定 digitalocean"></a>設定 digitalocean</h2><p><img src="https://hackmd.io/_uploads/rJCHqoKnp.png" alt="image"></p><blockquote><p><a href="https://www.digitalocean.com/">https://www.digitalocean.com/</a></p></blockquote><p>註冊好後選擇部屬到APPs 上<br><img src="https://hackmd.io/_uploads/BkfHTjKhT.png" alt="image"></p><p>設定連結到github<br><img src="https://hackmd.io/_uploads/rJVCTjK2T.png" alt="image"></p><p>這邊可以選擇想要的方案，這邊選擇Edit plan<br><img src="https://hackmd.io/_uploads/H1_W0iY36.png" alt="image"></p><p>這邊選擇最便宜的 每月5美元方案<br><img src="https://hackmd.io/_uploads/B1R6-hF2a.png" alt="image"></p><h2 id="接下來可以設定環境變數"><a href="#接下來可以設定環境變數" class="headerlink" title="接下來可以設定環境變數"></a>接下來可以設定環境變數</h2><p><img src="https://hackmd.io/_uploads/HkiGM3t26.png" alt="image"></p><p>選擇 Bulk Editor<br><img src="https://hackmd.io/_uploads/rJtVMnFha.png" alt="image"></p><p>複製 env.local 的所有內容</p><p><img src="https://hackmd.io/_uploads/Syesf2F3T.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Hy2oMhYn6.png" alt="image"></p><p>這邊點擊後會需要等待一段時間<br><img src="https://hackmd.io/_uploads/B1imR3K3p.png" alt="image"></p><p>成功後可以看到網站連結<br><img src="https://hackmd.io/_uploads/HkXxe6tnp.png" alt="image"></p><p>修改環境變數 AUTH0_BASE_URL 為<a href="https://squid-app-zu4dz.ondigitalocean.app/">https://squid-app-zu4dz.ondigitalocean.app/</a><br><img src="https://hackmd.io/_uploads/HJR9bpFha.png" alt="image"></p><p>修改 auth0 的環境變數<br><img src="https://hackmd.io/_uploads/HkKLzTY36.png" alt="image"></p><blockquote><p><a href="https://manage.auth0.com/">https://manage.auth0.com/</a></p></blockquote>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Next-JS/">Next JS</category>
      
      <category domain="https://gahgah147.github.io/tags/AUTH0/">AUTH0</category>
      
      <category domain="https://gahgah147.github.io/tags/Tailwind-CSS/">Tailwind CSS</category>
      
      <category domain="https://gahgah147.github.io/tags/Stripe/">Stripe</category>
      
      <category domain="https://gahgah147.github.io/tags/MongoDB/">MongoDB</category>
      
      <category domain="https://gahgah147.github.io/tags/OpenAI/">OpenAI</category>
      
      <category domain="https://gahgah147.github.io/tags/GPT-API/">GPT API</category>
      
      
      <comments>https://gahgah147.github.io/2024/02/27/Next-JS-%E5%92%8C%E9%96%8B%E6%94%BE%E5%BC%8F-AI-GPT%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3-Next-JS-%E5%92%8C-AI-%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GO 使用Gin和Swagger設定自動產生文件檔案</title>
      <link>https://gahgah147.github.io/2024/02/01/GO-%E4%BD%BF%E7%94%A8Gin%E5%92%8CSwagger%E8%A8%AD%E5%AE%9A%E8%87%AA%E5%8B%95%E7%94%A2%E7%94%9F%E6%96%87%E4%BB%B6%E6%AA%94%E6%A1%88/</link>
      <guid>https://gahgah147.github.io/2024/02/01/GO-%E4%BD%BF%E7%94%A8Gin%E5%92%8CSwagger%E8%A8%AD%E5%AE%9A%E8%87%AA%E5%8B%95%E7%94%A2%E7%94%9F%E6%96%87%E4%BB%B6%E6%AA%94%E6%A1%88/</guid>
      <pubDate>Thu, 01 Feb 2024 03:54:58 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;當開發RESTful API時，有效的文檔是極其重要的，它可以幫助開發者快速理解和使用API。Swagger是一個強大的工具，用於自動生成和</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>當開發RESTful API時，有效的文檔是極其重要的，它可以幫助開發者快速理解和使用API。Swagger是一個強大的工具，用於自動生成和維護API文檔。</p><p>本文將指導你如何使用Swagger在Gin框架中自動生成API文檔，並提供一些維護的最佳實踐。</p><h1 id="為什麼選擇Swagger？"><a href="#為什麼選擇Swagger？" class="headerlink" title="為什麼選擇Swagger？"></a>為什麼選擇Swagger？</h1><p>1.標準化: Swagger遵循OpenAPI規範，這是一個業界標準。<br>2.交互性: Swagger UI允許用戶直接從文檔中測試API，無需其他工具。</p><h1 id="安裝流程"><a href="#安裝流程" class="headerlink" title="安裝流程"></a>安裝流程</h1><p>安裝必要的套件<br>首先，我們需要安裝swag CLI工具和Gin的Swagger中間件。</p><p>swagger cmd: 用於生成介面文件的命令列工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><p>Starting in Go 1.17, installing executables with go get is deprecated. go install may be used instead:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/swaggo/swag/cmd/swag@latest</span><br></pre></td></tr></table></figure><p>gin-swagger: gin與swagger的中介軟體。<br>files: 幫助建立檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/swaggo/gin-swagger</span><br><span class="line">go get -u github.com/swaggo/files</span><br></pre></td></tr></table></figure><p>在你的主要應用文件中執行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swag init</span><br></pre></td></tr></table></figure><div class="note warning simple"><p><img src="https://hackmd.io/_uploads/S1QZb_O5T.png" alt="image"><br>這邊實作遇到這個問題，後來看這篇文章<br><a href="https://peggy-tsai.medium.com/golang-swag-command-not-found-error-handling-52e2cbc5240e">[Golang] “swag: command not found”error handling</a></p><p><a href="https://github.com/swaggo/swag/issues/197?source=post_page-----52e2cbc5240e--------------------------------#issuecomment-585102353">參考這個解法</a></p><p>輸入以下指令以獲得 Go 的工作路徑<br>go env GOPATH</p><p><img src="https://hackmd.io/_uploads/BJ_ZV__9T.png" alt="image"></p><p>找路徑後到 go&#x2F;bin資料夾中，輸入下方command</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=$(go env GOPATH)/bin:$PATH</span><br></pre></td></tr></table></figure><p>回到專案資料夾，即可正常使用<br><img src="https://hackmd.io/_uploads/BJ7PNdd5T.png" alt="image"></p></div><p>這將生成docs目錄，其中包含Swagger的文檔資料。</p><p>將Swagger UI加入Gin<br>在你的Gin應用中，導入必要的包並將Swagger中間件添加到路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    swaggerFiles &quot;github.com/swaggo/files&quot;</span><br><span class="line">ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="line">    &quot;message/docs&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    docs.SwaggerInfo.BasePath = &quot;/api/v1&quot;</span><br><span class="line">    r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line">    // other routes...</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這一步實作發現還要引入專案 docs 文件才行</p><h1 id="Swagger-註解"><a href="#Swagger-註解" class="headerlink" title="Swagger 註解"></a>Swagger 註解</h1><h2 id="一般說明"><a href="#一般說明" class="headerlink" title="一般說明"></a>一般說明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// @title Gin swagger</span><br><span class="line">// @version 1.0</span><br><span class="line">// @description Gin swagger</span><br><span class="line"></span><br><span class="line">// @contact.name nathan.lu</span><br><span class="line">// @contact.url https://tedmax100.github.io/</span><br><span class="line"></span><br><span class="line">// @license.name Apache 2.0</span><br><span class="line">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><br><span class="line"></span><br><span class="line">// @host localhost:8080</span><br><span class="line">// schemes http</span><br><span class="line">func main() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>API Info</p><table><thead><tr><th>註解</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>必須簡單API專案的標題或主要的業務功能</td></tr><tr><td>version</td><td>必須目前這專案&#x2F;API的版本</td></tr><tr><td>description</td><td>簡單描述</td></tr><tr><td>tersOfService</td><td>服務條款</td></tr><tr><td>contact.name</td><td>作者名稱</td></tr><tr><td>contact.url</td><td>作者blog</td></tr><tr><td>contact.email</td><td>作者email</td></tr><tr><td>license.name</td><td>必須許可證名稱</td></tr><tr><td>license.url</td><td>許可證網址</td></tr><tr><td>host</td><td>服務名稱或者是ip</td></tr><tr><td>BasePath</td><td>基本URL路徑, (&#x2F;api&#x2F;v1, &#x2F;v2…)</td></tr><tr><td>schemes</td><td>提供的協定, (http, https)</td></tr></tbody></table><h2 id="API-功能註解"><a href="#API-功能註解" class="headerlink" title="API 功能註解"></a>API 功能註解</h2><p>API Operation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">helloHandler.go</span><br><span class="line"></span><br><span class="line">// @Summary 說Hello</span><br><span class="line">// @Id 1</span><br><span class="line">// @Tags Hello</span><br><span class="line">// @version 1.0</span><br><span class="line">// @produce text/plain</span><br><span class="line">// @Success 200 string string 成功後返回的值</span><br><span class="line">// @Router /hello [get]</span><br><span class="line">func GetHello(ctx *gin.Context) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">// @Summary Delete Hello</span><br><span class="line">// @Id 1</span><br><span class="line">// @Tags Hello</span><br><span class="line">// @version 1.0</span><br><span class="line">// @produce text/plain</span><br><span class="line">// @param id path int true &quot;id&quot;</span><br><span class="line">// @Success 200 string string 成功後返回的值</span><br><span class="line">// @Router /hello/&#123;id&#125; [delete]</span><br><span class="line">func DeleteHello(ctx *gin.Context) &#123; ... &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>註解</th><th>描述</th></tr></thead><tbody><tr><td>summary</td><td>描述該API</td></tr><tr><td>tags</td><td>歸屬同一類的API的tag</td></tr><tr><td>accept</td><td>request的context-type</td></tr><tr><td>produce</td><td>response的context-type</td></tr><tr><td>param</td><td>參數按照 參數名 參數類型 參數的資料類型 是否必須 註解 (中間都要空一格)</td></tr><tr><td>header</td><td>response header return code 參數類型 資料類型 註解</td></tr><tr><td>router</td><td>path httpMethod</td></tr></tbody></table><h1 id="最佳作法"><a href="#最佳作法" class="headerlink" title="最佳作法"></a>最佳作法</h1><p>1.保持文檔最新: 每次更新API時，確保運行swag init以更新文檔。<br>2.描述和詳細: 使用Swagger註釋提供充分的API描述和範例。<br>3.版本控制: 如果你的API有多個版本，確保在Swagger文檔中明確指出。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>利用Swagger與Gin結合，不僅可以自動生成API文檔，還可以提供一個交互式的界面，使其他開發者更容易理解和使用你的API。</p><p>但這邊目前看來還是要人工撰寫，感覺不夠自動化，我認為需要再進一找看看有沒有自動化工具</p><h1 id="swagger-註解自動化"><a href="#swagger-註解自動化" class="headerlink" title="swagger 註解自動化"></a>swagger 註解自動化</h1><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料:"></a>參考資料:</h1><p><a href="https://peggy-tsai.medium.com/golang-swag-command-not-found-error-handling-52e2cbc5240e">https://peggy-tsai.medium.com/golang-swag-command-not-found-error-handling-52e2cbc5240e</a><br><a href="https://vocus.cc/article/650d7ee8fd89780001aa431a">https://vocus.cc/article/650d7ee8fd89780001aa431a</a><br><a href="https://github.com/swaggo/swag/issues/197?source=post_page-----52e2cbc5240e--------------------------------#issuecomment-585102353">https://github.com/swaggo/swag/issues/197?source=post_page-----52e2cbc5240e--------------------------------#issuecomment-585102353</a></p><p><a href="https://ithelp.ithome.com.tw/articles/10224472?sc=rss.iron">https://ithelp.ithome.com.tw/articles/10224472?sc=rss.iron</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/go/">go</category>
      
      <category domain="https://gahgah147.github.io/tags/Gin/">Gin</category>
      
      <category domain="https://gahgah147.github.io/tags/Swagger/">Swagger</category>
      
      <category domain="https://gahgah147.github.io/tags/OpenAPI/">OpenAPI</category>
      
      
      <comments>https://gahgah147.github.io/2024/02/01/GO-%E4%BD%BF%E7%94%A8Gin%E5%92%8CSwagger%E8%A8%AD%E5%AE%9A%E8%87%AA%E5%8B%95%E7%94%A2%E7%94%9F%E6%96%87%E4%BB%B6%E6%AA%94%E6%A1%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker -  MySql 資料庫 Container 內容持久化</title>
      <link>https://gahgah147.github.io/2024/01/29/Docker-MySql-%E8%B3%87%E6%96%99%E5%BA%AB-Container-%E5%85%A7%E5%AE%B9%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <guid>https://gahgah147.github.io/2024/01/29/Docker-MySql-%E8%B3%87%E6%96%99%E5%BA%AB-Container-%E5%85%A7%E5%AE%B9%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <pubDate>Mon, 29 Jan 2024 02:10:59 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇是我看到 &lt;a href=&quot;https://blog.mewo.com.tw/docker/docker-%E5%A6%82%E4%BD</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇是我看到 <a href="https://blog.mewo.com.tw/docker/docker-%E5%A6%82%E4%BD%95%E8%AE%93-mysql-%E4%BF%9D%E5%AD%98%EF%BC%8C%E4%B8%8D%E6%9C%83%E9%9A%A8%E8%91%97%E5%AE%B9%E5%99%A8%E8%80%8C%E6%B6%88%E5%A4%B1/?fbclid=IwAR29_1eWXWRUYc8w_pUzs0b8oK_1XACRTVlcqPiz60QJipYG-etzRzvJCpU">[Docker] 如何讓 MySql 資料保存，不會隨著容器而消失</a><br>跟著實作的紀錄</p><h1 id="Container-內容持久化"><a href="#Container-內容持久化" class="headerlink" title="Container 內容持久化"></a>Container 內容持久化</h1><p>開發的時候 Docker 扮演一個重要的角色，我們能透過 docker-compose 快速的啟用一些需要使用到 App服務. 此篇就是要來介紹，如果透過 Volume 的方式，將 MySql Container 內容持久化。</p><h1 id="Docker-指令介紹"><a href="#Docker-指令介紹" class="headerlink" title="Docker 指令介紹"></a>Docker 指令介紹</h1><p>根據 dokcer-compose .yaml 啟動</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>停止 contanier</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><p>移除 container</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>使用 docker 指令的時候，很會透過 docker-compose down 來關閉 container，這時候就會發現存放在 mysql 中的 資料，在下一次啟動 container 的時候就會全部消失。</p><h1 id="如何解決-docker-compose-down-資料也不會消失"><a href="#如何解決-docker-compose-down-資料也不會消失" class="headerlink" title="如何解決 docker-compose down 資料也不會消失"></a>如何解決 docker-compose down 資料也不會消失</h1><p>在 yaml 中新增 Volumes，Volumes 會將資料存放於 Container 之外，範例中就是會把資料存放於 db_data 這個資料夾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">      - ./db_data:/var/lib/mysql</span><br></pre></td></tr></table></figure><p>此時使用 docker-compose down 關閉 container</p><p>再透過 docker-compose up 就會發現 mysql 的資料還存在</p><h1 id="Yaml-設定檔內容"><a href="#Yaml-設定檔內容" class="headerlink" title="Yaml 設定檔內容"></a>Yaml 設定檔內容</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mydb:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    volumes:</span><br><span class="line">      - ./db_data:/var/lib/mysql</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">      MYSQL_DATABASE: mydatebae</span><br><span class="line">      MYSQL_USER: root</span><br><span class="line">      MYSQL_PASSWORD: password</span><br><span class="line">networks:</span><br><span class="line">    LAN:</span><br><span class="line">        driver: bridge</span><br><span class="line">        name: mysql_LAN</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      <category domain="https://gahgah147.github.io/tags/MySql/">MySql</category>
      
      <category domain="https://gahgah147.github.io/tags/Docker-compose/">Docker compose</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/29/Docker-MySql-%E8%B3%87%E6%96%99%E5%BA%AB-Container-%E5%85%A7%E5%AE%B9%E6%8C%81%E4%B9%85%E5%8C%96/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 Go 來寫一個 Repository Restful API 的留言板</title>
      <link>https://gahgah147.github.io/2024/01/29/%E4%BD%BF%E7%94%A8-Go-%E4%BE%86%E5%AF%AB%E4%B8%80%E5%80%8B-Repository-Restful-API-%E7%9A%84%E7%95%99%E8%A8%80%E6%9D%BF/</link>
      <guid>https://gahgah147.github.io/2024/01/29/%E4%BD%BF%E7%94%A8-Go-%E4%BE%86%E5%AF%AB%E4%B8%80%E5%80%8B-Repository-Restful-API-%E7%9A%84%E7%95%99%E8%A8%80%E6%9D%BF/</guid>
      <pubDate>Mon, 29 Jan 2024 02:04:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇是我看到這篇文章&lt;br&gt;&lt;a href=&quot;https://github.com/880831ian/go-restful-api-rep</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇是我看到這篇文章<br><a href="https://github.com/880831ian/go-restful-api-repository-messageboard?tab=readme-ov-file">https://github.com/880831ian/go-restful-api-repository-messageboard?tab=readme-ov-file</a><br>跟著實作練習的紀錄，是使用 Go 來寫一個 Repository Restful API 的留言板，並且會使用 gin 以及 gorm (使用 Mysql)套件。<br>另外有加入 docker-compose設定跟mysql 連線調整。</p><h1 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h1><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><p><img src="https://hackmd.io/_uploads/Hy_t7sx5a.png" alt="image"></p><blockquote><p><a href="https://go.dev/">https://go.dev/</a></p></blockquote><h2 id="GIN框架"><a href="#GIN框架" class="headerlink" title="GIN框架"></a>GIN框架</h2><p><img src="https://hackmd.io/_uploads/B1ZiXjl5p.png" alt="image"></p><blockquote><p><a href="https://gin-gonic.com/">https://gin-gonic.com/</a></p></blockquote><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p><img src="https://hackmd.io/_uploads/Sks3mogcT.png" alt="image"><br><img src="https://hackmd.io/_uploads/SJXmVogc6.png" alt="image"></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="https://hackmd.io/_uploads/SyXkVjl56.png" alt="image"></p><h1 id="檔案結構"><a href="#檔案結構" class="headerlink" title="檔案結構"></a>檔案結構</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── controller</span><br><span class="line">│   └── controller.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── model</span><br><span class="line">│   └── model.go</span><br><span class="line">├── repository</span><br><span class="line">│   └── repository.go</span><br><span class="line">├── router</span><br><span class="line">│   └── router.go</span><br><span class="line">└── sql</span><br><span class="line">    ├── connect.yaml</span><br><span class="line">    └── sql.go</span><br></pre></td></tr></table></figure><p>資料夾個別功能與作用:<br>sql：放置連線資料庫檔案。<br>controller：商用邏輯控制。<br>model：定義資料表資料型態。<br>repository：處理與資料庫進行交握。<br>router：設定網站網址路由。</p><h2 id="設定-go-mod"><a href="#設定-go-mod" class="headerlink" title="設定 go.mod"></a>設定 go.mod</h2><p>到開發資料夾底下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd message_board</span><br></pre></td></tr></table></figure><p>初始化設定 go.mod 的 module</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init message</span><br></pre></td></tr></table></figure><p>接著使用 go get 來引入 gin、gorm、mysql、yaml 套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/gin-gonic/gin</span><br><span class="line">$ go get -u gorm.io/gorm</span><br><span class="line">$ go get -u gorm.io/driver/mysql</span><br><span class="line">$ go get -u gopkg.in/yaml.v2</span><br></pre></td></tr></table></figure><h2 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;message/model&quot;</span><br><span class="line">&quot;message/router&quot;</span><br><span class="line">&quot;message/sql&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//連線資料庫</span><br><span class="line">if err := sql.InitMySql(); err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//連結模型</span><br><span class="line">sql.Connect.AutoMigrate(&amp;model.Message&#123;&#125;)</span><br><span class="line">//sql.Connect.Table(&quot;message&quot;) //也可以使用連線已有資料表方式</span><br><span class="line"></span><br><span class="line">//註冊路由</span><br><span class="line">r := router.SetRouter()</span><br><span class="line"></span><br><span class="line">//啟動埠為8082的專案</span><br><span class="line">fmt.Println(&quot;開啟127.0.0.0.1:8082...&quot;)</span><br><span class="line">r.Run(&quot;127.0.0.1:8082&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入我們 Repository 架構，將 config、model、router 導入，先測試是否可以連線資料庫，使用 AutoMigrate 來新增資料表(如果沒有才新增)，或是使用 Table 來連線已有資料表，註冊網址路由，最後啟動專案，我們將 Port 設定成 8082。</p><h2 id="sql-設定"><a href="#sql-設定" class="headerlink" title="sql 設定"></a>sql 設定</h2><p>connect.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">host: 127.0.0.1</span><br><span class="line">username: root</span><br><span class="line">password: &quot;密碼&quot;</span><br><span class="line">dbname: &quot;資料庫名稱&quot;</span><br><span class="line">port: 3306</span><br></pre></td></tr></table></figure><p>我們把 mysql 連線的資訊寫在此處。  (專案正式環境可能要加入gitignore 比較安全)</p><p>sql.go (下面為一個檔案，但長度有點長，分開說明)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package sql</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;gopkg.in/yaml.v2&quot;</span><br><span class="line">&quot;gorm.io/gorm&quot;</span><br><span class="line">&quot;gorm.io/driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>import 會使用到的套件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var Connect *gorm.DB</span><br><span class="line"></span><br><span class="line">type conf struct &#123;</span><br><span class="line">Host     string `yaml:&quot;host&quot;`</span><br><span class="line">UserName string `yaml:&quot;username&quot;`</span><br><span class="line">Password string `yaml:&quot;password&quot;`</span><br><span class="line">DbName   string `yaml:&quot;dbname&quot;`</span><br><span class="line">Port     string `yaml:&quot;port&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *conf) getConf() *conf &#123;</span><br><span class="line">//讀取config/connect.yaml檔案</span><br><span class="line">yamlFile, err := ioutil.ReadFile(&quot;sql/connect.yaml&quot;)</span><br><span class="line"></span><br><span class="line">//若出現錯誤，列印錯誤訊息</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//將讀取的字串轉換成結構體conf</span><br><span class="line">err = yaml.Unmarshal(yamlFile, c)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定資料庫連線的 conf 來讀取 yaml 檔案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//初始化連線資料庫</span><br><span class="line">func InitMySql() (err error) &#123;</span><br><span class="line">var c conf</span><br><span class="line"></span><br><span class="line">//獲取yaml配置引數</span><br><span class="line">conf := c.getConf()</span><br><span class="line"></span><br><span class="line">//將yaml配置引數拼接成連線資料庫的url</span><br><span class="line">dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;,</span><br><span class="line">conf.UserName,</span><br><span class="line">conf.Password,</span><br><span class="line">conf.Host,</span><br><span class="line">conf.Port,</span><br><span class="line">conf.DbName,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//連線資料庫</span><br><span class="line">Connect, err = gorm.Open(mysql.New(mysql.Config&#123;DSN: dsn&#125;), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化資料庫，會把剛剛讀取 yaml 的 conf 串接成可以連接資料庫的 url ，最後連線資料庫。</p><h2 id="路由設定"><a href="#路由設定" class="headerlink" title="路由設定"></a>路由設定</h2><p>router.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package router</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;message/controller&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func SetRouter() *gin.Engine &#123;</span><br><span class="line">//顯示 debug 模式</span><br><span class="line">gin.SetMode(gin.ReleaseMode)</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">v1 := r.Group(&quot;api/v1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">//新增留言</span><br><span class="line">v1.POST(&quot;/message&quot;, controller.Create)</span><br><span class="line">//查詢全部留言</span><br><span class="line">v1.GET(&quot;/message&quot;, controller.GetAll)</span><br><span class="line">//查詢 &#123;id&#125; 留言</span><br><span class="line">v1.GET(&quot;/message/:id&quot;, controller.Get)</span><br><span class="line">//修改 &#123;id&#125; 留言</span><br><span class="line">v1.PATCH(&quot;/message/:id&quot;, controller.Update)</span><br><span class="line">//刪除 &#123;id&#125; 留言</span><br><span class="line">v1.DELETE(&quot;/message/:id&quot;, controller.Delete)</span><br><span class="line">&#125;</span><br><span class="line">return r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定路由，版本 v1 網址是 api&#x2F;v1 ，分別是新增留言、查詢全部留言、查詢 {id} 留言、修改 {id} 留言、刪除 {id} 留言，連接到不同的 controller function 。</p><h2 id="資料表設定"><a href="#資料表設定" class="headerlink" title="資料表設定"></a>資料表設定</h2><p>model.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package model</span><br><span class="line"></span><br><span class="line">import &quot;gorm.io/gorm&quot;</span><br><span class="line"></span><br><span class="line">func (Message) TableName() string &#123;</span><br><span class="line">return &quot;message&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Message struct &#123;</span><br><span class="line">Id        int    `gorm:&quot;primary_key,type:INT;not null;AUTO_INCREMENT&quot;`</span><br><span class="line">User_Id   int    `json:&quot;User_Id&quot;  binding:&quot;required&quot;`</span><br><span class="line">Content   string `json:&quot;Content&quot;  binding:&quot;required&quot;`</span><br><span class="line">Version   int    `gorm:&quot;default:0&quot;`</span><br><span class="line">// 包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位</span><br><span class="line">    gorm.Model</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定資料表的結構，使用 gorm.Model 預設裡面會包含 CreatedAt 和 UpdatedAt 和 DeletedAt 欄位。</p><h2 id="controller-設定"><a href="#controller-設定" class="headerlink" title="controller 設定"></a>controller 設定</h2><p>controller.go<br>(下面為一個檔案，但長度有點長，分開說明)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package controller</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;message/model&quot;</span><br><span class="line">&quot;message/repository&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;unicode/utf8&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>import 會使用到的套件。</p><p>查詢留言功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func GetAll(c *gin.Context) &#123;</span><br><span class="line">message, err := repository.GetAllMessage()</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;&quot;message&quot;: err.Error()&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: message&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Get(c *gin.Context) &#123;</span><br><span class="line">var message model.Message</span><br><span class="line"></span><br><span class="line">if err := repository.GetMessage(&amp;message, c.Param(&quot;id&quot;)); err != nil &#123;</span><br><span class="line">c.JSON(http.StatusNotFound, gin.H&#123;&quot;message&quot;: &quot;找不到留言&quot;&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: message&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetAll() 會使用到 repository.GetAllMessage() 查詢並回傳顯示查詢的資料。</p><p>c.Param(“id”) 是網址讀入後的 id，網址是<a href="http://127.0.0.1:8081/api/v1/message/%7Bid%7D">http://127.0.0.1:8081/api/v1/message/{id}</a> ，將輸入的 id 透過 repository.GetMessage() 查詢並回傳顯示查詢的資料。</p><p>新增留言功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Create(c *gin.Context) &#123;</span><br><span class="line">var message model.Message</span><br><span class="line"></span><br><span class="line">if c.PostForm(&quot;Content&quot;) == &quot;&quot; || utf8.RuneCountInString(c.PostForm(&quot;Content&quot;)) &gt;= 20 &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;&quot;message&quot;: &quot;沒有輸入內容或長度超過20個字元&quot;&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Bind(&amp;message)</span><br><span class="line">repository.CreateMessage(&amp;message)</span><br><span class="line">c.JSON(http.StatusCreated, gin.H&#123;&quot;message&quot;: message&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Gin 框架中的 Bind 函數，可以將 url 的查詢參數 query parameter，http 的 Header、body 中提交的數據給取出，透過 repository.CreateMessage() 將要新增的資料帶入，如果失敗就顯示 http.StatusBadRequest，如果成功就顯示 http.StatusCreated 以及新增的資料。</p><p>修改留言功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func Update(c *gin.Context) &#123;</span><br><span class="line">var message model.Message</span><br><span class="line"></span><br><span class="line">if c.PostForm(&quot;Content&quot;) == &quot;&quot; || utf8.RuneCountInString(c.PostForm(&quot;Content&quot;)) &gt;= 20 &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;&quot;message&quot;: &quot;沒有輸入內容或長度超過20個字元&quot;&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err := repository.UpdateMessage(&amp;message, c.PostForm(&quot;Content&quot;), c.Param(&quot;id&quot;)); err != nil &#123;</span><br><span class="line">c.JSON(http.StatusNotFound, gin.H&#123;&quot;message&quot;: &quot;找不到留言&quot;&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: message&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先使用 repository.GetMessage() 以及 c.Param(“id”) 來查詢此 id 是否存在，再帶入要修改的 Content ，透過 repository.UpdateMessage() 將資料修改，，如果失敗就顯示 http.StatusNotFound 以及找不到留言，如果成功就顯示 http.StatusOK 以及修改的資料。</p><p>刪除留言功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func Delete(c *gin.Context) &#123;</span><br><span class="line">var message model.Message</span><br><span class="line"></span><br><span class="line">if err := repository.DeleteMessage(&amp;message, c.Param(&quot;id&quot;)); err != nil &#123;</span><br><span class="line">c.JSON(http.StatusNotFound, gin.H&#123;&quot;message&quot;: &quot;找不到留言&quot;&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusNoContent, gin.H&#123;&quot;message&quot;: &quot;刪除留言成功&quot;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過 repository.DeleteMessage() 將資料刪除，如果失敗就顯示 http.StatusNotFound  以及找不到留言，如果成功就顯示 http.StatusNoContent。</p><h2 id="repository-go"><a href="#repository-go" class="headerlink" title="repository.go"></a>repository.go</h2><p>(下面為一個檔案，但長度有點長，分開說明)</p><p>所有的邏輯判斷都要在 controller 處理，所以 repository.go 就單純對資料庫就 CRUD：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package repository</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;message/model&quot;</span><br><span class="line">&quot;message/sql&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>import 會使用到的套件。</p><p>查詢留言資料讀取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//查詢全部留言</span><br><span class="line">func GetAllMessage() (message []*model.Message, err error) &#123;</span><br><span class="line">err = sql.Connect.Find(&amp;message).Error</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查詢 &#123;id&#125; 留言</span><br><span class="line">func GetMessage(message *model.Message, id string) (err error) &#123;</span><br><span class="line">err = sql.Connect.Where(&quot;id=?&quot;, id).First(&amp;message).Error</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增留言資料讀取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//新增留言</span><br><span class="line">func CreateMessage(message *model.Message) (err error) &#123;</span><br><span class="line">err = sql.Connect.Create(&amp;message).Error</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改留言資料讀取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//更新 &#123;id&#125; 留言</span><br><span class="line">func UpdateMessage(message *model.Message, content, id string) (err error) &#123;</span><br><span class="line">err = sql.Connect.Where(&quot;id=?&quot;, id).First(&amp;message).Update(&quot;content&quot;, content).Error</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刪除留言資料讀取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//刪除 &#123;id&#125; 留言</span><br><span class="line">func DeleteMessage(message *model.Message, id string) (err error) &#123;</span><br><span class="line">err = sql.Connect.Where(&quot;id=?&quot;, id).First(&amp;message).Delete(&amp;message).Error</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mysql-docker-compose-設定"><a href="#Mysql-docker-compose-設定" class="headerlink" title="Mysql docker-compose 設定"></a>Mysql docker-compose 設定</h1><p>因為我在實作時發現沒有做 mysql server的設定，我這邊作了以下調整</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 使用 Go 官方映像作為基礎映像</span><br><span class="line">FROM golang:latest</span><br><span class="line"></span><br><span class="line"># 設定工作目錄</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 複製 go.mod 和 go.sum 文件</span><br><span class="line">COPY go.mod go.sum ./</span><br><span class="line"></span><br><span class="line"># 下載依賴</span><br><span class="line">RUN go mod download</span><br><span class="line"></span><br><span class="line"># 複製源代碼文件到工作目錄</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 構建應用程序</span><br><span class="line">RUN go build -o main .</span><br><span class="line"></span><br><span class="line"># 暴露端口</span><br><span class="line">EXPOSE 8082</span><br><span class="line"></span><br><span class="line"># 執行應用程序</span><br><span class="line">CMD [&quot;./main&quot;]</span><br></pre></td></tr></table></figure><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2.1&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    db:</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_ROOT_PASSWORD: root</span><br><span class="line">            MYSQL_DATABASE: go</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;3306:3306&quot;</span><br><span class="line">        restart: always</span><br><span class="line"></span><br><span class="line">    phpmyadmin:</span><br><span class="line">        image: phpmyadmin/phpmyadmin</span><br><span class="line">        environment:</span><br><span class="line">            PMA_HOST: db</span><br><span class="line">            PMA_PORT: 3306</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;8084:80&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - db</span><br><span class="line"></span><br><span class="line">    go-app:</span><br><span class="line">        build: .</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;8082:8082&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - db</span><br></pre></td></tr></table></figure><p>這邊設定了 phpmyadmin跟 mysql 服務，另外有一個go-app 的服務運行這個專案</p><h2 id="啟用docker-compose"><a href="#啟用docker-compose" class="headerlink" title="啟用docker-compose"></a>啟用docker-compose</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HkpcFix56.png" alt="image"></p><blockquote><p>運行結果</p></blockquote><p><img src="https://hackmd.io/_uploads/ByzLhixca.png" alt="image"></p><blockquote><p>phpmyadmin連線</p></blockquote><h1 id="Postman-測試"><a href="#Postman-測試" class="headerlink" title="Postman 測試"></a>Postman 測試</h1><h2 id="查詢全部留言-成功-無資料"><a href="#查詢全部留言-成功-無資料" class="headerlink" title="查詢全部留言 - 成功(無資料)"></a>查詢全部留言 - 成功(無資料)</h2><p><img src="https://hackmd.io/_uploads/Hy_Ja5x96.png" alt="image"></p><h2 id="查詢全部留言-成功-有資料"><a href="#查詢全部留言-成功-有資料" class="headerlink" title="查詢全部留言 - 成功(有資料)"></a>查詢全部留言 - 成功(有資料)</h2><p><img src="https://hackmd.io/_uploads/HkqgWig5T.png" alt="image"></p><h2 id="查詢-id-留言-成功"><a href="#查詢-id-留言-成功" class="headerlink" title="查詢{id}留言 - 成功"></a>查詢{id}留言 - 成功</h2><p><img src="https://hackmd.io/_uploads/rkPUWig56.png" alt="image"></p><h2 id="查詢-id-留言-失敗"><a href="#查詢-id-留言-失敗" class="headerlink" title="查詢{id}留言 - 失敗"></a>查詢{id}留言 - 失敗</h2><p><img src="https://hackmd.io/_uploads/rJeKWilqp.png" alt="image"></p><h2 id="新增留言-成功"><a href="#新增留言-成功" class="headerlink" title="新增留言 - 成功"></a>新增留言 - 成功</h2><p><img src="https://hackmd.io/_uploads/By2w1jxqT.png" alt="image"></p><h2 id="修改-id-留言-成功"><a href="#修改-id-留言-成功" class="headerlink" title="修改{id}留言 - 成功"></a>修改{id}留言 - 成功</h2><p><img src="https://hackmd.io/_uploads/SyYGejec6.png" alt="image"></p><h2 id="刪除-id-留言-成功"><a href="#刪除-id-留言-成功" class="headerlink" title="刪除{id}留言 - 成功"></a>刪除{id}留言 - 成功</h2><p><img src="https://hackmd.io/_uploads/ByDofsxcp.png" alt="image"></p><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p><img src="https://hackmd.io/_uploads/SJv2GoxcT.png" alt="image"></p><h2 id="練習結果Repo"><a href="#練習結果Repo" class="headerlink" title="練習結果Repo"></a>練習結果Repo</h2><p><a href="https://github.com/gahgah147/go-restful-api-repository-messageboard">https://github.com/gahgah147/go-restful-api-repository-messageboard</a></p><h2 id="測試postmain-內容-export"><a href="#測試postmain-內容-export" class="headerlink" title="測試postmain 內容 export"></a>測試postmain 內容 export</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;info&quot;: &#123;</span><br><span class="line">&quot;_postman_id&quot;: &quot;957a0737-049b-4605-b718-07ca8e13d683&quot;,</span><br><span class="line">&quot;name&quot;: &quot;GO Repository Restful API  留言板&quot;,</span><br><span class="line">&quot;schema&quot;: &quot;https://schema.getpostman.com/json/collection/v2.1.0/collection.json&quot;,</span><br><span class="line">&quot;_exporter_id&quot;: &quot;4951341&quot;,</span><br><span class="line">&quot;_collection_link&quot;: &quot;https://martian-escape-400870.postman.co/workspace/GO-Repository-Restful-API-%25E7%259A%2584%25E7%2595%2599%25E8%25A8%2580%25E6%259D%25BF~4f66f5ef-49b8-47c3-918f-cf7a14414aa4/collection/4951341-957a0737-049b-4605-b718-07ca8e13d683?action=share&amp;source=collection_link&amp;creator=4951341&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;item&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;查詢全部留言&quot;,</span><br><span class="line">&quot;request&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">&quot;header&quot;: [],</span><br><span class="line">&quot;url&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &quot;http://127.0.0.1:8082/api/v1/message/&quot;,</span><br><span class="line">&quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">&quot;host&quot;: [</span><br><span class="line">&quot;127&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;1&quot;</span><br><span class="line">],</span><br><span class="line">&quot;port&quot;: &quot;8082&quot;,</span><br><span class="line">&quot;path&quot;: [</span><br><span class="line">&quot;api&quot;,</span><br><span class="line">&quot;v1&quot;,</span><br><span class="line">&quot;message&quot;,</span><br><span class="line">&quot;&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;response&quot;: []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;查詢留言&quot;,</span><br><span class="line">&quot;request&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">&quot;header&quot;: [],</span><br><span class="line">&quot;url&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &quot;http://127.0.0.1:8082/api/v1/message/&quot;,</span><br><span class="line">&quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">&quot;host&quot;: [</span><br><span class="line">&quot;127&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;1&quot;</span><br><span class="line">],</span><br><span class="line">&quot;port&quot;: &quot;8082&quot;,</span><br><span class="line">&quot;path&quot;: [</span><br><span class="line">&quot;api&quot;,</span><br><span class="line">&quot;v1&quot;,</span><br><span class="line">&quot;message&quot;,</span><br><span class="line">&quot;&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;response&quot;: []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;新增留言&quot;,</span><br><span class="line">&quot;request&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">&quot;header&quot;: [],</span><br><span class="line">&quot;body&quot;: &#123;</span><br><span class="line">&quot;mode&quot;: &quot;raw&quot;,</span><br><span class="line">&quot;raw&quot;: &quot;&#123;\r\n    \&quot;message\&quot;:&#123;\r\n        \&quot;id\&quot;:1,\r\n        \&quot;User_Id\&quot;: 2,\r\n        \&quot;Content\&quot;: \&quot;早安\&quot;,\r\n        \&quot;Version\&quot;: 0,\r\n        \&quot;ID\&quot;: 0,\r\n        \&quot;CreatedAt\&quot;: \&quot;2022-03-29T17:39:33.014+08:00\&quot;,\r\n        \&quot;UpdatedAt\&quot;: \&quot;2022-03-29T17:39:33.014+08:00\&quot;,\r\n        \&quot;DeletedAt\&quot;: null\r\n    &#125;\r\n&#125;&quot;,</span><br><span class="line">&quot;options&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &#123;</span><br><span class="line">&quot;language&quot;: &quot;json&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;url&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &quot;http://127.0.0.1:8082/api/v1/message&quot;,</span><br><span class="line">&quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">&quot;host&quot;: [</span><br><span class="line">&quot;127&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;1&quot;</span><br><span class="line">],</span><br><span class="line">&quot;port&quot;: &quot;8082&quot;,</span><br><span class="line">&quot;path&quot;: [</span><br><span class="line">&quot;api&quot;,</span><br><span class="line">&quot;v1&quot;,</span><br><span class="line">&quot;message&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;response&quot;: []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;修改留言&quot;,</span><br><span class="line">&quot;request&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">&quot;header&quot;: [],</span><br><span class="line">&quot;body&quot;: &#123;</span><br><span class="line">&quot;mode&quot;: &quot;raw&quot;,</span><br><span class="line">&quot;raw&quot;: &quot;&#123;\r\n    \&quot;message\&quot;:&#123;\r\n        \&quot;id\&quot;:1,\r\n        \&quot;User_Id\&quot;: 2,\r\n        \&quot;Content\&quot;: \&quot;早安\&quot;,\r\n        \&quot;Version\&quot;: 0,\r\n        \&quot;ID\&quot;: 0,\r\n        \&quot;CreatedAt\&quot;: \&quot;2022-03-29T17:39:33.014+08:00\&quot;,\r\n        \&quot;UpdatedAt\&quot;: \&quot;2022-03-29T17:39:33.014+08:00\&quot;,\r\n        \&quot;DeletedAt\&quot;: null\r\n    &#125;\r\n&#125;&quot;,</span><br><span class="line">&quot;options&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &#123;</span><br><span class="line">&quot;language&quot;: &quot;json&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;url&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &quot;http://127.0.0.1:8082/api/v1/message&quot;,</span><br><span class="line">&quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">&quot;host&quot;: [</span><br><span class="line">&quot;127&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;1&quot;</span><br><span class="line">],</span><br><span class="line">&quot;port&quot;: &quot;8082&quot;,</span><br><span class="line">&quot;path&quot;: [</span><br><span class="line">&quot;api&quot;,</span><br><span class="line">&quot;v1&quot;,</span><br><span class="line">&quot;message&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;response&quot;: []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;刪除留言&quot;,</span><br><span class="line">&quot;request&quot;: &#123;</span><br><span class="line">&quot;method&quot;: &quot;DELETE&quot;,</span><br><span class="line">&quot;header&quot;: [],</span><br><span class="line">&quot;body&quot;: &#123;</span><br><span class="line">&quot;mode&quot;: &quot;raw&quot;,</span><br><span class="line">&quot;raw&quot;: &quot;&#123;\r\n    \&quot;message\&quot;:&#123;\r\n        \&quot;id\&quot;:1,\r\n        \&quot;User_Id\&quot;: 2,\r\n        \&quot;Content\&quot;: \&quot;早安\&quot;,\r\n        \&quot;Version\&quot;: 0,\r\n        \&quot;ID\&quot;: 0,\r\n        \&quot;CreatedAt\&quot;: \&quot;2022-03-29T17:39:33.014+08:00\&quot;,\r\n        \&quot;UpdatedAt\&quot;: \&quot;2022-03-29T17:39:33.014+08:00\&quot;,\r\n        \&quot;DeletedAt\&quot;: null\r\n    &#125;\r\n&#125;&quot;,</span><br><span class="line">&quot;options&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &#123;</span><br><span class="line">&quot;language&quot;: &quot;json&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;url&quot;: &#123;</span><br><span class="line">&quot;raw&quot;: &quot;http://127.0.0.1:8082/api/v1/message/1&quot;,</span><br><span class="line">&quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">&quot;host&quot;: [</span><br><span class="line">&quot;127&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;0&quot;,</span><br><span class="line">&quot;1&quot;</span><br><span class="line">],</span><br><span class="line">&quot;port&quot;: &quot;8082&quot;,</span><br><span class="line">&quot;path&quot;: [</span><br><span class="line">&quot;api&quot;,</span><br><span class="line">&quot;v1&quot;,</span><br><span class="line">&quot;message&quot;,</span><br><span class="line">&quot;1&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;response&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加入Container-內容持久化設定"><a href="#加入Container-內容持久化設定" class="headerlink" title="加入Container 內容持久化設定"></a>加入Container 內容持久化設定</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">            - ./db_data:/var/lib/mysql</span><br></pre></td></tr></table></figure><p>在 yaml 中新增 Volumes，Volumes 會將資料存放於 Container 之外，範例中就是會把資料存放於 db_data 這個資料夾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db:</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        container_name: db</span><br><span class="line">        command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_ROOT_PASSWORD: root</span><br><span class="line">            MYSQL_DATABASE: go</span><br><span class="line">        volumes:</span><br><span class="line">            - ./db_data:/var/lib/mysql</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;3306:3306&quot;</span><br><span class="line">        restart: always</span><br><span class="line">        networks:</span><br><span class="line">          - default</span><br></pre></td></tr></table></figure><h1 id="設定container之間的連線"><a href="#設定container之間的連線" class="headerlink" title="設定container之間的連線"></a>設定container之間的連線</h1><p>加入network設定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">networks:</span><br><span class="line">  default:</span><br></pre></td></tr></table></figure><p>並調整 docker-compose 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2.1&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    db:</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        container_name: db</span><br><span class="line">        command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_ROOT_PASSWORD: root</span><br><span class="line">            MYSQL_DATABASE: go</span><br><span class="line">        volumes:</span><br><span class="line">            - ./db_data:/var/lib/mysql</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;3306:3306&quot;</span><br><span class="line">        restart: always</span><br><span class="line">        networks:</span><br><span class="line">          - default</span><br><span class="line">    phpmyadmin:</span><br><span class="line">        image: phpmyadmin/phpmyadmin</span><br><span class="line">        container_name: phpmyadmin</span><br><span class="line">        environment:</span><br><span class="line">            PMA_HOST: db</span><br><span class="line">            PMA_PORT: 3306</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;8084:80&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - db</span><br><span class="line">        networks:</span><br><span class="line">          - default</span><br><span class="line">    go-app:</span><br><span class="line">        build: .</span><br><span class="line">        container_name: go-app</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;8082:8082&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - db</span><br><span class="line">        networks:</span><br><span class="line">          - default</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br></pre></td></tr></table></figure><p>調整 connect.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">host: db</span><br><span class="line">username: root</span><br><span class="line">password: root</span><br><span class="line">dbname: go</span><br><span class="line">port: 3306</span><br></pre></td></tr></table></figure><p>這邊設定 db連線到db這個 container</p><h1 id="專案練習-Repo"><a href="#專案練習-Repo" class="headerlink" title="專案練習 Repo"></a>專案練習 Repo</h1><p><a href="https://github.com/gahgah147/go-restful-api-repository-messageboard">https://github.com/gahgah147/go-restful-api-repository-messageboard</a></p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://github.com/880831ian/go-restful-api-repository-messageboard?tab=readme-ov-file">https://github.com/880831ian/go-restful-api-repository-messageboard?tab=readme-ov-file</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      <category domain="https://gahgah147.github.io/tags/Gin/">Gin</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%BE%8C%E7%AB%AF/">後端</category>
      
      <category domain="https://gahgah147.github.io/tags/Go/">Go</category>
      
      <category domain="https://gahgah147.github.io/tags/Mysql/">Mysql</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/29/%E4%BD%BF%E7%94%A8-Go-%E4%BE%86%E5%AF%AB%E4%B8%80%E5%80%8B-Repository-Restful-API-%E7%9A%84%E7%95%99%E8%A8%80%E6%9D%BF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Azure Blob Storage 設定流程</title>
      <link>https://gahgah147.github.io/2024/01/23/Azure-Blob-Storage-%E8%A8%AD%E5%AE%9A%E6%B5%81%E7%A8%8B/</link>
      <guid>https://gahgah147.github.io/2024/01/23/Azure-Blob-Storage-%E8%A8%AD%E5%AE%9A%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Tue, 23 Jan 2024 06:38:19 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這一篇是參考以下教學文章&lt;br&gt;&lt;a href=&quot;https://xenby.com/b/238-%E6%95%99%E5%AD%B8-azure-blob-storage-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%89%B5%E5%</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這一篇是參考以下教學文章<br><a href="https://xenby.com/b/238-%E6%95%99%E5%AD%B8-azure-blob-storage-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%89%B5%E5%BB%BA%E7%AF%87">[教學] Azure Blob Storage 使用指南 – 創建篇</a><br>實作練習的紀錄</p><h1 id="Azure-Blob-Storage-設定流程"><a href="#Azure-Blob-Storage-設定流程" class="headerlink" title="Azure Blob Storage 設定流程"></a>Azure Blob Storage 設定流程</h1><p>Microsoft Azure 的 Blob Storage 提供了透過 restful api 來對檔案進行取得檔案以及對其新增、修改刪除的功能，對於在許多機房能夠同時存取非常方便，本篇將教學如何透過 azure portal 創建 Microsoft Azure 的 Blob Storage。</p><p><img src="https://hackmd.io/_uploads/SkJpZ2jFp.png" alt="image"></p><p>Blob 主要架構分為三層</p><p><img src="https://hackmd.io/_uploads/rJtXbCnFa.png" alt="image"></p><table><thead><tr><th>架構</th><th>說明</th></tr></thead><tbody><tr><td>儲存體帳戶 (storage account)</td><td>表示一個倉庫帳號，一個使用者可以創間多個儲存體帳戶</td></tr><tr><td>容器 (container)</td><td>類似於硬碟的概念，在一個 storage account 可以有多個 container，用來區分不同用途的檔案</td></tr><tr><td>Blob (檔案或資料)</td><td>類似於檔案系統的檔案，並且可以有資料夾多層式的階層來做更進一步的分類</td></tr></tbody></table><h1 id="創建-storage-account"><a href="#創建-storage-account" class="headerlink" title="創建 storage account"></a>創建 storage account</h1><p>首先進入 azure portal </p><p><img src="https://hackmd.io/_uploads/B1DgMChKa.png" alt="image"></p><blockquote><p><a href="https://portal.azure.com/">https://portal.azure.com/</a></p></blockquote><p>進入頁面中會有Azure 服務清單，點 [建立資源]</p><p><img src="https://hackmd.io/_uploads/HJJdz02Fa.png" alt="image"></p><blockquote><p>接著在列表中點 [儲存體] 並選擇 [儲存體帳戶 – Blob、檔案、資料表、佇列]</p></blockquote><p>創建需要填寫儲存體的設定</p><p><img src="https://hackmd.io/_uploads/B1Uq4AhK6.png" alt="image"></p><ul><li>訂用帳戶：如果是公司的帳號，可能會有多個訂用帳戶用於不同場景，依照需求選擇</li><li>資源群組：設定該資源設置屬於群組，可以依照不同專案或者是不同用途來區分，之後用來檢視哪些專案使用多少資源會比較方便</li><li>儲存體帳戶名稱：這會影響預設的資源存取 domain，以及簽署存取簽章時需要，不過也能夠自行更改 domain 可參考：針對 Azure 儲存體帳戶設定自訂網域名稱</li><li>位置：伺服器機房所在位置</li><li>效能：空間硬碟的IO速度等級</li><li>帳戶總類：參考 Azure 儲存體帳戶概觀，一般直接選擇 StorageV2</li><li>複寫：設定資料在複製多份時會以哪種策略分布</li><li>存取層：可參考 Azure Blob 儲存體：經常性、非經常性和封存存取層，主要影響讀取的速度，不同總類的價格也不同</li></ul><p>進階設定</p><p><img src="https://hackmd.io/_uploads/B12CBC2ta.png" alt="image"></p><ul><li>需要安全傳輸：進行資料傳輸過程是否加密，例如使用 restful API 存取時是否只允許使用 https</li><li>大型檔案共用：是否有大檔案的需求，如果勾選後可以存放檔案大小上限達 100TB 的檔案</li><li>Blob 虛刪除：設定檔案刪除是否只是標記為刪除，並且支援將標記的檔案復原功能</li><li>階層式命名空間：參考 Azure Data Lake 儲存體，對於極大量資料可以有好的效能</li></ul><p>網路設定</p><p><img src="https://hackmd.io/_uploads/S1qNLR2FT.png" alt="image"><br>用於設定哪些網路可以存取此 storage，依據自己的用途選擇</p><p>資料保護設定</p><p><img src="https://hackmd.io/_uploads/SJciI02K6.png" alt="image"></p><p>加密設定<br><img src="https://hackmd.io/_uploads/Sk2oPRnY6.png" alt="image"></p><p>標籤設定<br><img src="https://hackmd.io/_uploads/SyYyOA2F6.png" alt="image"></p><p>最後會驗證必填的資料是否都有填寫，並且確認設定沒有錯誤按下[建立]<br><img src="https://hackmd.io/_uploads/Skac_Cnta.png" alt="image"></p><p>等待它完成部署<br><img src="https://hackmd.io/_uploads/HkV1FAnYT.png" alt="image"></p><p>完成部署後，可以點 [前往資源] 進行資源的檢視<br><img src="https://hackmd.io/_uploads/SkhZYChFp.png" alt="image"></p><p>而如果要讓服務能夠使用需要先建立容器 (container)</p><p>在左邊的列表中找到 [Blob服務]，並且點擊 [容器]<br><img src="https://hackmd.io/_uploads/SkJ_tCnK6.png" alt="image"></p><p>並且點擊左上的新增容器按鈕</p><p><img src="https://hackmd.io/_uploads/SJMRF0ntT.png" alt="image"></p><p>輸入自己想要的容器名稱，按下 [確定] 建立容器</p><p><img src="https://hackmd.io/_uploads/SyP8qC3Ka.png" alt="image"><br>成功後進入容器就可以開始使用，可以選擇手動上傳檔案或是透過程式 API 來進行檔案新增修改刪除</p><p><img src="https://hackmd.io/_uploads/r1mqoR3Kp.png" alt="image"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Azure/">Azure</category>
      
      <category domain="https://gahgah147.github.io/tags/Azure-Blob-Storage/">Azure Blob Storage</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99/">雲端服務</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/23/Azure-Blob-Storage-%E8%A8%AD%E5%AE%9A%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 Vercel 部署 NestJS 程式</title>
      <link>https://gahgah147.github.io/2024/01/17/%E4%BD%BF%E7%94%A8-Vercel-%E9%83%A8%E7%BD%B2-NestJS-%E7%A8%8B%E5%BC%8F/</link>
      <guid>https://gahgah147.github.io/2024/01/17/%E4%BD%BF%E7%94%A8-Vercel-%E9%83%A8%E7%BD%B2-NestJS-%E7%A8%8B%E5%BC%8F/</guid>
      <pubDate>Wed, 17 Jan 2024 08:15:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這邊我是參考這篇 &lt;a href=&quot;https://www.levenx.com/article/how-to-deploy-your-ne</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這邊我是參考這篇 <a href="https://www.levenx.com/article/how-to-deploy-your-nestjs-application-using-vercel#heading-4">一文教会你如何使用 Vercel 部署你的 NestJS 应用</a> 教學文章跟著操作的紀錄</p><h1 id="Nestjs-專案增加-vercel-設定文件"><a href="#Nestjs-專案增加-vercel-設定文件" class="headerlink" title="Nestjs 專案增加 vercel 設定文件"></a>Nestjs 專案增加 vercel 設定文件</h1><p>在跟目錄下新增 vercel.json 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;version&quot;: 2,</span><br><span class="line">  &quot;builds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;src&quot;: &quot;src/main.ts&quot;,</span><br><span class="line">      &quot;use&quot;: &quot;@vercel/node&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;routes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;src&quot;: &quot;/(.*)&quot;,</span><br><span class="line">      &quot;dest&quot;: &quot;src/main.ts&quot;,</span><br><span class="line">      &quot;methods&quot;: [</span><br><span class="line">        &quot;GET&quot;,</span><br><span class="line">        &quot;POST&quot;,</span><br><span class="line">        &quot;PUT&quot;,</span><br><span class="line">        &quot;DELETE&quot;,</span><br><span class="line">        &quot;PATCH&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nestjs-專案上傳到github"><a href="#Nestjs-專案上傳到github" class="headerlink" title="Nestjs 專案上傳到github"></a>Nestjs 專案上傳到github</h1><p><img src="https://hackmd.io/_uploads/rkGZLZHtT.png" alt="image"></p><h1 id="授權给-vercel"><a href="#授權给-vercel" class="headerlink" title="授權给 vercel"></a>授權给 vercel</h1><p>點選右上角頭像展開選單<br><img src="https://hackmd.io/_uploads/ByXTLWBKT.png" alt="image"></p><p>選擇setting<br><img src="https://hackmd.io/_uploads/SywhLZBt6.png" alt="image"></p><p>選擇 config<br><img src="https://hackmd.io/_uploads/B1Ps8ZBtp.png" alt="image"></p><h1 id="Vercel-平台新增專案"><a href="#Vercel-平台新增專案" class="headerlink" title="Vercel 平台新增專案"></a>Vercel 平台新增專案</h1><p>這邊找到剛剛建立的repo 點選import<br><img src="https://hackmd.io/_uploads/rkP6w-HY6.png" alt="image"></p><p>修改執行命令，並且執行 deploy</p><p>部屬完成<br><img src="https://hackmd.io/_uploads/ryEjdZSKp.png" alt="image"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Vercel/">Vercel</category>
      
      <category domain="https://gahgah147.github.io/tags/Nestjs/">Nestjs</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%BE%8C%E7%AB%AF/">後端</category>
      
      <category domain="https://gahgah147.github.io/tags/CI-CD/">CI/CD</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/17/%E4%BD%BF%E7%94%A8-Vercel-%E9%83%A8%E7%BD%B2-NestJS-%E7%A8%8B%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt3 運行在Docker 上</title>
      <link>https://gahgah147.github.io/2024/01/11/Nuxt3-%E9%81%8B%E8%A1%8C%E5%9C%A8Docker-%E4%B8%8A/</link>
      <guid>https://gahgah147.github.io/2024/01/11/Nuxt3-%E9%81%8B%E8%A1%8C%E5%9C%A8Docker-%E4%B8%8A/</guid>
      <pubDate>Thu, 11 Jan 2024 08:30:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這邊在練習Nuxt 3時想要運行在Docker 上，所以就找到這篇文章&lt;br&gt;&lt;a href=&quot;https://www.ruyut.com/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這邊在練習Nuxt 3時想要運行在Docker 上，所以就找到這篇文章<br><a href="https://www.ruyut.com/2023/04/deploy-nuxt3-to-docker-with-dockerfile.html">將 Nuxt3 發布至 docker 中，Dockerfile 看這裡就對了</a><br>實際測試可以成功，所以記錄一下過程</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 使用 node 長期支援版</span><br><span class="line">FROM node:lts-alpine</span><br><span class="line"></span><br><span class="line"># 設定工作目錄</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 複製 package.json 和 package-lock.json 至工作目錄</span><br><span class="line">COPY package*.json ./</span><br><span class="line"></span><br><span class="line"># 依照指定版本安裝依賴</span><br><span class="line">RUN npm ci</span><br><span class="line"></span><br><span class="line"># 複製所有</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 建立生產版本</span><br><span class="line">RUN npm run build</span><br><span class="line"></span><br><span class="line"># 暴露的連接埠</span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"># 啟動應用程式</span><br><span class="line">CMD [&quot;node&quot;, &quot;.output/server/index.mjs&quot;]</span><br></pre></td></tr></table></figure><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-nuxt-app .</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1pUUXp_T.png" alt="image"></p><h1 id="啟動"><a href="#啟動" class="headerlink" title="啟動"></a>啟動</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nuxt-app -p 3000:3000 my-nuxt-app</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SkGuLmT_T.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SJX9I7pOa.png" alt="image"></p><blockquote><p>結果成功執行</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      <category domain="https://gahgah147.github.io/tags/Nuxt-3/">Nuxt 3</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/11/Nuxt3-%E9%81%8B%E8%A1%8C%E5%9C%A8Docker-%E4%B8%8A/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LinkedIn Redesign Nuxtjs3</title>
      <link>https://gahgah147.github.io/2024/01/09/LinkedIn-Redesign-Nuxtjs3/</link>
      <guid>https://gahgah147.github.io/2024/01/09/LinkedIn-Redesign-Nuxtjs3/</guid>
      <pubDate>Tue, 09 Jan 2024 09:45:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;LinkedIn-Redesign-Nuxtjs3&quot;&gt;&lt;a href=&quot;#LinkedIn-Redesign-Nuxtjs3&quot; class=&quot;headerlink&quot; title=&quot;LinkedIn Redesign Nuxtjs3&quot;&gt;&lt;/a&gt;LinkedIn Re</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="LinkedIn-Redesign-Nuxtjs3"><a href="#LinkedIn-Redesign-Nuxtjs3" class="headerlink" title="LinkedIn Redesign Nuxtjs3"></a>LinkedIn Redesign Nuxtjs3</h1><h1 id="準備Figma-設計稿"><a href="#準備Figma-設計稿" class="headerlink" title="準備Figma 設計稿"></a>準備Figma 設計稿</h1><p><a href="https://www.figma.com/file/7EeOLaEuMD7cNIsXTM8vp0/LinkedIn-Redesign-UI-Kit-(Community)?node-id=0:1&mode=dev">https://www.figma.com/file/7EeOLaEuMD7cNIsXTM8vp0/LinkedIn-Redesign-UI-Kit-(Community)?node-id=0%3A1&amp;mode=dev</a></p><h1 id="建立Nuxt-js-3-專案"><a href="#建立Nuxt-js-3-專案" class="headerlink" title="建立Nuxt.js 3 專案"></a>建立Nuxt.js 3 專案</h1><p>npx nuxi@latest init nuxt-linkedIn-redesign</p><h1 id="把每一頁透過-Builder-io-產生程式"><a href="#把每一頁透過-Builder-io-產生程式" class="headerlink" title="把每一頁透過 Builder.io 產生程式"></a>把每一頁透過 Builder.io 產生程式</h1><p><img src="https://hackmd.io/_uploads/B1ILUFqO6.png" alt="image"></p><p>Framework 選擇 Vue<br><img src="https://hackmd.io/_uploads/ryyKLY5Op.png" alt="image"></p><h1 id="新增-profile-page-元件"><a href="#新增-profile-page-元件" class="headerlink" title="新增 profile page 元件"></a>新增 profile page 元件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add page profile</span><br></pre></td></tr></table></figure><p>調整 app.vue 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;NuxtPage /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><div class="note info simple"><p>另外需要安裝 tailwindcss</p></div><p><img src="https://hackmd.io/_uploads/B1jHtt5da.png" alt="image"></p><p>成果:<br><img src="https://hackmd.io/_uploads/BkJ_tF9ua.png" alt="image"></p><blockquote><p><a href="http://localhost:3000/profile">http://localhost:3000/profile</a></p></blockquote><p>專案repo:<br><a href="https://github.com/gahgah147/nuxt-linkedIn-redesign">https://github.com/gahgah147/nuxt-linkedIn-redesign</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Builder-io/">Builder.io</category>
      
      <category domain="https://gahgah147.github.io/tags/Figma/">Figma</category>
      
      <category domain="https://gahgah147.github.io/tags/Nuxt-3/">Nuxt 3</category>
      
      <category domain="https://gahgah147.github.io/tags/tailwindcss/">tailwindcss</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/09/LinkedIn-Redesign-Nuxtjs3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PixiJS 安裝設定</title>
      <link>https://gahgah147.github.io/2024/01/09/PixiJS-%E5%AE%89%E8%A3%9D%E8%A8%AD%E5%AE%9A/</link>
      <guid>https://gahgah147.github.io/2024/01/09/PixiJS-%E5%AE%89%E8%A3%9D%E8%A8%AD%E5%AE%9A/</guid>
      <pubDate>Tue, 09 Jan 2024 06:58:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇文章是我在 2022 iTHome 鐵人賽看到 &lt;a href=&quot;https://ithelp.ithome.com.tw/users/</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇文章是我在 2022 iTHome 鐵人賽看到 <a href="https://ithelp.ithome.com.tw/users/20152526/ironman/5741">PixiJS青銅玩家 系列</a> 文章做的一個紀錄。</p><h1 id="PixiJS-是什麼"><a href="#PixiJS-是什麼" class="headerlink" title="PixiJS 是什麼?"></a>PixiJS 是什麼?</h1><p>PixiJS 是一個用於創建2D網頁遊戲和互動內容的快速輕量級渲染引擎。它是一個使用JavaScript編寫的開源庫，提供了簡單而強大的API，使開發者能夠輕鬆地創建高性能的瀏覽器內遊戲和互動應用。</p><h1 id="安裝PixiJS"><a href="#安裝PixiJS" class="headerlink" title="安裝PixiJS"></a>安裝PixiJS</h1><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pixi.js</span><br></pre></td></tr></table></figure><h2 id="下載JS文件"><a href="#下載JS文件" class="headerlink" title="下載JS文件"></a>下載JS文件</h2><p><a href="https://github.com/pixijs/pixijs/releases">https://github.com/pixijs/pixijs/releases</a></p><p>可以從以上PixiJS的主要發布頁面中，找到各種版本的PixiJS，現在最新版本是v8.0.0-rc.2，往下滑到Asset的部份，可以看見很多個文件（如下圖），其中最重要的就是pixi.js跟pixi.min.js，這兩個檔案都可以使用。</p><p><img src="https://hackmd.io/_uploads/By8t1DcO6.png" alt="image"></p><blockquote><p><a href="https://github.com/pixijs/pixijs/releases/tag/v8.0.0-rc.2">https://github.com/pixijs/pixijs/releases/tag/v8.0.0-rc.2</a></p></blockquote><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p><a href="https://cdnjs.com/libraries/pixi.js/4.5.5">https://cdnjs.com/libraries/pixi.js/4.5.5</a></p><p><img src="https://hackmd.io/_uploads/r1n7XwcuT.png" alt="image"></p><blockquote><p><a href="https://cdnjs.com/libraries/pixi.js">https://cdnjs.com/libraries/pixi.js</a></p></blockquote><div class="note info simple"><p>.js檔與.min.js檔案的區別</p><table><thead><tr><th></th><th>.js檔</th><th>.min.js檔</th></tr></thead><tbody><tr><td>優點</td><td>可讀性高，比較好觀察、修改</td><td>1. 減小體積，使傳輸變快 2. 可以使JS防止被偷窺、竊取</td></tr><tr><td>缺點</td><td>體積較大，傳輸較慢</td><td>可讀性差</td></tr></tbody></table></div><h1 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h1><p>在HTML執行 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;範例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.5/pixi.min.js&quot; &gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        let type = &quot;WebGL&quot;</span><br><span class="line">        if(!PIXI.utils.isWebGLSupported())&#123;</span><br><span class="line">        type = &quot;canvas&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PIXI.utils.sayHello(type)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>當我們執行上述程式碼後，假如PixiJS成功可以運作時，以Chrome來說就可以在DevTools中的console裡面看見底下的圖片：<br><img src="https://hackmd.io/_uploads/BywBnwc_p.png" alt="image"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/PixiJS/">PixiJS</category>
      
      <category domain="https://gahgah147.github.io/tags/2022-iTHome-%E9%90%B5%E4%BA%BA%E8%B3%BD/">2022 iTHome 鐵人賽</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/09/PixiJS-%E5%AE%89%E8%A3%9D%E8%A8%AD%E5%AE%9A/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt 3 DevTools 視覺化工具</title>
      <link>https://gahgah147.github.io/2024/01/03/Nuxt-3-DevTools-%E8%A6%96%E8%A6%BA%E5%8C%96%E5%B7%A5%E5%85%B7/</link>
      <guid>https://gahgah147.github.io/2024/01/03/Nuxt-3-DevTools-%E8%A6%96%E8%A6%BA%E5%8C%96%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Wed, 03 Jan 2024 07:33:31 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 &lt;a href=&quot;https://ithelp.ithome.co</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 <a href="https://ithelp.ithome.com.tw/users/20152617/ironman/6959">Nuxt 3 實戰筆記 系列</a> 文章做的一個紀錄，我之前也都有看到發表Nuxt 相關的文章，寫得都很用心仔細很值得跟著練習，我覺得最特別的是 Nuxt 新的 DevTools功能 </p><h1 id="安裝與啟用-Nuxt-DevTools"><a href="#安裝與啟用-Nuxt-DevTools" class="headerlink" title="安裝與啟用 Nuxt DevTools"></a>安裝與啟用 Nuxt DevTools</h1><p>目前最新版的 Nuxt CLI 在建立專案時，預設已經預置並啟用了 Nuxt DevTools，你無需再另外設置，你可以透過專案下的 .&#x2F;nuxt.config.ts 檔案確定，devtools.enabled 屬性是否設定為 true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default defineNuxtConfig(&#123;</span><br><span class="line">  devtools: &#123;</span><br><span class="line">    enabled: true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果你的專案尚未啟用 Nuxt DevTools，你可以使用下列指令來為專案加入，需要注意的是 Nuxt DevTools 需要 Nuxt v3.1.0 或更高版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi@latest devtools enable</span><br></pre></td></tr></table></figure><p>當你使用指令啟用 devtools，等同於下列步驟安裝與配置 @nuxt&#x2F;devtools 模組。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D @nuxt/devtools</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// nuxt.config.ts</span><br><span class="line">export default defineNuxtConfig(&#123;</span><br><span class="line">  modules: [</span><br><span class="line">    &#x27;@nuxt/devtools&#x27;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同樣的你也可以透過設定 devtools.enabled 屬性為 <strong>false，</strong>或使用下列指令來禁用 Nuxt Devtools。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi@latest devtools disable</span><br></pre></td></tr></table></figure><p>接下來我們以 Nuxt 3 的演示專案 Nuxt Movies 來展示 DevTools 的功能，你也可以直接套用在你的專案搭配著本篇介紹一步一步來嘗試使用 Nuxt DevTools。</p><p>接下來我們以 Nuxt 3 的演示專案 <a href="https://github.com/nuxt/movies">Nuxt Movies</a> 來展示 DevTools 的功能，你也可以直接套用在你的專案搭配著本篇介紹一步一步來嘗試使用 Nuxt DevTools。</p><p>fork 練習 專案 <a href="https://github.com/nalson0219/movies">https://github.com/nalson0219/movies</a></p><h1 id="開啟-Nuxt-Devtools-面板"><a href="#開啟-Nuxt-Devtools-面板" class="headerlink" title="開啟 Nuxt Devtools 面板"></a>開啟 Nuxt Devtools 面板</h1><p>安裝並啟用 Nuxt DevTools 後，在你啟動開發伺服器後，使用瀏覽器瀏覽網站頁面上會出現一個 Nuxt Logo 的圖示，如下圖紅色框起處，通常預設會是吸附在頁面底部。<br><img src="https://hackmd.io/_uploads/r1_bhFtL6.png" alt="image"></p><blockquote><p>npm run dev 開啟專案</p></blockquote><p>當你把滑鼠滑入圖示時，就會展開工具，如果它遮擋著你的頁面，你也可以拖曳它來移動畫面中貼附的位置。</p><p><img src="https://hackmd.io/_uploads/B1K2pttIp.png" alt="image"><br>展開的工具共有三欄，分別為<br>1.Nuxt 圖示點擊後可以開啟 Nuxt Devtools 面板<br>2.導航至頁面載入時間<br>3.檢查器（Inspector）</p><p>如下圖，當我們需要開啟 Nuxt DevTools 面板，點擊頁面懸浮迷你面板最左方的 Nuxt 圖示便會開啟，當然你也可以透過快捷鍵，例如 Mac 使用 Shift + Option + D 來開啟，開啟後的面板你也可以根據需求來調整大小。</p><p><img src="https://hackmd.io/_uploads/ryFw0YFUa.png" alt="image"></p><p>當我們點擊顯示 DevTools 面板，會出現如下圖的概覽，包含了 Nuxt 與 Vue 的版本，甚至提示你版本落後可以進行更新，蓋懶得資料也包含了整個 Nuxt 專案的資訊頁面、元件、載入、模組與插件的數量等，可以很快速的讓你了解專案概況。</p><p><img src="https://hackmd.io/_uploads/HJbqRKYIa.png" alt="image"></p><h1 id="使用-Nuxt-DevTools-檢查器（Inspector）"><a href="#使用-Nuxt-DevTools-檢查器（Inspector）" class="headerlink" title="使用 Nuxt DevTools 檢查器（Inspector）"></a>使用 Nuxt DevTools 檢查器（Inspector）</h1><p>當你的專案是接手維護或規模比較大的團隊協作時，Nuxt DevTools 整合了 <a href="https://github.com/webfansplz/vite-plugin-vue-inspector">vite-plugin-vue-inspector</a> 插件，<br>這項功能使元件的調整更加的容易，你也可以不必深入完整了解專案結構，就能快速定位渲染的程式。</p><p><img src="https://hackmd.io/_uploads/B1Drz9KUa.png" alt="image"></p><blockquote><p>點擊檢查器後，當滑鼠滑入畫面的元素便會提示元件檔案位置與行數，點擊後能前往該檔案。</p></blockquote><div class="note warning simple"><p>這功能我目前測試有問題，點開是不會跳到那邊</p></div><h1 id="Nuxt-DevTools-工具面板介面功能"><a href="#Nuxt-DevTools-工具面板介面功能" class="headerlink" title="Nuxt DevTools 工具面板介面功能"></a>Nuxt DevTools 工具面板介面功能</h1><p><img src="https://hackmd.io/_uploads/SJp9QcYI6.png" alt="image"></p><p>如果你是第一次使用或想要調整工具面板的設定，可以點選左下角的圖示，如下圖紅色框起處，就會切換至設定的分頁，在這裡你可以決定左側選單的項目顯示或隱藏，這將有助於關閉一些對你來說不重要的分頁圖示，你也可以在這裡修改深色模式、懸浮迷你面板的縮小間隔時間與 UI 縮放等設置。</p><p><img src="https://hackmd.io/_uploads/H1TzEcYIp.png" alt="image"></p><p>基本上 Nuxt DevTools 面板上可以使用功能，多數只要切換至該功能分頁，你就能理解它將帶給你的資訊與協助。</p><h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><p>目前 Nuxt DevTools 雖然還處於預覽階段，但已經有許多強大的功能，未來 Nuxt DevTools 計畫提供更直觀、更有趣的方式來呈現數據，除了輕鬆管理與建立 Nuxt 的專案外，在開發工具上也提高框架約定的透明度來改善開發體驗，如果你有興趣也可以關注 Nuxt DevTools 的專案並分享想法與建議甚至做出貢獻，更多資訊與功能也可以查看<a href="https://github.com/nuxt/devtools">官方文件</a>。</p><h1 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h1><p>在開啟 Nuxt Tools 工具面板後，我們切換到 Pages 分頁。<br><img src="https://hackmd.io/_uploads/S1EMrcF86.png" alt="image"></p><p>Pages 分頁展示了目前專案所有註冊的頁面路由 (Rotes) 與路由中間件 (Middleware)。</p><h2 id="所有註冊的頁面路由-All-Routes"><a href="#所有註冊的頁面路由-All-Routes" class="headerlink" title="所有註冊的頁面路由 -  All Routes"></a>所有註冊的頁面路由 -  All Routes</h2><p><img src="https://hackmd.io/_uploads/HylgUqYI6.png" alt="image"></p><p>如果你不熟悉頁面檔案所產生的路由名稱，在下圖的紅色框起處的路由名稱，可以幫助你在使用程式化導航時，以具名的方式來前往路由，如 router.push({ name: ‘search’ })。</p><p>你可以點擊路由的路徑網址就可以同步網頁進行路由導航，點擊就會跳轉至 &#x2F;search 搜尋頁面，當然你也可以透過面板上方的輸入框來編輯導航路徑。</p><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><p>你也可以看到屬於全域、匿名或僅適用於客戶端或伺服器的路由中間件，點擊就能開啟編輯器跳轉至實作的特定行數。</p><h1 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h1><p>Components 分頁展示了目前專案所有的元件 (Components)，可以在這邊使用搜尋框搜尋元件的名稱，也可以依據使用與非使用中的元件來進行過濾。</p><p><img src="https://hackmd.io/_uploads/BJ4i1jFLa.png" alt="image"></p><p>元件以四種分類的方式於面板上呈現，分別如下：</p><table><thead><tr><th>元件類型</th><th>說明</th></tr></thead><tbody><tr><td>User components</td><td>使用者自行建立的元件，通常是放置在專案 .&#x2F;components 目錄下的元件。</td></tr><tr><td>Runtime components</td><td>在執行時期使用的元件，通常有使用才打包進來。</td></tr><tr><td>Built-in components</td><td>Nuxt 的內建元件。</td></tr><tr><td>Components from libraries</td><td>由外部模組或套件所提供的元件。</td></tr></tbody></table><p><img src="https://hackmd.io/_uploads/rkgUxjKUp.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HJHjgstI6.png" alt="image"></p><p>你可以點擊如下圖示按鈕，元件將會以圖 (Graph) 的視覺化效果來呈現，專案中使用的元件彼此之間的關聯。<br><img src="https://hackmd.io/_uploads/H18cSoFU6.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/Skq_SoKUa.png" alt="image"></p><p>如果透過元件名稱或圖的表示的元件關聯，不能夠滿足你搜尋畫面中所呈現的元件，你可以嘗試使用檢查器 (Inspector)，如下圖紅色框起處的圖示，它的執行方式類似於瀏覽器的除錯工具「檢查元素」。</p><h1 id="組合式函式-Imports"><a href="#組合式函式-Imports" class="headerlink" title="組合式函式 - Imports"></a>組合式函式 - Imports</h1><p>Imports 分頁展示了目前專案所有的組合式函式 (Imports)，你可以在這邊使用搜尋框搜尋組合式函式的名稱，也可以依據使用與非使用到的組合式函式來進行過濾。</p><p><img src="https://hackmd.io/_uploads/H1J4IjFIT.png" alt="image"></p><p>元件以四種分類的方式於面板上呈現，分別如下：</p><table><thead><tr><th>Imports 類型</th><th>說明</th></tr></thead><tbody><tr><td>User composables</td><td>使用者自行建立的組合式函式，通常是放置在專案 .&#x2F;composables 目錄下的式。</td></tr><tr><td>Built-in composables</td><td>內建元件，例如 Nuxt 提供的 navigateTo 和 Vue 的 computed 等。</td></tr><tr><td>Components from libraries</td><td>由外部模組或套件所提供的組合式函式。</td></tr></tbody></table><p><img src="https://hackmd.io/_uploads/r1ebDiYIp.png" alt="image"></p><p>你可以在這個分頁搜尋與篩選組合式函式，在使用的函式名稱上也會標示綠色 x1, x2 表示使用的次數，當你點擊組合式函式，除了可以複製與跳轉至原始碼的實作，部分組合式函式有提供文件，也可以透過按鈕快速地前往官方文件查看使用說明。</p><h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><p>Modules 分頁展示了，Nuxt 專案內所使用的模組，也會顯示模組版本、官方網站與 GitHub 專案等資訊。</p><p><img src="https://hackmd.io/_uploads/HkQG_sYIa.png" alt="image"></p><p>可以點選右下角的 Install New Module 來搜尋並安裝新的 Nuxt 模組<br><img src="https://hackmd.io/_uploads/rywNdiF8T.png" alt="image"></p><p>如果專案中使用的模組版本落後，在面板上也會顯示最新的版本號，如下圖紅色框起處，點擊後也會提示升級的指令，或透過介面一鍵升級。</p><h1 id="靜態資源-Assets"><a href="#靜態資源-Assets" class="headerlink" title="靜態資源 - Assets"></a>靜態資源 - Assets</h1><p>如下圖 Modules 分頁展示專案內的靜態資源讓你可以在這邊快速瀏覽與搜尋，不過目前僅支援專案下的 public 目錄的檔案。<br><img src="https://hackmd.io/_uploads/r1UcOiY8p.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/r1RPFiF8T.png" alt="image"></p><blockquote><p>需要填入啟動開發伺服器的終端機上提示的 Token 或點擊連結來授權，就可以開始使用。</p></blockquote><p><img src="https://hackmd.io/_uploads/HkJTYsYUa.png" alt="image"></p><blockquote><p>圖片可以直接拖曳上傳</p></blockquote><h1 id="專案內部-Server-Server-Routes"><a href="#專案內部-Server-Server-Routes" class="headerlink" title="專案內部 Server - Server Routes"></a>專案內部 Server - Server Routes</h1><p>Server Routes 分頁展示了目前專案內部 Server API，它可以方便你針對 .&#x2F;server 目錄下建置的內部 API 來發送與測試 HTTP 請求，有點類似輕便版的 Postman，專為開發者提供的 API 測試工具。</p><p><img src="https://hackmd.io/_uploads/r1Km9otUa.png" alt="image"></p><h1 id="使用儲存層的資料-Storage"><a href="#使用儲存層的資料-Storage" class="headerlink" title="使用儲存層的資料 - Storage"></a>使用儲存層的資料 - Storage</h1><p>Storage 分頁展示了網站伺服器使用到儲存層 (Storage Layer) 時的資料，這項功能對於有使用 Nuxt 建立內部伺服器 API 與搭配使用 Nitro 提供內建儲存層來抽象檔案系統或資料庫做快取操作等。</p><p><img src="https://hackmd.io/_uploads/H1HJojtLa.png" alt="image"></p><h1 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h1><p>Nuxt DevTools 整合了 VS Code Server，讓完整的 VS Code 編輯器可以整合至開發工具內，也可以安裝 VS Code 的插件及導入你個人化的設定。</p><p>接下來，我們切換到下圖紅色框起處的 VS Code 分頁。<br><img src="https://hackmd.io/_uploads/rJDXsst8T.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/S10KcLf_6.png" alt="image"></p><div class="note info simple"><p>這邊要指定 code server port 3080</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-server --port 3080</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkzKL_zda.png" alt="image"></p><blockquote><p>成功啟用 code server</p></blockquote><h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p><img src="https://hackmd.io/_uploads/HyzguOzO6.png" alt="image"></p><p>Hooks 分頁展示了網站客戶端與伺服器端使用的 Hooks，分頁上條列各個 Hook 名稱、監聽事件數量、執行數與花費時間，對於模組的作者或更進階的使用，它可以幫助你檢查問題與瓶頸進而調整網站的效能。</p><p><img src="https://hackmd.io/_uploads/BkkS_dfdT.png" alt="image"></p><h1 id="Virtual-Files"><a href="#Virtual-Files" class="headerlink" title="Virtual Files"></a>Virtual Files</h1><p><img src="https://hackmd.io/_uploads/S1yvOuGu6.png" alt="image"></p><p>Virtual Files 分頁展示了 Nuxt 產生的虛擬文件，虛擬文件是動態產生的，某些情況你可能會使用到這些檔案，但這些產生的檔案主要是為了支援框架的約定，也屬於適合模組或比較進階的開發者，並更提供更好的開發者體驗。</p><p><img src="https://hackmd.io/_uploads/BklSFdOG_T.png" alt="image"></p><h1 id="Inspect"><a href="#Inspect" class="headerlink" title="Inspect"></a>Inspect</h1><p><img src="https://hackmd.io/_uploads/HkX3ddMdT.png" alt="image"></p><p>Inspect 分頁整合了 antfu&#x2F;vite-plugin-inspect 插件，如下圖，你可以切換不同的呈現方式，或者觀看 Vite 插件的執行時間等。</p><p><img src="https://hackmd.io/_uploads/HkxeKOfup.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HJClFOMOp.png" alt="image"></p><h1 id="Module-Contributed-View"><a href="#Module-Contributed-View" class="headerlink" title="Module Contributed View"></a>Module Contributed View</h1><p>考量了 Nuxt 的生態系統，Nuxt DevTools 的開發與設計上非常的靈活也具擴展性，不管是官方、社群或個人的模組，都可以像 DevTools 貢獻自己的分頁，使模組也能整合進 Nuxt DevTools 中並提供使用者進行交互。</p><p>舉例來說，專案上使用到了 VueUse 與 Viteest 這兩個模組，而且這兩個模組都有整合至 Nuxt DevTools 的分頁中，如下圖在 DevTools 的面板左側就能看到 VueUse 與 Vitest 兩個圖示分頁。</p><p>在 VueUse 模組分頁上提供了可使用的組合式函式的搜尋頁面與文件說明。</p><p><img src="https://hackmd.io/_uploads/rymwsdf_a.png" alt="image"></p><h1 id="Nuxt-Vitest"><a href="#Nuxt-Vitest" class="headerlink" title="Nuxt Vitest"></a>Nuxt Vitest</h1><p><img src="https://hackmd.io/_uploads/BJtmnOzuT.png" alt="image"></p><blockquote><p>import Vitest  模組</p></blockquote><p><img src="https://hackmd.io/_uploads/Sk_G2OfOa.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HJJgndMu6.png" alt="image"></p><h1 id="Runtime-Configs"><a href="#Runtime-Configs" class="headerlink" title="Runtime Configs"></a>Runtime Configs</h1><p><img src="https://hackmd.io/_uploads/rJAEStzOp.png" alt="image"></p><p>Runtime Configs 分頁展示了目前專案 App Config 及公開與私有的 Runtime Configs，這邊也有個小細節，如果是私有的設定 Private Runtime Config，預設是不會展開的。</p><p><img src="https://hackmd.io/_uploads/rJ2ISYMda.png" alt="image"></p><p>在每個分類的設定中，都可以使用 JSON Editor 來進行新增編輯與驗證等操作，例如新增一個 primaryColor，如果你編輯數值也會同步響應至變數。</p><p><img src="https://hackmd.io/_uploads/r1e9rYfOT.png" alt="image"></p><h1 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h1><p><img src="https://hackmd.io/_uploads/rkPirKfua.png" alt="image"></p><p>Payload 分頁展示了網站中使用到組合式函式 useState、useAsyncData 與 useFetch 所建立的狀態，這些狀態在伺服器端建立時，會以 JSON Payload 與 HTML 一併回傳給客戶端重複做使用，讓客戶端不必在次請求資料直接在 Payload 中取得。</p><p><img src="https://hackmd.io/_uploads/H120rYfO6.png" alt="image"></p><p>你也可以在 State 或 Data 狀態分類中修改各個狀態JSON 結構的 Payload，修改的值也會同步的響應至狀態，例如我們修改頁面中使用 useAsyncData 得到的文章資料 Payload，修改後的 title 頁面中也會同步響應呈現。</p><p>State 或 Data 狀態分類中，每個狀態都擁有兩個圖示按鈕 Refresh View 與 Generate Data Scheme，分別可以重新同步頁面上的狀態及產生狀態的 Scheme。</p><p><img src="https://hackmd.io/_uploads/BkwSLYz_T.png" alt="image"></p><h1 id="Open-Graph"><a href="#Open-Graph" class="headerlink" title="Open Graph"></a>Open Graph</h1><p><img src="https://hackmd.io/_uploads/SyPqLKz_T.png" alt="image"></p><p>Open Graph 分頁，能幫助你在做網頁的 SEO 搜尋引擎最佳化時，查看你對網頁設定的 Meta Tags 並提醒與建議你遺漏的 Meta Tags，除了可以透過上方網址列快速跳轉到其他頁面，也使用旁邊的按鈕圖示來開啟檔案、重新整理資料，另外你也透過面板提供的預覽功能，查看你的 Open Graph Tags 是否設定正確，它以常見的社群媒體預覽不同樣式的連結縮圖。</p><p><img src="https://hackmd.io/_uploads/rJnkDYM_T.png" alt="image"></p><p>面板上不僅會呈現遺漏的建議標籤，也可以透過如下圖的紅色框起處，來使用工具提供建議的程式碼片段來添加建議的 Meta Tags。</p><p><img src="https://hackmd.io/_uploads/r1lBwYGuT.png" alt="image"></p><h1 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h1><p><img src="https://hackmd.io/_uploads/Hy7SKKM_6.png" alt="image"><br>Plugins 分頁依序展示了專案中插件的載入，包含了使用者自訂、套件模組的插件，並依序條列的載入出來，每個插件也會標記上來自於套件或哪個目錄下的檔案，也會依據伺服器端、客戶端等類型來特別標記插件。</p><p><img src="https://hackmd.io/_uploads/rJBDYYfup.png" alt="image"></p><p>標示了各個插件載入執行所花費的時間與所有插件的執行總時間，插件在載入執行的時間，其實間接的影響到頁面的請求時間，所以如果對於效能要求比較高的網站，使用介面提供資訊能輔助你追蹤載入較費時的插件。</p><h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><p><img src="https://hackmd.io/_uploads/B1N9KFz_6.png" alt="image"></p><p>Timeline 分頁的功能就像是瀏覽器開發者工具的時間線 (Timeline)，可以讓你追蹤網站的耗費時間的分佈，例如 DOM 事件、分頁元件的渲染等，Nuxt DevTools 的 Timeline 功能預設是關閉的，如下圖依據指引進行啟用就可以開始使用該功能。</p><p><img src="https://hackmd.io/_uploads/ByD_stzdp.png" alt="image"></p><blockquote><p>在介面上按下 Start Tracking，並開始操作網頁上的事件，例如點擊連結，介面就會開始紀錄函式的呼叫與花費時間。</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Nuxt-3/">Nuxt 3</category>
      
      <category domain="https://gahgah147.github.io/tags/2023-iTHome-%E9%90%B5%E4%BA%BA%E8%B3%BD/">2023 iTHome 鐵人賽</category>
      
      <category domain="https://gahgah147.github.io/tags/DevTools/">DevTools</category>
      
      <category domain="https://gahgah147.github.io/tags/Vue/">Vue</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</category>
      
      
      <comments>https://gahgah147.github.io/2024/01/03/Nuxt-3-DevTools-%E8%A6%96%E8%A6%BA%E5%8C%96%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt 3 使用 Nuxi 建立模板檔案</title>
      <link>https://gahgah147.github.io/2023/12/14/Nuxt-3-%E4%BD%BF%E7%94%A8-Nuxi-%E5%BB%BA%E7%AB%8B%E6%A8%A1%E6%9D%BF%E6%AA%94%E6%A1%88/</link>
      <guid>https://gahgah147.github.io/2023/12/14/Nuxt-3-%E4%BD%BF%E7%94%A8-Nuxi-%E5%BB%BA%E7%AB%8B%E6%A8%A1%E6%9D%BF%E6%AA%94%E6%A1%88/</guid>
      <pubDate>Thu, 14 Dec 2023 08:53:41 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 &lt;a href=&quot;https://ithelp.ithome.co</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 <a href="https://ithelp.ithome.com.tw/users/20152617/ironman/6959">Nuxt 3 實戰筆記 系列</a> 文章做的一個紀錄，我之前也都有看到發表Nuxt 相關的文章，寫得都很用心仔細很值得跟著練習，我覺得最特別的是 Nuxt 新的 DevTools功能 </p><h1 id="使用-nuxi-快速建立模板檔案"><a href="#使用-nuxi-快速建立模板檔案" class="headerlink" title="使用 nuxi 快速建立模板檔案"></a>使用 nuxi 快速建立模板檔案</h1><p>建立檔案的指令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add &lt;TEMPLATE&gt; &lt;NAME&gt; [--cwd] [--force]</span><br></pre></td></tr></table></figure><table><thead><tr><th>變數</th><th>功能</th></tr></thead><tbody><tr><td>TEMPLATE</td><td>指定要產生的檔案模板類型，目前支援專案內常會使用到的 component、page 與伺服器 api 等。</td></tr><tr><td>NAME</td><td>填寫檔案名稱，也可以以路徑串接，來建立子資料夾中的檔案</td></tr><tr><td>–cwd</td><td>指定專案起始目錄，預設為 .。</td></tr><tr><td>–force</td><td>如果檔案存在，強制覆蓋檔案。</td></tr></tbody></table><h2 id="建立路由頁面-nuxi-add-page"><a href="#建立路由頁面-nuxi-add-page" class="headerlink" title="建立路由頁面 - nuxi add page"></a>建立路由頁面 - nuxi add page</h2><p>舉個例子，建立一個 about 路由頁面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add page about</span><br></pre></td></tr></table></figure><p>產生出的檔案 .&#x2F;pages&#x2F;about.vue 內容如下，預設會有一個模板提供給使用者快速進行後續開發。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Page: foo</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ByRF-EuLp.png" alt="image"></p><p>產生出的檔案 .&#x2F;pages&#x2F;category&#x2F;[id].vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add page &quot;category/[id]&quot;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1jfoEdUp.png" alt="image"></p><h2 id="建立-composable-nuxi-add-composable"><a href="#建立-composable-nuxi-add-composable" class="headerlink" title="建立 composable - nuxi add composable"></a>建立 composable - nuxi add composable</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add composable foo</span><br></pre></td></tr></table></figure><p>建立 .&#x2F;composables&#x2F;foo.ts 檔案<br><img src="https://hackmd.io/_uploads/B1_vsVuUa.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/HJKLjVO8a.png" alt="image"></p><h2 id="建立-layout-nuxi-add-layout"><a href="#建立-layout-nuxi-add-layout" class="headerlink" title="建立 layout - nuxi add layout"></a>建立 layout - nuxi add layout</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add layout custom</span><br></pre></td></tr></table></figure><p>建立 .&#x2F;layouts&#x2F;custom.ts 檔案<br><img src="https://hackmd.io/_uploads/BJjciEOL6.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/SyN3iVO8T.png" alt="image"></p><h2 id="建立元件-nuxi-add-component"><a href="#建立元件-nuxi-add-component" class="headerlink" title="建立元件 - nuxi add component"></a>建立元件 - nuxi add component</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add component TheHeader</span><br><span class="line"># 等價</span><br><span class="line">npx nuxi add component TheHeader --mode &quot;client|server&quot;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HyNo0V_UT.png" alt="image"></p><p>建立 .&#x2F;components&#x2F;TheHeader.vue 檔案</p><p>在建立元件時，可以添加修飾參數 –mode “client|server”、–client、–server，來建立客戶端或伺服器端的元件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add component TheFooter --client</span><br><span class="line"># 等價</span><br><span class="line">npx nuxi add component TheFooter --mode client</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HkQTC4OIp.png" alt="image"></p><p>建立 .&#x2F;components&#x2F;TheFooter.client.vue 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add component TheFooter --server</span><br><span class="line"># 等價</span><br><span class="line">npx nuxi add component TheFooter --mode server</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ByMZyBuUa.png" alt="image"></p><p>建立 .&#x2F;components&#x2F;TheFooter.server.vue 檔案</p><p><img src="https://hackmd.io/_uploads/HJO71rd86.png" alt="image"></p><h2 id="建立插件-nuxi-add-plugin"><a href="#建立插件-nuxi-add-plugin" class="headerlink" title="建立插件 - nuxi add plugin"></a>建立插件 - nuxi add plugin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add plugin analytics</span><br></pre></td></tr></table></figure><p>插件的建立，同樣也可以添加修飾參數 –mode “client|server”、–client、–server。<br><img src="https://hackmd.io/_uploads/rJsSJHuIp.png" alt="image"></p><p>建立 .&#x2F;plugins&#x2F;analytics.ts 檔案</p><p><img src="https://hackmd.io/_uploads/SkaPkBdLp.png" alt="image"></p><h2 id="建立路由中間件-nuxi-add-middleware"><a href="#建立路由中間件-nuxi-add-middleware" class="headerlink" title="建立路由中間件 - nuxi add middleware"></a>建立路由中間件 - nuxi add middleware</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add middleware auth</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ByEBlrdLT.png" alt="image"><br>建立路由中間件 .&#x2F;middleware&#x2F;auth.ts 檔案。</p><p>建立時可以添加修飾參數 –global 用以建立通用的全域路由中間件，舉例來說，建立 .&#x2F;middleware&#x2F;always-run.global.ts 檔案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add middleware always-run --global</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rkwvlSu8a.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/B1_KxBu8T.png" alt="image"></p><h2 id="建立伺服器-API-nuxi-add-api"><a href="#建立伺服器-API-nuxi-add-api" class="headerlink" title="建立伺服器 API - nuxi add api"></a>建立伺服器 API - nuxi add api</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add api hello</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/S1ehZruUT.png" alt="image"></p><p>建立伺服器 API 處理程式 .&#x2F;server&#x2F;api&#x2F;hello.ts。</p><p>建立時可以添加修飾參數 –method post、–method delete 等用以建立不同請求方法的 API，舉例來說，建立 .&#x2F;server&#x2F;api&#x2F;items.post.ts 檔案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi add api items --method post</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1_abrdU6.png" alt="image"></p><blockquote><p>支援請求方法的參數有 connect, delete, get, head, options, patch, post, put 或 trace</p></blockquote><p><img src="https://hackmd.io/_uploads/BkK1MBOL6.png" alt="image"></p><h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><p>nuxi add 指令最重要的是透過指令建立的模板，你不需要在擔心要在哪一個目錄建立，使用的約定是什麼，Nuxt CLI 將會幫你處理好並建立在對應的目錄，在使用 nuxi add 指令建立的模板檔案時，因為 Nuxt 內置了 TypeScript，所以你會發現模板實作多以 TypeScript 的方式來定義，不過也不影響尚未導入 TypeScript 的專案，僅需要把一些 TypeScript 的關鍵字移除及重新命名檔案名稱後，就可以接續檔案內的實作範例來做開發，對於開發上還是能提升不少的速度。</p><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>這邊觀察下來我認為算是一個框架規範，每個人使用的話就都會產生固定格式的東西</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Nuxt-3/">Nuxt 3</category>
      
      <category domain="https://gahgah147.github.io/tags/2023-iTHome-%E9%90%B5%E4%BA%BA%E8%B3%BD/">2023 iTHome 鐵人賽</category>
      
      <category domain="https://gahgah147.github.io/tags/Vue/">Vue</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</category>
      
      <category domain="https://gahgah147.github.io/tags/nuxi/">nuxi</category>
      
      
      <comments>https://gahgah147.github.io/2023/12/14/Nuxt-3-%E4%BD%BF%E7%94%A8-Nuxi-%E5%BB%BA%E7%AB%8B%E6%A8%A1%E6%9D%BF%E6%AA%94%E6%A1%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt 3 實戰學習筆記 - 環境設定</title>
      <link>https://gahgah147.github.io/2023/12/14/Nuxt-3-%E5%AF%A6%E6%88%B0%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A/</link>
      <guid>https://gahgah147.github.io/2023/12/14/Nuxt-3-%E5%AF%A6%E6%88%B0%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A/</guid>
      <pubDate>Thu, 14 Dec 2023 07:47:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 &lt;a href=&quot;https://ithelp.ithome.co</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇文章是我在 2023 iTHome 鐵人賽看到 Ryan 大大 寫的 <a href="https://ithelp.ithome.com.tw/users/20152617/ironman/6959">Nuxt 3 實戰筆記 系列</a> 文章做的一個紀錄，我之前也都有看到發表Nuxt 相關的文章，寫得都很用心仔細很值得跟著練習，我覺得最特別的是 Nuxt 新的 DevTools功能 </p><h1 id="Nuxt-CLI-指令"><a href="#Nuxt-CLI-指令" class="headerlink" title="Nuxt CLI 指令"></a>Nuxt CLI 指令</h1><p>nuxi 全名為 (Nuxt CLI, Nuxt Command Line Interface)，是由 Nuxt 提供開發的標準工具，Nuxt CLI 就像是 Vue CLI 可以建立 Vue 專案，我們當然也就可以使用 Nuxt CLI 來建立 Nuxt 的專案。</p><h1 id="環境準備"><a href="#環境準備" class="headerlink" title="環境準備"></a>環境準備</h1><p>環境準備流程如下，通常主要會用到的nuxi 指令也是這幾個</p><p>清除 npx 快取<br>建立 Nuxt 專案<br>檢查專案相關資訊<br>升級 Nuxt 3 版本<br>啟動開發伺服器<br>清除自動產生的 Nuxt 檔案和快取<br>產生靜態網站使用的預渲染<br>打包專案建構生產環境需要的程式包<br>預覽網站<br>開發工具 Nuxt DevTools</p><p>更多完整的指令與用法可以參考<a href="https://nuxt.com/docs/api/commands/init">官方文件</a>。</p><h2 id="清除-npx-快取-clear-npx-cache"><a href="#清除-npx-快取-clear-npx-cache" class="headerlink" title="清除 npx 快取 - clear-npx-cache"></a>清除 npx 快取 - clear-npx-cache</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx clear-npx-cache</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Syy08m_8T.png" alt="image"></p><p>當一切準備就緒後，你可以執行下列指令，它將會安裝最新版本的 Nuxt CLI 並執行 –help 來看相關說明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi@latest --help</span><br></pre></td></tr></table></figure><p>如果你有看到如下圖的相關指令說明，就代表你安裝成功囉！<br><img src="https://hackmd.io/_uploads/HJsbvQ_UT.png" alt="image"></p><h2 id="使用-nuxi-建立-Nuxt-專案與啟動開發伺服器"><a href="#使用-nuxi-建立-Nuxt-專案與啟動開發伺服器" class="headerlink" title="使用 nuxi 建立 Nuxt 專案與啟動開發伺服器"></a>使用 nuxi 建立 Nuxt 專案與啟動開發伺服器</h2><p>如果你第一次使用 Nuxt 3，依據官網的範例，你可以在終端機執行下列指令，就能開始建立 Nuxt 的專案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi@latest init nuxt-app</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/B1bpPX_U6.png" alt="image"></p><blockquote><p>建立的過程</p></blockquote><p>這邊首先會問  Which package manager would you like to use?<br>選擇 npm</p><p>Are you interested in participating?</p><p>操作完成之後會告訴你接下來如何開啟專案<br>✨ Nuxt project has been created with the v3 template. Next steps:<br> › cd nuxt-app<br> › Start development server with npm run dev</p><p>當你在開發時，可以在專案資料夾內執行下列指令來啟動開發伺服器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>上述指令，實際上是執行 package.json 中的 scripts 所定義的 dev 對應腳本指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nuxt dev</span><br></pre></td></tr></table></figure><p>其實也等同於你在專案目錄下執行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi dev</span><br></pre></td></tr></table></figure><p>nuxi 不僅在啟動開發伺服器與部署編譯上需要使用，開發的過程中，也還有許多不同的指令與參數可以操作使用，以幫助我們開發 Nuxt 專案上的使用。</p><h2 id="檢查-Nuxt-專案相關資訊-info"><a href="#檢查-Nuxt-專案相關資訊-info" class="headerlink" title="檢查 Nuxt 專案相關資訊 -info"></a>檢查 Nuxt 專案相關資訊 -info</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi info</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HydWK7OIp.png" alt="image"></p><h2 id="升級-Nuxt-3-版本-upgrade"><a href="#升級-Nuxt-3-版本-upgrade" class="headerlink" title="升級 Nuxt 3 版本  -upgrade"></a>升級 Nuxt 3 版本  -upgrade</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi upgrade</span><br></pre></td></tr></table></figure><p>這個指令可以用來將目前專案的 Nuxt 3 升級至最新的版本，如果有一些可能行為調整或不相容的情況，可以再依據實際情境搭配 -f, –force 參數來強制更新。</p><p><img src="https://hackmd.io/_uploads/By8Qh7OLp.png" alt="image"></p><h2 id="啟動開發伺服器-run-dev"><a href="#啟動開發伺服器-run-dev" class="headerlink" title="啟動開發伺服器 - run dev"></a>啟動開發伺服器 - run dev</h2><p>一個新建立的 Nuxt 專案，當你要啟動開發伺服器，你可以使用下面的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line"># 或</span><br><span class="line">npx nuxi dev</span><br></pre></td></tr></table></figure><p>Nuxt 的 Nitro 就會幫我們啟動開發伺服器，並監聽 Port: 3000。<br><img src="https://hackmd.io/_uploads/BJSPKmdI6.png" alt="image"></p><h3 id="–port-p-設定監聽Port"><a href="#–port-p-設定監聽Port" class="headerlink" title="–port, -p 設定監聽Port"></a>–port, -p 設定監聽Port</h3><p>預設監聽 Port: 3000，若因為衝突或有需要做調整可以使用這個參數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm run dev -- -p 5173</span><br><span class="line"># 等價</span><br><span class="line">npx nuxi dev -p 5173</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用 npm 執行 scripts，可以加上兩個減號 – 以添加腳本指令後的參數。</p></blockquote><h3 id="–host-h-設定-伺服器主機名稱"><a href="#–host-h-設定-伺服器主機名稱" class="headerlink" title="–host, -h 設定 伺服器主機名稱"></a>–host, -h 設定 伺服器主機名稱</h3><p>預設伺服器主機名稱為 localhost，若因為一些跨域或驗證等開發需求，也可以調整</p><h3 id="–open-o-設定-開啟瀏覽器"><a href="#–open-o-設定-開啟瀏覽器" class="headerlink" title="–open, -o 設定 開啟瀏覽器"></a>–open, -o 設定 開啟瀏覽器</h3><p>當開發伺服器啟動時，開啟瀏覽器並導向到開發的網址。</p><h3 id="–https-設定-啟用https"><a href="#–https-設定-啟用https" class="headerlink" title="–https 設定 啟用https"></a>–https 設定 啟用https</h3><p>在開發時若有一些驗證或請求需要 HTTPS，也可以使用這個參數來啟用 HTTPS，預設情況也含有自簽名的 SSL 證書。</p><p><img src="https://hackmd.io/_uploads/rJkfi7dIa.png" alt="image"></p><h2 id="清除自動產生的-Nuxt-檔案和快取-cleanup"><a href="#清除自動產生的-Nuxt-檔案和快取-cleanup" class="headerlink" title="清除自動產生的 Nuxt 檔案和快取 -cleanup"></a>清除自動產生的 Nuxt 檔案和快取 -cleanup</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi cleanup</span><br></pre></td></tr></table></figure><p>Nuxt 3 在啟動開發伺服器後，會自動建立 .nuxt 目錄與產生相關的檔案或 TypeScript 使用的類型，建構專案或產生靜態網站時也會建立 .output 或 dist 目錄等，我們可以使用指令來清除這些自動產生的檔案和快取。</p><h3 id="刪除的目錄包含如下："><a href="#刪除的目錄包含如下：" class="headerlink" title="刪除的目錄包含如下："></a>刪除的目錄包含如下：</h3><ul><li>.nuxt</li><li>.output</li><li>dist</li><li>node_modules&#x2F;.vite</li><li>node_modules&#x2F;.cache</li></ul><h2 id="產生靜態網站使用的預渲染-generate"><a href="#產生靜態網站使用的預渲染-generate" class="headerlink" title="產生靜態網站使用的預渲染  -generate"></a>產生靜態網站使用的預渲染  -generate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi generate</span><br></pre></td></tr></table></figure><p>我們可以使用以下指令來預渲染專案中的每個路由路徑，並將其結果儲存在純 HTML 當中，其產生的檔案會建立在 .output&#x2F;public 與 dist 目錄，兩個目錄的檔案內容是一樣的，你可以選擇使用 .output&#x2F;public 作為靜態網站的部署。</p><p><img src="https://hackmd.io/_uploads/BJ9vh7_UT.png" alt="image"></p><h2 id="打包專案建構生產環境需要的程式包-build"><a href="#打包專案建構生產環境需要的程式包-build" class="headerlink" title="打包專案建構生產環境需要的程式包  -build"></a>打包專案建構生產環境需要的程式包  -build</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi build</span><br></pre></td></tr></table></figure><p>當專案開發到一個階段要準備部署時，你會需要打包並建構生產環境所需要的程式，你可以使用以下指令來編譯建構。</p><p><img src="https://hackmd.io/_uploads/r10chQOLa.png" alt="image"></p><p>這個指令會建立一個 .output 目錄，其中包含所有應用程式、伺服器與依賴配置，你可以將此目錄作為生產環境使用的目錄進行服務部署。</p><h2 id="預覽網站-preview"><a href="#預覽網站-preview" class="headerlink" title="預覽網站 -preview"></a>預覽網站 -preview</h2><p>當使用 nuxi build 專案打包建構完成後，你可以使用下 preview 指令來啟動伺服器，預覽你的 Nuxt 網站。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi preview</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkT9pQd86.png" alt="image"></p><h2 id="開發工具-Nuxt-DevTools"><a href="#開發工具-Nuxt-DevTools" class="headerlink" title="開發工具 Nuxt DevTools"></a>開發工具 Nuxt DevTools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi devtools enable</span><br></pre></td></tr></table></figure><p>透過最新版本 Nuxt CLI 建置的 Nuxt 3 專案已經將 Nuxt DevTools 預置在 Nuxt 專案中並預設為啟用，如果你的專案的 Nuxt 3 版本還比較舊，可以手動安裝 Nuxt DevTools，或使用以下指令來配置。</p><p><img src="https://hackmd.io/_uploads/ByJT67uUT.png" alt="image"></p><h3 id="關閉-Nuxt-DevTools"><a href="#關閉-Nuxt-DevTools" class="headerlink" title="關閉 Nuxt DevTools"></a>關閉 Nuxt DevTools</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi devtools disable</span><br></pre></td></tr></table></figure><p>如果你想要關閉 Nuxt DevTools，可以使用以下指令來關閉，它會提示您是否要將 .&#x2F;nuxt.config.ts 檔案內的 devtools.enabled 設定為 false 來關閉 DevTools。</p><h1 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源:"></a>參考來源:</h1><p><a href="https://ithelp.ithome.com.tw/users/20152617/ironman/6959">https://ithelp.ithome.com.tw/users/20152617/ironman/6959</a><br><a href="https://nuxt.com/docs/api/commands/init">https://nuxt.com/docs/api/commands/init</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Nuxt-3/">Nuxt 3</category>
      
      <category domain="https://gahgah147.github.io/tags/2023-iTHome-%E9%90%B5%E4%BA%BA%E8%B3%BD/">2023 iTHome 鐵人賽</category>
      
      <category domain="https://gahgah147.github.io/tags/Vue/">Vue</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</category>
      
      
      <comments>https://gahgah147.github.io/2023/12/14/Nuxt-3-%E5%AF%A6%E6%88%B0%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python 網頁服務開發的 UX 與 DX 比較</title>
      <link>https://gahgah147.github.io/2023/11/27/Python-%E7%B6%B2%E9%A0%81%E6%9C%8D%E5%8B%99%E9%96%8B%E7%99%BC%E7%9A%84-UX-%E8%88%87-DX-%E6%AF%94%E8%BC%83/</link>
      <guid>https://gahgah147.github.io/2023/11/27/Python-%E7%B6%B2%E9%A0%81%E6%9C%8D%E5%8B%99%E9%96%8B%E7%99%BC%E7%9A%84-UX-%E8%88%87-DX-%E6%AF%94%E8%BC%83/</guid>
      <pubDate>Mon, 27 Nov 2023 02:27:09 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇文章是我在 Agoda Engineering 部落格的文章閱讀紀錄&lt;br&gt;&lt;a href=&quot;https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1&quot;&gt;UX vs.</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇文章是我在 Agoda Engineering 部落格的文章閱讀紀錄<br><a href="https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1">UX vs. DX in Python Web Servers</a></p><h1 id="UX-vs-DX-in-Python-Web-Servers"><a href="#UX-vs-DX-in-Python-Web-Servers" class="headerlink" title="UX vs. DX in Python Web Servers"></a>UX vs. DX in Python Web Servers</h1><p>Agoda在11月舉辦了一場與曼谷Python社群合作的ThaiPy聚會。<br>演講者是Agoda的高級軟體工程師Mohamad Kamar，他分享了有關“Python Web伺服器中的UX vs DX”的演講。<br>他深入探討了Python在Web伺服器架構方面的多樣性，從簡單的同步伺服器到複雜的異步和基於框架的伺服器。<br>這篇博客文章總結了演講中討論的要點。</p><h1 id="什麼是-UX-and-DX"><a href="#什麼是-UX-and-DX" class="headerlink" title="什麼是 UX and DX ?"></a>什麼是 UX and DX ?</h1><p>使用者體驗（UX）指的是使用者與網路應用程式互動的整體體驗。<br>這包括速度、可用性、可存取性以及整體使用者滿意度等考慮因素。</p><p>開發者體驗（DX）代表開發者在建構、維護和擴展網路應用程式時的經驗。<br>易於設置、程式碼可維護性和除錯能力等因素在這裡扮演重要的角色。</p><p>當專注於改善開發者體驗（DX）或使用者體驗（UX）時，通常會為另一方帶來間接的好處。<br>例如，對功能開發速度的關注能夠提供更簡化的結果給最終使用者體驗，同時降低錯誤出現的機率，從而幫助開發者。</p><h1 id="探索-Python-功能"><a href="#探索-Python-功能" class="headerlink" title="探索 Python 功能"></a>探索 Python 功能</h1><p>Python的多用途性彰顯在其處理各種網頁伺服器架構的能力上，從處理一次請求的簡單同步伺服器到更複雜的異步和基於框架的伺服器，Python提供了廣泛的選擇。</p><p>每種方法對使用者體驗（UX）和開發者體驗（DX）都有其獨特的影響。</p><p><img src="https://hackmd.io/_uploads/BkFj2wWBT.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1">https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1</a></p></blockquote><p><a href="https://xkcd.com/353/">XKCD Python Fly Library import</a></p><h1 id="如何衡量網頁伺服器程式碼的開發者體驗"><a href="#如何衡量網頁伺服器程式碼的開發者體驗" class="headerlink" title="如何衡量網頁伺服器程式碼的開發者體驗"></a>如何衡量網頁伺服器程式碼的開發者體驗</h1><p>評估開發者體驗（DX）涉及探索多個方面。<br>儘管我的分析具有主觀性，但旨在提供在Python網頁伺服器開發中DX景觀的清晰概述：</p><p>以下是這些具體區域的分解：</p><ol><li>安裝的便利性：啟動伺服器有多輕鬆？這包括文件的品質、入門模板的可用性、所需的依賴項數量以及在設置過程中錯誤消息的清晰度等方面。</li><li>代碼可讀性：這是開發者能夠輕鬆導覽和理解代碼庫的程度。這包括命名慣例、代碼組織、註釋的使用，以及是否遵守Python的風格指南（PEP 8）等因素。</li><li>可維護性：此組件評估測試、擴展、更新、修復和增強代碼的簡單程度。可維護性受可移植性的影響（代碼是否可以在不進行重大重構的情況下移動或適應不同的環境或框架）、模塊化和是否遵循最佳實踐等。</li><li>調試設施：這涉及評估網頁伺服器提供的工具和功能，以幫助識別和解決代碼問題。這包括本地調試工具、記錄設施、錯誤消息以及與外部調試工具集成的便利性。</li></ol><p>以這些為我們分析DX的基礎，我們可以比較不同方式構建Python網頁伺服器在相互之間的表現。</p><p>http.server：作為標準Python庫的一部分，http.server的設置是簡單明瞭的，但它僅提供基本功能，對於複雜應用程式的可維護性產生影響。調試和測試能力很大程度上取決於您使用的其他Python庫。</p><p>值得注意的是，http.server模組本身的文檔頁面建議開發者不要使用這些庫來構建生產應用程式，因為它缺乏安全功能。</p><p><img src="https://hackmd.io/_uploads/S1E9x_ZSa.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1">https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1</a></p></blockquote><p>aiohttp：由於它的異步性質，這使得設置比http.server更為複雜。<br>然而，使用Python的asyncio可以實現更有效的I&#x2F;O操作，對於I&#x2F;O密集型應用程式，這對可維護性產生積極影響。aiohttp的文檔提供了調試的線索，但測試異步代碼可能會更具挑戰性，需要使用Python的asyncio測試工具。</p><p>此外，aiohttp是一個非常輕量的庫，功能沒有這個列表上的其他庫多，通常被用作創建網頁伺服器的補充庫，而不是主要的構建塊。根據JetBrains進行的開發者調查：</p><blockquote><p>“大多數框架的受歡迎程度在年復年之間保持穩定。唯一的例外是提供異步程式設計支援的庫。asyncio庫在2022年達到歷史最高水平（21%），aiohttp顯示了輕微的增加，而httpx首次在調查中亮相，被9%的受訪者選擇。”</p></blockquote><p><img src="https://hackmd.io/_uploads/BJq7bd-BT.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1">https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1</a></p></blockquote><p><a href="https://www.jetbrains.com/lp/devecosystem-2022/python/">Python Developer Survey</a></p><ul><li><p>FastAPI：FastAPI因其快速且簡便的設置而受到讚譽，這要歸功於巧妙使用Python型別提示。FastAPI促進可維護的代碼，並包含用於調試和測試支援的內建文檔。</p></li><li><p>Flask：以其極簡的方式，Flask提供了簡單的設置和靈活的環境。它為開發者提供了一系列選擇，儘管它缺乏內置的調試工具，但可以透過擴展（如Flask-Debug Toolbar）獲取這些功能。</p></li><li><p>Django：以其“一切皆備”的理念而聞名，很多東西在安裝時就已經設置好了，這使得Django對新用戶來說可能有點壓倒性。但一旦配置完成，Django的高度模塊化和可重用的代碼可以使維護變得更加可管理。它配備了一個強大的ORM和管理面板，這可以協助調試，並且還有一個內置的測試框架。</p></li></ul><p>FastAPI、Django和Flask目前是市場上使用最多的框架，其次是Tornado和一些較不知名的庫。對即將到來的部分進行一點預告，前5名最常用的Python庫中沒有一個在最高性能評分中得分。</p><p><img src="https://hackmd.io/_uploads/ryQDf_bST.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1">https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1</a></p></blockquote><p><a href="https://www.jetbrains.com/lp/devecosystem-2022/python/">Python Developer Survey</a></p><h1 id="Developer-Preference"><a href="#Developer-Preference" class="headerlink" title="Developer Preference"></a>Developer Preference</h1><p>開發者的偏好是由個人經驗和項目需求所塑造的。<br>隨著時間的推移，他們自然而然地傾向於他們熟悉的技術。<br>這種熟悉感提升了他們的舒適度和效率。<br>例如，一位精通Django的開發者可能會在網頁伺服器任務中偏好使用它，熟悉其功能、社區和文檔。</p><p>項目需求在很大程度上影響開發者在網頁伺服器和框架中的選擇。項目的性質和範圍決定了最佳選擇。<br>開發者可能會傾向於使用Flask來創建一個輕量級、小規模的應用程式，而對於功能較為豐富、複雜的項目，可能會選擇Django或Pyramid。<br>像伺服器負載、實時更新以及對強大文檔和社區支援的需求等因素也可能影響這些決策。</p><h1 id="Performance-Considerations"><a href="#Performance-Considerations" class="headerlink" title="Performance Considerations"></a>Performance Considerations</h1><p>性能是選擇網頁伺服器的一個關鍵因素。<br>在比較網頁庫的性能時，考慮到WSGI和ASGI標準是很重要的。<br>像aiohttp和FastAPI這樣的異步庫是為ASGI環境（例如uvicorn）設計的，而Django和Flask則默認使用WSGI設置（例如gunicorn），可能需要額外的努力進行其他部署。</p><h1 id="Striking-a-Balance-UX-and-DX-Optimization"><a href="#Striking-a-Balance-UX-and-DX-Optimization" class="headerlink" title="Striking a Balance: UX and DX Optimization"></a>Striking a Balance: UX and DX Optimization</h1><p>平衡使用者體驗（UX）和開發者體驗（DX）更像是一門藝術而非科學。這是關於為正確的任務選擇合適的工具。每個框架的實用性在很大程度上取決於你的具體用例。如果你的項目規模相對較小，使用像Django這樣的重量級框架可能會顯得過於臃腫。相反，像Flask或FastAPI這樣的極簡選擇可能更合適。</p><p>對於需要廣泛內建功能且使用一個有主觀意見的框架不是問題的更大、更複雜的項目，Django可能是一個更合適的選擇。如果你喜歡極簡的方法並且喜歡從頭開始建立一切的過程，考慮使用aiohttp。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>選擇合適的Python網頁伺服器框架需要在使用者體驗（UX）和開發者體驗（DX）之間取得平衡。<br>每個框架都提供獨特的功能，適用於不同的項目需求。<br>了解這些差異並將其與項目需求相一致是實現最佳網頁伺服器選擇的關鍵。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://medium.com/@tj.joyson/an-another-django-vs-flask-comparison-which-one-is-better-236a163c18c6">Django vs. Flask comparison</a><br><a href="https://www.jetbrains.com/lp/devecosystem-2022/python/">Python developer survey</a></p><h1 id="文章來源-https-medium-com-agoda-engineering-ux-vs-dx-in-python-web-servers-3e3d9db864b1"><a href="#文章來源-https-medium-com-agoda-engineering-ux-vs-dx-in-python-web-servers-3e3d9db864b1" class="headerlink" title="文章來源 :https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1"></a>文章來源 :<a href="https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1">https://medium.com/agoda-engineering/ux-vs-dx-in-python-web-servers-3e3d9db864b1</a></h1>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Python/">Python</category>
      
      <category domain="https://gahgah147.github.io/tags/Agoda-Engineering-%E9%83%A8%E8%90%BD%E6%A0%BC/">Agoda Engineering 部落格</category>
      
      <category domain="https://gahgah147.github.io/tags/UX/">UX</category>
      
      <category domain="https://gahgah147.github.io/tags/DX/">DX</category>
      
      
      <comments>https://gahgah147.github.io/2023/11/27/Python-%E7%B6%B2%E9%A0%81%E6%9C%8D%E5%8B%99%E9%96%8B%E7%99%BC%E7%9A%84-UX-%E8%88%87-DX-%E6%AF%94%E8%BC%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>優化前端分析：Agoda 開發者的品質策略與工具</title>
      <link>https://gahgah147.github.io/2023/11/27/%E5%84%AA%E5%8C%96%E5%89%8D%E7%AB%AF%E5%88%86%E6%9E%90%EF%BC%9AAgoda-%E9%96%8B%E7%99%BC%E8%80%85%E7%9A%84%E5%93%81%E8%B3%AA%E7%AD%96%E7%95%A5%E8%88%87%E5%B7%A5%E5%85%B7/</link>
      <guid>https://gahgah147.github.io/2023/11/27/%E5%84%AA%E5%8C%96%E5%89%8D%E7%AB%AF%E5%88%86%E6%9E%90%EF%BC%9AAgoda-%E9%96%8B%E7%99%BC%E8%80%85%E7%9A%84%E5%93%81%E8%B3%AA%E7%AD%96%E7%95%A5%E8%88%87%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Mon, 27 Nov 2023 02:23:42 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇文章是我在 &lt;a href=&quot;https://medium.com/agoda-engineering&quot;&gt;Agoda Engineering 部落格&lt;/a&gt;的文章閱讀紀錄&lt;br&gt;&lt;a href=&quot;https://medium.com/agoda-engineering/</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇文章是我在 <a href="https://medium.com/agoda-engineering">Agoda Engineering 部落格</a>的文章閱讀紀錄<br><a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">Refining Front End Analytics: Quality Strategies and Tools for Developers at Agoda</a></p><h1 id="Front-End-FE-Analytics-at-Agoda"><a href="#Front-End-FE-Analytics-at-Agoda" class="headerlink" title="Front End (FE) Analytics at Agoda"></a>Front End (FE) Analytics at Agoda</h1><p>在Agoda，前端（FE）分析是一個動態框架，旨在追蹤使用者在前端應用程式中的行為和互動。<br>這個系統每天處理超過35億個事件，並分析超過1500個上下文字段，對於塑造和優化Agoda面向客戶、合作夥伴和內部應用程式的使用者體驗至關重要。</p><p>FE Analytics 提供了一系列廣泛的功能，以滿足Agoda不同專業需求：</p><ul><li>開發人員和品質保證（QA）：在生產中進行調試和監控用戶互動，並識別問題或趨勢方面發揮了關鍵作用。</li><li>產品擁有者：基於新添加的功能計算用戶互動趨勢的變化，並證明&#x2F;否定提升用戶體驗的假設方面發揮了作用。</li><li>分析師：檢查用戶互動中的模式，提供有關不同假設的報告和儀表板方面發揮了作用。</li><li>機器學習：檢測詐騙用戶並根據先前的互動個性化搜索結果方面發揮了作用。</li></ul><p>就隱私擔憂而言，我們確保在這個數據集中不會記錄任何可識別個人信息（PII）。<br>數據嚴格僅包含與領域相關的基於互動的上下文，而不是用戶，以符合全球隱私標準，同時保護用戶數據並提供有價值的見解。</p><p><img src="https://hackmd.io/_uploads/H1KDVap4p.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p>目前，開發人員必須手動將每個事件添加到這個表中，這在保持一致的高質量數據方面存在挑戰。由於有眾多開發人員參與，對最佳實踐的不同解釋，以及可能存在人為錯誤的可能性，確保數據質量具有挑戰性。</p><p>本文突顯了我們努力提高數據質量並實施檢查和平衡措施以識別和解決問題的努力。</p><h1 id="Understanding-Data-Quality"><a href="#Understanding-Data-Quality" class="headerlink" title="Understanding Data Quality"></a>Understanding Data Quality</h1><p>對於依賴數據做出決策的企業而言，確保數據的準確性和適用性至關重要。</p><p>忽視這一點可能導致重大後果，例如：</p><ul><li>可能導致收入損失的誤導性決策。</li><li>錯失的機會。</li><li>對所有參與者而言的時間和精力浪費。</li></ul><p><img src="https://hackmd.io/_uploads/By6y8T6Ep.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p>如何衡量所生成數據的質量？我們已經提出了以下需要牢記的因素，特別是針對 FE Analytics，但這些原則應該適用於任何一般數據集。</p><p><img src="https://hackmd.io/_uploads/HJ8VYTpVa.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><h1 id="The-Frontend-Data-Team"><a href="#The-Frontend-Data-Team" class="headerlink" title="The Frontend Data Team"></a>The Frontend Data Team</h1><p>在Agoda，有一個專門的團隊致力於構建和維護圍繞用戶互動事件的框架。<br>這個團隊由Web和移動應用程式開發人員組成，專注於在源頭最大程度地提高數據質量。<br>他們的任務是建立流程，確保更好的數據質量，有時這可能會影響開發人員的體驗和交付時間。</p><p><img src="https://hackmd.io/_uploads/BJgpiT6V6.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p>以下是這個團隊針對提升數據質量所提出的概述。</p><h1 id="FE-Analytics-Framework"><a href="#FE-Analytics-Framework" class="headerlink" title="FE Analytics Framework"></a>FE Analytics Framework</h1><p>FE分析框架的開發始於對現有系統的全面審查。</p><h1 id="Building-blocks"><a href="#Building-blocks" class="headerlink" title="Building blocks"></a>Building blocks</h1><p>一個事件通常包含兩個部分:</p><ul><li>發生事件：用戶在特定應用程序的頁面上與元素進行互動。</li><li>內容：該事件周圍狀況的各種狀態。</li></ul><p><img src="https://hackmd.io/_uploads/By32h664p.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><h1 id="The-rocky-development-process"><a href="#The-rocky-development-process" class="headerlink" title="The rocky development process"></a>The rocky development process</h1><p>先前對於發送這些數據是沒有控制的。以下是跟蹤一個硬編碼事件而沒有任何控制的過程。</p><p><img src="https://hackmd.io/_uploads/SyTgpaTNT.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p>基於產品擁有者的需求，開發人員將事件硬編碼，推出了該功能，然後等待了幾天以收集足夠的數據進行分析。</p><p>在這一點上，如果幸運的話，他們可能有了良好的數據，或者發現了需要在分析中修復的問題，這將導致進一步的延遲。<br>這導致了精力的浪費和延遲的結果，本來可以幫助評估KPI的實現。如果不幸的話，他們可能會做出不受支持的決策，可能影響功能的採用。</p><p>隨著時間的推移，這個框架已經進化以應對這些問題，現在提供了一個早期警報系統，用於確定分析是否值得信賴。</p><h1 id="Classifying-the-Issues"><a href="#Classifying-the-Issues" class="headerlink" title="Classifying the Issues"></a>Classifying the Issues</h1><p>為了增強我們FE Analytics的效能，我們將各種團隊遇到的挑戰分類為需要解決的特定類型的問題。<br>這些問題可以與事件本身的構建塊相關聯。</p><h2 id="Bad-events"><a href="#Bad-events" class="headerlink" title="Bad events"></a>Bad events</h2><ul><li>誤導性事件 — 不正確的操作類型、頁面或應用程式名稱</li><li>實施問題 — 事件重複、事件遺漏。</li></ul><h2 id="Bad-context"><a href="#Bad-context" class="headerlink" title="Bad context"></a>Bad context</h2><ul><li>誤導性上下文 — 上下文的值錯誤或難以分析。</li><li>缺失上下文 — 需要的值遺失。</li></ul><p>除此之外，我們還存在一個問題，那就是可靠地確定哪個團隊擁有特定的事件。<br>我們還需要控制數據，確保人們僅發送純粹的用戶互動，而不將數據混合用於其他目的（如加載時間和內部狀態）。<br><img src="https://hackmd.io/_uploads/HkJzATpE6.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><h1 id="Defining-Events"><a href="#Defining-Events" class="headerlink" title="Defining Events"></a>Defining Events</h1><p>開發人員首先需要在一個集中的儲存庫中定義一個事件。由於表的扁平結構包含1500多個列，其中在任何給定事件中大多數列都將是空的，我們需要確保特定元素、頁面或應用程式的必需字段是存在的。</p><p>因此，這個集中式儲存庫提供了一個用於定義事件的API，看起來如下所示。</p><p><img src="https://hackmd.io/_uploads/HyKV1RT4p.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p>在定義被創建之後，由我們擁有這個集中式 C# 儲存庫的團隊進行 MR（Merge Request）審查，並對事件的設計質量發表評論。我們確保人們發送必要的事件和上下文，檢查命名以及其他質量準則。</p><p>這也成為預期事件的真實來源，從中我們可以:</p><ul><li>目錄事件</li><li>標記事件的擁有權</li><li>生成封裝事件標識和上下文的類型化對象</li><li>生成用於捕捉回歸的驗證規則。</li></ul><p>一旦一切都得到批准，MR（Merge Request）就會被合併。從這一點開始，代碼被生成並作為事件類型的庫的一部分進行部署。</p><h1 id="Implementing-Events-Using-the-FE-Analytics-Library"><a href="#Implementing-Events-Using-the-FE-Analytics-Library" class="headerlink" title="Implementing Events Using the FE Analytics Library"></a>Implementing Events Using the FE Analytics Library</h1><p>這個庫基本上提供了一種改進的開發人員體驗，同時確保追踪的事件是前一狀態定義中生成的代碼對象。</p><p>在這裡，我們在UI框架的頂部提供了觀察者，以直觀地在UI本身上直接追踪正確的操作。對於事件觀察，我們目前提供API支持</p><ul><li>HTML DOM Observers for web applications</li><li>SwiftUI for iOS</li><li>Jetpack Compose for Android</li></ul><p>除此之外，我們還允許開發人員從應用程序的邏輯層手動追踪事件，盡管我們強烈建議他們盡可能使用觀察者。</p><p>通過使用為事件生成的類型與觀察者，我們確保他們在預期的上下文中追踪元素上的正確操作。</p><p>除了提供新的API之外，還需要更多，因為許多事件是使用舊的實現發送的。我們還需要開發人員將事件遷移到新系統，主要是為了進行目錄化和標記擁有權。這可能是一個挑戰，我們還投入了更多的努力來實現更簡便的代碼遷移，正如我的同事在文章<a href="https://medium.com/agoda-engineering/tackling-legacy-code-how-we-accelerate-code-migration-at-agoda-with-metaprogramming-ead43f4ffe4a">《應對舊代碼：我們如何通過元編程在Agoda加速代碼遷移》</a>中所描述的。</p><h1 id="Testing-the-Events"><a href="#Testing-the-Events" class="headerlink" title="Testing the Events"></a>Testing the Events</h1><p>測試分析數據是有爭議的，因為編寫測試對於像追踪事件這樣的“簡單”事物被認為很昂貴，往往容易被忽視。為了幫助簡化這個過程，我們的團隊提供了一套與觀察&#x2F;追踪API綁定的測試工具，以減少撰寫測試所需的步驟。</p><p>我們最少期望開發人員能夠手動測試事件，以確保基本合理性。<br>然而，這也是一個具有挑戰性的經歷，因為人們必須查看網絡層，基本上是在冗長的請求主體中尋找他們的事件，猶如在一堆中尋找針芥。</p><p>最終，儘管已經編寫了測試並通過手動檢查確保事件正確，但在生產環境中仍然有可能發生一些問題。假設根據用例場景（國家、貨幣、屬性等）考慮上下文的所有可能值，那麼上下文的可能組合使得幾乎不可能確保不發生任何回歸。</p><p>因此，我們設計了一個系統，利用基於定義生成的規則在prelive和production環境中驗證事件，並根據所涵蓋的情景提供最大的反饋。</p><h1 id="Providing-Pre-and-Post-Production-Feedback"><a href="#Providing-Pre-and-Post-Production-Feedback" class="headerlink" title="Providing Pre and Post-Production Feedback"></a>Providing Pre and Post-Production Feedback</h1><p>我們的驗證系統基於實現JSON Schema規範。<br>我們從定義中生成一個JSON Schema“規則”，然後與兩個系統同步，以不同的方式提供反饋。</p><ul><li>來自分析伺服器的實時反饋：這僅發生在pre-live應用程序中，可在開發或pre-live測試期間使用。</li><li>生產後監控：我們無法實時驗證所有事件，因為參與的規模和計算量太大。因此，該系統驗證在生產中接收的一部分事件，並將其記錄下來，我們的報告讀取並將這些問題轉換為直接在擁有事件的團隊的問題追踪看板上提出的錯誤。</li></ul><p><img src="https://hackmd.io/_uploads/BkFWBATVa.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p>最終，這個設置使得分析開發週期在產品擁有者分析數據之前，具有更多檢查點，以提供反饋，並意識到分析存在問題。</p><p><img src="https://hackmd.io/_uploads/ry5VS0aVp.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><h1 id="Improving-the-Debugging-Experience"><a href="#Improving-the-Debugging-Experience" class="headerlink" title="Improving the Debugging Experience"></a>Improving the Debugging Experience</h1><p>即使這些反饋機制已經就位，我們的開發人員在使用實時反饋機制時仍然需要協助。<br>這是相當冗長的，需要一些努力來準確找出他們分析中的問題。</p><p>為了使這個過程更加直觀，我們提供了一個開發人員工具，作為一個名為 Mimir 的Chrome擴展的一部分。<br>該工具幫助用戶可視化和調試從應用程序發送出去的分析。<br>它逐一顯示應用程序發送的分析，如果從伺服器接收到任何驗證反饋，則將其突顯顯示。它不僅連接到瀏覽器中運行的當前Web會話，而且我們還允許其他非Web應用程序通過使用QR碼進行遠程連接，將分析顯示在這個調試器上。</p><p><img src="https://hackmd.io/_uploads/Bk_0HRp4T.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p><img src="https://hackmd.io/_uploads/Hku1806Ea.png" alt="image"></p><blockquote><p>圖片來源: <a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></p></blockquote><p>有了這一點，我們將體驗提升到一個難以爭辯的地步，即由於任何困難，不進行手動測試分析是困難的。</p><p>Mimir Chrome擴展對Agoda的內部用戶提供的不僅僅是調試分析的功能，這是另一篇文章的主題。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在Agoda，FE Analytics對於收集和分析用戶互動數據至關重要，這對於提升用戶體驗至關重要。<br>由於這個系統的每個事件都需要由開發人員實現，存在錯誤和不一致性的可能性很高，最終可能導致錯誤的決策，以及時間和收入的損失。為了確保數據質量並減少任何可能的問題，FE數據團隊維護了一個系統和流程，使開發人員能夠定義、實現和測試他們的事件，在開發過程中獲得早期反饋，並通過觀察生產中的事件提前發出警告。</p><p>這個流程仍然有很大的改進空間，我們正在努力設計更好的API和保護措施，以在分析問題進入生產之前預防它們。</p><h1 id="文章來源-https-medium-com-agoda-engineering-refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f"><a href="#文章來源-https-medium-com-agoda-engineering-refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f" class="headerlink" title="文章來源:https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f"></a>文章來源:<a href="https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f">https://medium.com/agoda-engineering/refining-front-end-analytics-quality-strategies-and-tools-for-developers-at-agoda-f0bb8778578f</a></h1>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Agoda-Engineering-%E9%83%A8%E8%90%BD%E6%A0%BC/">Agoda Engineering 部落格</category>
      
      <category domain="https://gahgah147.github.io/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      <category domain="https://gahgah147.github.io/tags/Front-End-Analytics/">Front End Analytics</category>
      
      <category domain="https://gahgah147.github.io/tags/Front-End/">Front End</category>
      
      
      <comments>https://gahgah147.github.io/2023/11/27/%E5%84%AA%E5%8C%96%E5%89%8D%E7%AB%AF%E5%88%86%E6%9E%90%EF%BC%9AAgoda-%E9%96%8B%E7%99%BC%E8%80%85%E7%9A%84%E5%93%81%E8%B3%AA%E7%AD%96%E7%95%A5%E8%88%87%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Google Analytics 4 練習紀錄</title>
      <link>https://gahgah147.github.io/2023/11/13/Google-Analytics-4-%E7%B7%B4%E7%BF%92%E7%B4%80%E9%8C%84/</link>
      <guid>https://gahgah147.github.io/2023/11/13/Google-Analytics-4-%E7%B7%B4%E7%BF%92%E7%B4%80%E9%8C%84/</guid>
      <pubDate>Mon, 13 Nov 2023 01:32:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇是記錄我在看&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10314237&quot;&gt;鐵人賽  跟著 OXXO 一起學 GA4 ( Google Analytics 4 )&lt;/a&gt; 的過程 &lt;/p&gt;
&lt;h1 id=&quot;GA4-介紹&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇是記錄我在看<a href="https://ithelp.ithome.com.tw/articles/10314237">鐵人賽  跟著 OXXO 一起學 GA4 ( Google Analytics 4 )</a> 的過程 </p><h1 id="GA4-介紹"><a href="#GA4-介紹" class="headerlink" title="GA4 介紹"></a>GA4 介紹</h1><h2 id="GA4-是什麼？"><a href="#GA4-是什麼？" class="headerlink" title="GA4 是什麼？"></a>GA4 是什麼？</h2><p>Google Analytics 4 ( GA4 ) 是 Google 的最新版本分析工具，與過去的版本不同的是，GA4 更加注重事件驅動的分析，除了支持跨設備和跨平台數據收集，也提供了更多人工智慧和機器學習功能，能夠更有效地透過流量了解使用者。</p><p>GA4 以「事件 Events」為資料收集的基礎，除了幾個基本事件，如果要分析額外資訊，則需要自行建立其他額外事件，這種全新的資料收集架構，大幅提高在商業應用上的深度與彈性，但也增加了不少學習門檻，且 GA4 目前仍在不斷發展階段，許多未來「可能調整」的介面或功能，也是導入 GA4 時需要面對的挑戰。</p><h2 id="發展歷程"><a href="#發展歷程" class="headerlink" title="發展歷程"></a>發展歷程</h2><p>自 2005 年推出以來，GA 整合了許多的功能，已經成為一個廣泛使用且不可或缺的分析工具，下方簡單整理了 GA 的發展歷程與重要里程碑：</p><table><thead><tr><th>年份</th><th>概要</th></tr></thead><tbody><tr><td>1997</td><td>網站數據分析工具 Urchin 誕生</td></tr><tr><td>2005</td><td>Google 收購 Urchin，正式推出 Google Analytics ( GA )。</td></tr><tr><td>2008</td><td>加入 Custom Reports 和 Advanced Segments 功能，增強自訂分析和進階分析的能力。</td></tr><tr><td>2009</td><td>加入 Event Tracking 功能，增強深度監測和分析使用者互動行為。</td></tr><tr><td>2011</td><td>加入 Multi-Channel Funnels ( MCF ) 功能，降低多管道歸因分析門檻，並加入 Real-Time 即時監看數據的功能。</td></tr><tr><td>2012</td><td>發佈 Google Tag Manager ( GTM )，讓使用者更能有效地整合自己的 GA 程式碼。</td></tr><tr><td>2012</td><td>發佈Universal Analytics ( UA )，允許跨設備和跨平台數據收集。</td></tr><tr><td>2013</td><td>發佈 Measurement Protocol 測量協議，定義從任何系統或裝置傳送資料到 Google Anlaytics 的方法。</td></tr><tr><td>2014</td><td>發佈 Enhanced ecommerce，增強電商處理數據功能。</td></tr><tr><td>2016</td><td>發佈 Google Analytics 360，整體解決方案升級為 Google Analytics Solutions。</td></tr><tr><td>2018</td><td>發佈 Google Marketing Platform，整合 Google Analytics 360 和 DoubleClick。</td></tr><tr><td>2019</td><td>發佈 APP + Web Property ( 取代 Google Analytics For APP )。</td></tr><tr><td>2020</td><td>發佈 Google Analytics 4 ( GA4 )，也是 APP + Web 的延伸。</td></tr><tr><td>2023</td><td>全面使用 GA4，停用通用版本 GA。</td></tr></tbody></table><h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><ol><li>智慧化報告：透過更加智慧化的報告，更容易了解使用者行為。</li><li>注重資料隱私：更強大的資料隱私功能，可以更好地保護用戶的資料安全 ( 例如無 Cookie 的評估功能、行為與轉換模擬 )。</li><li>跨設備追蹤：具有跨設備追蹤功能，可以追蹤使用者在不同設備上的互動。</li><li>事件驅動：以事件 (而非工作階段) 為基礎的資料。</li><li>客製化功能：具有更加靈活的客製化功能，可以根據使用者需求定製不同的報告。</li><li>整合媒體平台：整合 Google 廣告系統，可以更好地管理網絡廣告。</li><li>預測功能：不需要複雜模型即可提供指引。</li></ol><h1 id="建立分析資源"><a href="#建立分析資源" class="headerlink" title="建立分析資源"></a>建立分析資源</h1><h2 id="單純建立-GA4-分析資源"><a href="#單純建立-GA4-分析資源" class="headerlink" title="單純建立 GA4 分析資源"></a>單純建立 GA4 分析資源</h2><p>登入 Google 帳戶之後，從下方的網址可以前往 Google Analytics 平台：<br><img src="https://hackmd.io/_uploads/BJzAdSAM6.png"></p><blockquote><p><a href="https://analytics.google.com/analytics/web/provision/#/provision">https://analytics.google.com/analytics/web/provision/#/provision</a></p></blockquote><div class="note info simple"><p>點擊開始評估就能啟用 Google Analytics 的帳戶</p></div><p><img src="https://hackmd.io/_uploads/S1DuKrRMT.png"></p><blockquote><p>在帳戶設定步驟，將「帳戶共用設定」的共用方式全部勾選 ( 或是使用預設值也可以 )。</p></blockquote><p>在資源設定步驟，輸入資源名稱以及對應的貨幣、時區，進階選項會詢問是否建立通用版的 GA，根據個人需求選擇是否同時建立 ( 因為 2023 年 7 月以後 Google 不支援通用版 GA，因此可以不用建立 )。<br><img src="https://hackmd.io/_uploads/SJItkkbXa.png" alt="image.png"></p><p><img src="https://hackmd.io/_uploads/ByksJ1Z7p.png" alt="image.png"></p><blockquote><p>建立商家資訊</p></blockquote><p><img src="https://hackmd.io/_uploads/HJT61kZQT.png" alt="image.png"></p><blockquote><p>選擇業務目標</p></blockquote><p><img src="https://hackmd.io/_uploads/ryaSxJ-QT.png" alt="image.png"></p><blockquote><p>設定資料串流</p></blockquote><p><img src="https://hackmd.io/_uploads/HJ8qxkZXa.png" alt="image.png"></p><blockquote><p>一個 GA4 的分析資源就會建立完成。</p></blockquote><p>如果已經有 Google Analytics 的帳戶和資源，點擊左下角的「設定」按鈕圖示，就能「建立帳戶」或從現有帳戶「建立資源」。</p><h1 id="安裝資料收集代碼"><a href="#安裝資料收集代碼" class="headerlink" title="安裝資料收集代碼"></a>安裝資料收集代碼</h1><p><img src="https://hackmd.io/_uploads/rJB7VCW7a.png" alt="image.png"><br>點擊該筆資料串流，開啟串流設定畫面後捲動到最下方，點擊「查看代碼操作說明」。</p><p><img src="https://hackmd.io/_uploads/S1S8EAZQa.png" alt="image.png"></p><blockquote><p>複製要放在網站中的資料收集代碼，並將這些資料收集代碼，按照說明放在網頁的 HTML 中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Google tag (gtag.js) --&gt;</span><br><span class="line">&lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=G-RQQ6S8TM5J&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.dataLayer = window.dataLayer || [];</span><br><span class="line">  function gtag()&#123;dataLayer.push(arguments);&#125;</span><br><span class="line">  gtag(&#x27;js&#x27;, new Date());</span><br><span class="line"></span><br><span class="line">  gtag(&#x27;config&#x27;, &#x27;G-RQQ6S8TM5J&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="測試-GA4-資料收集代碼"><a href="#測試-GA4-資料收集代碼" class="headerlink" title="測試 GA4 資料收集代碼"></a>測試 GA4 資料收集代碼</h2><p>參考下方範例程式碼，將資料收集代碼放入網頁 HTML 裡，可以使用 JS Bin 的線上網頁編輯器進行測試 ( 參考「使用測試網頁」)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Google tag (gtag.js) --&gt;</span><br><span class="line">  &lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=G-XXXXXX&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    window.dataLayer = window.dataLayer || [];</span><br><span class="line">    function gtag()&#123;dataLayer.push(arguments);&#125;</span><br><span class="line">    gtag(&#x27;js&#x27;, new Date());</span><br><span class="line">    gtag(&#x27;config&#x27;, &#x27;G-XXXXXX);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>網頁開啟後，應該就能在 GA4 資源的「首頁」裡，看到過去 30 分鐘的使用者出現「1」個使用者，這也表示資料收集代碼已經順利安裝成功。</p><blockquote><p>GA4 的「即時」通常可能會有三十秒到一分鐘左右的延遲。<br>要正確執行代碼，不能單純開啟網頁，而是要在本機環境啟用一個網頁伺服器，或使用 JS Bin 的線上網頁編輯器進行測試 ( 參考「使用測試網頁」 )</p></blockquote><p><img src="https://hackmd.io/_uploads/ByXNBAWQT.png" alt="image.png"></p><h2 id="查看-GA4-資料串流評估-ID"><a href="#查看-GA4-資料串流評估-ID" class="headerlink" title="查看 GA4 資料串流評估 ID"></a>查看 GA4 資料串流評估 ID</h2><p>如果要查看 GA4 資料串流評估 ID，可以從「管理 &gt; 資源 &gt; 資料串流」裡，點擊想要查看的資料串流。<br><img src="https://hackmd.io/_uploads/H1RvBCbmp.png" alt="image.png"></p><h2 id="刪除與還原帳戶"><a href="#刪除與還原帳戶" class="headerlink" title="刪除與還原帳戶"></a>刪除與還原帳戶</h2><p>如果要刪除帳戶，可以從「管理 &gt; 帳戶 &gt; 帳戶詳情」的頁面，點擊「丟進垃圾桶」就能刪除帳戶。<br><img src="https://hackmd.io/_uploads/BJ1k1uwm6.png" alt="image.png"></p><blockquote><p>點擊「丟棄帳戶」，就會將該帳戶放入垃圾桶。</p></blockquote><p><img src="https://hackmd.io/_uploads/rkTgJuDQ6.png" alt="image.png"></p><p>前往「已經被丟棄的帳戶」的「管理 &gt; 帳戶 &gt; 垃圾桶」，就能看到被刪除的帳戶，垃圾桶中的項目在保留 35 天之後，就會永久刪除。系統會在變更記錄中留下刪除記錄 ( 帳戶如果存在垃圾桶中，無法使用帳戶設定以及篩選器功能 )。</p><p><img src="https://hackmd.io/_uploads/ryU7k_wmp.png" alt="image.png"></p><p>勾選要還原的帳戶，點擊「還原」，就能還原帳戶 ( 還原帳戶需要有「編輯者」權限的使用者 )。<br><img src="https://hackmd.io/_uploads/rkwV1_wQa.png" alt="image.png"></p><h2 id="刪除與還原資源"><a href="#刪除與還原資源" class="headerlink" title="刪除與還原資源"></a>刪除與還原資源</h2><p>如果要刪除資源，可以從「管理 &gt; 資源 &gt; 資源設定」的頁面，點擊「丟進垃圾桶」就能刪除資源。<br><img src="https://hackmd.io/_uploads/rkOv1_wma.png" alt="image.png"></p><p>點擊「移至垃圾桶」，就會將該資源放入垃圾桶。<br><img src="https://hackmd.io/_uploads/r10_JuPQa.png" alt="image.png"></p><p>前往「管理 &gt; 帳戶 &gt; 垃圾桶」，就能看到被刪除的資源，垃圾桶中的項目在保留 35 天之後，就會永久刪除。系統會在變更記錄中留下刪除記錄，點擊「還原」，就能還原資源 ( 還原帳戶需要有「編輯者」權限的使用者 )。</p><h2 id="移動資源"><a href="#移動資源" class="headerlink" title="移動資源"></a>移動資源</h2><p>移動資源功能可以將資源從「來源」帳戶移至「目標」帳戶，移動資源時，例如代碼 ID、資源設定、資料串流、報表資料、資源層級整合等項目會跟著移動，但是例如變更記錄則會保留在來源帳戶中。如果要移動資源，可以從「管理 &gt; 資源 &gt; 資源設定」的頁面，點擊「移動資源」。</p><p><img src="https://hackmd.io/_uploads/ry91gdwma.png" alt="image.png"></p><p>選擇要移動到的帳戶，勾選確認變更後，點擊「開始移動」就會移動資源。</p><p><img src="https://hackmd.io/_uploads/Bk6Wguv7a.png" alt="image.png"></p><h2 id="查看帳戶與資源變更紀錄"><a href="#查看帳戶與資源變更紀錄" class="headerlink" title="查看帳戶與資源變更紀錄"></a>查看帳戶與資源變更紀錄</h2><p>只要帳戶有所更動，在「管理 &gt; 帳戶 &gt; 帳戶變更紀錄」裡都會看到相關資訊。</p><p><img src="https://hackmd.io/_uploads/SySte_w76.png" alt="image.png"></p><p>如果是資源變更資訊，可以在「管理 &gt; 資源 &gt; 資源變更紀錄」裡看到相關資訊。</p><p><img src="https://hackmd.io/_uploads/SkNugOvQa.png" alt="image.png"></p><h2 id="開啟設定輔助程式"><a href="#開啟設定輔助程式" class="headerlink" title="開啟設定輔助程式"></a>開啟設定輔助程式</h2><p><img src="https://hackmd.io/_uploads/HJWQGuvXT.png" alt="image.png"><br>設定輔助程式可以讓使用者快速進行 GA4 的常用設定，只要點擊各項設定後方的「&gt;」，就會引導至對應的設定畫面或直接進行設定，如果勾選標示完成，上方也會顯示完成的進度條。</p><p>設定輔助程式可以進行的設定<br>下方列出設定輔助程式可以進行的相關設定：</p><table><thead><tr><th>設定</th><th>說明</th></tr></thead><tbody><tr><td>收集網站和應用程式資料</td><td>前往「資料串流」新增資料串流收集資料( 教學參考 )。</td></tr><tr><td>啟用 Google 信號</td><td>前往「資料設定 &gt; 資料收集」啟用或關閉 Google 信號( 教學參考 )。</td></tr><tr><td>設定轉換</td><td>前往「轉換」管理轉換事件( 教學參考 )。</td></tr><tr><td>定義目標對象</td><td>前往「目標對象」管理目標對象。</td></tr><tr><td>連結至 Google Ads</td><td>前往「Google Ads 連結」管理 Google Ads 的連結。</td></tr><tr><td>針對 GA4 轉換出價</td><td>確認是否使用GA4 轉換出價。</td></tr><tr><td>將廣告指定給 GA4 目標對象</td><td>確認是否將廣告指定給 GA4 目標對象。</td></tr><tr><td>管理使用者</td><td>前往「資源存取管理」管理使用者權限，或匯入通用版 GA 使用者資料。</td></tr><tr><td>匯入資料</td><td>確認是否使用匯入資料 ( 教學參考 )。</td></tr><tr><td>連結至 BigQuery</td><td>前往「BigQuery 連結」管理與 BigQuery 的連結。</td></tr><tr><td>設定 User-ID</td><td>確認是否使用 User-ID ( 教學參考 )。</td></tr><tr><td>使用 Measurement Protocol</td><td>確認是否使用 Measurement Protocol ( 教學參考 )。</td></tr></tbody></table><h1 id="使用測試網頁"><a href="#使用測試網頁" class="headerlink" title="使用測試網頁"></a>使用測試網頁</h1><h2 id="JS-Bin"><a href="#JS-Bin" class="headerlink" title="JS Bin"></a>JS Bin</h2><blockquote><p>網址：<a href="https://jsbin.com/?html,output">https://jsbin.com/?html,output</a></p></blockquote><p>開啟 JS Bin 後，將 GA4 的資料收集代碼貼到 HTML 欄位的程式碼裡，放在 </head> 之前，按下右上角的「Run width JS」就會執行網頁，隨後在 GA4 的即時監控中就能看到出現一個使用者。</p><p><img src="https://hackmd.io/_uploads/Hkwfd3KmT.png" alt="image.png"></p><h2 id="JSFiddle"><a href="#JSFiddle" class="headerlink" title="JSFiddle"></a>JSFiddle</h2><blockquote><p>網址：<a href="https://jsfiddle.net/">https://jsfiddle.net/</a></p></blockquote><p>開啟 JSFiddle 後，將 GA4 的資料收集代碼貼到 HTML 欄位的程式碼裡，按下左上角的「Run」就會執行網頁，隨後在 GA4 的即時監控中就能看到出現一個使用者。</p><p><img src="https://hackmd.io/_uploads/Hy9qKhYm6.png" alt="image.png"></p><h2 id="CodePen"><a href="#CodePen" class="headerlink" title="CodePen"></a>CodePen</h2><p>CodePen 是一個偏向「網頁作品展示」的線上編輯器，除了可以編輯 HTML、CSS 和 JavaScript，更加入社群的功能，讓程式設計師可以在平台裡分享自己的程式作品。</p><blockquote><p>網址：<a href="https://codepen.io/">https://codepen.io/</a></p></blockquote><p>開啟 CodePen 後，將 GA4 的資料收集代碼貼到 HTML 欄位的程式碼裡，按下左上角的「Run」就會執行網頁，隨後在 GA4 的即時監控中就能看到出現一個使用者。<br><img src="https://hackmd.io/_uploads/BkjFs2tma.png" alt="image.png"></p><h1 id="啟用示範帳戶"><a href="#啟用示範帳戶" class="headerlink" title="啟用示範帳戶"></a>啟用示範帳戶</h1><p>Google Analytics 示範帳戶是功能完整的 GA 帳戶，可供任何 Google 使用者存取。其中包含一個通用版 GA 資源和兩個 GA4 資源，在 Google 官方教學裡，也是使用示範帳戶進行展示，這篇文章會介紹如何啟用 Google Analytics 示範帳戶。</p><h2 id="存取示範帳戶"><a href="#存取示範帳戶" class="headerlink" title="存取示範帳戶"></a>存取示範帳戶</h2><p>Google Analytics 提供了三個示範帳戶，登入並建立 Google Analytics 帳戶後 ( 參考「建立分析資源」)，點擊示範帳戶網址，示範帳戶就會自動加入自己的 GA 資源裡 ( 參考「示範帳戶」 )。</p><blockquote><p><a href="https://support.google.com/analytics/answer/6367342#access&zippy=%2C%E6%9C%AC%E6%96%87%E5%85%A7%E5%AE%B9">Google Analytics (分析) 4 資源：Google 商品網路商店 (網站資料)</a><br><a href="https://support.google.com/analytics/answer/6367342#access">Google Analytics (分析) 4 資源：Flood-It! (應用程式和網站資料)</a><br><a href="https://support.google.com/analytics/answer/6367342#access&zippy=%2C%E6%9C%AC%E6%96%87%E5%85%A7%E5%AE%B9">通用 Analytics (分析) 資源：Google 商品網路商店 (網站資料)</a></p></blockquote><h1 id="GTM"><a href="#GTM" class="headerlink" title="GTM"></a>GTM</h1><p>GTM ( Google Tag Manager ) 是 Google 提供的免費網站標籤管理工具，它可以讓網站管理者更容易的新增、編輯和刪除網站上的追蹤程式碼 ( 例如 Google Analytics、Facebook Pixel、Google Ads Conversion Tracking…等 )，GTM 可以透過網頁標籤嵌入網頁，在不需要接觸網站原始碼的情況下，就能快速管理所有網站追蹤程式碼。</p><p><img src="https://hackmd.io/_uploads/rkXLCWiQT.png" alt="image"></p><h2 id="GTM-和-GA-的差別"><a href="#GTM-和-GA-的差別" class="headerlink" title="GTM 和 GA 的差別"></a>GTM 和 GA 的差別</h2><p>GTM ( Google Tag Manager ) 和 GA ( Google Analytics ) 都是 Google 所提供的工具，但是它們的功能和使用方式有所不同。</p><p>GTM 是一個「網站標籤管理工具」，它可以讓管理者更容易地管理和部署網站上的跟蹤標籤，例如 GA 追蹤碼、Facebook Pixel…等。GTM 提供一個容器，在不需要進入網站原始碼的情況下，就能進行添加、編輯和刪除追蹤標籤。它還提供了許多進階功能，例如事件追蹤、電子商務追蹤、自定義 JavaScript 程式碼…等。</p><p>GA 是一個「分析工具」，它可以幫助管理者追蹤和分析使用者的行為和互動。GA 也可以掌握使用者的地理位置、瀏覽器類型、裝置類型、訪問時間、頁面流量…等，並進一步分析訪問者的行為，例如頁面停留時間、轉換率、漏斗分析，GA 甚至還提供許多報表和圖表，可以更有效的了解各項數據和趨勢。</p><table><thead><tr><th></th><th>功能</th><th>進階功能</th></tr></thead><tbody><tr><td>GTM</td><td>網站標籤管理工具</td><td>事件追蹤、電子商務追蹤、自定義 JavaScript 程式碼…</td></tr><tr><td>GA</td><td>分析工具</td><td>掌握使用者的地理位置、瀏覽器類型、裝置類型、訪問時間、頁面流量…</td></tr></tbody></table><p><img src="https://hackmd.io/_uploads/rk0lQMs76.png" alt="image"></p><blockquote><p>GTM 可以用於部署 GA 追蹤碼，而 GA 可以分析 GTM 中所設置的事件和行為。</p></blockquote><h2 id="使用-GTM-的好處"><a href="#使用-GTM-的好處" class="headerlink" title="使用 GTM 的好處"></a>使用 GTM 的好處</h2><p>對於管理者而言，使用 GTM 有下列幾個好處：</p><ul><li>簡化網站追蹤程式碼管理流程：管理者可以更快速地添加、刪除和更新程式碼，不需要依賴開發人員。</li><li>提高網站效能：GTM 可以將多個跟蹤程式碼整合成一個標籤，減少網站載入時間。</li><li>提供更好的追蹤功能，GTM 可以追蹤網站的各種行為和互動 ( 例如點擊、頁面滾動、表單提交…等 )。</li><li>追蹤碼統一管理：所有追蹤碼都可以從後台清楚呈現，維護更新非常方便。</li></ul><h2 id="GTM-對行銷人員的好處"><a href="#GTM-對行銷人員的好處" class="headerlink" title="GTM 對行銷人員的好處"></a>GTM 對行銷人員的好處</h2><p>通常行銷人員並不如程式設計師一般的熟悉程式編輯，因此對於行銷人員而言，GTM 有下列幾個好處：</p><ul><li>更容易管理和追蹤：GTM 還提供了許多追蹤功能 ( 事件追蹤、電子商務追蹤、網站轉換追蹤…等 )，行銷人員可以更好的了解使用者在網站上的行為和互動，並能追蹤訂單、收入和轉換率等重要指標，也可以透過網站轉換追蹤去追蹤特定目標，甚至進行 A&#x2F;B 測試，比較不同版本的網站，找到最有效的方案。</li><li>不需要過度仰賴程式設計師：行銷人員可以透過 GTM 快速添加、編輯和刪除追蹤標籤，不需要過度依賴開發人員，節省時間和成本。</li></ul><p>總而言之，對於行銷人員而言，透過 GTM 可以更容易去了解使用者行為和網站效能，並且可以幫助他們更有效地執行網站的改善和數據驅動的行銷策略。</p><h2 id="使用GTM"><a href="#使用GTM" class="headerlink" title="使用GTM"></a>使用GTM</h2><blockquote><p>原文參考：<a href="https://steam.oxxostudio.tw/category/ga4/gtm/start-use.html">開始使用 GTM</a></p></blockquote><p>登入 GTM<br>使用 Google 帳號登入 GTM，登入後可以建立帳戶，或查看自己 Google 帳號下的 GA 追蹤代碼。</p><blockquote><p>GTM 網址：<a href="https://tagmanager.google.com/">https://tagmanager.google.com/</a></p></blockquote><p><img src="https://hackmd.io/_uploads/rJmQoGimT.png" alt="image"></p><p>在「建立帳戶」頁籤裡，可以建立 GTM 的帳戶已變進行代碼管理，切換到「Google 代碼」頁籤，則可以管理自己 Google 帳號下擁有管理或觀察權限的 GA 追蹤代碼。</p><p><img src="https://hackmd.io/_uploads/H1AJhfj7p.png" alt="image"></p><h3 id="建立帳戶"><a href="#建立帳戶" class="headerlink" title="建立帳戶"></a>建立帳戶</h3><p>要使用 GTM 必須先「建立帳戶」，該帳戶與個人帳戶不同，是專門用來管理 GTM 代碼的帳戶，點擊「建立帳戶」按鈕，簡單輸入帳戶名稱以及容器名稱 ( 通常是以網站網址作爲名稱 )。</p><blockquote><p>在 GTM 裡，會使用「容器」安裝各種不同工具與代碼，每個帳號下可以具有有多個不同的容器，每個容器裡可以建立多個不同種類的代碼，容器彼此獨立互不影響。</p></blockquote><p><img src="https://hackmd.io/_uploads/HJA-pGsXa.png" alt="image"></p><p>確認相關條款後，GTM 的帳戶就建立完成。</p><p><img src="https://hackmd.io/_uploads/BydB6Momp.png" alt="image"></p><h3 id="新增代碼"><a href="#新增代碼" class="headerlink" title="新增代碼"></a>新增代碼</h3><p>點擊左側「代碼」選項，點擊右上方的「新增」，就能在 GTM 的容器裡，新增相關的追蹤代碼。<br><img src="https://hackmd.io/_uploads/H1yBCMjQa.png" alt="image"></p><p>點擊「代碼設定」欄位，就能選擇要加入的代碼類型，在「精選」的區域通常是 Google 自家追蹤代碼。</p><p><img src="https://hackmd.io/_uploads/S1xx1moQ6.png" alt="image"></p><p>如果有其他沒有在清單裡面的代碼，就需要使用「自訂 HTML 代碼」進行部署，甚至也可以使用「自訂圖片代碼」部署像素廣告代碼<br><img src="https://hackmd.io/_uploads/r1ydxQs7T.png" alt="image"></p><h3 id="安裝-GTM-容器代碼"><a href="#安裝-GTM-容器代碼" class="headerlink" title="安裝 GTM 容器代碼"></a>安裝 GTM 容器代碼</h3><p>如果要透過 GTM 執行各種代碼的追蹤，必須要先將 GTM 的容器代碼放到網站 HTML 裡，點擊「管理」頁籤，點選「安裝 Google 代碼管理工具」。</p><p><img src="https://hackmd.io/_uploads/r1P9xmjXa.png" alt="image"><br>點擊後，按照操作步驟，將 GTM 容器程式碼放到網頁 HTML 中指定的位置，放在 <head></head> 裡的是主要容器代碼，放在 <body></body> 裡的是在瀏覽器不支援 JavaScript 時才會啟用的代碼。</p><p><img src="https://hackmd.io/_uploads/r11ngmomT.png" alt="image"></p><h3 id="認識-GTM-的-Data-Layer"><a href="#認識-GTM-的-Data-Layer" class="headerlink" title="認識 GTM 的 Data Layer"></a>認識 GTM 的 Data Layer</h3><p>資料層 ( Data Layer ) 是 GTM 運作的基礎，也是 GTM 用於收集網站數據的關鍵。Data Layer 屬於一種 JavaScript 物件，目的在於儲存網站中所獲得的數據，讓 GTM 可以輕鬆地檢測到並追蹤這些數據，並在特定事件發生時進行觸發，GTM 可以更準確地追蹤使用者行為並收集更豐富的數據。</p><p>觀察安裝在 HTML 裡的 GTM 程式碼，可以發現裡面出現了「dataLayer」的文字，在程式碼中的 dataLayer 代表程式變數，目的是透過變數收集數據，並藉由 push 的命令將數據傳送到 GTM，因此透過 GTM 操作自訂事件時，常常會使用dataLayer.push的語法。</p><h1 id="gtag-js"><a href="#gtag-js" class="headerlink" title="gtag.js"></a>gtag.js</h1><p>gtag.js 是 Google Analytics 的 JavaScript 追踪代碼，它取代了以前 的Analytics.js 代碼。gtag.js 可以直接嵌入網站代碼中，以收集使用者的行為數據，並更加精確地測量網站的流量與互動成效。</p><blockquote><p>詳細設定參考：<a href="https://steam.oxxostudio.tw/category/ga4/info/install.html">安裝 GA4 資料收集代碼</a></p></blockquote><p>只要將 gtag.js 的資料收集代碼放到網頁 HTML 中指定的位置，網頁開啟後就會開始收集數據，基本的範例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Google tag (gtag.js) --&gt;</span><br><span class="line">  &lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=G-XXXXXX&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    window.dataLayer = window.dataLayer || [];</span><br><span class="line">    function gtag()&#123;dataLayer.push(arguments);&#125;</span><br><span class="line">    gtag(&#x27;js&#x27;, new Date());</span><br><span class="line">    gtag(&#x27;config&#x27;, &#x27;G-XXXXXX);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="GTM-和-gtag-js-比較"><a href="#GTM-和-gtag-js-比較" class="headerlink" title="GTM 和 gtag.js 比較"></a>GTM 和 gtag.js 比較</h2><p>功能：</p><table><thead><tr><th>GTM</th><th>全面的標籤管理系統，可以管理許多種不同的標籤和代碼，包括 Google Analytics、AdWords、Facebook Pixel…等。</th></tr></thead><tbody><tr><td>gtag.js</td><td>專門用於 Google Analytics 數據收集的輕量級追踪代碼。</td></tr></tbody></table><p>實現方式：</p><table><thead><tr><th>GTM</th><th>屬於中間層的「容器」，可以在不更改網站代碼的情況下進行管理和部署作業。</th></tr></thead><tbody><tr><td>gtag.js</td><td>直接嵌入到網站 HTML 中的追踪代碼，不需要通過中間層容器進行管理。</td></tr></tbody></table><p>效率：</p><table><thead><tr><th>GTM</th><th>因使用時需要通過中間層容器進行處理，可能會對網站速度產生輕微的影響。</th></tr></thead><tbody><tr><td>gtag.js</td><td>直接將資料傳遞至 Google Analytics，速度相對較快。</td></tr></tbody></table><p>難易度：</p><table><thead><tr><th>GTM</th><th>GTM 可能需要較長的學習曲線，去熟悉其控制介面和設定方式，且仍需學習 GA4 的用法。</th></tr></thead><tbody><tr><td>gtag.js</td><td>只需要知道程式碼安裝的位置和寫法，同樣也需要學習 GA4 的用法。</td></tr></tbody></table><p>跨平台部署：</p><table><thead><tr><th>GTM</th><th>可以跨多個平台進行部署，包括網站、移動應用程序和 AMP 頁面等等。</th></tr></thead><tbody><tr><td>gtag.js</td><td>只能在網站中使用，無法應用於移動應用程序或 AMP 頁面等其他平台。</td></tr></tbody></table><p>版本控制：</p><table><thead><tr><th>GTM</th><th>允許使用版本控制系統來管理和維護標籤與容器版本。</th></tr></thead><tbody><tr><td>gtag.js</td><td>沒有版本控制功能，所有更改都必須手動維護。</td></tr></tbody></table><h1 id="安裝-GTM-容器代碼-1"><a href="#安裝-GTM-容器代碼-1" class="headerlink" title="安裝 GTM 容器代碼"></a>安裝 GTM 容器代碼</h1><p>使用 Google 帳號登入 GTM 並進入管理帳戶，點擊「管理」頁籤，點選「安裝 Google 代碼管理工具」。</p><blockquote><p>GTM 網址：<a href="https://tagmanager.google.com/">https://tagmanager.google.com/</a><br>參考：開始使用 GTM</p></blockquote><p><img src="https://hackmd.io/_uploads/S1sHOxkE6.png" alt="image"></p><p>點擊後，按照操作步驟，將 GTM 容器程式碼放到網頁 HTML 中指定的位置，放在 <head></head> 裡的是主要容器代碼，放在 <body></body> 裡的是在瀏覽器不支援 JavaScript 時才會啟用的代碼。</p><p><img src="https://hackmd.io/_uploads/SJYPul1E6.png" alt="image"></p><h1 id="新增-GA4-設定代碼"><a href="#新增-GA4-設定代碼" class="headerlink" title="新增 GA4 設定代碼"></a>新增 GA4 設定代碼</h1><p>回到 GTM 帳戶，點擊左側「代碼」選項，點擊右上方的「新增」，在 GTM 的容器裡，新增相關的追蹤代碼。<br><img src="https://hackmd.io/_uploads/SyC5uey4T.png" alt="image"></p><p>點擊「代碼設定」，選擇「Google Analytics ( 分析 )：GA4 設定」，填入 GA4 的評估 ID</p><p><img src="https://hackmd.io/_uploads/Syd-YgJ46.png" alt="image"></p><p>在「觸發條件」裡設定觸發條件為「All Pages」。<br><img src="https://hackmd.io/_uploads/r1APKekNT.png" alt="image"></p><p>完成後儲存代碼，點擊右上方的「提交」。<br><img src="https://hackmd.io/_uploads/BJUE9gkVp.png" alt="image"></p><p>輸入這次更動的版本名稱和內容，按下「發布」，就能發布並更新 GTM 代碼內容。<br><img src="https://hackmd.io/_uploads/r11vqxyNp.png" alt="image"></p><p>如果順利發布完成，就會出現已經上線的畫面。<br><img src="https://hackmd.io/_uploads/rkrq9gJVa.png" alt="image"></p><h1 id="檢查-GA4-代碼是否正確安裝"><a href="#檢查-GA4-代碼是否正確安裝" class="headerlink" title="檢查 GA4 代碼是否正確安裝"></a>檢查 GA4 代碼是否正確安裝</h1><p>回到已經安裝 GTM 容器代碼的網頁，重新執行該網頁，此時從 GA4 的即時總覽裡，應該就能看到出現了使用者，這表示 GA4 已經順利安裝在 GTM 裡並正常執行收集數據。</p><p><img src="https://hackmd.io/_uploads/ryGyjxk4a.png" alt="image"></p><p>參考資料:<br><a href="">GA4 ( Google Analytics 4 ) 教學</a><br><a href="https://ithelp.ithome.com.tw/articles/10314237">2023 ithome鐵人賽 - 跟著 OXXO 一起學 GA4 ( Google Analytics 4 )系列</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/GA4/">GA4</category>
      
      
      <comments>https://gahgah147.github.io/2023/11/13/Google-Analytics-4-%E7%B7%B4%E7%BF%92%E7%B4%80%E9%8C%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Agoda全端工程師的日常生活</title>
      <link>https://gahgah147.github.io/2023/11/11/Agoda%E5%85%A8%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/</link>
      <guid>https://gahgah147.github.io/2023/11/11/Agoda%E5%85%A8%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/</guid>
      <pubDate>Sat, 11 Nov 2023 03:54:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;這篇文章是我在 &lt;a href=&quot;https://medium.com/agoda-engineering&quot;&gt;Agoda Engineering 部落格&lt;/a&gt;的文章閱讀紀錄&lt;br&gt;&lt;a href=&quot;https://medium.com/agoda</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>這篇文章是我在 <a href="https://medium.com/agoda-engineering">Agoda Engineering 部落格</a>的文章閱讀紀錄<br><a href="https://medium.com/agoda-engineering/a-day-in-the-life-of-a-full-stack-engineer-33f640270ae9">A Day in the Life of a Full-Stack Engineer</a></p></blockquote><p>在軟體開發不斷變化的領域中，全端工程師的角色既關鍵又全面。<br>這些多才多藝的專業人員是網絡的建築師和建造者，同時負責製作用戶界面元素，<br>同時管理保持數字平台運行順暢的服務器端流程。<br>這是一個要求不僅廣泛技能，還需要解決問題思維和持續學習的角色。<br>在這篇文章中，Maksym Zavodniuk分享了他作為一名全端工程師的見解。</p><h1 id="全端工程師的角色"><a href="#全端工程師的角色" class="headerlink" title="全端工程師的角色"></a>全端工程師的角色</h1><p>全端工程師負責設計和實現後端（BE）和前端（FE）任務上的功能。<br>我們精通於前端使用的語言和庫，如JavaScript、React、Angular和Vue，並使用CSS進行界面設計。<br>在後端方面，我們熟練地管理像MongoDB、SQL或PostgreSQL這樣的數據庫。<br>根據我們的具體專業深度，我們可能更傾向於前端或後端。</p><h1 id="在Agoda的一天生活"><a href="#在Agoda的一天生活" class="headerlink" title="在Agoda的一天生活"></a>在Agoda的一天生活</h1><p>我已經在Agoda工作了三年，目前在WhiteLabel預訂創建團隊工作。在Agoda的我們的全端工程師每天的任務可以千變萬化。這些任務從後端（BE）導向的職責到純粹的前端（FE）任務，有時還包括兩者的混合。有時，我們甚至深入研究配置CI&#x2F;CD流水線和理解各種服務的內部運作。</p><p>對於一些任務，需要對系統有更深入的了解。在這種情況下，我們通常會從一個“調查”任務開始。這裡的主要目標是進行研究，收集有關數據處理、流程以及數據在數據庫中的表示方式的信息。這是一種情況，其中後端和前端的經驗確實有助於看清為什麼會做出某些決策的全貌。</p><p>最近，我們有一個任務是防止重復預訂，確保相同的房型不會在相同的名字和日期下被預訂兩次。這個任務需要對數據庫進行更新，以存儲用戶信息以供比較。在前端，我們還實現了一個驗證機制，以提醒用戶警告。</p><h1 id="技術技能和工具"><a href="#技術技能和工具" class="headerlink" title="技術技能和工具"></a>技術技能和工具</h1><p>作為一名網頁全端工程師，了解JavaScript是至關重要的。這是使您的Web應用程序動態且現代化的唯一方法。當構建後端應用程序時，JavaScript通常也用作一種常見的編程語言，特別是對那些從前端背景轉向的工程師。在整個技術堆疊上使用相同的語法相當方便。然而，成為一名全端工程師並不一定意味著您需要堅守單一的編程語言。</p><p>為了保持平衡，我在工作中經常在前端和後端的任務之間切換。在我的業餘時間，我喜歡從事個人的側項目，通常探索與我的日常工作任務不同的技術。</p><h1 id="有效的溝通和協作"><a href="#有效的溝通和協作" class="headerlink" title="有效的溝通和協作"></a>有效的溝通和協作</h1><p>確保前端（FE）和後端（BE）團隊之間的無縫溝通和協作至關重要。我們使用協作技巧，如集思廣益、設計審查、調查工作單，以及通過API契約保持清晰度。</p><h1 id="專業成長和學習"><a href="#專業成長和學習" class="headerlink" title="專業成長和學習"></a>專業成長和學習</h1><p>我通過參與技術社區、在Agoda與同事討論、參加課程、閱讀文章，並透過一些實踐或PoC來保持對新技術的更新。</p><h1 id="回顧一個重要的職業時刻"><a href="#回顧一個重要的職業時刻" class="headerlink" title="回顧一個重要的職業時刻"></a>回顧一個重要的職業時刻</h1><p>我職業生涯中的一個重要時刻是我第一份全端角色的工作，那時我使用了MEAN stack。這是一個實踐經驗，讓我能夠看到我的貢獻在整個開發堆棧中變為現實，從前端表單驗證到後端數據處理。</p><h1 id="成為一名全端工程師的職業建議"><a href="#成為一名全端工程師的職業建議" class="headerlink" title="成為一名全端工程師的職業建議"></a>成為一名全端工程師的職業建議</h1><p>如果你希望追求一個全端工程師的職業或者加入Agoda公司，我的建議是在前端（FE）和後端（BE）開發方面建立堅實的基礎。實際經驗至關重要。不要害怕動手去做，通過實踐學習。不要回避挑戰，它們是深化你專業知識的機會。</p><p>作為一名Agoda公司的全端工程師，我的職業生涯一直是一個不斷學習、適應和解決問題的旅程。這是一項需要對技術充滿熱情並致力於終身學習的工作。無論是解決數據庫問題還是創建響應式用戶界面，全端工程師的職業之路充滿了成長和創新的機會。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Agoda/">Agoda</category>
      
      <category domain="https://gahgah147.github.io/tags/Full-Stack/">Full-Stack</category>
      
      
      <comments>https://gahgah147.github.io/2023/11/11/Agoda%E5%85%A8%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pytest-sugar 測試輸出美化與隨機測試</title>
      <link>https://gahgah147.github.io/2023/10/27/pytest-sugar-%E6%B8%AC%E8%A9%A6%E8%BC%B8%E5%87%BA%E7%BE%8E%E5%8C%96%E8%88%87%E9%9A%A8%E6%A9%9F%E6%B8%AC%E8%A9%A6/</link>
      <guid>https://gahgah147.github.io/2023/10/27/pytest-sugar-%E6%B8%AC%E8%A9%A6%E8%BC%B8%E5%87%BA%E7%BE%8E%E5%8C%96%E8%88%87%E9%9A%A8%E6%A9%9F%E6%B8%AC%E8%A9%A6/</guid>
      <pubDate>Fri, 27 Oct 2023 03:36:37 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;今天我們要介紹該如何美化我們在進行測試時終端機的輸出，以及讓我們的測試可以隨機的進行&lt;/p&gt;
&lt;h1 id=&quot;測試輸出美化套件安裝&quot;&gt;&lt;a href=&quot;#測試輸出美化套件安裝&quot; class=&quot;headerlink&quot; title=&quot;測試輸出美化套件安裝&quot;&gt;&lt;/a&gt;測試輸出美化</description>
        
      
      
      
      <content:encoded><![CDATA[<p>今天我們要介紹該如何美化我們在進行測試時終端機的輸出，以及讓我們的測試可以隨機的進行</p><h1 id="測試輸出美化套件安裝"><a href="#測試輸出美化套件安裝" class="headerlink" title="測試輸出美化套件安裝"></a>測試輸出美化套件安裝</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-sugar</span><br></pre></td></tr></table></figure><h1 id="測試案例"><a href="#測試案例" class="headerlink" title="測試案例"></a>測試案例</h1><p>下方為本次會使用到的測試案例，透過參數化的方式建立四次測試</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">argvalues = [[1, 1, 2], [4, 4, 8]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=argvalues)</span><br><span class="line">def test_add(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=argvalues)</span><br><span class="line">def example_add(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br></pre></td></tr></table></figure><h1 id="結果展示"><a href="#結果展示" class="headerlink" title="結果展示"></a>結果展示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s -v ./day_30/test_demo.py</span><br></pre></td></tr></table></figure><p>沒有使用 pytest-sugar 的終端機測試輸出畫面<br><img src="https://hackmd.io/_uploads/r1kG13_GT.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s -v ./day_30/test_demo.py</span><br></pre></td></tr></table></figure><p>有使用 pytest-sugar 的終端機測試輸出畫面<br><img src="https://hackmd.io/_uploads/ryyu13dMT.png"></p><h1 id="隨機測試套件安裝"><a href="#隨機測試套件安裝" class="headerlink" title="隨機測試套件安裝"></a>隨機測試套件安裝</h1><p>在 pytest 當中，測試預設是一個接著一個按順序進行測試的，若想要隨機進行測試，可以透過安裝 pytest-random-order 這個第三方套件來協助我們進行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-random-order</span><br></pre></td></tr></table></figure><h1 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s -v --random-order ./day_30/test_demo.py</span><br></pre></td></tr></table></figure><p>可以看到下圖當中我們成功將測試打散進行測試<br><img src="https://hackmd.io/_uploads/S1Igg2dfT.png"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/">自動化測試</category>
      
      <category domain="https://gahgah147.github.io/tags/pytest/">pytest</category>
      
      <category domain="https://gahgah147.github.io/tags/pytest-sugar/">pytest-sugar</category>
      
      <category domain="https://gahgah147.github.io/tags/pytest-random-order/">pytest-random-order</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/27/pytest-sugar-%E6%B8%AC%E8%A9%A6%E8%BC%B8%E5%87%BA%E7%BE%8E%E5%8C%96%E8%88%87%E9%9A%A8%E6%A9%9F%E6%B8%AC%E8%A9%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pytest-xdist併發測試</title>
      <link>https://gahgah147.github.io/2023/10/27/pytest-xdist%E4%BD%B5%E7%99%BC%E6%B8%AC%E8%A9%A6/</link>
      <guid>https://gahgah147.github.io/2023/10/27/pytest-xdist%E4%BD%B5%E7%99%BC%E6%B8%AC%E8%A9%A6/</guid>
      <pubDate>Fri, 27 Oct 2023 03:14:43 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇是記錄我在看鐵人賽 &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10307902&quot;&gt;Python 與自動化測試的敲門磚 &lt;/a&gt; 的過程&lt;/p&gt;
&lt;p&gt;pytest-xdist，可以協助我們將 pytest 用併發的方式</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇是記錄我在看鐵人賽 <a href="https://ithelp.ithome.com.tw/articles/10307902">Python 與自動化測試的敲門磚 </a> 的過程</p><p>pytest-xdist，可以協助我們將 pytest 用併發的方式進行測試，白話來說就是同時進行很多個測試，而不是一個測完才接著下一個</p><h1 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-xdist</span><br></pre></td></tr></table></figure><h1 id="建立測試程式"><a href="#建立測試程式" class="headerlink" title="建立測試程式"></a>建立測試程式</h1><p>建立三個測試程式，並於每個測試案例內都進行等待五秒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_case_1():</span><br><span class="line">    sleep(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_case_2():</span><br><span class="line">    sleep(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_case_3():</span><br><span class="line">    sleep(5)</span><br></pre></td></tr></table></figure><h1 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h1><p>未使用併發測試時，可以看到測試總共花了 15 秒左右<br><img src="https://hackmd.io/_uploads/H1XbtoOM6.png"></p><p>使用 pytest -n auto 表示要使用併發模式進行測試，可以看到測試時間只花了六秒鐘左右<br><img src="https://hackmd.io/_uploads/B1iHYj_zT.png"></p><div class="note warning simple"><p>併發數量若使用 auto 會自動抓取電腦 CPU 核心數，來建立併發數量，一般建議使用 CPU 核心數 &#x2F; 2 的併發數量來進行測試<br>可以透過 pytest -n <concurrency_amount> 來進行併發數量的設定，<br>例如：pytest -n 3 .&#x2F;day_29&#x2F;test_demo.py</p></div>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/pytest/">pytest</category>
      
      <category domain="https://gahgah147.github.io/tags/pytest-xdist/">pytest-xdist</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/27/pytest-xdist%E4%BD%B5%E7%99%BC%E6%B8%AC%E8%A9%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Pytest 客製化</title>
      <link>https://gahgah147.github.io/2023/10/27/Pytest-%E5%AE%A2%E8%A3%BD%E5%8C%96/</link>
      <guid>https://gahgah147.github.io/2023/10/27/Pytest-%E5%AE%A2%E8%A3%BD%E5%8C%96/</guid>
      <pubDate>Fri, 27 Oct 2023 02:01:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇是記錄我在看鐵人賽 &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10307485&quot;&gt;Python 與自動化測試的敲門磚 &lt;/a&gt; 的過程&lt;/p&gt;
&lt;p&gt;透過設定 pytest.ini 即可讓我們進行一些簡單的客製化，讓 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇是記錄我在看鐵人賽 <a href="https://ithelp.ithome.com.tw/articles/10307485">Python 與自動化測試的敲門磚 </a> 的過程</p><p>透過設定 pytest.ini 即可讓我們進行一些簡單的客製化，讓 pytest 更符合我們的需求</p><h1 id="預設指令"><a href="#預設指令" class="headerlink" title="預設指令"></a>預設指令</h1><p>透過設定 pytest.ini 我們可以達到每次執行 pytest 時，會自動帶入指定的參數，例如：-s、-v …<br>於整個專案最外層建立 pytest.ini 檔案</p><p>編輯 pytest.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line"></span><br><span class="line">addopts = --maxfail=1 -s -v </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>範例當中，我們設定了在使用 pytest 時會自動帶入 -s、-v 參數，並且設定當發生一次錯誤時就會停止測試</p><p>建立測試程式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">argvalues = [[1, 1, 2], [2, 2, 5], [3, 3, 7], [4, 4, 8]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=argvalues)</span><br><span class="line">def test_add(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br></pre></td></tr></table></figure><p>範例當中，我們利用參數化的方式建立了四次測試</p><p>結果展示<br><img src="https://hackmd.io/_uploads/rknCv5uMp.png"></p><p>正常來說應該會有四次的測試結果，下圖為沒有設定 pytest.ini 時的情況，pytest 就成功執行了四次測試並且其中兩次為錯誤<br><img src="https://hackmd.io/_uploads/BJvtPcdf6.png"></p><h1 id="蒐集條件"><a href="#蒐集條件" class="headerlink" title="蒐集條件"></a>蒐集條件</h1><p>pytest 預設會自動蒐集開頭為 test 的 function，當然這個部份我們也可以透過 pytest.ini 來進行設定</p><p>編輯 pytest.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line">python_functions = test_* example_*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建立測試程式<br>下方利用參數化的方式建立兩個測試函式，總共數量會是八個測試，並分別用 test_ 開頭以及 example_ 開頭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">argvalues = [[1, 1, 2], [2, 2, 5], [3, 3, 7], [4, 4, 8]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=argvalues)</span><br><span class="line">def test_add(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=argvalues)</span><br><span class="line">def example_add(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br></pre></td></tr></table></figure><p>利用 pytest –co 觀察蒐集到的測試函式數量，可以看到成功蒐集到八個測試</p><p><img src="https://hackmd.io/_uploads/rJI2ccOG6.png"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Pytest/">Pytest</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/27/Pytest-%E5%AE%A2%E8%A3%BD%E5%8C%96/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Pytest 與 Mock</title>
      <link>https://gahgah147.github.io/2023/10/26/Pytest-%E8%88%87-Mock/</link>
      <guid>https://gahgah147.github.io/2023/10/26/Pytest-%E8%88%87-Mock/</guid>
      <pubDate>Thu, 26 Oct 2023 09:38:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇是記錄我在看鐵人賽 &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10306922&quot;&gt;Python 與自動化測試的敲門磚 &lt;/a&gt; 的過程&lt;/p&gt;
&lt;p&gt;專案練習有同步到 github 上，可以前往 &lt;a href=&quot;ht</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇是記錄我在看鐵人賽 <a href="https://ithelp.ithome.com.tw/articles/10306922">Python 與自動化測試的敲門磚 </a> 的過程</p><p>專案練習有同步到 github 上，可以前往 <a href="https://github.com/gahgah147/PytestMock">這個網址</a></p><h1 id="pytest-mock-使用情境"><a href="#pytest-mock-使用情境" class="headerlink" title="pytest-mock 使用情境"></a>pytest-mock 使用情境</h1><p>今天我們要說明該如何再進行測試時，把不想要執行的方法給替換掉，在測試的過程中，有時候只是要測試函式的可用性，但像是發送 email、撰寫檔案等等的函式，往往是不希望被執行的，總不能每執行一次測試就寄一封 mail 給你，這樣信箱會很快就爆炸的，針對這個情況我們就可以透過 pytest-mock 來替我們進行函式的抽換，並回傳假的資料，只要確認函式運行的流程是正確的即可</p><h1 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-mock</span><br></pre></td></tr></table></figure><h1 id="抽換屬性"><a href="#抽換屬性" class="headerlink" title="抽換屬性"></a>抽換屬性</h1><h2 id="建立函式-demo-py"><a href="#建立函式-demo-py" class="headerlink" title="建立函式 demo.py"></a>建立函式 demo.py</h2><p>建立一個透過 sys 取得 platform 的函式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_sys_platform():</span><br><span class="line">    platform = sys.platform</span><br><span class="line">    return platform</span><br></pre></td></tr></table></figure><h2 id="建立測試函式-test-demo-py"><a href="#建立測試函式-test-demo-py" class="headerlink" title="建立測試函式 test_demo.py"></a>建立測試函式 test_demo.py</h2><p>將會用到的 package 全部 import 近來<br>直接在 test case 當中的參數部分打上 mocker 即可進行使用，後面的 MockFixture 只是用來提式型態用的<br>建立一個變數用來存放假的回傳資料，此樹使用 new (對齊 mock.path 函式的參數)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import demo</span><br><span class="line">from pytest_mock import MockFixture</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_mock_object(mocker: MockFixture):</span><br><span class="line">    new = &quot;test_mock&quot;</span><br></pre></td></tr></table></figure><p>使用 mocker.patch.object 進行變數的替換</p><table><thead><tr><th>target</th><th>指定要替換的物件</th></tr></thead><tbody><tr><td>attribute</td><td>指定要替換的物件的屬性</td></tr><tr><td>new</td><td>要回傳的假資料</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import demo</span><br><span class="line">from pytest_mock import MockFixture</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_mock_object(mocker: MockFixture):</span><br><span class="line">    new = &quot;test_mock&quot;</span><br><span class="line"></span><br><span class="line">    mocker.patch.object(target=sys,</span><br><span class="line">                        attribute=&quot;platform&quot;,</span><br><span class="line">                        new=new)</span><br></pre></td></tr></table></figure><p>實際呼叫想要測試的函式並進行驗證</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import demo</span><br><span class="line">from pytest_mock import MockFixture</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_mock_object(mocker: MockFixture):</span><br><span class="line">    new = &quot;test_mock&quot;</span><br><span class="line">    mocker.patch.object(target=sys,</span><br><span class="line">                        attribute=&quot;platform&quot;,</span><br><span class="line">                        new=new)</span><br><span class="line"></span><br><span class="line">    result = demo.get_sys_platform()</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    assert result == new</span><br></pre></td></tr></table></figure><p>下圖中我們實際執行此測試函式，可以看到終端機上印出 test_mock 字串且測試結果為 passed<br><img src="https://hackmd.io/_uploads/HytEAsvfa.png"></p><h1 id="抽換函式"><a href="#抽換函式" class="headerlink" title="抽換函式"></a>抽換函式</h1><h2 id="建立函式"><a href="#建立函式" class="headerlink" title="建立函式"></a>建立函式</h2><p>demo.py 新增以下程式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def add(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calculate(num1, num2):</span><br><span class="line">    add_result = add(num1=num1, num2=num2)</span><br><span class="line"></span><br><span class="line">    return add_result</span><br></pre></td></tr></table></figure><h2 id="建立測試函式"><a href="#建立測試函式" class="headerlink" title="建立測試函式"></a>建立測試函式</h2><p>透過 mocker.patch 直接進行抽換</p><table><thead><tr><th>target</th><th>使用 “字串” 指定要抽換的函式路徑，當成式執行到此函式時，會直接回傳一個假資料並不會實際執行該函式</th></tr></thead><tbody><tr><td>return_value</td><td>指定要回傳的假資料</td></tr></tbody></table><p>test_demo.py 新增以下程式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import demo</span><br><span class="line">from pytest_mock import MockFixture</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_mock_function(mocker: MockFixture):</span><br><span class="line">    return_value = 100</span><br><span class="line"></span><br><span class="line">    mocker.patch(target=&quot;demo.add&quot;,</span><br><span class="line">                 return_value=return_value)</span><br><span class="line"></span><br><span class="line">    result = demo.calculate(num1=10, num2=10)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    assert result == return_value</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/pytest/">pytest</category>
      
      <category domain="https://gahgah147.github.io/tags/Mock/">Mock</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/26/Pytest-%E8%88%87-Mock/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>自動化測試 CI/CD</title>
      <link>https://gahgah147.github.io/2023/10/25/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6-CI-CD/</link>
      <guid>https://gahgah147.github.io/2023/10/25/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6-CI-CD/</guid>
      <pubDate>Wed, 25 Oct 2023 05:57:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇是記錄我在看鐵人賽 &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10290529&quot;&gt;Python 與自動化測試的敲門磚 &lt;/a&gt; 的過程&lt;/p&gt;
&lt;h1 id=&quot;CI-CD-簡介&quot;&gt;&lt;a href=&quot;#CI-CD-簡介&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇是記錄我在看鐵人賽 <a href="https://ithelp.ithome.com.tw/articles/10290529">Python 與自動化測試的敲門磚 </a> 的過程</p><h1 id="CI-CD-簡介"><a href="#CI-CD-簡介" class="headerlink" title="CI&#x2F;CD 簡介"></a>CI&#x2F;CD 簡介</h1><p>CI&#x2F;CD 其實是指兩個部分，分別是 Continuous Integration (持續整合) 以及 Continuous Deployment (持續部屬)</p><h2 id="CI-持續整合"><a href="#CI-持續整合" class="headerlink" title="CI 持續整合"></a>CI 持續整合</h2><p>在軟體開發的過程中，通常會由無數個開發人員一起工作，然而隨著程式碼以及人數的增加，專案會越來越難進行整合，這個時候我們就可以透過 CI 來進行。與其說 CI 是個工具，不如說 CI 是一種合作模式，藉由簡單的設定來讓 CI 工具替我們進行測試，就可以降低我們的專案在進行更新、整合時碰到問題的機率。</p><p>在 CI 執行的過程中，會建議每個開發人員每天上班前先做一次 pull 的動作，於每天下班前至少執行一次 push 的動作，以此確保 CI 的運行效率。</p><h2 id="CD-持續部屬"><a href="#CD-持續部屬" class="headerlink" title="CD 持續部屬"></a>CD 持續部屬</h2><p>每當我們透過 CI 將專案整合完成後，便可以透過 CD 來進行自動化的部屬，減少我們在測試與部屬之間所耗費的時間</p><h1 id="CI-CD-常用工具"><a href="#CI-CD-常用工具" class="headerlink" title="CI&#x2F;CD 常用工具"></a>CI&#x2F;CD 常用工具</h1><h2 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h2><p>於 GitLab 上提供了 CI&#x2F;CD 的介面，藉由在某處部屬好的 docker image，即可進行 CI&#x2F;CD，為目前主流的 CI&#x2F;CD 工具</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>GitHub 於 2019 年推出了 GitHub Actions，此工具可以協助我們進行 CI，不過由於此功能還算新，尚有許多功能不成熟，因此比較建議使用在小型專案的 CI 當中</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>為目前主流的 CD 工具，藉由 GitLab 進行 CI 後，會將程式碼打包到 Jenkins 進行自動化部屬</p><h1 id="GitHub-設定"><a href="#GitHub-設定" class="headerlink" title="GitHub 設定"></a>GitHub 設定</h1><h2 id="建立-yml-file"><a href="#建立-yml-file" class="headerlink" title="建立 yml file"></a>建立 yml file</h2><p>進入 github 專案並點選 Actions 選項<br><img src="https://hackmd.io/_uploads/B1bGcmKlT.png"></p><p><img src="https://hackmd.io/_uploads/SynUsXKx6.png"></p><blockquote><p>需要點擊啟用 Actions 設定</p></blockquote><p><img src="https://hackmd.io/_uploads/B1Rqj7Fxp.png"><br>點擊 New Workflow</p><p>在 Workflows 欄位底下輸入 “python” 進行搜尋<br><img src="https://hackmd.io/_uploads/SJpG5Xte6.png"></p><p>選擇 Python Application，並點選 Configure 選項<br><img src="https://hackmd.io/_uploads/Bkum5mYxp.png"></p><p>將跳轉後出現的頁面的程式碼滑到最底下，並將 pytest 更改為 echo “hello”</p><p>點選右上方 “Start Commit” 選項<br><img src="https://hackmd.io/_uploads/BkD4qQtla.png"></p><p>點選 “Commit new file” 選項<br><img src="https://hackmd.io/_uploads/HycBcXYep.png"></p><div class="note info simple"><p>測試若有設定過會出錯，需要新建立一個repository才會成功</p></div><p>頁面會自動跳轉回專案首頁，請點選回 “Actions”，就可以看到 github 按照剛剛建立的檔案建立了一個 CI 任務</p><p><img src="https://hackmd.io/_uploads/HyOv9QKlT.png"></p><p>點進此任務，並選擇 build 選項<br><img src="https://hackmd.io/_uploads/Bk-uqQFla.png"></p><p>點選 “Test with pytest” 部分即可看到剛剛修改的 echo “hello”<br><img src="https://hackmd.io/_uploads/S10t27tgp.png"></p><p><img src="https://hackmd.io/_uploads/HJ2O9XYlp.png"></p><h2 id="修改-yml"><a href="#修改-yml" class="headerlink" title="修改 yml"></a>修改 yml</h2><p>由於我們剛剛是直接在 github 上進行 commit 來新增 workflows，因此我們要先回到專案上執行 git pull 確保專案同步</p><p>執行完 git pull 後即可在專案上看到 “.github” 這個目錄，並且有 “workflows” 這個子目錄</p><p>“workflows” 目錄下會有一個 python-app.yml 檔案，這個就是我們等一下要修改的檔案</p><p><img src="https://hackmd.io/_uploads/rJ-s9mYxp.png"></p><p>在修改 yml 前我們先建立幾個簡單的 test case 並存放到 day_22&#x2F;test_demo.py 目錄下<br><img src="https://hackmd.io/_uploads/Byso9XKx6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def test_export_report_1():</span><br><span class="line">    a = 1 + 1</span><br><span class="line">    b = 2 + 2</span><br><span class="line"></span><br><span class="line">    assert b &gt; a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_export_report_2():</span><br><span class="line">  a = 2 + 2</span><br><span class="line">  b = 4 + 4</span><br><span class="line"></span><br><span class="line">  assert a &lt; b</span><br></pre></td></tr></table></figure><p>打開 python-app.yml</p><p>將剛剛的 echo “hello” 修改為 pytest -s -v .&#x2F;day_22&#x2F;test_demo.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># This workflow will install Python dependencies, run tests and lint with a single version of Python</span><br><span class="line"># For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions</span><br><span class="line"></span><br><span class="line">name: Python application</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ &quot;master&quot; ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ &quot;master&quot; ]</span><br><span class="line"></span><br><span class="line">permissions:</span><br><span class="line">  contents: read</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - uses: actions/checkout@v3</span><br><span class="line">    - name: Set up Python 3.10</span><br><span class="line">      uses: actions/setup-python@v3</span><br><span class="line">      with:</span><br><span class="line">        python-version: &quot;3.10&quot;</span><br><span class="line">    - name: Install dependencies</span><br><span class="line">      run: |</span><br><span class="line">        python -m pip install --upgrade pip</span><br><span class="line">        pip install flake8 pytest</span><br><span class="line">        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi</span><br><span class="line">    - name: Lint with flake8</span><br><span class="line">      run: |</span><br><span class="line">        # stop the build if there are Python syntax errors or undefined names</span><br><span class="line">        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics</span><br><span class="line">        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide</span><br><span class="line">        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics</span><br><span class="line">    - name: Test with pytest</span><br><span class="line">      run: |</span><br><span class="line">        pytest -s -v ./day_22/test_demo.py</span><br></pre></td></tr></table></figure><h2 id="察看結果"><a href="#察看結果" class="headerlink" title="察看結果"></a>察看結果</h2><p>修改完成後，我們就可以將整個專案 push 到 Github 上，這個時候我們就可以回到剛剛的 “Actions” 頁面察看結果了</p><p>下圖中我們可以看到 Acitons 這邊多了一個任務，任務名稱會使用剛剛的 commit message 命名<br><img src="https://hackmd.io/_uploads/HkdxiQKxT.png"></p><p>點進去該任務後就可以查看 pytest 的執行結果了<br><img src="https://hackmd.io/_uploads/ryZWjQtgT.png"></p><h2 id="python-app-yml"><a href="#python-app-yml" class="headerlink" title="python-app.yml"></a>python-app.yml</h2><h3 id="運行於指定的-branch-上"><a href="#運行於指定的-branch-上" class="headerlink" title="運行於指定的 branch 上"></a>運行於指定的 branch 上</h3><p>我們可以透過 on 參數來設定當哪個 branch 被推上 Github 上時要進行 CI 的動作，由於 CI 的進行也是需要耗費一定的資源，因此不太可能讓所有瑣碎的 branch 被推上去時都自動進行一次，透過設定 branches 可以指定那些 branch 被推上來時要執行 CI</p><p>補充：可以看到 on 底下有分為 push 以及 pull_request 兩個層級，分別代表著 Github 上的兩種協作方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ &quot;master&quot; ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ &quot;master&quot; ]</span><br></pre></td></tr></table></figure><h3 id="建立-CI-任務"><a href="#建立-CI-任務" class="headerlink" title="建立 CI 任務"></a>建立 CI 任務</h3><table><thead><tr><th>變數</th><th>功能</th></tr></thead><tbody><tr><td>runs-on</td><td>為 CI 執行時最底下的一個 docker image 名稱，設定完成後 CI 會於執行時使用該 image 建立環境</td></tr><tr><td>steps</td><td>為實際 CI 執行的細項，每一個細項開頭都會使用 “-“ 來表示</td></tr><tr><td>uses</td><td>為為運行此 steps 時啟動的服務，為 docker image 名稱</td></tr><tr><td>name</td><td>為此 step 的名稱</td></tr><tr><td>run</td><td>為此 step 要執行的命令</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - uses: actions/checkout@v3</span><br><span class="line">      </span><br><span class="line">    - name: Set up Python 3.10</span><br><span class="line">      uses: actions/setup-python@v3</span><br><span class="line">      with:</span><br><span class="line">        python-version: &quot;3.10&quot;</span><br><span class="line">    </span><br><span class="line">    - name: Test with pytest</span><br><span class="line">      run: |</span><br><span class="line">        pytest -s -v ./day_22/test_demo.py</span><br></pre></td></tr></table></figure><h1 id="GitLab-設定"><a href="#GitLab-設定" class="headerlink" title="GitLab 設定"></a>GitLab 設定</h1><h2 id="建立-CI-CD-runner"><a href="#建立-CI-CD-runner" class="headerlink" title="建立 CI&#x2F;CD runner"></a>建立 CI&#x2F;CD runner</h2><p>在 GitLab 運行 CI&#x2F;CD 時，同樣需要一個 runner 在背後執行，只是在 GitHub 的時候，他們幫我們做好了，因此我們不需要去碰到這塊，下面的方法為建立 runner 並和 GitLab 上的專案綁定的方法</p><div class="note info simple"><p>接下來的步驟請先在要建立 runner 的電腦上安裝 docker</p></div><p>前往 GitLab 專案的 Setting 裡面的 CI&#x2F;CD 頁面</p><p><img src="https://hackmd.io/_uploads/HJPEL21Ma.png"></p><blockquote><p>Setting &gt; CI&#x2F;CD</p></blockquote><p><img src="https://hackmd.io/_uploads/SJwSU2yfT.png"></p><blockquote><p>找到 Runner 部分並打開，可以看到要和 runner 做連線的網址以及 token</p></blockquote><p>打開 terminal</p><p>建立 docker volume</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create gitlab-runner</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJ1MO21fp.png"></p><p>啟動 docker 並將他連上剛剛建立的 volume</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always -v /var/run/docker.sock:/var/run/docker.sock -v gitlab-runner:/etc/gitlab-runner gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure><p>使用下方指令進行 runner 與 GitLab 的連線</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v gitlab-runner:/etc/gitlab-runner gitlab/gitlab-runner:latest register</span><br></pre></td></tr></table></figure><p>接下來會開始進行註冊程序，我們會以一個問題搭配一個回答的方式撰寫</p><table><thead><tr><th>註冊程序</th><th>回答</th></tr></thead><tbody><tr><td>Enter the GitLab instance URL</td><td>寫上剛剛在 GitLab 上看到的 url</td></tr><tr><td>Enter the registration token</td><td>寫上剛剛在 GitLab 上看到的 token</td></tr><tr><td>Enter a description for the runner</td><td>寫上你想要為這個 runner 的描述，這邊使用 “nickchen1998_ithelp_2022_marathon”</td></tr><tr><td>Enter tags for the runner</td><td>為這個 runner 增加 tag，用來指派 CI&#x2F;CD 任務用，這邊先寫上 “nickchen1998_ithelp_2022_marathon”</td></tr><tr><td>Enter optional maintenance note for the runner</td><td>這部份我們不需要，直接按 Enter</td></tr><tr><td>Enter an executor</td><td>這邊我們輸入 “docker”，用來作為 runner 運行的環境</td></tr><tr><td>Enter the default Docker image</td><td>當 yaml 檔沒有指定要使用的 image 時，預設會使用的 image，這邊我們輸入 “python:latest”</td></tr></tbody></table><p>註冊完成</p><p><img src="https://hackmd.io/_uploads/By4VF3Jz6.png"></p><p><img src="https://hackmd.io/_uploads/rk4D5nkzT.png"></p><blockquote><p>回到剛剛的 runner 頁面，我們就可以看到一個新的 runner 被建立給這個專案</p></blockquote><h2 id="設定環境變數"><a href="#設定環境變數" class="headerlink" title="設定環境變數"></a>設定環境變數</h2><p>我們可以透過 Settings 內的 CI&#x2F;CD 頁面裡面的 Variables 欄位進行環境變數的設定</p><p><img src="https://hackmd.io/_uploads/HJsfs2yGp.png"></p><blockquote><p>Settings &gt; CI&#x2F;CD &gt; Variables</p></blockquote><p><img src="https://hackmd.io/_uploads/ryORi3yz6.png"></p><blockquote><p>點選 Add Variable 開始設定環境變數</p></blockquote><p><img src="https://hackmd.io/_uploads/r13x221zp.png"></p><blockquote><p>依序輸入 key、value 並點選 Add Variable</p></blockquote><p><img src="https://hackmd.io/_uploads/rJk7hnJza.png"></p><blockquote><p>可以看到成功新增的變數</p></blockquote><h2 id="設定-yaml-檔案"><a href="#設定-yaml-檔案" class="headerlink" title="設定 yaml 檔案"></a>設定 yaml 檔案</h2><h3 id="建立-gitlab-ci-yml"><a href="#建立-gitlab-ci-yml" class="headerlink" title="建立 .gitlab-ci.yml"></a>建立 .gitlab-ci.yml</h3><p>在整個專案的 “最外層” 建立 gitlab-ci.yml 檔案</p><h3 id="建立流程"><a href="#建立流程" class="headerlink" title="建立流程"></a>建立流程</h3><p>直接將工作名稱寫在最外層，並於其下一層利用 stage 表示此工作階段的名稱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute-test:</span><br><span class="line">  stage: test</span><br></pre></td></tr></table></figure><p>將要執行的指令依序寫在 scripts 後方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute-test:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - pip3 install pytest</span><br><span class="line">    - pytest -s -v ./day_25/test_demo.py</span><br></pre></td></tr></table></figure><p>最後利用 tag 指定我們要執行這個任務的 runner (昨天文章有提到該如何建立 runner)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execute-test:</span><br><span class="line">stage: test</span><br><span class="line">script:</span><br><span class="line">  - pip3 install pytest</span><br><span class="line">  - pytest -s -v ./day_25/test_demo.py</span><br><span class="line">tags:</span><br><span class="line">  - nickchen1998_ithelp_2022_marathon</span><br></pre></td></tr></table></figure><h3 id="管理-stage"><a href="#管理-stage" class="headerlink" title="管理 stage"></a>管理 stage</h3><p>透過設定 stage 可以來管理我們要執行哪個部份的腳本</p><p>透過下面這段程式碼，我們就成功設定執行所有 stage 為 test 的任務了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">execute-test:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - pip3 install pytest</span><br><span class="line">    - pytest -s -v ./day_25/test_demo.py</span><br><span class="line">  tags:</span><br><span class="line">    - nickchen1998_ithelp_2022_marathon</span><br></pre></td></tr></table></figure><h3 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h3><p>可以看到下圖中 GitLab 順利為我們生成一條 CI pipline<br><img src="https://hackmd.io/_uploads/ryHR33Vfa.png"></p><div class="note warning simple"><p>這邊要注意 runner 要指定對並且是執行中才會成功，不然會 Pending</p></div><p><img src="https://hackmd.io/_uploads/B1IbpnEMT.png"></p><h2 id="Selenium-設定"><a href="#Selenium-設定" class="headerlink" title="Selenium 設定"></a>Selenium 設定</h2><h3 id="修改-gitlab-ci-yml-設定檔案"><a href="#修改-gitlab-ci-yml-設定檔案" class="headerlink" title="修改 .gitlab-ci.yml 設定檔案"></a>修改 .gitlab-ci.yml 設定檔案</h3><p>首先我們要替我們的 .gitlab-ci.yml 加上 service 表示我們要在指定的任務中運行其他服務</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">execute-test:</span><br><span class="line">  stage: test</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line"></span><br><span class="line">  script:</span><br><span class="line">    - pip3 install -r ./requirements.txt</span><br><span class="line">    - pytest -s -v ./day_26/test_demo.py</span><br><span class="line">  tags:</span><br><span class="line">    - nickchen1998_ithelp_2022_marathon</span><br></pre></td></tr></table></figure><p>接著透過設定 services 底下的 name 參數來指定我們要使用哪個 docker image，我們會需要使用到 selenium&#x2F;standalone-chrome 這個 image 來替我們建立一個可以遠端執行 Chrome 的環境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">execute-test:</span><br><span class="line">  stage: test</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    - name: selenium/standalone-chrome</span><br><span class="line"></span><br><span class="line">  script:</span><br><span class="line">    - pip3 install -r ./requirements.txt</span><br><span class="line">    - pytest -s -v ./day_26/test_demo.py</span><br><span class="line">  tags:</span><br><span class="line">    - nickchen1998_ithelp_2022_marathon</span><br></pre></td></tr></table></figure><p>最後透過設定 alias 參數來為這個 services 進行命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">execute-test:</span><br><span class="line">  stage: test</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    - name: selenium/standalone-chrome</span><br><span class="line">      alias: CICD_Selenium</span><br><span class="line"></span><br><span class="line">  script:</span><br><span class="line">    - pip3 install -r ./requirements.txt</span><br><span class="line">    - pytest -s -v ./day_26/test_demo.py</span><br><span class="line">  tags:</span><br><span class="line">    - nickchen1998_ithelp_2022_marathon</span><br></pre></td></tr></table></figure><div class="note info simple"><p>script 方面我有實際測試，<br>pip3 install -r .&#x2F;requirements.txt<br>這行實際運行會出錯，我後來調整成這樣可以運行成功</p><p>script:<br>    - pip3 install pytest<br>    - pip3 install selenium<br>    - pip3 install webdriver_manager<br>    - pytest -s -v .&#x2F;day_26&#x2F;test_demo.py</p></div><h3 id="建立-fixture"><a href="#建立-fixture" class="headerlink" title="建立 fixture"></a>建立 fixture</h3><p>建立一個 conftest.py 並將 driver 的 fixture 寫在裡面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import pytest</span><br><span class="line">from typing import Union</span><br><span class="line">from selenium.webdriver import Remote, Chrome</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;driver&quot;)</span><br><span class="line">def driver_fixture() -&gt; Union[Remote, Chrome]:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(f&quot;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span><br><span class="line">                         f&quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;)</span><br><span class="line"></span><br><span class="line">    if sys.platform == &quot;win32&quot;:</span><br><span class="line">        driver = Chrome(ChromeDriverManager().install(),</span><br><span class="line">                        options=options)</span><br><span class="line">    else:</span><br><span class="line">        driver = Remote(command_executor=&quot;http://CICD_Selenium:4444/wd/hub&quot;,</span><br><span class="line">                        options=options)</span><br><span class="line"></span><br><span class="line">    yield driver</span><br><span class="line"></span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h3 id="撰寫測試程式"><a href="#撰寫測試程式" class="headerlink" title="撰寫測試程式"></a>撰寫測試程式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver import Remote, Chrome</span><br><span class="line">from typing import Union</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_current_url(driver: Union[Remote, Chrome]):</span><br><span class="line">    driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line"></span><br><span class="line">    correct_url = &quot;https://ithelp.ithome.com.tw/&quot;</span><br><span class="line">    assert driver.current_url == correct_url</span><br><span class="line"></span><br><span class="line">    correct_title_start = &quot;iT 邦幫忙&quot;</span><br><span class="line">    assert driver.title.startswith(correct_title_start)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Pytest/">Pytest</category>
      
      <category domain="https://gahgah147.github.io/tags/Selenium/">Selenium</category>
      
      <category domain="https://gahgah147.github.io/tags/CI-CD/">CI/CD</category>
      
      <category domain="https://gahgah147.github.io/tags/GitHub/">GitHub</category>
      
      <category domain="https://gahgah147.github.io/tags/GitLab/">GitLab</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/25/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6-CI-CD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux 複製檔案 cp 指令</title>
      <link>https://gahgah147.github.io/2023/10/18/Linux-%E8%A4%87%E8%A3%BD%E6%AA%94%E6%A1%88-cp-%E6%8C%87%E4%BB%A4/</link>
      <guid>https://gahgah147.github.io/2023/10/18/Linux-%E8%A4%87%E8%A3%BD%E6%AA%94%E6%A1%88-cp-%E6%8C%87%E4%BB%A4/</guid>
      <pubDate>Wed, 18 Oct 2023 10:45:16 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;複製檔案&quot;&gt;&lt;a href=&quot;#複製檔案&quot; class=&quot;headerlink&quot; title=&quot;複製檔案&quot;&gt;&lt;/a&gt;複製檔案&lt;/h1&gt;&lt;p&gt;若要將 source.txt 檔案複製一份到 dest.txt，可以執行：&lt;/p&gt;
&lt;figure class=&quot;highl</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="複製檔案"><a href="#複製檔案" class="headerlink" title="複製檔案"></a>複製檔案</h1><p>若要將 source.txt 檔案複製一份到 dest.txt，可以執行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 將 source.txt 複製到 dest.txt</span><br><span class="line">cp source.txt dest.txt</span><br></pre></td></tr></table></figure><h1 id="複製目錄"><a href="#複製目錄" class="headerlink" title="複製目錄"></a>複製目錄</h1><p>如果要複製整個目錄以及該目錄下的所有子目錄與檔案，可以加上 -r 參數（或是 -R、–recursive 參數亦可），以遞迴的方式進行複製：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 將 myfolder 目錄複製到 /path/to/ 路徑下</span><br><span class="line">cp -r myfolder /path/to/</span><br></pre></td></tr></table></figure><h1 id="強制覆蓋檔案"><a href="#強制覆蓋檔案" class="headerlink" title="強制覆蓋檔案"></a>強制覆蓋檔案</h1><p>如果希望 cp 指令在無法寫入目的檔案時，嘗試刪除目的檔案，再重新複製一份新的檔案，可以加上 -f 或 –force 參數：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -f source.txt dest.txt</span><br></pre></td></tr></table></figure><h1 id="不要覆蓋既有檔案"><a href="#不要覆蓋既有檔案" class="headerlink" title="不要覆蓋既有檔案"></a>不要覆蓋既有檔案</h1><p>如果希望 cp 指令遇到目的檔案已經存在的狀況，不要覆蓋既有的檔案，可以加上 -n 或 –no-clobber 參數：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -n source.txt dest.txt</span><br></pre></td></tr></table></figure><h1 id="自動備份檔案"><a href="#自動備份檔案" class="headerlink" title="自動備份檔案"></a>自動備份檔案</h1><p>若希望 cp 指令在覆蓋檔案時，可以將舊檔案自動備份起來，可以加上 -b 或 –backup 參數：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -b source.txt dest.txt</span><br></pre></td></tr></table></figure><h1 id="保留檔案屬性"><a href="#保留檔案屬性" class="headerlink" title="保留檔案屬性"></a>保留檔案屬性</h1><p>若希望 cp 在複製檔案時，可以連同檔案屬性一起複製，可以加上 -p 或 –preserve 參數：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -p source.txt dest.txt</span><br></pre></td></tr></table></figure><h1 id="連結檔解析"><a href="#連結檔解析" class="headerlink" title="連結檔解析"></a>連結檔解析</h1><p>假設我們建立一個連結檔 link.txt 指向 source.txt：</p><p>建立連結檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s source.txt link.txt</span><br></pre></td></tr></table></figure><p>如果希望 cp 指令在複製連結檔案時，能夠解析連結檔所指向的實際檔案，複製那一個實際的目標檔案，可以加上 -L 或 –dereference 參數：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -L link.txt dest.txt</span><br></pre></td></tr></table></figure><p>由於 link.txt 是指向 source.txt 的連結檔，所以這裡的 dest.txt 實際上就是從 source.txt 所複製出來了。</p><p>若希望 cp 指令在複製連結檔案時，不要進行連結的解析，僅將連結檔直接複製，則可改用 -P 或 –no-dereference 參數：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -P link.txt link2.txt</span><br></pre></td></tr></table></figure><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://blog.gtwang.org/linux/linux-cp-command-copy-files-and-directories-tutorial/">Linux 複製檔案 cp 指令用法教學與範例</a></p><p><a href="https://www.howtoforge.com/linux-cp-command/">HowtoForge：Linux cp command tutorial for beginners (8 examples)</a><br><a href="https://www.geeksforgeeks.org/cp-command-linux-examples/">GeeksforGeeks：cp command in Linux with examples</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Linux/">Linux</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/18/Linux-%E8%A4%87%E8%A3%BD%E6%AA%94%E6%A1%88-cp-%E6%8C%87%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 基本操作 - 進入容器</title>
      <link>https://gahgah147.github.io/2023/10/16/Docker-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</link>
      <guid>https://gahgah147.github.io/2023/10/16/Docker-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Mon, 16 Oct 2023 06:23:09 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Docker 進入容器 &lt;/p&gt;
&lt;p&gt;以下文章是在使用 Docker 時查詢到的好文章 我覺得&lt;a href=&quot;https://philipzheng.gitbook.io/docker_practice/&quot;&gt;這篇&lt;/a&gt;記錄的很詳細，所以記錄一下&lt;/p&gt;
&lt;h1 id=</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Docker 進入容器 </p><p>以下文章是在使用 Docker 時查詢到的好文章 我覺得<a href="https://philipzheng.gitbook.io/docker_practice/">這篇</a>記錄的很詳細，所以記錄一下</p><h1 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h1><p>docker exec 是Docker內建的命令。下面示範如何使用該命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line">$sudo docker exec -ti nostalgic_hypatia bash</span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure><h1 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h1><p>docker attach 亦是Docker內建的命令。下面示例如何使用該命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line">$sudo docker attach nostalgic_hypatia</span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure><p>按下 ctrl + P 然後 ctrl + Q 跳離容器，讓它繼續在背景執行。<br>但是使用 attach 命令有時候並不方便。當多個視窗同時 attach 到同一個容器的時候，所有視窗都會同步顯示。當某個視窗因命令阻塞時,其他視窗也無法執行操作了。</p><h1 id="nsenter-命令"><a href="#nsenter-命令" class="headerlink" title="nsenter 命令"></a>nsenter 命令</h1><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>nsenter 工具已含括在 util-linux 2.23 後的版本內。 如果系統中 util-linux 包沒有該命令，可以按照下面的方法從原始碼安裝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /tmp; curl https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz | tar -zxf-; cd util-linux-2.24;</span><br><span class="line">$ ./configure --without-ncurses</span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter /usr/local/bin</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>nsenter 可以存取另一個程式的命名空間。nsenter 要正常工作需要有 root 權限。 很不幸，Ubuntu 14.4 仍然使用的是 util-linux 2.20。安裝最新版本的 util-linux（2.24）版，請按照以下步驟：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz; tar xzvf util-linux-2.24.tar.gz</span><br><span class="line">$ cd util-linux-2.24</span><br><span class="line">$ ./configure --without-ncurses &amp;&amp; make nsenter</span><br><span class="line">$ sudo cp nsenter /usr/local/bin</span><br></pre></td></tr></table></figure><p>為了連線到容器，你還需要找到容器的第一個程式的 PID，可以透過下面的命令取得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID=$(docker inspect --format &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</span><br></pre></td></tr></table></figure><p>透過這個 PID，就可以連線到這個容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nsenter --target $PID --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure><p>下面給出一個完整的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line">$ PID=$(docker-pid 243c32535da7)</span><br><span class="line">10981</span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid</span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure><p>更簡單的，建議大家下載 .bashrc_docker，並將內容放到 .bashrc 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker;</span><br><span class="line">$ echo &quot;[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker&quot; &gt;&gt; ~/.bashrc; source ~/.bashrc</span><br></pre></td></tr></table></figure><p>這個檔案中定義了很多方便使用 Docker 的命令，例如 docker-pid 可以取得某個容器的 PID；而 docker-enter 可以進入容器或直接在容器內執行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $(docker-pid &lt;container&gt;)</span><br><span class="line">$ docker-enter &lt;container&gt; ls</span><br></pre></td></tr></table></figure><p>參考文章: <a href="https://philipzheng.gitbook.io/docker_practice/container/enter">https://philipzheng.gitbook.io/docker_practice/container/enter</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/16/Docker-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Selenium 自動化測試</title>
      <link>https://gahgah147.github.io/2023/10/03/Selenium-%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/</link>
      <guid>https://gahgah147.github.io/2023/10/03/Selenium-%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/</guid>
      <pubDate>Tue, 03 Oct 2023 03:49:28 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇是記錄我在看鐵人賽 &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10290529&quot;&gt;Python 與自動化測試的敲門磚 &lt;/a&gt; 的過程&lt;/p&gt;
&lt;h1 id=&quot;套件安裝&quot;&gt;&lt;a href=&quot;#套件安裝&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇是記錄我在看鐵人賽 <a href="https://ithelp.ithome.com.tw/articles/10290529">Python 與自動化測試的敲門磚 </a> 的過程</p><h1 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h1><p>selenium：用來建立模擬器<br>webdriver_manager：用來協助我們做驅動程式的安裝，可以無需實際下載瀏覽器的驅動程式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br><span class="line">pip install webdriver_manager</span><br></pre></td></tr></table></figure><h1 id="快速入門"><a href="#快速入門" class="headerlink" title="快速入門"></a>快速入門</h1><p>程式解析：</p><p>透過 make_webdriver 內的程式碼，可以建立一個 Chrome 物件，習慣上我們會將此物件命名為 driver<br>透過實作該方法得到 driver<br>透過 driver.get() 對網址進行請求，這個時候 driver 就會實際替我們開啟一個瀏覽器<br>為了展示開啟成功，使用 time.sleep() 讓瀏覽器畫面停止一下<br>使用 driver.quit() 來確保瀏覽器完全關閉，不會殘留在記憶體當中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_webdriver() -&gt; Chrome:</span><br><span class="line">    driver = Chrome(ChromeDriverManager().install())</span><br><span class="line"></span><br><span class="line">    return driver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &quot;https://ithelp.ithome.com.tw/questions&quot;</span><br><span class="line">    _driver = make_webdriver()</span><br><span class="line">    </span><br><span class="line">    _driver.get(url=url)</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    </span><br><span class="line">    _driver.quit()</span><br></pre></td></tr></table></figure><p>成果展示：</p><p>可以看到下圖當中，透過 selenium 開啟的瀏覽器上方會有註明受到測試軟體控制</p><h1 id="加上參數"><a href="#加上參數" class="headerlink" title="加上參數"></a>加上參數</h1><p>我們可以透過加上一些參數，來設定瀏覽器開啟時的相關設定，下方直接透過程式講解<br>程式解析：</p><p>import Options 這個 class<br>於 function 內實作此 class<br>透過 add_argument 加入參數<br>–headless：讓瀏覽器進入無頭模式，簡單來說就是放在背景運行，不會實際開一個視窗出來<br>–start-maximized：確保瀏覽器每次執行時都可以開到最大的視窗，避免 RWD 造成一些元素讀不到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line"></span><br><span class="line">def create_options() -&gt; Options:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line"></span><br><span class="line">    return options</span><br></pre></td></tr></table></figure><p>完整程式碼：<br>透過在 driver 中添加 options 參數，我們即可為 driver 做一些瀏覽器的設定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_webdriver() -&gt; Chrome:</span><br><span class="line">    options = create_options()</span><br><span class="line">    driver = Chrome(ChromeDriverManager().install(),</span><br><span class="line">                    options=options)</span><br><span class="line"></span><br><span class="line">    return driver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_options() -&gt; Options:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line"></span><br><span class="line">    return options</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &quot;https://ithelp.ithome.com.tw/questions&quot;</span><br><span class="line">    _driver = make_webdriver()</span><br><span class="line"></span><br><span class="line">    _driver.get(url=url)</span><br><span class="line"></span><br><span class="line">    _driver.quit()</span><br></pre></td></tr></table></figure><h1 id="搭配-fixture"><a href="#搭配-fixture" class="headerlink" title="搭配 fixture"></a>搭配 fixture</h1><p>在撰寫測試程式的時候，driver 就特別適合撰寫成 fixture 來進行使用，下面也是直接附上範例</p><p>程式解析：</p><p>建立一個 fixture 並命名為 driver<br>建立 options<br>建立 driver 並指派 options 參數<br>透過 yield 將 driver 回傳出去<br>測試程式結束後回到 fixture 內執行 driver.quit() 退出 driver</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;driver&quot;)</span><br><span class="line">def driver_fixture() -&gt; Chrome:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line"></span><br><span class="line">    driver = Chrome(ChromeDriverManager().install(),</span><br><span class="line">                    options=options)</span><br><span class="line"></span><br><span class="line">    yield driver</span><br><span class="line"></span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h1 id="建立-driver-函式"><a href="#建立-driver-函式" class="headerlink" title="建立 driver 函式"></a>建立 driver 函式</h1><p>首先我們先建立一個通用的可以回傳 driver 的函式，這個部份我們昨天介紹過了，今天就直接上範例方便大家對應函式名稱</p><p>本次進行範例說明所請求的網址為 PTT 熱門版，下方範例中有附上網址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line">url = &quot;https://www.ptt.cc/bbs/index.html&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_chrome_driver() -&gt; Chrome:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line"></span><br><span class="line">    driver = Chrome(ChromeDriverManager().install(),</span><br><span class="line">                    options=options)</span><br><span class="line">    return driver</span><br></pre></td></tr></table></figure><h1 id="使用-CSS-SELECTOR-定位"><a href="#使用-CSS-SELECTOR-定位" class="headerlink" title="使用 CSS_SELECTOR 定位"></a>使用 CSS_SELECTOR 定位</h1><p>Selenium 的官方文件中，提供了許多種定位 HTML 元素的方式，今天我們就挑兩種比較常用的來進行介紹，首先我們先介紹 CSS_SELECTOR</p><p>CSS_SELECTOR 語法：&lt;html 元素名稱&gt;&lt;CSS 名稱&gt;，其中 CSS 名稱可以是複數個，下面附上使用範例，至於該如何取得 CSS，我們可以透過在網頁上按又鍵開啟 “檢查” 選項來進行查看</p><p>程式解析：</p><p>取得 driver 並進行請求<br>使用 driver.find_element 來尋找元素，並指定使用 CSS_SELECTOR 進行尋找，第二個參數為 CSS 條件<br>印出該元素的資訊<br>使用 driver.find_elements 尋找所有在葉面上已出現並符合 CSS 條件的資訊<br>透過 generator 的方式來印出所有元素的文字資訊<br>補充說明：<br>每一個透過 selenium 找到的元素都一定有 text 屬性以及 get_attribute() 方法，其中 text 會印出該元素下所有的文字資訊，get_attribute() 則可以該元素的相關資訊，例如：class、href … 等等，下方的範例為取得 text</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">def demo_css_selector():</span><br><span class="line">    driver = make_chrome_driver()</span><br><span class="line">    driver.get(url=url)</span><br><span class="line">    </span><br><span class="line">    # 回傳最先找到的元素，若沒有找到則會跳 error</span><br><span class="line">    data = driver.find_element(By.CSS_SELECTOR, &quot;div.b-ent&quot;).text</span><br><span class="line">    print(data)</span><br><span class="line">    </span><br><span class="line">    # 會尋找目前葉面當中所有符合條件的元素，並回傳一個 list，若沒找到會回傳一個空 list</span><br><span class="line">    datas = driver.find_elements(By.CSS_SELECTOR, &quot;div.b-ent&quot;)</span><br><span class="line">    [print(tmp.text) for tmp in datas]</span><br></pre></td></tr></table></figure><h1 id="使用-XPATH-定位"><a href="#使用-XPATH-定位" class="headerlink" title="使用 XPATH 定位"></a>使用 XPATH 定位</h1><p>接下來的範例當中，我們會使用 XPATH 的方式尋找元素，並使用 get_attribute() 來取得該元素的 class</p><p>補充：我們同樣可以透過 “檢查” 來複製該元素在網頁上的 XPATH</p><p>在 “檢查” 當中找到該元素<br>對該元素點選右鍵，選取 “複製” -&gt; “複製 XPATH” or “複製完整 XPATH”<br>至於 XPATH 的使用方式則不是本次重點，之後可以在鐵人賽後找時間進行說明</p><p>程式解析：<br>運作邏輯基本上一樣，只是 By.CSS_SELECTOR 更換成 By.XPATH，並搭配 XPATH 條件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def demo_xpath():</span><br><span class="line">    driver = make_chrome_driver()</span><br><span class="line">    driver.get(url=url)</span><br><span class="line"></span><br><span class="line">    data = driver.find_element(By.XPATH, &quot;//*[@id=&#x27;main-container&#x27;]/div[2]/div[1]&quot;)</span><br><span class="line">    print(data.get_attribute(&quot;class&quot;))</span><br><span class="line"></span><br><span class="line">    datas = driver.find_elements(By.XPATH, &quot;//*[@id=&#x27;main-container&#x27;]/div[2]/div&quot;)</span><br><span class="line">    [print(tmp.get_attribute(&quot;class&quot;)) for tmp in datas]</span><br></pre></td></tr></table></figure><h1 id="等待元素出現"><a href="#等待元素出現" class="headerlink" title="等待元素出現"></a>等待元素出現</h1><p>由於 selenium 是實際開啟一個瀏覽器來進行請求，因此會受限於各種情況導致元素會比較慢出現，因此 selenium 提供了一種等待元素的方式，下面附上使用範例</p><p>程式解析：</p><p>透過 WebDriverWait 進行元素的等待，告訴 Selenium 等待該元素 10 秒，當元素在 10 秒內出現，則會繼續進行下一段程式，但是超過 10 秒還沒出現，則會拋出 Timeout 錯誤<br>ec.presence_of_element_located 則表示要去尋找目前出現在畫面上的元素，和下方的 of_all 差別為單數之分，用法同 find_element</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as ec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo_wait():</span><br><span class="line">    driver = make_chrome_driver()</span><br><span class="line">    driver.get(url=url)</span><br><span class="line">    </span><br><span class="line">    # 單個元素，回傳 webelement 物件</span><br><span class="line">    data = WebDriverWait(driver, 10).until(</span><br><span class="line">        ec.presence_of_element_located((By.CSS_SELECTOR, &quot;div.b-ent&quot;)))</span><br><span class="line">    print(data.text)</span><br><span class="line">    </span><br><span class="line">    # 多個元素，回傳 list</span><br><span class="line">    datas = WebDriverWait(driver, 10).until(</span><br><span class="line">        ec.presence_of_all_elements_located((By.CSS_SELECTOR, &quot;div.b-ent&quot;)))</span><br><span class="line">    [print(tmp.text) for tmp in datas]</span><br></pre></td></tr></table></figure><h1 id="建立-driver-函式-1"><a href="#建立-driver-函式-1" class="headerlink" title="建立 driver 函式"></a>建立 driver 函式</h1><p>同樣的我們今天一樣先附上建立 driver 的函式，今天比較不一樣的地方是，我們透過 contextmanager 來建立，<br>這樣我們就可以透過 yield 以及 with 的方式來操作 driver，並於操作結束後會自動回到此函式內執行 driver.quit()，以此確保瀏覽器會被完全關閉，不殘留在記憶體當中</p><p>另外我們今天爬取的目標是 ithelp，因此代入 user-agent 以免被誤認為是機器人而造成範例失敗，理論上如果是拿來測試網頁的話，應該是不用帶入這個參數的，不過還是要視情況而定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def make_chrome_driver() -&gt; Chrome:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line">    options.add_argument(f&quot;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span><br><span class="line">                         f&quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;)</span><br><span class="line"></span><br><span class="line">    driver = Chrome(ChromeDriverManager().install(),</span><br><span class="line">                    options=options)</span><br><span class="line">    yield driver</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h1 id="取得基本資訊"><a href="#取得基本資訊" class="headerlink" title="取得基本資訊"></a>取得基本資訊</h1><p>我們可以透過 driver 物件本身取得一些瀏覽器的資訊，下面列舉三點並附上程式碼做參考：</p><p>driver.current_url：取得瀏覽器目前所在頁面的網址<br>driver.title：取得瀏覽器目前所在頁面的 title，就是我們可以在瀏覽器最上方看到的分頁的名稱<br>driver.page_source：取得瀏覽器目前所在頁面的 HTML Code，取得後可透過 BeautifulSoup 進行網頁解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def demo_basic_info():</span><br><span class="line">    with make_chrome_driver() as driver:</span><br><span class="line">        driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line"></span><br><span class="line">        # 取得目前頁面的網址</span><br><span class="line">        current_url = driver.current_url</span><br><span class="line">        print(current_url)</span><br><span class="line"></span><br><span class="line">        # 取得目前頁面的 title</span><br><span class="line">        current_title = driver.title</span><br><span class="line">        print(current_title)</span><br><span class="line"></span><br><span class="line">        # 取得目前頁面的 HTML Code</span><br><span class="line">        current_code = driver.page_source</span><br><span class="line">        print(current_code)</span><br></pre></td></tr></table></figure><h1 id="點選元素"><a href="#點選元素" class="headerlink" title="點選元素"></a>點選元素</h1><p>在 selenium 當中點選元素的方式有兩種，分別為透過 selenium 找到元素後進行點選以及找到元素後透過執行 javascript 進行點選，後者通常用於當要被點選的按鈕被某個跳出視窗遮住，或是畫面上被隱藏但是 HTML Code 實際上是存在時，我們就可以透過執行 javascript 直接對其進行點選的動作</p><h2 id="使用-Selenium-點選"><a href="#使用-Selenium-點選" class="headerlink" title="使用 Selenium 點選"></a>使用 Selenium 點選</h2><p>程式解析：</p><p>利用 selenium 找到 “技術文章” 按鈕元素<br>透過呼叫元素當中的 click() 方法即代表使用 selenium 內建的方式進行點選<br>點選該元素後頁面會進行跳轉，於點選後透過 driver.current_url 來取得該頁面網址<br>驗證取得的網址是否如同預期該出現的網址內容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as ec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo_click_by_selenium():</span><br><span class="line">    with make_chrome_driver() as driver:</span><br><span class="line">        driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line">        technical_article_button = WebDriverWait(driver, 30).until(</span><br><span class="line">            ec.presence_of_element_located((By.XPATH, &quot;/html/body/div[1]/nav/div[1]/div/ul[1]/li[2]/a&quot;)))</span><br><span class="line"></span><br><span class="line">        # click by selenium</span><br><span class="line">        technical_article_button.click()</span><br><span class="line"></span><br><span class="line">        technical_article_url = &quot;https://ithelp.ithome.com.tw/articles?tab=tech&quot;</span><br><span class="line">        current_url = driver.current_url</span><br><span class="line"></span><br><span class="line">        assert current_url == technical_article_url</span><br></pre></td></tr></table></figure><h2 id="使用-Javascript-點選"><a href="#使用-Javascript-點選" class="headerlink" title="使用 Javascript 點選"></a>使用 Javascript 點選</h2><p>語法：driver.execute_script(“arguments[0].click();”, &lt;元素名稱&gt;)</p><p>程式解析：<br>運作邏輯基本同上面一樣，差別只在於透過 javascript 執行點選的部分，有特別使用註解標記</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as ec</span><br><span class="line"></span><br><span class="line">def demo_click_by_javascript():</span><br><span class="line">    with make_chrome_driver() as driver:</span><br><span class="line">        driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line">        technical_article_button = WebDriverWait(driver, 30).until(</span><br><span class="line">            ec.presence_of_element_located((By.XPATH, &quot;/html/body/div[1]/nav/div[1]/div/ul[1]/li[2]/a&quot;)))</span><br><span class="line"></span><br><span class="line">        # click by js</span><br><span class="line">        driver.execute_script(&quot;arguments[0].click();&quot;, technical_article_button)</span><br><span class="line"></span><br><span class="line">        technical_article_url = &quot;https://ithelp.ithome.com.tw/articles?tab=tech&quot;</span><br><span class="line">        current_url = driver.current_url</span><br><span class="line"></span><br><span class="line">        assert current_url == technical_article_url</span><br></pre></td></tr></table></figure><h1 id="鍵盤操作"><a href="#鍵盤操作" class="headerlink" title="鍵盤操作"></a>鍵盤操作</h1><p>在 selenium 當中，我們可以透過 send_keys() 方法來對元素進行文字的輸入，另外也可以透過 selenium 提供的 Keys 類別來模擬鍵盤的操作，下面的範例當中我們就分別使用上述兩種方法來進行帳號密碼的輸入，並用 Enter 鍵進行確認</p><p>程式解析：</p><ul><li>先分別透過 selenium 找到輸入帳號、密碼的元素</li><li>利用 send_keys() 輸入帳號及密碼</li><li>輸入完成後於 password 利用 Keys 模擬 Enter 鍵的操作進行確認以及頁面跳轉</li><li>於跳轉後，取得 user name 並進行驗證</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as ec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo_input_keyboard():</span><br><span class="line">    with make_chrome_driver() as driver:</span><br><span class="line">        driver.get(&quot;https://member.ithome.com.tw/login&quot;)</span><br><span class="line">        account = WebDriverWait(driver, 30).until(ec.presence_of_element_located((By.XPATH, &quot;//*[@id=&#x27;account&#x27;]&quot;)))</span><br><span class="line">        password = WebDriverWait(driver, 30).until(ec.presence_of_element_located((By.XPATH, &quot;//*[@id=&#x27;password&#x27;]&quot;)))</span><br><span class="line"></span><br><span class="line">        account.send_keys(&quot;&lt;你的帳號&gt;&quot;)</span><br><span class="line">        password.send_keys(&quot;&lt;你的密碼&gt;&quot;)</span><br><span class="line">        password.send_keys(Keys.ENTER)</span><br><span class="line"></span><br><span class="line">        user_name = WebDriverWait(driver, 30).until(</span><br><span class="line">            ec.presence_of_element_located((By.XPATH, &quot;//*[@id=&#x27;editNickname&#x27;]&quot;)))</span><br><span class="line"></span><br><span class="line">        assert user_name.text == &quot;熊熊工程師&quot;</span><br></pre></td></tr></table></figure><h1 id="建立測試目標"><a href="#建立測試目標" class="headerlink" title="建立測試目標"></a>建立測試目標</h1><ol><li>確認瀏覽器請求網址後的網址是否為 “<a href="https://ithelp.ithome.com.tw/%22%EF%BC%8Ctitle">https://ithelp.ithome.com.tw/&quot;，title</a> 開頭是否為 “iT 邦幫忙”</li><li>確認請求 “<a href="https://ithelp.ithome.com.tw/">https://ithelp.ithome.com.tw/</a>“ 後，網頁上是否有出現 “技術問答” 字樣，且 HTML tag 為 h2</li><li>確認請求 “<a href="https://ithelp.ithome.com.tw/">https://ithelp.ithome.com.tw/</a>“ 後，網也上是否有出現 “技術問答”、”技術文章”… 等選項按鈕</li></ol><h1 id="建立-conftest-py"><a href="#建立-conftest-py" class="headerlink" title="建立 conftest.py"></a>建立 conftest.py</h1><p>在開始撰寫測試程式前，我們可以先撰寫 fixture 方便後續的測試進行，而由於 driver 確定是每個 test case 都會使用到的功能，因此我們將此 fixture 撰寫在 conftest.py 當中</p><p>conftest.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;driver&quot;)</span><br><span class="line">def driver_fixture() -&gt; Chrome:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line">    options.add_argument(f&quot;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span><br><span class="line">                         f&quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;)</span><br><span class="line"></span><br><span class="line">    driver = Chrome(ChromeDriverManager().install(),</span><br><span class="line">                    options=options)</span><br><span class="line"></span><br><span class="line">    yield driver</span><br><span class="line"></span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h1 id="驗證-url-及-title"><a href="#驗證-url-及-title" class="headerlink" title="驗證 url 及 title"></a>驗證 url 及 title</h1><p>程式解析：</p><p>先對指定網址進行請求<br>驗證請求後跳轉的網址是否正確<br>驗證跳轉網址後的頁面的 title 是否開頭為 “iT 邦幫忙”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver import Chrome</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_current_url(driver: Chrome):</span><br><span class="line">    driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line"></span><br><span class="line">    correct_url = &quot;https://ithelp.ithome.com.tw/&quot;</span><br><span class="line">    assert driver.current_url == correct_url</span><br><span class="line"></span><br><span class="line">    correct_title_start = &quot;iT 邦幫忙&quot;</span><br><span class="line">    assert driver.title.startswith(correct_title_start)</span><br></pre></td></tr></table></figure><h1 id="驗證元素文字是否正確"><a href="#驗證元素文字是否正確" class="headerlink" title="驗證元素文字是否正確"></a>驗證元素文字是否正確</h1><p>程式解析：</p><p>建立測試資料<br>進行請求<br>透過 CSS_SELECTOR 找到元素<br>驗證該元素的 text 內容是否符合測試資料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_text_visible(driver: Chrome):</span><br><span class="line">    correct_text = &quot;技術問答&quot;</span><br><span class="line"></span><br><span class="line">    driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line">    question_h2_element = driver.find_element(</span><br><span class="line">        By.CSS_SELECTOR, &quot;h2.tab-title&quot;)</span><br><span class="line"></span><br><span class="line">    assert question_h2_element.text == correct_text</span><br></pre></td></tr></table></figure><h1 id="驗證按鈕選項是否都有出現"><a href="#驗證按鈕選項是否都有出現" class="headerlink" title="驗證按鈕選項是否都有出現"></a>驗證按鈕選項是否都有出現</h1><p>程式解析：</p><p>建立測試資料<br>進行請求<br>透過 driver 先找到位於左方的選項列表元素 (ul)<br>在針對該元素尋找所有的選項內容 (li) 並透過 generator 的方式取得文字內容串列<br>文字內容串列是否符合正確的測試資料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_element_clickable(driver: Chrome):</span><br><span class="line">    correct_options = [&quot;技術問答&quot;, &quot;技術文章&quot;, &quot;iT 徵才&quot;,</span><br><span class="line">                       &quot;Tag&quot;, &quot;聊天室&quot;, &quot;2022 鐵人賽&quot;]</span><br><span class="line"></span><br><span class="line">    driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line">    options = driver.find_element(</span><br><span class="line">        By.CSS_SELECTOR, &quot;ul.list-unstyled.menu__left&quot;)</span><br><span class="line">    options = [tmp.text for tmp in options.find_elements(</span><br><span class="line">        By.CSS_SELECTOR, &quot;li.menu__item&quot;)]</span><br><span class="line"></span><br><span class="line">    assert options == correct_options</span><br></pre></td></tr></table></figure><h1 id="安裝-Selenium-IDE"><a href="#安裝-Selenium-IDE" class="headerlink" title="安裝 Selenium IDE"></a>安裝 Selenium IDE</h1><ol><li>前往這個網址：<a href="https://chrome.google.com/webstore/detail/selenium-ide/mooikfkahbdckldjjndioackbalphokd">https://chrome.google.com/webstore/detail/selenium-ide/mooikfkahbdckldjjndioackbalphokd</a></li><li>點選 “加到 Chrome” 選項</li><li>選擇 “新增擴充功能” 選項</li><li>過一陣子之後就可以在 Chrome 的右上角看到 Selenium IDE 被成功加入<br><a href="https://ithelp.ithome.com.tw/upload/images/20221002/20144024nmnQrxsQAM.png">https://ithelp.ithome.com.tw/upload/images/20221002/20144024nmnQrxsQAM.png</a></li></ol><h1 id="介面介紹"><a href="#介面介紹" class="headerlink" title="介面介紹"></a>介面介紹</h1><h2 id="建立新專案"><a href="#建立新專案" class="headerlink" title="建立新專案"></a>建立新專案</h2><p>在開始介面介紹之前，我們先透過下面步驟建立一個簡單的測試計畫</p><ol><li>開啟 Selenium IDE</li><li>選擇 “Record a new test in a new project” 選項</li><li>輸入 project 名稱，範例使用 “demo”</li><li>輸入此測試計畫的目標網址，此處使用 <a href="https://ithelp.ithome.com.tw/">https://ithelp.ithome.com.tw/</a></li><li>點選 “START RECORD” 選項開始進行錄製</li><li>點選該選項之後，就可以看到他幫我們開啟一個連覽器並且右下角有顯示 Recording 字樣</li></ol><p><img src="https://hackmd.io/_uploads/Syz_9ZFg6.png"></p><h2 id="介面介紹-1"><a href="#介面介紹-1" class="headerlink" title="介面介紹"></a>介面介紹</h2><p><img src="https://hackmd.io/_uploads/SkOqcZtla.png"></p><ol><li>project name：測試計畫名稱，我們可以透過命名計畫名稱來替測試分類</li><li>test 分類：分別有 Tests、Test Suites、Executing，此為 Selenium IDE，表示 Test 的部分</li><li>Tests：會列出所有 Test case</li><li>Test Suites：該計畫內部中的分類，預設會有 Default Suites 的存在</li><li>Executing：目前正在執行測試的 test case 會出現在此分類</li><li>test case 列表：依照　test 分類顯示出對應的 test case</li><li>指令列表：列出該 test case 當中所有的指令，並會依照順序進行執行</li><li>編輯指令：每個指令都可以透過這個視窗進行編輯、更換</li><li>存檔</li><li>錄製按鈕：按下此按鈕後會開啟瀏覽器並進行錄製</li></ol><h2 id="錄製腳本展示"><a href="#錄製腳本展示" class="headerlink" title="錄製腳本展示"></a>錄製腳本展示</h2><p>我們可以透過錄製腳本的方式來進行測試案例的建立，也可以透過手動插入腳本的方式進行建立，不過在驗證的部分一定是透過手動插入的，Selenium IDE 只能協助我們錄製在我們想驗證的元素出現之前該進行甚麼樣的動作</p><p>另外經過筆者實測，建議在開始錄製之前都手動插入一行 open 命令來開啟網址，在錄製的過程中會比較順暢，下面我們就簡單錄製一個腳本給大家看</p><h3 id="腳本說明"><a href="#腳本說明" class="headerlink" title="腳本說明"></a>腳本說明</h3><p>我們會按照下面的步驟來進行腳本的錄製：</p><ol><li>開啟　<a href="https://ithelp.ithome.com.tw/">https://ithelp.ithome.com.tw/</a></li><li>放大瀏覽器畫面</li><li>點選 “技術文章”</li><li>驗證 “h2 技術文章” 元素是否有出現</li></ol><h3 id="腳本展示"><a href="#腳本展示" class="headerlink" title="腳本展示"></a>腳本展示</h3><ol><li>點選紅色方框按鈕可以進行單個測試程式測試，左方按鈕為執行所有測試程式</li><li>建議於錄製完成後，都將第一行 open 指令中的 “Target” 修改成想要到達的網址，避免造成錯誤</li></ol><p><img src="https://hackmd.io/_uploads/Bkq1jbtlp.png"></p><h3 id="驗證方式"><a href="#驗證方式" class="headerlink" title="驗證方式"></a>驗證方式</h3><p>這個部分會說明一些常用的驗證項目，也就是 assert 的選項</p><ul><li>assert alert：驗證是否有跳出提示視窗</li><li>assert element present：驗證元素是否有出現</li><li>assert element not present：驗證元素是否沒出現</li><li>assert text：驗證元素文字是否為指定的數值</li><li>assert not text：驗證元素是否不為指定的數值</li></ul><h3 id="輸出為-Python-腳本"><a href="#輸出為-Python-腳本" class="headerlink" title="輸出為 Python 腳本"></a>輸出為 Python 腳本</h3><h4 id="輸出步驟"><a href="#輸出步驟" class="headerlink" title="輸出步驟"></a>輸出步驟</h4><p>透過下面的方式可以將錄製好的腳本輸出為 Python 以及其他語言的腳本，然後就可以交給測試部門的 RD 進行程式的重構或使用，進一步套入 CI&#x2F;CD 進行自動化測試</p><p>回到 Tests 分類</p><p>點選要匯出的測試案例旁邊的三個按鈕<br><a href="https://ithelp.ithome.com.tw/upload/images/20221002/20144024nOaNk5J8ye.jpg">https://ithelp.ithome.com.tw/upload/images/20221002/20144024nOaNk5J8ye.jpg</a></p><p>選擇 “EXPORT” 選項</p><p>選擇 “Python pytest” 選項</p><p>選擇 “EXPORT” 選項</p><h4 id="腳本展示-1"><a href="#腳本展示-1" class="headerlink" title="腳本展示"></a>腳本展示</h4><p>透過 Selenium IDE 所輸出的 Python 腳本，可以直接執行，不如果要套入 CI&#x2F;CD，或是公司本身自有的測試框架或其他種類流程的話，<br>都會需要進行某種程度上的重構，這時後錄製腳本的人員如果沒有程式相關背景的話，就可以交給 RD 進行重構並納入自動化測試當中，<br>或本身是測試部門的 RD 的話，也可以透過這個小工具來減少我們寫 code 的時間，獲取更多偷懶的機會</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Generated by Selenium IDE</span><br><span class="line">import pytest</span><br><span class="line">import time</span><br><span class="line">import json</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.common.action_chains import ActionChains</span><br><span class="line">from selenium.webdriver.support import expected_conditions</span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line">from selenium.webdriver.common.desired_capabilities import DesiredCapabilities</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestDemo():</span><br><span class="line">    def setup_method(self, method):</span><br><span class="line">        self.driver = webdriver.Chrome()</span><br><span class="line">        self.vars = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def teardown_method(self, method):</span><br><span class="line">        self.driver.quit()</span><br><span class="line"></span><br><span class="line">    def test_demo(self):</span><br><span class="line">        self.driver.get(&quot;https://ithelp.ithome.com.tw/&quot;)</span><br><span class="line">        self.driver.set_window_size(1552, 832)</span><br><span class="line">        self.driver.find_element(By.LINK_TEXT, &quot;技術文章&quot;).click()</span><br><span class="line">        elements = self.driver.find_elements(By.XPATH, &quot;//h2[contains(.,\&#x27;技術文章\&#x27;)]&quot;)</span><br><span class="line">        assert len(elements) &gt; 0</span><br><span class="line">        self.driver.close()</span><br></pre></td></tr></table></figure><h1 id="XPATH"><a href="#XPATH" class="headerlink" title="XPATH"></a>XPATH</h1><h2 id="建立-driver-函式-2"><a href="#建立-driver-函式-2" class="headerlink" title="建立 driver 函式"></a>建立 driver 函式</h2><p>這邊就不再贅述，直接上範例，唯一不一樣的地方是，在這個階段我們會直接開啟指定的 url 再將 driver 回傳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line">from selenium.webdriver import Chrome</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">from webdriver_manager.chrome import ChromeDriverManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def make_chrome_driver() -&gt; Chrome:</span><br><span class="line">    options = Options()</span><br><span class="line">    options.add_argument(&quot;--headless&quot;)</span><br><span class="line">    options.add_argument(&quot;--start-maximized&quot;)</span><br><span class="line">    options.add_argument(f&quot;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span><br><span class="line">                         f&quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;)</span><br><span class="line"></span><br><span class="line">    driver = Chrome(ChromeDriverManager().install(),</span><br><span class="line">                    options=options)</span><br><span class="line">    driver.get(&quot;https://ithelp.ithome.com.tw/questions&quot;)</span><br><span class="line">    yield driver</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h2 id="相對位置-XPATH"><a href="#相對位置-XPATH" class="headerlink" title="相對位置 XPATH"></a>相對位置 XPATH</h2><p>在 selenium 當中，我們可以透過相對位置的 XPATH 來定位我們的元素，語法結構大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpath = &quot;//div[@class=&#x27;board tabs-content&#x27;]/div[1]&quot;</span><br></pre></td></tr></table></figure><ul><li>&#x2F;&#x2F;：表示當前網頁 or 元素</li><li>div：要尋找的 HTML tag</li><li>[]：為 XPATH 的運算邏輯，在裡面可以增加 class、id 甚至是 and 等條件，語法為 “@&lt;屬性名稱&gt;”，ex: @class、@id、@name…</li><li>div[1]：同層級且同樣的元素可能會有很多個，例如：ithelp 問答葉面的問題列表，可以透過取串列的方式來取得指定的個數，若沒有預設為取得第一個找到符合條件的元素</li></ul><p>上述的 XPATH 語法代表要取得 “class 為 board tabs-content 的 div” 底下的 “第一個 div”</p><p>範例程式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_question_by_relative_xpath():</span><br><span class="line">    with make_chrome_driver() as driver:</span><br><span class="line">        xpath = &quot;//div[@class=&#x27;board tabs-content&#x27;]/div[1]&quot;</span><br><span class="line">        question = driver.find_element(By.XPATH, xpath)</span><br><span class="line">        print(question.text)</span><br></pre></td></tr></table></figure><p>執行結果：<br><img src="https://hackmd.io/_uploads/ryik6btlp.png"></p><h2 id="取得多個元素"><a href="#取得多個元素" class="headerlink" title="取得多個元素"></a>取得多個元素</h2><p>當你找元素時使用的是 driver.find_elements，XPATH 會協助你將所有符合條件的元素都蒐集回來，下方的範例當中就成功將問答頁面第一頁中所有的問題都爬娶回來並印出數量</p><p>範例程式：</p><p>可以看到下方範例當中，我們將最後面的 div[1] 取代為 div[@class&#x3D;’qa-list’]，表示我們要在這一層取得所有 “class 為 qa-list的 div”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_questions_by_relative_xpath():</span><br><span class="line">    with make_chrome_driver() as driver:</span><br><span class="line">        xpath = &quot;//div[@class=&#x27;board tabs-content&#x27;]/div[@class=&#x27;qa-list&#x27;]&quot;</span><br><span class="line">        questions = driver.find_elements(By.XPATH, xpath)</span><br><span class="line">        print(len(questions))</span><br></pre></td></tr></table></figure><p>執行結果：<br><img src="https://hackmd.io/_uploads/S1QMaWYx6.png"></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Python/">Python</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/">自動化測試</category>
      
      <category domain="https://gahgah147.github.io/tags/Selenium/">Selenium</category>
      
      <category domain="https://gahgah147.github.io/tags/XPATH/">XPATH</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/03/Selenium-%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TDD 測試驅動開發流程</title>
      <link>https://gahgah147.github.io/2023/10/02/TDD-%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E6%B5%81%E7%A8%8B/</link>
      <guid>https://gahgah147.github.io/2023/10/02/TDD-%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Mon, 02 Oct 2023 07:59:49 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;這篇是記錄我在看鐵人賽 &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10290529&quot;&gt;Python 與自動化測試的敲門磚 &lt;/a&gt; 的過程&lt;/p&gt;
&lt;h1 id=&quot;TDD-簡介&quot;&gt;&lt;a href=&quot;#TDD-簡介&quot; cla</description>
        
      
      
      
      <content:encoded><![CDATA[<p>這篇是記錄我在看鐵人賽 <a href="https://ithelp.ithome.com.tw/articles/10290529">Python 與自動化測試的敲門磚 </a> 的過程</p><h1 id="TDD-簡介"><a href="#TDD-簡介" class="headerlink" title="TDD 簡介"></a>TDD 簡介</h1><p>TDD 全名為 Test-Driven Development 中文翻譯為 「測試驅動開發」，顧名思義就是藉著撰寫測試程式，來一步一步建構出我們的系統，其倡導的概念為，先撰寫測試程式，再撰寫實際相對應的 function，因此程式開發者需要先行和 PM 或使用者討論系統需求，並逐步擬定測試計畫，最後才會真正開始撰寫程式</p><p>採用 TDD 開發的優缺點</p><table><thead><tr><th>好處</th><th>壞處</th></tr></thead><tbody><tr><td>無須事後再補寫測試程式</td><td>若系統需求溝通不良，會容易造成系統設計不良</td></tr><tr><td>每一位 RD 都可以透過測試程式了解每個 function 的內容，較容易熟悉系統</td><td>測試程式有很大的機率只有 RD 部門看得懂，需要花費多於成本溝通</td></tr><tr><td>可以確保每個 function 被更動時，可以馬上進行測試，降低錯誤產生</td><td></td></tr></tbody></table><h1 id="3A-原則"><a href="#3A-原則" class="headerlink" title="3A 原則"></a>3A 原則</h1><p>在 TDD 當中，對於每個測試程式的撰寫有著 3A 原則 (步驟)，分別為 Arrange、Act 以及 Assert，下面按照順序來進行說明</p><p>下面這段程式碼是我們在 demo 3A 原則的時候要進行測試的函式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add_num(num1: int, num2: int) -&gt; int:</span><br><span class="line">    return num1 + num2</span><br></pre></td></tr></table></figure><h2 id="Arrange-初始、期望結果"><a href="#Arrange-初始、期望結果" class="headerlink" title="Arrange 初始、期望結果"></a>Arrange 初始、期望結果</h2><p>在這個步驟當中，我們要準備我們的測試環境、測試資料 以及預期結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_add_num():</span><br><span class="line">    # Arrange</span><br><span class="line">    num1 = 10</span><br><span class="line">    num2 = 20</span><br><span class="line">    except_result = 30</span><br></pre></td></tr></table></figure><h2 id="Act-實際呼叫"><a href="#Act-實際呼叫" class="headerlink" title="Act 實際呼叫"></a>Act 實際呼叫</h2><p>在這個步驟當中，我們就會實際呼叫我們需要測試的 function 來驗證其正確性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def test_add_num():</span><br><span class="line">    # Arrange</span><br><span class="line">    num1 = 10</span><br><span class="line">    num2 = 20</span><br><span class="line">    except_result = 30</span><br><span class="line"></span><br><span class="line">    # Act</span><br><span class="line">    result = add_num(num1, num2)</span><br></pre></td></tr></table></figure><h2 id="Assert-驗證"><a href="#Assert-驗證" class="headerlink" title="Assert 驗證"></a>Assert 驗證</h2><p>最後我們才會進行驗證，看看該 function 是否如預期的回傳我們想要的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def test_add_num():</span><br><span class="line">    # Arrange</span><br><span class="line">    num1 = 10</span><br><span class="line">    num2 = 20</span><br><span class="line">    except_result = 30</span><br><span class="line"></span><br><span class="line">    # Act</span><br><span class="line">    result = add_num(num1, num2)</span><br><span class="line"></span><br><span class="line">    # Assert</span><br><span class="line">    assert result == except_result</span><br></pre></td></tr></table></figure><p>以上就是 TDD 針對撰寫每一個 test case 的 3A 原則</p><h1 id="TDD-的開發五步驟"><a href="#TDD-的開發五步驟" class="headerlink" title="TDD 的開發五步驟"></a>TDD 的開發五步驟</h1><p>接下來是要講的部分是，TDD 針對開發流程的五步驟，亦即每一組函式的開發過程 (function + test function)，分別為：</p><h2 id="新增測試程式"><a href="#新增測試程式" class="headerlink" title="新增測試程式"></a>新增測試程式</h2><p>選定一個要撰寫的需求、功能 (function)<br>思考使用情境，準備測試環境以及資料<br>先建立測試函式，不要先寫 function 本身 (即先撰寫 test_function)<br>對應到 3A 中的 Arrange)</p><h2 id="執行測試程式-亮紅燈"><a href="#執行測試程式-亮紅燈" class="headerlink" title="執行測試程式 (亮紅燈)"></a>執行測試程式 (亮紅燈)</h2><p>由於還沒有實踐撰寫 function，因此在這個步驟一定會是錯誤<br>這個步驟要確定的是錯誤只發生在沒有撰寫 function 的部分，其他部分必須要確保可以正常運行，例如：fixture<br>是否可以正常接收，測試資料語法是否錯誤</p><h2 id="撰寫-function"><a href="#撰寫-function" class="headerlink" title="撰寫 function"></a>撰寫 function</h2><p>這個步驟我們要開始撰寫 function 本身<br>撰寫原則為以最低限度可以回傳正確資料為主，不需要對程式碼進行優化<br>對應到 3A 中的 Act</p><h2 id="執行測試程式-亮綠燈"><a href="#執行測試程式-亮綠燈" class="headerlink" title="執行測試程式 (亮綠燈)"></a>執行測試程式 (亮綠燈)</h2><p>確保撰寫的功能正常<br>驗證回傳資料是否正確<br>對應到 3A 中的 Assert</p><h2 id="優化程式"><a href="#優化程式" class="headerlink" title="優化程式"></a>優化程式</h2><p>在前面四個步驟當中，我們已經將整組 function 以及 test_function 準備完成，接下來我們可以針對 function 進行重構<br>重構的過程當中我們可以不斷地執行測試程式，確保每一次改動都可以回傳正確資料</p><h1 id="TDD-實作"><a href="#TDD-實作" class="headerlink" title="TDD 實作"></a>TDD 實作</h1><h2 id="需求設定"><a href="#需求設定" class="headerlink" title="需求設定"></a>需求設定</h2><p>建立一個爬蟲針對 ptt 熱門看板 進行爬取<br>每執行一次爬蟲腳本，會進行爬取並印出各個版名稱、分類以及最新文章</p><h2 id="爬蟲部分開發"><a href="#爬蟲部分開發" class="headerlink" title="爬蟲部分開發"></a>爬蟲部分開發</h2><h3 id="需求思考"><a href="#需求思考" class="headerlink" title="需求思考"></a>需求思考</h3><p>需要一個 url 參數，來進行網址的請求<br>回傳格式為 list，每個版資料使用 dictionary 裝起來<br>需要驗證項目：<br>list 不可為空<br>每個 dictionary 內需要有 board、class 以及 latest_paragraph</p><h3 id="程式開發"><a href="#程式開發" class="headerlink" title="程式開發"></a>程式開發</h3><h4 id="撰寫測試程式"><a href="#撰寫測試程式" class="headerlink" title="撰寫測試程式"></a>撰寫測試程式</h4><p>可以看到我們在這個步驟憑空撰寫了一個 get_data 的 function 但是實際上並沒有進行任何的 import<br>test_utils.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def test_crawler():</span><br><span class="line">    # 建立測試參數</span><br><span class="line">    url = &quot;https://www.ptt.cc/bbs/index.html&quot;</span><br><span class="line">    </span><br><span class="line">    # 呼叫方法</span><br><span class="line">    result = get_data(url=url)</span><br><span class="line"></span><br><span class="line">    # 進行驗證</span><br><span class="line">    assert result</span><br><span class="line">    for data in result:</span><br><span class="line">        assert data.get(&quot;board&quot;)</span><br><span class="line">        assert data.get(&quot;class&quot;)</span><br><span class="line">        assert data.get(&quot;latest_paragraph&quot;)</span><br></pre></td></tr></table></figure><div class="note info simple"><p>需要安裝套件<br>pip install beautifulsoup4<br>pip install lxml</p></div><h4 id="執行測試-亮紅燈"><a href="#執行測試-亮紅燈" class="headerlink" title="執行測試 (亮紅燈)"></a>執行測試 (亮紅燈)</h4><p>接著我們要執行測試，此步驟需要確認錯誤的位置必須在 get_data() 的部分，因為我們還沒有實際撰寫此 function</p><p><img src="https://hackmd.io/_uploads/S14MLgdeT.png"></p><blockquote><p>圖中我們可以確認，發生錯誤的原因確實是因為沒有此 function</p></blockquote><h4 id="建立-function"><a href="#建立-function" class="headerlink" title="建立 function"></a>建立 function</h4><p>utils.py<br>在這個步驟當中，我們實際撰寫了一個爬蟲的 function 並命名為 get_data</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_data(url: str) -&gt; list:</span><br><span class="line">    res = requests.get(url=url)</span><br><span class="line">    if res.status_code == 200:</span><br><span class="line">        soup = BeautifulSoup(res.text, &quot;lxml&quot;)</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        targets = soup.find_all(&quot;div&quot;, class_=&quot;b-ent&quot;)</span><br><span class="line">        for target in targets:</span><br><span class="line">            tmp = &#123;&quot;board&quot;: target.find(&quot;div&quot;, class_=&quot;board-name&quot;).text,</span><br><span class="line">                   &quot;class&quot;: target.find(&quot;div&quot;, class_=&quot;board-class&quot;).text,</span><br><span class="line">                   &quot;latest_paragraph&quot;: target.find(&quot;div&quot;, class_=&quot;board-title&quot;).text&#125;</span><br><span class="line">            result.append(tmp)</span><br><span class="line"></span><br><span class="line">        return result</span><br></pre></td></tr></table></figure><h4 id="進行測試-亮綠燈"><a href="#進行測試-亮綠燈" class="headerlink" title="進行測試 (亮綠燈)"></a>進行測試 (亮綠燈)</h4><p>接著我們要開始進行測試，於測試程式內實際將 get_data 進行 import 並測試調整直到亮綠燈</p><p>test_utils.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from utils import get_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_crawler():</span><br><span class="line">    # 建立測試參數</span><br><span class="line">    url = &quot;https://www.ptt.cc/bbs/index.html&quot;</span><br><span class="line"></span><br><span class="line">    # 呼叫方法</span><br><span class="line">    result = get_data(url=url)</span><br><span class="line"></span><br><span class="line">    # 進行驗證</span><br><span class="line">    assert result</span><br><span class="line">    for data in result:</span><br><span class="line">        assert data.get(&quot;board&quot;)</span><br><span class="line">        assert data.get(&quot;class&quot;)</span><br><span class="line">        assert data.get(&quot;latest_paragraph&quot;)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>下圖中可以看到我們很幸運的一次就成功了，代表可以進入下個步驟</p><h4 id="程式碼優化"><a href="#程式碼優化" class="headerlink" title="程式碼優化"></a>程式碼優化</h4><p> 在這個過程中，我們就可以開始針對程式碼進行重構，切記，每進行一次重構，就要執行一次對應的 test case<br>確保每次的異動不會造成 function 異常</p><p>由於需求提到需要印出，因此於這個步驟我們替 get_data 加上 print 讓需求完善，並建立腳本進入點</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_data(url: str) -&gt; list:</span><br><span class="line">    res = requests.get(url=url)</span><br><span class="line">    if res.status_code == 200:</span><br><span class="line">        soup = BeautifulSoup(res.text, &quot;lxml&quot;)</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        targets = soup.find_all(&quot;div&quot;, class_=&quot;b-ent&quot;)</span><br><span class="line">        for target in targets:</span><br><span class="line">            tmp = &#123;&quot;board&quot;: target.find(&quot;div&quot;, class_=&quot;board-name&quot;).text,</span><br><span class="line">                   &quot;class&quot;: target.find(&quot;div&quot;, class_=&quot;board-class&quot;).text,</span><br><span class="line">                   &quot;latest_paragraph&quot;: target.find(&quot;div&quot;, class_=&quot;board-title&quot;).text&#125;</span><br><span class="line">            result.append(tmp)</span><br><span class="line"></span><br><span class="line">        pprint(result)  # pprint 用於自動排版輸出</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    get_data(url=&quot;https://www.ptt.cc/bbs/index.html&quot;)</span><br></pre></td></tr></table></figure><p>下圖為利用 cmd 執行的結果<br><img src="https://hackmd.io/_uploads/B1BjwluxT.png"></p><blockquote><p> python3  utils.py</p></blockquote><p>參考文章:<br><a href="https://ithelp.ithome.com.tw/articles/10299287">https://ithelp.ithome.com.tw/articles/10299287</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Pytest/">Pytest</category>
      
      <category domain="https://gahgah147.github.io/tags/Python/">Python</category>
      
      <category domain="https://gahgah147.github.io/tags/%E9%96%8B%E7%99%BC%E6%B5%81%E7%A8%8B/">開發流程</category>
      
      <category domain="https://gahgah147.github.io/tags/TDD/">TDD</category>
      
      <category domain="https://gahgah147.github.io/tags/%E7%88%AC%E8%9F%B2/">爬蟲</category>
      
      
      <comments>https://gahgah147.github.io/2023/10/02/TDD-%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在Windows上安裝 pnpm</title>
      <link>https://gahgah147.github.io/2023/09/26/%E5%9C%A8Windows%E4%B8%8A%E5%AE%89%E8%A3%9D-pnpm/</link>
      <guid>https://gahgah147.github.io/2023/09/26/%E5%9C%A8Windows%E4%B8%8A%E5%AE%89%E8%A3%9D-pnpm/</guid>
      <pubDate>Tue, 26 Sep 2023 01:13:46 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因為練習Next.js 開發blog 需要安裝 pnpm 紀錄一下 windows 上如何安裝pnpm &lt;/p&gt;
&lt;p&gt;後來在&lt;a href</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因為練習Next.js 開發blog 需要安裝 pnpm 紀錄一下 windows 上如何安裝pnpm </p><p>後來在<a href="https://stackoverflow.com/questions/75365692/how-to-install-pnpm-on-windows">這篇文章</a>找到解決方法</p><p>參考影片: <a href="https://www.youtube.com/watch?v=q5iDjNR1O7Y&ab_channel=GeekyScript">https://www.youtube.com/watch?v=q5iDjNR1O7Y&amp;ab_channel=GeekyScript</a></p><h1 id="打開CMD執行以下指令"><a href="#打開CMD執行以下指令" class="headerlink" title="打開CMD執行以下指令"></a>打開CMD執行以下指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br></pre></td></tr></table></figure><p>以上是一個 PowerShell 命令<br>set-ExecutionPolicy：這是 用於設置執行策略。</p><p>RemoteSigned：這是一個執行策略的值。在這種情況下，它表示允許執行本地（在本機計算機上）簽名過的腳本，但來自遠程位置（例如網絡上的腳本）的腳本需要經過簽名才能執行。這有助於提高安全性，因為它可以防止遠程未經信任的腳本在你的系統上運行。</p><p>-Scope CurrentUser：這部分指定了執行策略的作用範圍。在這種情況下，它設置執行策略只對當前使用者（CurrentUser）生效，而不會影響其他使用者。這是一種局部的設置，只影響當前使用者的 PowerShell 會話。</p><p>總結起來，這個命令的含義是：將當前使用者的 PowerShell 執行策略設置為 RemoteSigned，這意味著他們可以執行本地簽名過的腳本，但需要簽名的遠程腳本才能運行。這是一種安全的默認策略，可防止未經信任的遠程腳本在系統上執行。</p><h1 id="執行-Get-ExecutionPolicy"><a href="#執行-Get-ExecutionPolicy" class="headerlink" title="執行 Get-ExecutionPolicy"></a>執行 Get-ExecutionPolicy</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ExecutionPolicy</span><br></pre></td></tr></table></figure><p>Get-ExecutionPolicy 是 PowerShell 中的一個 cmdlet（命令），它用於檢索當前的執行策略。執行策略指定了哪些 PowerShell 腳本可以在系統上執行，以及它們如何被允許執行。當你運行 Get-ExecutionPolicy 命令時，它會返回當前使用者或系統的執行策略設置。</p><h1 id="查看所有的-Policy-可以執行以下指令"><a href="#查看所有的-Policy-可以執行以下指令" class="headerlink" title="查看所有的 Policy 可以執行以下指令"></a>查看所有的 Policy 可以執行以下指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ExecutionPolicy -list</span><br></pre></td></tr></table></figure><p>執行策略有不同的級別，包括：</p><p>Restricted：這是最嚴格的策略，它禁止執行所有腳本，包括本地和遠程腳本。這通常是預設的策略，以確保系統的安全性。</p><p>AllSigned：這個策略要求所有腳本都必須經過數位簽名，無論是本地還是遠程的。只有經過簽名的腳本才能執行。</p><p>RemoteSigned：這個策略要求遠程腳本必須經過數位簽名，但本地腳本可以自由執行，不需要簽名。</p><p>Unrestricted：這個策略允許所有腳本在系統上執行，不需要簽名。這是最不安全的策略，應謹慎使用。</p><p>Bypass：這個策略完全禁用執行策略，允許所有腳本自由執行。這是一個非常不安全的設置，應該極少使用，如果需要請謹慎使用</p><h1 id="安裝-pnpm"><a href="#安裝-pnpm" class="headerlink" title="安裝 pnpm"></a>安裝 pnpm</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g pnpm</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/pnpm/">pnpm</category>
      
      <category domain="https://gahgah147.github.io/tags/windows/">windows</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/26/%E5%9C%A8Windows%E4%B8%8A%E5%AE%89%E8%A3%9D-pnpm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用docker執行jenkins</title>
      <link>https://gahgah147.github.io/2023/09/23/%E4%BD%BF%E7%94%A8docker%E5%9F%B7%E8%A1%8Cjenkins/</link>
      <guid>https://gahgah147.github.io/2023/09/23/%E4%BD%BF%E7%94%A8docker%E5%9F%B7%E8%A1%8Cjenkins/</guid>
      <pubDate>Sat, 23 Sep 2023 07:22:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;使用docker執行jenkins&quot;&gt;&lt;a href=&quot;#使用docker執行jenkins&quot; class=&quot;headerlink&quot; title=&quot;使用docker執行jenkins&quot;&gt;&lt;/a&gt;使用docker執行jenkins&lt;/h1&gt;&lt;h2 id=&quot;拉取doc</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="使用docker執行jenkins"><a href="#使用docker執行jenkins" class="headerlink" title="使用docker執行jenkins"></a>使用docker執行jenkins</h1><h2 id="拉取docker-hub上的jenkins-image"><a href="#拉取docker-hub上的jenkins-image" class="headerlink" title="拉取docker hub上的jenkins image"></a>拉取docker hub上的jenkins image</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure><h2 id="運行docker-鏡像命令"><a href="#運行docker-鏡像命令" class="headerlink" title="運行docker 鏡像命令"></a>運行docker 鏡像命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -u root \</span><br><span class="line">  --rm \</span><br><span class="line">  -d \</span><br><span class="line">  -p 8081:8080 \</span><br><span class="line">  -p 50000:50000 \</span><br><span class="line">  -v jenkins-data:/root/docker/jenkins_home \</span><br><span class="line">  -v $PWD/allure-results:/allure-results \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  jenkinsci/blueocean</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HJaG4-2y6.png"></p><blockquote><p>執行後可以看見docker 運行的狀況</p></blockquote><h2 id="打開8081-port，登入jenkins首頁"><a href="#打開8081-port，登入jenkins首頁" class="headerlink" title="打開8081 port，登入jenkins首頁"></a>打開8081 port，登入jenkins首頁</h2><p><img src="https://hackmd.io/_uploads/SyJLEWnJp.png"><br><a href="http://localhost:8081/">http://localhost:8081/</a></p><h2 id="進入容器取得管理員密碼"><a href="#進入容器取得管理員密碼" class="headerlink" title="進入容器取得管理員密碼"></a>進入容器取得管理員密碼</h2><p>點擊docker<br><img src="https://hackmd.io/_uploads/rytAVWhkT.png"></p><p><img src="https://hackmd.io/_uploads/BydZSbnyT.png"></p><blockquote><p>點擊 Terminal </p></blockquote><p>輸入 cat &#x2F;var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword<br>可以拿到密碼</p><h2 id="選擇插件，安装jenkins，等待即可完成"><a href="#選擇插件，安装jenkins，等待即可完成" class="headerlink" title="選擇插件，安装jenkins，等待即可完成"></a>選擇插件，安装jenkins，等待即可完成</h2><p><img src="https://hackmd.io/_uploads/HJlSPZ21a.png"><br>設定系統管理員帳號後就可以使用了</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/docker/">docker</category>
      
      <category domain="https://gahgah147.github.io/tags/jenkins/">jenkins</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/23/%E4%BD%BF%E7%94%A8docker%E5%9F%B7%E8%A1%8Cjenkins/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Pytest 自動測試</title>
      <link>https://gahgah147.github.io/2023/09/22/Pytest-%E8%87%AA%E5%8B%95%E6%B8%AC%E8%A9%A6/</link>
      <guid>https://gahgah147.github.io/2023/09/22/Pytest-%E8%87%AA%E5%8B%95%E6%B8%AC%E8%A9%A6/</guid>
      <pubDate>Fri, 22 Sep 2023 08:59:32 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Pytest-指令&quot;&gt;&lt;a href=&quot;#Pytest-指令&quot; class=&quot;headerlink&quot; title=&quot;Pytest 指令&quot;&gt;&lt;/a&gt;Pytest 指令&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;t</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Pytest-指令"><a href="#Pytest-指令" class="headerlink" title="Pytest 指令"></a>Pytest 指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest &lt;.py 檔案位置&gt;</span><br></pre></td></tr></table></figure><p>範例：pytest .\day_03\test_demo.py</p><h2 id="參數執行"><a href="#參數執行" class="headerlink" title="參數執行"></a>參數執行</h2><p>1.列出每個 test case 的執行狀況</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -v &lt;目錄 or 檔案位置&gt;</span><br></pre></td></tr></table></figure><p>2.會印出在 test case 內有 print 出來的數值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s &lt;目錄 or 檔案位置&gt;</span><br></pre></td></tr></table></figure><p>3.不同的參數間，也可以進行混用，這邊進行簡單的範例展示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s -v &lt;目錄 or 檔案位置&gt;：</span><br></pre></td></tr></table></figure><h1 id="產生報表"><a href="#產生報表" class="headerlink" title="產生報表"></a>產生報表</h1><h2 id="產出-JSON-格式報表"><a href="#產出-JSON-格式報表" class="headerlink" title="產出 JSON 格式報表"></a>產出 JSON 格式報表</h2><h3 id="安裝-pytest-json-report-套件"><a href="#安裝-pytest-json-report-套件" class="headerlink" title="安裝 pytest-json-report 套件"></a>安裝 pytest-json-report 套件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-json-report </span><br></pre></td></tr></table></figure><h3 id="套件使用"><a href="#套件使用" class="headerlink" title="套件使用"></a>套件使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest &lt;pytest 原生參數 ex: -s -v&gt; --json-report --json-report-file=&lt;檔案名稱 or ./目錄位置/檔案名稱&gt; &lt;要執行的 .py 檔案 (可省略直接對整個目錄做讀取)&gt;</span><br></pre></td></tr></table></figure><p>使用範例：pytest -s -v –json-report –json-report-file&#x3D;.\report\report.json .\test_demo.py</p><h3 id="報表結果解析"><a href="#報表結果解析" class="headerlink" title="報表結果解析"></a>報表結果解析</h3><table><thead><tr><th>Column 1</th><th>Column 2</th></tr></thead><tbody><tr><td>duration</td><td>本次測試執行所耗費的時間</td></tr><tr><td>root</td><td>從哪個目錄下 pytest 指令的</td></tr><tr><td>environment</td><td>一些環境的設定，例如 Python 版本</td></tr><tr><td>summary</td><td>測試結果總攬，collected 的部份表示 pytest 從 root 開始往下蒐集到多少個 test case</td></tr><tr><td>collectors</td><td>蒐集 test case 的過程</td></tr><tr><td>tests</td><td>測試的詳細結果，包含 setup、teardown 和 test case 本身的執行過程、時間</td></tr></tbody></table><h2 id="產出-HTML-報表"><a href="#產出-HTML-報表" class="headerlink" title="產出 HTML 報表"></a>產出 HTML 報表</h2><h3 id="安裝-pytest-html-套件"><a href="#安裝-pytest-html-套件" class="headerlink" title="安裝 pytest-html 套件"></a>安裝 pytest-html 套件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-html</span><br></pre></td></tr></table></figure><h3 id="套件使用-1"><a href="#套件使用-1" class="headerlink" title="套件使用"></a>套件使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --html=&lt;檔案名稱.html or .\目錄位置\檔案名稱.html&gt; &lt;執行的 .py 檔，省略會直接對整個目錄執行&gt;</span><br></pre></td></tr></table></figure><p>使用範例：pytest –html&#x3D;.\report\report.html .\test_demo.py</p><p><img src="https://hackmd.io/_uploads/r1hrz_F1p.png"></p><h2 id="Allure"><a href="#Allure" class="headerlink" title="Allure"></a>Allure</h2><h3 id="安裝-Java-JDK"><a href="#安裝-Java-JDK" class="headerlink" title="安裝 Java JDK"></a>安裝 Java JDK</h3><p>可參考這篇安裝 Java JDK<br><a href="https://medium.com/@pierre.viara/install-java-on-windows-10-linux-subsystem-875f1f286ee8">https://medium.com/@pierre.viara/install-java-on-windows-10-linux-subsystem-875f1f286ee8</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SyTX8dF1p.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Hkbrv_Yyp.png"></p><p>可以用 java –version 確認是否安裝成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --version</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJqUvOY16.png"></p><h3 id="安裝-Allure"><a href="#安裝-Allure" class="headerlink" title="安裝 Allure"></a>安裝 Allure</h3><p>下載地址: <a href="https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/">https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/</a></p><p>可以選擇適合的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/2.9.0/allure-commandline-2.9.0.tgz</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/rJYSLtK1T.png"></p><p>解壓縮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf allure-commandline-2.9.0.tgz</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SyiLIYtyp.png"></p><p>設定環境</p><p>進入解壓縮後的資料夾獲得絕對路徑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd allure-2.9.0/bin/</span><br><span class="line"></span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>建立軟連結</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/user/allure-2.9.0/bin/allure /usr/bin/allure</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJ3BtFYk6.png"></p><blockquote><p>完成後輸入 allure –version 可以驗證是否安裝成功</p></blockquote><h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install allure-pytest</span><br></pre></td></tr></table></figure><h3 id="執行測試與生成報表"><a href="#執行測試與生成報表" class="headerlink" title="執行測試與生成報表"></a>執行測試與生成報表</h3><p>方法一<br>執行測試並產生 allure 暫存檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest &lt;測試檔案 or 目錄&gt; --alluredir &lt;allure 暫存檔存放位置&gt;</span><br></pre></td></tr></table></figure><p>使用 allure 暫存檔生成報表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allure generate &lt;allure 暫存檔存放位置&gt; -o &lt;輸出報表位置&gt; --clean</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install allure-pytest</span><br></pre></td></tr></table></figure><p>執行測試並產生 allure 暫存檔<br>py.test –alluredir&#x3D;&lt;allure 暫存檔存放位置&gt; &lt;測試檔案 or 目錄&gt;</p><p>使用 allure 暫存檔生成報表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allure serve &lt;allure 暫存檔存放位置&gt;</span><br></pre></td></tr></table></figure><div class="note warning simple"><p>目前測試產生的</p></div><h3 id="使用docker-compose在docker容器中運行pytest"><a href="#使用docker-compose在docker容器中運行pytest" class="headerlink" title="使用docker-compose在docker容器中運行pytest"></a>使用docker-compose在docker容器中運行pytest</h3><div class="note info simple"><p>參考文章: <a href="https://geek-docs.com/pytest/pytest-questions/9_pytest_how_to_run_pytest_from_a_docker_container_within_dockercompose.html">https://geek-docs.com/pytest/pytest-questions/9_pytest_how_to_run_pytest_from_a_docker_container_within_dockercompose.html</a></p></div><p>安裝套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest pytest-docker</span><br></pre></td></tr></table></figure><h1 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h1><h2 id="setup、teardown"><a href="#setup、teardown" class="headerlink" title="setup、teardown"></a>setup、teardown</h2><p>在 function 等級設定 setup、teardown 時，會於每個 function 的開始以及結束時都會執行一次</p><h3 id="建立-env-檔案"><a href="#建立-env-檔案" class="headerlink" title="建立 .env 檔案"></a>建立 .env 檔案</h3><p>env 檔案當中時常會保留我們不想要進入版本控制的重要資訊</p><div class="note info simple"><p>注意： github 上的專案並沒有把 .env 推上去，若想使用請自行建立</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ACCOUNT=&quot;test_account_123&quot;</span><br><span class="line">PASSWORD=&quot;test_password_123&quot;</span><br></pre></td></tr></table></figure><h3 id="安裝套件-1"><a href="#安裝套件-1" class="headerlink" title="安裝套件"></a>安裝套件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-dotenv</span><br></pre></td></tr></table></figure><h3 id="撰寫測試環境"><a href="#撰寫測試環境" class="headerlink" title="撰寫測試環境"></a>撰寫測試環境</h3><p>建立 test_example.py 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import dotenv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def setup_module():</span><br><span class="line">    dotenv.load_dotenv(&quot;./.env&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_get_env_account():</span><br><span class="line">    print(os.getenv(&quot;ACCOUNT&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_get_env_password():</span><br><span class="line">    print(os.getenv(&quot;PASSWORD&quot;))</span><br></pre></td></tr></table></figure><h2 id="fixture"><a href="#fixture" class="headerlink" title="fixture"></a>fixture</h2><h3 id="目錄架構"><a href="#目錄架構" class="headerlink" title="目錄架構"></a>目錄架構</h3><p><img src="https://hackmd.io/_uploads/ByeEkGglT.png"></p><h3 id="快速建立-fixtures-py-檔案"><a href="#快速建立-fixtures-py-檔案" class="headerlink" title="快速建立 fixtures.py 檔案"></a>快速建立 fixtures.py 檔案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line">import requests</span><br><span class="line">from fake_useragent import FakeUserAgent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;headers&quot;, scope=&quot;function&quot;, autouse=False)</span><br><span class="line">def headers_fixture() -&gt; dict:</span><br><span class="line">    ua = FakeUserAgent()</span><br><span class="line">    headers = &#123;&quot;User-Agent&quot;: ua.random&#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;make_user_agent&quot;, scope=&quot;function&quot;, autouse=False)</span><br><span class="line">def make_user_agent_fixture() -&gt; dict:</span><br><span class="line">    ua = FakeUserAgent()</span><br><span class="line">    headers = &#123;&quot;User-Agent&quot;: ua.random&#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;parse_user_agent&quot;, scope=&quot;function&quot;, autouse=False)</span><br><span class="line">def parse_user_agent_fixture(make_user_agent: dict) -&gt; dict:</span><br><span class="line">    url = &quot;https://httpbin.org/headers&quot;</span><br><span class="line">    res = requests.get(url=url, headers=make_user_agent)</span><br><span class="line">    user_agent = res.json()[&quot;headers&quot;][&#x27;User-Agent&#x27;]</span><br><span class="line"></span><br><span class="line">    return &#123;&quot;User-Agent&quot;: user_agent&#125;</span><br></pre></td></tr></table></figure><h3 id="fixture-裝飾器參數介紹"><a href="#fixture-裝飾器參數介紹" class="headerlink" title="fixture 裝飾器參數介紹"></a>fixture 裝飾器參數介紹</h3><table><thead><tr><th>參數</th><th>功能</th></tr></thead><tbody><tr><td>scope</td><td>表示作用域，預設為 “function”，亦即每個有用到此 fixture 的 test case 都會執行，另外還有 module、class 以及 session 三種</td></tr><tr><td>name</td><td>用來設定 fixture 的別名，預設為函式名稱</td></tr><tr><td>autouse</td><td>預設為 False，若為 True，則會自動進行使用 (根據 scope 作用域而定)</td></tr></tbody></table><h3 id="程式解釋"><a href="#程式解釋" class="headerlink" title="程式解釋"></a>程式解釋</h3><p>利用 @pytest.fixture 標註該函式為 fixture<br>利用 fake_useragent 隨機生成一個 User-Agent (需另外安裝 fake-useragent 套件)<br>回傳 headers 給有使用此 fixture 的 test case</p><h3 id="使用-fixture"><a href="#使用-fixture" class="headerlink" title="使用 fixture"></a>使用 fixture</h3><p>接著我們回到 test_demo.py 當中，來使用剛剛所製作的 fixture。使用的方式則非常簡單，首先我們必須將剛剛撰寫好的 fixture 的 function 給 import 進來，這樣 pytest 才抓地到，接著只需要在 test case 接收參數的地方打上剛剛為 fixture 命名的名稱 (若無則預設為 fixture 的 function name)，接著我們就可以在 test case 內使用此 fixture 回傳出的內容了。</p><p>1.將要使用 fixture 先進行 import</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from fixtures import headers_fixture, parse_user_agent_fixture, make_user_agent_fixture</span><br></pre></td></tr></table></figure><p>2.利用 <a href="https://httpbin.org/headers">https://httpbin.org/headers</a> 來取得我們送出去的 headers</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def test_assert_headers(headers: dict):</span><br><span class="line">    url = &quot;https://httpbin.org/headers&quot;</span><br><span class="line">    res = requests.get(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line">    print(res.status_code)</span><br><span class="line">    print(res.json())</span><br><span class="line"></span><br><span class="line">    assert res.status_code == 200</span><br><span class="line">    assert res.json()[&#x27;headers&#x27;][&quot;User-Agent&quot;] == headers[&quot;User-Agent&quot;]</span><br></pre></td></tr></table></figure><p>3.最後驗證取得的 headers 和我們利用 fixture 製作的 headers 是否相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def test_assert_user_agent(make_user_agent: dict, parse_user_agent: dict):</span><br><span class="line">    assert make_user_agent == parse_user_agent</span><br></pre></td></tr></table></figure><p>備註：本測試範例只使用了一個 fixture 作為展示，實際上一個 test case 可以同時使用多個 fixture 是沒問題的</p><h3 id="fixture-使用時機"><a href="#fixture-使用時機" class="headerlink" title="fixture 使用時機"></a>fixture 使用時機</h3><ol><li><p>為 test case 建立環境時<br> 若是有很多個 test case 在測試前需要做一些環境的建置、參數的準備，則很適合適用 fixture</p></li><li><p>當你不想使用 setup、teardown 時<br> 由於使用 setup、teardown 會造成該 .py 檔內的所有 test case 都被引響，而 fixture 若沒有被寫在 test case 接收的參數內，則不會被影響 (除非作用域不為 function 且 autouse&#x3D;False)</p></li></ol><p>以上練習是參考 iTHome 鐵人賽 Python 與自動化測試的敲門磚 文章跟著練習的內容</p><h1 id="虛擬資料庫"><a href="#虛擬資料庫" class="headerlink" title="虛擬資料庫"></a>虛擬資料庫</h1><h2 id="虛擬關聯式資料庫-SQLite"><a href="#虛擬關聯式資料庫-SQLite" class="headerlink" title="虛擬關聯式資料庫 SQLite"></a>虛擬關聯式資料庫 SQLite</h2><h3 id="專案架構介紹"><a href="#專案架構介紹" class="headerlink" title="專案架構介紹"></a>專案架構介紹</h3><p><img src="https://hackmd.io/_uploads/BJaRufglp.png"></p><table><thead><tr><th>檔案</th><th>功能</th></tr></thead><tbody><tr><td>crud.py</td><td>存放對資料庫做 CRUD 操作的函式</td></tr><tr><td>fixtures.py</td><td>存放使用 pytest 製作出的 fixture</td></tr><tr><td>models.py</td><td>存放 sqlalchemy 建立的 ORM 架構</td></tr><tr><td>test_demo.py</td><td>存放 test case</td></tr></tbody></table><h3 id="資料庫路徑"><a href="#資料庫路徑" class="headerlink" title="資料庫路徑"></a>資料庫路徑</h3><p>用在將資料庫與 ORM 架構做連線時的資料庫位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database_name&gt;</span><br></pre></td></tr></table></figure><p>今天要介紹的虛擬關聯式資料庫，是使用 SQLite 所提供的 In-memory 的資料庫，使用的路徑非常簡單，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite://</span><br></pre></td></tr></table></figure><p>且由於 python 內自帶 sqlite 的套件，所以只要將上面的路徑放入資料庫連線的路徑，電腦就會動使用記憶體協助我們進行資料表的建立以及操作</p><h3 id="建立測試內容"><a href="#建立測試內容" class="headerlink" title="建立測試內容"></a>建立測試內容</h3><p>這邊我們會先簡單介紹放在 models 的內容以及要被測試的 CRUD 的函式</p><p>models.py<br>建立一張名為 User 的資料表並且有 id 、 username 以及 birthday 三個欄位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy import String, Column, Integer, DATETIME</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class User(Base):</span><br><span class="line">    __tablename__ = &quot;user&quot;</span><br><span class="line">    id: int = Column(Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    username: str = Column(String(64))</span><br><span class="line">    birthday: datetime = Column(DATETIME)</span><br></pre></td></tr></table></figure><p>crud.py<br>建立一個可以利用 sqlalchemy 寫入資料的 function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy.orm import Session</span><br><span class="line">from models import User</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_user_in_sqlite(data: User, session: Session) -&gt; User:</span><br><span class="line">    session.add(data)</span><br><span class="line">    session.commit()</span><br><span class="line">    session.refresh(data)</span><br><span class="line"></span><br><span class="line">    return data</span><br></pre></td></tr></table></figure><h3 id="建立-fixture"><a href="#建立-fixture" class="headerlink" title="建立 fixture"></a>建立 fixture</h3><p>接下來就是重點了，sqlalchemy 實際對資料庫進行操作的時後，需要一個 session 物件來協助我們進行操作，接下來我們就要利用 fixture 來替我們在測試前做建立資料表以及產生一個 session 的動作</p><p>程式解析：</p><p>利用剛剛所介紹的方法，先建立一個 engine 並與虛擬的 sqlite 進行連線<br>在測試之前我們先利用 fixture 替我們將資料表建立好，這樣在測試的過程中就不需要再花時間在撰寫建立環境的部分<br>接著我們實際建立一個 session 並 yield 出去<br>使用 yield 的原因是，當 test case 結束後，就會回到 fixture 內執行接下來的動作<br>由於式使用 with 進行 session 的建立，因此也 test case 結束後回到 fixture 內，此 session 會自動關閉<br>最後 test case 結束會到 fixture 內將資料表全部刪除，確保下一個 test case 有乾淨的環境做測試</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.orm import Session, sessionmaker</span><br><span class="line">from models import Base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;sqlite_session&quot;)</span><br><span class="line">def sqlite_session_fixture() -&gt; Session:</span><br><span class="line">    # 建立 engine</span><br><span class="line">    engine_url = &quot;sqlite://&quot;</span><br><span class="line">    engine = create_engine(engine_url)</span><br><span class="line"></span><br><span class="line">    # 建立資料表</span><br><span class="line">    Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line">    #  yield 出 Session</span><br><span class="line">    with sessionmaker(bind=engine)() as session:</span><br><span class="line">        yield session</span><br><span class="line"></span><br><span class="line">    # 刪除資料表</span><br><span class="line">    Base.metadata.drop_all(engine)</span><br></pre></td></tr></table></figure><h3 id="建立測試程式"><a href="#建立測試程式" class="headerlink" title="建立測試程式"></a>建立測試程式</h3><p>接下來就來就準備撰寫 test case 了，一樣附上程式碼並逐行解釋</p><p>程式解析：</p><p>將所使用到的套件分別進行 import<br>建立 test case 並使用 fixture sqlite_session 並提示 IDE 此為一個 Session 型態的參數<br>利用 User 建立一個測試資料<br>利用 crud 內的函式對資料庫測式寫入<br>驗證寫入函式回傳出的 username 是否和我們手動建立的 username 是否一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from crud import create_user_in_sqlite</span><br><span class="line">from models import User</span><br><span class="line">from fixtures import sqlite_session_fixture</span><br><span class="line">from sqlalchemy.orm import Session</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">use_fixtures = [sqlite_session_fixture]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_create_user_in_sqlite(sqlite_session: Session):</span><br><span class="line">    data = User(username=&quot;test_user&quot;, birthday=datetime.now())</span><br><span class="line"></span><br><span class="line">    result: User = create_user_in_sqlite(data=data, session=sqlite_session)</span><br><span class="line">    print(result.__dict__)</span><br><span class="line"></span><br><span class="line">    assert result.username == data.username</span><br></pre></td></tr></table></figure><div class="note info simple"><p>測試需要安裝套件<br>pip install sqlalchemy</p></div><h3 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h3><p>接著我們就可以利用 pytest 對 test_demo.py 進行測試了，下方為測試結果截圖<br><img src="https://hackmd.io/_uploads/Hy_SRflxT.png"></p><h2 id="NoSQL-陣營的虛擬資料庫套件-MongoMock"><a href="#NoSQL-陣營的虛擬資料庫套件-MongoMock" class="headerlink" title="NoSQL 陣營的虛擬資料庫套件 - MongoMock"></a>NoSQL 陣營的虛擬資料庫套件 - MongoMock</h2><h3 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h3><p>pymongo：正式用來撰寫 mongo 相關的 CRUD 時常用的套件，crud.py 內的 MongoClient，會由此套件產生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymongo</span><br></pre></td></tr></table></figure><p>mongomock：協助用來建立一個虛擬的 MongoClient 讓我們可以透過 fixture 的方式來進行 crud.py 的測試</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mongomock</span><br></pre></td></tr></table></figure><h3 id="建立-crud"><a href="#建立-crud" class="headerlink" title="建立 crud"></a>建立 crud</h3><p>這邊會在 crud.py 檔案內建立一個寫入資料的方式，直接附上範例並進行解說</p><div class="note warning simple"><p>注意：在正式的專案檔案中 (即非測試程式) 需要使用 pymongo 所提供的 MongoClient，才不會造成不可避免的錯誤</p></div><p>程式解析：</p><p>import pymongo 的 MongoClient，進行 mongo 的 CRUD<br>建立一個 insert_user 函式<br>進行資料的寫入<br>寫入的同時取得 id<br>寫入完畢後透過 id 查詢該筆資料並回傳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pymongo.mongo_client import MongoClient</span><br><span class="line"></span><br><span class="line">database_name = &quot;test&quot;</span><br><span class="line">collection_name = &quot;user&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def insert_user(conn: MongoClient, data: dict) -&gt; dict:</span><br><span class="line">    # 插入資料並取得 id</span><br><span class="line">    insert_id = conn[database_name][collection_name].insert_one(data).inserted_id</span><br><span class="line"></span><br><span class="line">    # 藉由 id 搜尋並回傳</span><br><span class="line">    result = conn[database_name][collection_name].find_one(&#123;&quot;_id&quot;: insert_id&#125;)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure><h3 id="建立-fixtures"><a href="#建立-fixtures" class="headerlink" title="建立 fixtures"></a>建立 fixtures</h3><p>接著我們要利用 MongoMock 所提供的 MongoClient 來進行 fixture 的撰寫，在開頭有提到，MongoMock 可以很好的兼容 PyMongo，因此我們可以直接使用 MongoMock 的 MongoClient 來進行 CRUD 的測試，範例如下</p><p>注意：雖然 MongoMock 可以很好的兼容 PyMongo 不過由於版本問題，某些功能還是會無法使用，因此若測試過程中有跳錯，請留意一下錯誤訊息，看看是否為 MongoMock 還沒支援相關功能</p><p>程式解析：</p><p>import mongomock 的 MongoClient<br>建立一個 fixture 命名為 conn<br>利用 mongomock 的 MongoClient 建立一個虛擬的連線<br>透過 yield 回傳出去給 test case 使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line">from mongomock.mongo_client import MongoClient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;conn&quot;)</span><br><span class="line">def mongo_client_fixture() -&gt; MongoClient:</span><br><span class="line">    with MongoClient() as conn:</span><br><span class="line">        yield conn</span><br></pre></td></tr></table></figure><h3 id="test-case-建立"><a href="#test-case-建立" class="headerlink" title="test case 建立"></a>test case 建立</h3><p>最後我們要來建立測試程式了，直接附上範例進行解釋</p><p>程式解析：</p><p>將需要使用到的套件 import 進來<br>建立一筆假資料<br>調用 crud 當中的 insert_user 進行寫入測試<br>驗證回傳出的資料是否和我們建立的假資料內容一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from pymongo.mongo_client import MongoClient</span><br><span class="line">from fixtures import mongo_client_fixture</span><br><span class="line">from crud import insert_user</span><br><span class="line"></span><br><span class="line">use_fixtures = [mongo_client_fixture]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_insert_user(conn: MongoClient):</span><br><span class="line">    # 建立假資料</span><br><span class="line">    data = &#123;&quot;username&quot;: &quot;nick&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;test@test&quot;,</span><br><span class="line">            &quot;birthday&quot;: datetime(year=2022, month=12, day=31)&#125;</span><br><span class="line">    </span><br><span class="line">    # 測試 CRUD 方法</span><br><span class="line">    result = insert_user(data=data, conn=conn)</span><br><span class="line">    print(result)</span><br><span class="line">    </span><br><span class="line">    # 驗證內容</span><br><span class="line">    assert result[&quot;username&quot;] == data[&quot;username&quot;]</span><br><span class="line">    assert result[&quot;email&quot;] == data[&quot;email&quot;]</span><br><span class="line">    assert result[&quot;birthday&quot;] == data[&quot;birthday&quot;]</span><br></pre></td></tr></table></figure><h1 id="驗證錯誤與跳過案例"><a href="#驗證錯誤與跳過案例" class="headerlink" title="驗證錯誤與跳過案例"></a>驗證錯誤與跳過案例</h1><h2 id="驗證錯誤"><a href="#驗證錯誤" class="headerlink" title="驗證錯誤"></a>驗證錯誤</h2><p>程式解析：</p><p>建立 raise_error 函式來手動引發一個錯誤<br>於 test_error 內使用 pytest.raises(IndexError) 來驗證函式引發的錯誤種類是否如預期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def raise_error():</span><br><span class="line">    raise IndexError(&quot;list 的位置錯誤&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_error():</span><br><span class="line">    with pytest.raises(IndexError):</span><br><span class="line">        raise_error()</span><br></pre></td></tr></table></figure><p>注意：經筆者測試，在 pytest 驗證到預期內的錯誤訊息後，無法在同個 with 區域內進行其他驗證，都會顯示正確，若有需要驗證其他錯誤 or 案例，則需另開一個 with，或是將程式寫在 with 外部</p><p>如下方程式所示，手動驗證一個錯誤的條件需要寫在接收到預期錯誤的 with 區域之外，才會被檢查到錯誤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_error():</span><br><span class="line">    with pytest.raises(IndexError):</span><br><span class="line">        raise_error()</span><br><span class="line"></span><br><span class="line">    assert 1 + 1 == 3</span><br></pre></td></tr></table></figure><h3 id="驗證錯誤訊息"><a href="#驗證錯誤訊息" class="headerlink" title="驗證錯誤訊息"></a>驗證錯誤訊息</h3><p>pytest.raises() 除了在接收到預期內的錯誤不會報錯之外，我們也可以針對錯誤訊息的內容進行驗證</p><p>程式解析：</p><p>with pytest.raises(IndexError) as exc 我們可以理解成把接收到的錯誤丟給一個叫做 exc 的變數，並於外部做使用<br>驗證錯誤訊息的內容<br>驗證錯誤訊息的 class name</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def test_error_message():</span><br><span class="line">    # 將接收到的錯誤丟給一個名為 exc 的變數，該變數可於外部使用</span><br><span class="line">    with pytest.raises(IndexError) as exc:</span><br><span class="line">        raise_error()</span><br><span class="line">    </span><br><span class="line">    # 印出錯誤訊息內容並驗證</span><br><span class="line">    print(str(exc.value))</span><br><span class="line">    assert str(exc.value) == &quot;list 的位置錯誤&quot;</span><br><span class="line">    </span><br><span class="line">    # 印出錯誤訊息類別並驗證</span><br><span class="line">    print(str(exc.typename))</span><br><span class="line">    assert exc.typename == IndexError.__name__</span><br></pre></td></tr></table></figure><h3 id="跳過-test-case"><a href="#跳過-test-case" class="headerlink" title="跳過 test case"></a>跳過 test case</h3><p>某些情況下，我們可能會不想讓一些 test case 被執行，比方說某個 function 只能用在某個版本的時候，或是在某種作業系統上該函式使用的套件會失效，又或是暫時不想刪除，碰到這類的情況 pytest 有提供了跳過的功能，分別為 skip 和 skipif</p><p>為了測試方便，我們會將接下來的兩個範例連同上面所撰寫的兩個 test case 一起執行，並且觀察 pytest 收集到的 test case 數量</p><h3 id="直接跳過-skip"><a href="#直接跳過-skip" class="headerlink" title="直接跳過 skip"></a>直接跳過 skip</h3><p>程式解析：</p><p>利用 @pytest.mark.skip() 裝飾器的方式來標註該案例需要跳過<br>reason 則是用來撰寫跳過的原因，該原因會被印在 terminal 上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@pytest.mark.skip(reason=&quot;測試案例跳過範例&quot;)</span><br><span class="line">def test_skip_test_case():</span><br><span class="line">    assert 1 + 1 == 3</span><br></pre></td></tr></table></figure><p>結果展示：</p><p>可以看到下方圖片中，pytest 有成功蒐集到三個 test case，而第三個 test case 狀態為 SKIPPED 並且原因印出於狀態後方</p><h3 id="有條件跳過-skipif"><a href="#有條件跳過-skipif" class="headerlink" title="有條件跳過 skipif"></a>有條件跳過 skipif</h3><p>我們可以透過指定 sys 內的條件來進行跳過，下方的範例就是讀取目前的作業系統，如果為 “win32” 就不執行此範例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.skipif(condition=sys.platform == &quot;win32&quot;, reason=&quot;測試跳過指定條件範例&quot;)</span><br><span class="line">def test_skip_test_case_by_condition():</span><br><span class="line">    assert 1 + 1 == 4</span><br></pre></td></tr></table></figure><p>另外我們可以透過印出 sys 內的物件及屬性，來查看有哪些條件可以支援</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dir(sys))</span><br></pre></td></tr></table></figure><h1 id="parametrize-自動生成多筆測試"><a href="#parametrize-自動生成多筆測試" class="headerlink" title="parametrize 自動生成多筆測試"></a>parametrize 自動生成多筆測試</h1><p>今天我們要介紹如何利用 pytest 提供的 parametrize 來自動生成多筆測試，這個方式通常用於硬體的測試，需要使用很多不同的數值來對某個功能做測試，例如：USB 寫入速度跟寫入的檔案大小，但測試的 function 其實是一樣的，像這種情況我們就不需要撰寫多個 test case，利用 parametrize 的方式來進行測試即可</p><h2 id="簡單範例"><a href="#簡單範例" class="headerlink" title="簡單範例"></a>簡單範例</h2><p>下面我們直接上範例來進行解釋</p><p>程式解析：</p><p>利用裝飾器的方式來進行 parametrize 的撰寫<br>argnames 為一組字串，分別要對應到 test case 內所需接收的參數<br>注意：請不要將格式寫成　‘num1’, ‘num2’… 應該將所有名稱包在同一組字串內，如　‘num1, num2, …’<br>argvalues 用一個串列包起來並將每一組測試資料也用一個串列包起來，形成一個二維串列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 基本範例</span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=[(1, 1, 2), (2, 2, 4)])</span><br><span class="line">def test_add(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/S1iE5IZea.png"></p><h2 id="搭配檔案讀取"><a href="#搭配檔案讀取" class="headerlink" title="搭配檔案讀取"></a>搭配檔案讀取</h2><p>除此之外，我們也可以將多組測試參數寫進檔案中，在測試之前先讀取進 python 中，於裝飾器內再指派給 test case</p><p>test_args.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;test_add&quot;: [[1, 1, 2], [2, 2, 4]]&#125;</span><br></pre></td></tr></table></figure><p>test_demo.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 搭配檔案讀取</span><br><span class="line">with open(&quot;./test_args.json&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as file:</span><br><span class="line">    test_args = json.loads(file.read())[&#x27;test_add&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=test_args)</span><br><span class="line">def test_add_with_json_file(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkDTqLWxT.png"></p><blockquote><p>測試結果</p></blockquote><h2 id="ids-的使用"><a href="#ids-的使用" class="headerlink" title="ids 的使用"></a>ids 的使用</h2><p>如果同時生成許多組測試，可能會造成閱讀上的不易，這時候我們可以透過 ids 來為每一組測試提供名稱</p><p>這邊我們會沿用上方讀取 json 後產生的 test_args，並手動根據 test_args 的長度來建立相關的 id，當然 ids 也可以利用讀取檔案的方式讀取近來，只要數量符合測試資料筆數，且型態為 list 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ids 的使用</span><br><span class="line">ids = [f&quot;case: &#123;i&#125;&quot; for i in range(1, len(test_args) + 1)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=test_args, ids=ids)</span><br><span class="line">def test_add_with_json_file_and_ids(num1: int, num2: int, result: int):</span><br><span class="line">    assert num1 + num2 == result</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJkFiIbx6.png"></p><blockquote><p>可以看到 pytest 成功為我們的每組測試都加上名稱</p></blockquote><h2 id="搭配-fixture-做使用"><a href="#搭配-fixture-做使用" class="headerlink" title="搭配 fixture 做使用"></a>搭配 fixture 做使用</h2><p>網路上有很多 fixture 搭配 parametrize 的使用方式，不過筆者試了一下，發現 fixture 其實可以很直覺的 import 進來直接使用，請看下面範例</p><p>fixtures.py<br>建立一個 fixture 用來展示用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line">from mongomock.mongo_client import MongoClient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;conn&quot;)</span><br><span class="line">def mongo_client_fixture() -&gt; MongoClient:</span><br><span class="line">    with MongoClient() as conn:</span><br><span class="line">        yield conn</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>test_demo.py<br>可以看到在這個 test case 當中，直接將 import 進來的 fixture name 打在 test case 最後面的參數，即可進行使用，請務必將 fixture 放在最尾端避免造成額外的錯誤</p><p>為了驗證是否真的有被 import 近來，第二個 assert 的部分為驗證 conn 參數是否為 MongoClient 型態，而非 None</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from fixtures import mongo_client_fixture</span><br><span class="line">from mongomock.mongo_client import MongoClient</span><br><span class="line"></span><br><span class="line">use_fixtures = [mongo_client_fixture]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 搭配 fixture 使用</span><br><span class="line">@pytest.mark.parametrize(argnames=&#x27;num1, num2, result&#x27;, argvalues=[(1, 1, 2), (2, 2, 4)])</span><br><span class="line">def test_add_with_fixtures(num1: int, num2: int, result: int, conn: MongoClient):</span><br><span class="line">    assert num1 + num2 == result</span><br><span class="line">    assert isinstance(conn, MongoClient)</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SJEtnoMe6.png"></p><h1 id="conftest-py"><a href="#conftest-py" class="headerlink" title="conftest.py"></a>conftest.py</h1><h2 id="conftest-py-簡介"><a href="#conftest-py-簡介" class="headerlink" title="conftest.py 簡介"></a>conftest.py 簡介</h2><p>白話來說 conftest.py 就是一個可以讓我們存放 “經常被使用到” 的 fixture 的地方，被存放在 conftest.py 當中的 fixture 不需要透過 import就可以直接進行使用，pytest 在一開始執行時，就會先去抓是否有 conftest.py 的存在，因此若今天發現你的 fixture 被許多個 test module 使用到的話不彷可以試著將 fixture 放到 conftest.py 當中</p><p>順帶一提 conftest.py 的有效範圍是從 conftest.py 所存在的當前目錄以及其所有子目路中的 test case 都可以使用，若於不同目錄則需要另外寫一個 conftest.py</p><p>在本次的範例當中，會利用新增 pytest cmd argument 的方式來進行範例展示，下方附上本次專案目錄的結構</p><p><img src="https://hackmd.io/_uploads/SJuMajGeT.png"></p><h2 id="範例展示"><a href="#範例展示" class="headerlink" title="範例展示"></a>範例展示</h2><h3 id="建立-conftest-py"><a href="#建立-conftest-py" class="headerlink" title="建立 conftest.py"></a>建立 conftest.py</h3><p>conftest.py</p><ul><li>pytest_addoption 為 pytest 內建的 fixture，可以自定使用 cmd 執行時的參數</li><li>建立一個名為 permission 的參數，用來識別權限</li><li>建立 permission_fixture 用來讀取權限檔案，來識別使用者可以測試的範圍</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pytest_addoption(parser):</span><br><span class="line">    parser.addoption(&quot;--permission&quot;, default=&quot;RD&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(name=&quot;permission&quot;)</span><br><span class="line">def permission_fixture(pytestconfig):</span><br><span class="line">    role = pytestconfig.getoption(&quot;permission&quot;)</span><br><span class="line">    with open(&quot;./permission.json&quot;, &quot;r&quot;) as file:</span><br><span class="line">        permission_data = json.loads(file.read())</span><br><span class="line">    if role == &quot;RD&quot;:</span><br><span class="line">        permission = permission_data[&quot;RD&quot;]</span><br><span class="line">    else:</span><br><span class="line">        permission = permission_data[&quot;costumer&quot;]</span><br><span class="line"></span><br><span class="line">    return permission</span><br></pre></td></tr></table></figure><h3 id="建立-json-檔用來控制權限"><a href="#建立-json-檔用來控制權限" class="headerlink" title="建立 json 檔用來控制權限"></a>建立 json 檔用來控制權限</h3><p>permission.json</p><ul><li>如果角色是 RD，則可以進行 select、update、delete</li><li>其餘的則定位為 costumer，只能進行 select 的測試<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;RD&quot;: [</span><br><span class="line">    &quot;select&quot;,</span><br><span class="line">    &quot;update&quot;,</span><br><span class="line">    &quot;delete&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;costumer&quot;: [</span><br><span class="line">    &quot;select&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="撰寫-test-case"><a href="#撰寫-test-case" class="headerlink" title="撰寫 test case"></a>撰寫 test case</h3><p>test_demo.py</p><ul><li>大家可以發現，這裡使用 permission 這個 fixture 的時候並沒有像之前一樣進行 import 可以直接使用</li><li>分別有 select、update 兩項測試，並且於測試之前會進行權限的驗證</li><li>於 test_update_permission 的時候，若權限不足則會引發錯誤，並驗證錯誤訊息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_select_permission(permission: list):</span><br><span class="line">    if &quot;select&quot; in permission:</span><br><span class="line">        assert True</span><br><span class="line">    else:</span><br><span class="line">        assert False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_update_permission(permission: list):</span><br><span class="line">    if &quot;update&quot; in permission:</span><br><span class="line">        assert True</span><br><span class="line">    else:</span><br><span class="line">        with pytest.raises(ValueError) as exc:</span><br><span class="line">            raise ValueError(&quot;permission not allow&quot;)</span><br><span class="line"></span><br><span class="line">        print(str(exc.value))</span><br><span class="line">        assert str(exc.value) == &quot;permission not allow&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="結果展示"><a href="#結果展示" class="headerlink" title="結果展示"></a>結果展示</h3><p>啟動 pytest 指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s -v --permission costumer .\test_demo.py</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/r1iJe2Gxp.png"></p><blockquote><p>可以看到當 permission 為 costumer 時，成功地引發了錯誤並通過錯誤訊息的驗證</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s -v --permission RD .\test_demo.py</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/SkK-ehGxp.png"></p><blockquote><p>當權限為 RD 時，則 update 的部分不會引發錯誤</p></blockquote><h1 id="問題排除"><a href="#問題排除" class="headerlink" title="問題排除"></a>問題排除</h1><h2 id="chrome-driver版本過舊"><a href="#chrome-driver版本過舊" class="headerlink" title="chrome driver版本過舊"></a>chrome driver版本過舊</h2><p>selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 114</p><p>這個原因是 chrome 常常會更新  導致 chrome driver版本過舊</p><p>這時候要到這邊下載最新的<br><a href="https://googlechromelabs.github.io/chrome-for-testing/">https://googlechromelabs.github.io/chrome-for-testing/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/117.0.5938.92/linux64/chromedriver-linux64.zip</span><br></pre></td></tr></table></figure><p>解壓縮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip chromedriver-linux64.zip</span><br></pre></td></tr></table></figure><p>到 chromedriver-linux64 資料夾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd chromedriver-linux64</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mv chromedriver /usr/bin/chromedriver</span><br><span class="line">sudo chown root:root /usr/bin/chromedriver</span><br><span class="line">sudo chmod +x /usr/bin/chromedriver</span><br></pre></td></tr></table></figure><p>參考文章:<br><a href="https://ithelp.ithome.com.tw/articles/10293187">https://ithelp.ithome.com.tw/articles/10293187</a><br><a href="https://blog.csdn.net/qq_24166417/article/details/113850978">https://blog.csdn.net/qq_24166417/article/details/113850978</a><br><a href="https://github.com/nickchen1998/2022_ithelp_marathon">https://github.com/nickchen1998/2022_ithelp_marathon</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Pytest/">Pytest</category>
      
      <category domain="https://gahgah147.github.io/tags/Python/">Python</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/">自動化測試</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/22/Pytest-%E8%87%AA%E5%8B%95%E6%B8%AC%E8%A9%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python 與自動化測試</title>
      <link>https://gahgah147.github.io/2023/09/21/Python-%E8%88%87%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/</link>
      <guid>https://gahgah147.github.io/2023/09/21/Python-%E8%88%87%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/</guid>
      <pubDate>Thu, 21 Sep 2023 06:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇是記錄我在看鐵人賽 &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10290529&quot;&gt;P</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇是記錄我在看鐵人賽 <a href="https://ithelp.ithome.com.tw/articles/10290529">Python 與自動化測試的敲門磚 </a> 的過程</p><h1 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h1><table><thead><tr><th>主題</th><th>日程</th></tr></thead><tbody><tr><td>簡介</td><td>day 01</td></tr><tr><td>Pytest</td><td>day 02 ~ 10</td></tr><tr><td>TDD</td><td>day 11 ~ 12</td></tr><tr><td>Selenium</td><td>day 13 ~ 17</td></tr><tr><td>Appium</td><td>day 18 ~ 21</td></tr><tr><td>CI&#x2F;CD</td><td>day 22 ~ 26</td></tr><tr><td>Jenkins</td><td>day 27 ~ 29</td></tr><tr><td>結語</td><td>day 30</td></tr></tbody></table><h1 id="Pytest"><a href="#Pytest" class="headerlink" title="Pytest"></a>Pytest</h1><p>Pytest 是一種使用在 Python 語言裡面的一中單元測試框架，而 Pytest 基本上就是由 Python 原生自帶的單元測試框架 Unittest 衍生出來的，所以可以看到有些範例可以和 Unittest 的套件互相兼容混用。</p><p>Pytest 和 Unittest 相比，有下列幾項優點：</p><ol><li>更易於上手，撰寫 testcase 時較為直覺</li><li>擴展性高，可以兼容許多外掛套件</li><li>可以標註某些 testcase 為失敗是正常的</li><li>測試程式撰寫起來相較於 unittest 較為簡潔</li></ol><h1 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h1><p>TDD 完整名稱為 Test-driven development，中譯為 “測試驅動開發”，是一種軟體開發的方式，以這種模式開發的軟體，會需要在開發程式的同時一併撰寫測試程式，簡單來說就是一個 function 產出就要產出一個相對應的 testcase，好處是可以快速的檢查各項功能有沒有發生錯誤，也可以避免在開發完成後再回來補血測試程式，造成某些功能遺漏沒有測到。</p><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><p>相信很多人對於 Selenium 並不陌生，近年來很常被應用在網路爬蟲上，可以比較簡單的對動態網頁進行爬取，Selenium 最初被開發出來的時候，其實是拿來進行網頁自動化測試的</p><h1 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h1><p>Appium 顧名思義，適用於測試手機 APP 的一個自動化測試的工具，是一個 Open Source 的專案，Appium 提供跨平台的操作，亦即它可以同時測試 IOS 以及 Android 甚至是 Desktop 的 API</p><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>除了 Gitlab、Github 之外，Jenkins 也是目前主流的 CI&#x2F;CD 工具之一，由於 Jenkins 也是開源專案，因此發展速度非常快，也非常容易上手，這邊將花幾天的時間來介紹該如何進行 Jenkins 的操作以及環境的建置</p><p>接話來會將以上五個項目分別記錄文章</p><p>參考來源: <a href="https://ithelp.ithome.com.tw/articles/10290529">https://ithelp.ithome.com.tw/articles/10290529</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Python/">Python</category>
      
      <category domain="https://gahgah147.github.io/tags/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/">自動化測試</category>
      
      <category domain="https://gahgah147.github.io/tags/iThome%E9%90%B5%E4%BA%BA%E8%B3%BD/">iThome鐵人賽</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/21/Python-%E8%88%87%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Node.js 學習筆記 - NCU 版本檢查介紹及其安裝步驟</title>
      <link>https://gahgah147.github.io/2023/09/20/Node.js%20%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%20-%20NCU%20%E7%89%88%E6%9C%AC%E6%AA%A2%E6%9F%A5%E4%BB%8B%E7%B4%B9%E5%8F%8A%E5%85%B6%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/</link>
      <guid>https://gahgah147.github.io/2023/09/20/Node.js%20%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%20-%20NCU%20%E7%89%88%E6%9C%AC%E6%AA%A2%E6%9F%A5%E4%BB%8B%E7%B4%B9%E5%8F%8A%E5%85%B6%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/</guid>
      <pubDate>Wed, 20 Sep 2023 09:58:59 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Node-js-學習筆記-NCU-版本檢查介紹及其安裝步驟&quot;&gt;&lt;a href=&quot;#Node-js-學習筆記-NCU-版本檢查介紹及其安裝步驟&quot; class=&quot;headerlink&quot; title=&quot;Node.js 學習筆記 - NCU 版本檢查介紹及其安裝步驟&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Node-js-學習筆記-NCU-版本檢查介紹及其安裝步驟"><a href="#Node-js-學習筆記-NCU-版本檢查介紹及其安裝步驟" class="headerlink" title="Node.js 學習筆記 - NCU 版本檢查介紹及其安裝步驟"></a>Node.js 學習筆記 - NCU 版本檢查介紹及其安裝步驟</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 Node.js 開發時，版本問題和各種相依性問題常常導致每次在執行 <code>npm install</code> 後，專案啟動時出現錯誤，這真的是非常煩惱。不過，在看到這篇文章 <a href="https://blog.marsen.me/2022/09/08/2022/how_to_npm_update_more_smoothly/">無痛更新專案中的 npm 相依套件</a> 後，我發現原來有一個名為 <code>npm-check-updates</code> 的工具可以使用，這真的解決了許多問題。</p><h2 id="什麼是NCU"><a href="#什麼是NCU" class="headerlink" title="什麼是NCU?"></a>什麼是NCU?</h2><p>NCU (npm-check-updates) 是一個用於 Node.js 的套件，它可以檢查您的 npm（Node Package Manager）項目中的套件，並提示您可用的更新版本。這個工具可以幫助開發者輕鬆地確保他們的項目中使用的套件都是最新版本，從而提高代碼的安全性和可靠性。</p><h2 id="檢查過時的版本"><a href="#檢查過時的版本" class="headerlink" title="檢查過時的版本"></a>檢查過時的版本</h2><p>首先，我們可以使用 <code>npm outdated</code> 來檢查專案中有哪些套件是過時的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure><p>這個命令會列出所有需要更新的套件及其版本資訊。</p><p><img src="https://hackmd.io/_uploads/ByrKVUTVR.png" alt="image"></p><blockquote><p>畫面中可以看到我的部落格專案中有4個套件需要更新了。</p></blockquote><h2 id="安裝-ncu-npm-check-updates-工具"><a href="#安裝-ncu-npm-check-updates-工具" class="headerlink" title="安裝 ncu (npm-check-updates) 工具"></a>安裝 ncu (npm-check-updates) 工具</h2><p>接下來，我們來介紹 <code>npm-check-updates</code> 工具，它可以幫助我們更輕鬆地管理和更新專案中的 npm 相依套件。首先，全域安裝 <code>npm-check-updates</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure><h2 id="執行更新"><a href="#執行更新" class="headerlink" title="執行更新"></a>執行更新</h2><p>安裝完成後，我們可以使用 <code>ncu</code> 命令來檢查並更新相依套件。使用以下命令來更新專案中的套件版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/ByjbBU6ER.png" alt="image"></p><p>這個命令會自動更新 <code>package.json</code> 中的相依套件版本到最新版本。接著，我們只需要重新安裝相依套件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/HyXErI6EA.png" alt="image"></p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>通過 <code>npm-check-updates</code> 工具，我們可以更輕鬆地管理專案中的相依套件，確保它們始終保持最新，從而避免因為過時的套件版本而引發的各種問題。</p><p>參考來源: <a href="https://blog.marsen.me/2022/09/08/2022/how_to_npm_update_more_smoothly/">無痛更新專案中的 npm 相依套件</a></p><p>希望這篇文章能夠幫助你更好的管理專案中的 npm 相依套件。如果有任何問題或需要進一步的幫助，歡迎在留言區提出。</p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Node-js/">Node.js</category>
      
      <category domain="https://gahgah147.github.io/tags/NCU/">NCU</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/20/Node.js%20%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%20-%20NCU%20%E7%89%88%E6%9C%AC%E6%AA%A2%E6%9F%A5%E4%BB%8B%E7%B4%B9%E5%8F%8A%E5%85%B6%E5%AE%89%E8%A3%9D%E6%AD%A5%E9%A9%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Next.js 實作 Blog 功能</title>
      <link>https://gahgah147.github.io/2023/09/20/Next-js-%E5%AF%A6%E4%BD%9C-Blog-%E5%8A%9F%E8%83%BD/</link>
      <guid>https://gahgah147.github.io/2023/09/20/Next-js-%E5%AF%A6%E4%BD%9C-Blog-%E5%8A%9F%E8%83%BD/</guid>
      <pubDate>Wed, 20 Sep 2023 09:45:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這篇是參考 鐵人賽 系列文章 「從零開始打造炫砲個人部落格」系列簡介 - Modern Next.js Blog 系列 實作的紀錄，實際操作</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇是參考 鐵人賽 系列文章 「從零開始打造炫砲個人部落格」系列簡介 - Modern Next.js Blog 系列 實作的紀錄，實際操作上有遇到很多問題，但大致上跟著git修改的部分調整都可以修改成功。</p><p>這篇的解說很清楚，彙整的也很完整，推薦跟著教學文章操作。</p><p>使用的前端技術</p><table><thead><tr><th>功能</th><th>Next.js 工具</th></tr></thead><tbody><tr><td>UI 樣式</td><td>Tailwind CSS</td></tr><tr><td>多語系</td><td>next-i18next</td></tr><tr><td>SEO meta tags</td><td>next-seo</td></tr><tr><td>指令面板</td><td>kbar</td></tr><tr><td>留言系統</td><td>giscus</td></tr><tr><td>換頁進度條</td><td>nprogress</td></tr><tr><td>更扎實的 JavaScript</td><td>TypeScript</td></tr><tr><td>統一程式碼格式</td><td>ESLint, Prettier</td></tr><tr><td>Markdown&#x2F;MDX 文章處理</td><td>Contentlayer</td></tr><tr><td>網站託管</td><td>Vercel</td></tr></tbody></table><p>Next.js：現代全端框架<br>Vercel：網站託管<br>Contentlayer：Markdown&#x2F;MDX 文章處理</p><p>參考文章: <a href="https://ithelp.ithome.com.tw/articles/10291960">https://ithelp.ithome.com.tw/articles/10291960</a></p><h1 id="官方文件"><a href="#官方文件" class="headerlink" title="官方文件"></a>官方文件</h1><p><a href="https://nextjs.tw/learn/foundations/about-nextjs/what-is-nextjs">https://nextjs.tw/learn/foundations/about-nextjs/what-is-nextjs</a></p><h1 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h1><p>建立專案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm create next-app --typescript</span><br></pre></td></tr></table></figure><p>啟動 Next.js 專案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm dev</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Next-js/">Next.js</category>
      
      <category domain="https://gahgah147.github.io/tags/Blog/">Blog</category>
      
      <category domain="https://gahgah147.github.io/tags/React-js/">React.js</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/20/Next-js-%E5%AF%A6%E4%BD%9C-Blog-%E5%8A%9F%E8%83%BD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在Codespace 上運行Python</title>
      <link>https://gahgah147.github.io/2023/09/12/%E5%9C%A8Codespace-%E4%B8%8A%E9%81%8B%E8%A1%8CPython/</link>
      <guid>https://gahgah147.github.io/2023/09/12/%E5%9C%A8Codespace-%E4%B8%8A%E9%81%8B%E8%A1%8CPython/</guid>
      <pubDate>Tue, 12 Sep 2023 07:30:48 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;在Codespace-上運行Python&quot;&gt;&lt;a href=&quot;#在Codespace-上運行Python&quot; class=&quot;headerlink&quot; title=&quot;在Codespace 上運行Python&quot;&gt;&lt;/a&gt;在Codespace 上運行Python&lt;/h1&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="在Codespace-上運行Python"><a href="#在Codespace-上運行Python" class="headerlink" title="在Codespace 上運行Python"></a>在Codespace 上運行Python</h1><p>範例原始碼放在 GitHub Repo: <a href="https://github.com/gahgah147/vscode-remote-try-python">vscode-remote-try-python</a></p><p>參考文章:<a href="https://docs.github.com/en/codespaces/setting-up-your-project-for-codespaces/adding-a-dev-container-configuration/setting-up-your-python-project-for-codespaces">Setting up a Python project for GitHub Codespaces</a></p><h1 id="1-在-codespace-上開啟-project"><a href="#1-在-codespace-上開啟-project" class="headerlink" title="1. 在 codespace 上開啟 project"></a>1. 在 codespace 上開啟 project</h1><p>Go to <a href="https://github.com/microsoft/vscode-remote-try-python">https://github.com/microsoft/vscode-remote-try-python</a>.<br>Click Use this template, then </p><p><img src="https://hackmd.io/_uploads/Hy2vkS6C3.png"></p><blockquote><p>點擊 Open in a codespace.</p></blockquote><h1 id="2-新增-dev-container-設定檔案"><a href="#2-新增-dev-container-設定檔案" class="headerlink" title="2: 新增 dev container 設定檔案"></a>2: 新增 dev container 設定檔案</h1><p>1.使用 Visual Studio Code 指令 (Ctrl+Shift+P&#x2F;Shift+Command+P)，<br>然後輸入 add dev </p><p><img src="https://hackmd.io/_uploads/SyuKutTC2.png"></p><blockquote><p>點擊 Codespaces: Add Dev Container Configuration Files.</p></blockquote><ol start="2"><li><p>點擊 Create a new configuration.</p></li><li><p>因為已經存在’.devcontainer&#x2F;devcontainer.json’ 檔案所以未出現這個提示，這邊選擇 Continue<br><img src="https://hackmd.io/_uploads/r1KsOYaC2.png"></p></li><li><p>選擇 Show All Definitions.<br><img src="https://hackmd.io/_uploads/B1a7KKTA3.png"></p></li><li><p>輸入 python 然後選擇 Python 3<br><img src="https://hackmd.io/_uploads/BJxOtK6Cn.png"></p></li><li><p>選擇 python 版本 這邊我們選擇預設值<br><img src="https://hackmd.io/_uploads/Skj2KtTRh.png"></p></li><li><p>輸入 py 選擇 Coverage.py (via pipx) 然後點 OK<br><img src="https://hackmd.io/_uploads/rynr9FpA2.png"></p></li></ol><h1 id="3-修改-devcontainer-json-檔案"><a href="#3-修改-devcontainer-json-檔案" class="headerlink" title="3. 修改 devcontainer.json 檔案"></a>3. 修改 devcontainer.json 檔案</h1><ol><li><p>修改 devcontainer.json 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// For format details, see https://aka.ms/devcontainer.json. For config options, see the</span><br><span class="line">// README at: https://github.com/devcontainers/templates/tree/main/src/python</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Python 3&quot;,</span><br><span class="line">  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile</span><br><span class="line">  &quot;image&quot;: &quot;mcr.microsoft.com/devcontainers/python:0-3.11-bullseye&quot;,</span><br><span class="line">  &quot;features&quot;: &#123;</span><br><span class="line">    &quot;ghcr.io/devcontainers-contrib/features/coverage-py:2&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // Use &#x27;forwardPorts&#x27; to make a list of ports inside the container available locally.</span><br><span class="line">  // &quot;forwardPorts&quot;: [],</span><br><span class="line"></span><br><span class="line">  // Use &#x27;postCreateCommand&#x27; to run commands after the container is created.</span><br><span class="line">  &quot;postCreateCommand&quot;: &quot;pip3 install --user -r requirements.txt&quot;,</span><br><span class="line"></span><br><span class="line">  // Configure tool-specific properties.</span><br><span class="line">  &quot;customizations&quot;: &#123;</span><br><span class="line">    // Configure properties specific to VS Code.</span><br><span class="line">    &quot;vscode&quot;: &#123;</span><br><span class="line">      // Add the IDs of extensions you want installed when the container is created.</span><br><span class="line">      &quot;extensions&quot;: [</span><br><span class="line">        &quot;streetsidesoftware.code-spell-checker&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.</span><br><span class="line">  // &quot;remoteUser&quot;: &quot;root&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>(Ctrl+Shift+P) 輸入 rebuild<br><img src="https://hackmd.io/_uploads/Hk11hFaC3.png"><br>選擇 Codespaces: Rebuild Container.</p></li></ol><h1 id="4-接下來就能運行-python-了"><a href="#4-接下來就能運行-python-了" class="headerlink" title="4. 接下來就能運行 python 了"></a>4. 接下來就能運行 python 了</h1><p>測試輸入指令: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m flask run</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/Hyl83FTA3.png"></p><blockquote><p>選擇  Open in Browser </p></blockquote><p>會看到以下畫面<br><img src="https://hackmd.io/_uploads/HJ0DhYp03.png"></p><h1 id="5-可以把修改結果-Commit-上去"><a href="#5-可以把修改結果-Commit-上去" class="headerlink" title="5. 可以把修改結果 Commit 上去"></a>5. 可以把修改結果 Commit 上去</h1>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Python/">Python</category>
      
      <category domain="https://gahgah147.github.io/tags/GitHub/">GitHub</category>
      
      <category domain="https://gahgah147.github.io/tags/Codespace/">Codespace</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/12/%E5%9C%A8Codespace-%E4%B8%8A%E9%81%8B%E8%A1%8CPython/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Codespaces 上運行 Laravel Docker</title>
      <link>https://gahgah147.github.io/2023/09/06/Codespaces-%E4%B8%8A%E9%81%8B%E8%A1%8C-Laravel-Docker/</link>
      <guid>https://gahgah147.github.io/2023/09/06/Codespaces-%E4%B8%8A%E9%81%8B%E8%A1%8C-Laravel-Docker/</guid>
      <pubDate>Wed, 06 Sep 2023 03:37:49 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Codespaces-上運行-Laravel-Docker&quot;&gt;&lt;a href=&quot;#Codespaces-上運行-Laravel-Docker&quot; class=&quot;headerlink&quot; title=&quot;Codespaces 上運行 Laravel Docker&quot;&gt;&lt;/a</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Codespaces-上運行-Laravel-Docker"><a href="#Codespaces-上運行-Laravel-Docker" class="headerlink" title="Codespaces 上運行 Laravel Docker"></a>Codespaces 上運行 Laravel Docker</h1><p><img src="https://hackmd.io/_uploads/H1iYrdrRh.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前因為想要練習 Laravel，所以看到一篇在 Github Codespaces 上運行Laravel 的文章所以來實作，並將結果放在<a href="https://github.com/nalson0219/laravel-docker">這邊</a></p><h2 id="1-創建-Github-Repository-從-Laravel-Docker-範例"><a href="#1-創建-Github-Repository-從-Laravel-Docker-範例" class="headerlink" title="1.創建 Github Repository 從 Laravel Docker 範例"></a>1.創建 Github Repository 從 Laravel Docker 範例</h2><p><img src="https://hackmd.io/_uploads/rJuObwrCh.png"></p><blockquote><p><a href="https://github.com/rakibdevs/laravel-docker">https://github.com/rakibdevs/laravel-docker</a><br>點擊 Use this template</p></blockquote><h2 id="2-建立-Codespace"><a href="#2-建立-Codespace" class="headerlink" title="2.建立 Codespace"></a>2.建立 Codespace</h2><p><img src="https://hackmd.io/_uploads/B1EEEDrRh.png"></p><h2 id="3-Build-Docker-Container"><a href="#3-Build-Docker-Container" class="headerlink" title="3. Build Docker Container"></a>3. Build Docker Container</h2><p>下載必要的套件，並根據Dockerfile 建立 Docker image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose build</span><br></pre></td></tr></table></figure><p>完成後可以執行以下指令開啟 Docker container:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BJxTEPS03.png"></p><h2 id="4-下載-Laravel"><a href="#4-下載-Laravel" class="headerlink" title="4.下載 Laravel"></a>4.下載 Laravel</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 777 src/</span><br><span class="line">$ docker compose exec php composer create-project --prefer-dist laravel/laravel .</span><br></pre></td></tr></table></figure><p>Now copy .env.example to .env by following this command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp src/.env.example src/.env</span><br></pre></td></tr></table></figure><p>更新 database 設定檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DB_HOST=mysql</span><br><span class="line">DB_PORT=3306</span><br><span class="line">DB_DATABASE=laravel</span><br><span class="line">DB_USERNAME=root</span><br><span class="line">DB_PASSWORD=1234</span><br></pre></td></tr></table></figure><h2 id="5-Run-other-esential-commands"><a href="#5-Run-other-esential-commands" class="headerlink" title="5 Run other esential commands"></a>5 Run other esential commands</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose exec php php artisan storage:link</span><br><span class="line">$ docker compose exec php chmod -R 777 storage bootstrap/cache</span><br><span class="line">$ docker compose exec php php artisan migrate:refresh</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-產生-APP-KEY"><a href="#6-產生-APP-KEY" class="headerlink" title="6. 產生　APP_KEY"></a>6. 產生　APP_KEY</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd src </span><br><span class="line">$　composer install</span><br><span class="line">$ php artisan key:generate</span><br></pre></td></tr></table></figure><p>接下來點擊 codespace 下方這個圖案就能開啟網頁<br><img src="https://hackmd.io/_uploads/SkyVGdr0n.png"></p><blockquote><p>移動到 3399 port 的本機位置 ctrl + 按一下 就能看到 laravel 畫面</p></blockquote><p><img src="https://hackmd.io/_uploads/SJjtMur03.png"></p><p>參考文章: <a href="https://rakibdevs.medium.com/github-codespaces-code-on-the-go-with-laravel-in-docker-container-c31f42212e42">https://rakibdevs.medium.com/github-codespaces-code-on-the-go-with-laravel-in-docker-container-c31f42212e42</a></p><p>規劃後續練習參考教學文章: <a href="https://ithelp.ithome.com.tw/articles/10219573">https://ithelp.ithome.com.tw/articles/10219573</a></p>]]></content:encoded>
      
      
      
      <category domain="https://gahgah147.github.io/tags/Laravel/">Laravel</category>
      
      <category domain="https://gahgah147.github.io/tags/Docker/">Docker</category>
      
      <category domain="https://gahgah147.github.io/tags/Github/">Github</category>
      
      <category domain="https://gahgah147.github.io/tags/Codespaces/">Codespaces</category>
      
      
      <comments>https://gahgah147.github.io/2023/09/06/Codespaces-%E4%B8%8A%E9%81%8B%E8%A1%8C-Laravel-Docker/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo + Github 建立部落格</title>
      <link>https://gahgah147.github.io/2023/08/31/Hexo-Github-%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC/</link>
      <guid>https://gahgah147.github.io/2023/08/31/Hexo-Github-%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC/</guid>
      <pubDate>Thu, 31 Aug 2023 06:12:53 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Hexo-Github-建立部落格&quot;&gt;&lt;a href=&quot;#Hexo-Github-建立部落格&quot; class=&quot;headerlink&quot; title=&quot;Hexo + Github 建立部落格&quot;&gt;&lt;/a&gt;Hexo + Github 建立部落格&lt;/h1&gt;&lt;h2 id=&quot;為</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Hexo-Github-建立部落格"><a href="#Hexo-Github-建立部落格" class="headerlink" title="Hexo + Github 建立部落格"></a>Hexo + Github 建立部落格</h1><h2 id="為什麼想要架設-Blog"><a href="#為什麼想要架設-Blog" class="headerlink" title="為什麼想要架設 Blog"></a>為什麼想要架設 Blog</h2><p>身為一個工程師，不知不覺也工作了四年，工作上使用的套件不管是前端、後端、框架都越來越多，所以想記錄自己曾使用過的套件，要用的時候可以很快的查到。</p><ul><li>建立自己的工具箱</li><li>累積屬於自己在技術專業知識品牌</li><li>可以作為作品集展示</li><li>另外想紀錄什麼都可以寫上去</li></ul><h2 id="為什麼選-Hexo"><a href="#為什麼選-Hexo" class="headerlink" title="為什麼選 Hexo"></a>為什麼選 Hexo</h2><ul><li>可以免費放在Github 上</li><li>可以選好看的主題</li><li>支援 Markdown  (因為之前有在用 hackmd 紀錄文件)</li></ul><p>查找到感覺最完整的架設教學文章是這篇 </p><blockquote><p><a href="https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E6%9E%B6%E8%A8%AD-Blog">https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E6%9E%B6%E8%A8%AD-Blog</a></p></blockquote><p>所以就決定跟著來一起嘗試架設Blog</p><h2 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h2><h3 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h3><p><img src="https://hackmd.io/_uploads/Hygizoop62.png"></p><blockquote><p><a href="https://nodejs.org/en">https://nodejs.org/en</a></p></blockquote><div class="note info simple"><p>有用Node js 推薦也一起使用 nvm，因為有時候常常會遇到版本問題<br><img src="https://hackmd.io/_uploads/ryAznjaT3.png"></p><blockquote><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p></blockquote><p>選擇 nvm-setup 開始下載</p></div><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><img src="https://hackmd.io/_uploads/H1vIss66n.png"></p><blockquote><p><a href="https://git-scm.com/">https://git-scm.com/</a></p></blockquote><h3 id="Visual-Studio-Code-vs-code"><a href="#Visual-Studio-Code-vs-code" class="headerlink" title="Visual Studio Code (vs code)"></a>Visual Studio Code (vs code)</h3><p><img src="https://hackmd.io/_uploads/HJ4toipph.png"></p><blockquote><p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p></blockquote><h2 id="Hexo-設定"><a href="#Hexo-設定" class="headerlink" title="Hexo 設定"></a>Hexo 設定</h2><p>安裝 Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>建立 Hexo 專案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexoblog</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>會產生一個 hexoblog 資料夾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hexoblog</span><br></pre></td></tr></table></figure><p>啓動 Hexo 的伺服器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>接下來用瀏覽器打開 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到Hexo 的效果<br><img src="https://hackmd.io/_uploads/HkTGRjap3.png"></p><h2 id="要怎麼在在文章上放圖片呢"><a href="#要怎麼在在文章上放圖片呢" class="headerlink" title="要怎麼在在文章上放圖片呢"></a>要怎麼在在文章上放圖片呢</h2><p>查看了各種教學後來決定先把文章圖片放在 HackMD上，再採用設定公開表的方式分享照片<br><img src="https://hackmd.io/_uploads/SyLWU7JR3.png"></p><h2 id="選擇主題樣式"><a href="#選擇主題樣式" class="headerlink" title="選擇主題樣式"></a>選擇主題樣式</h2><h3 id="使用-Butterfly-主題樣式"><a href="#使用-Butterfly-主題樣式" class="headerlink" title="使用 Butterfly 主題樣式"></a>使用 Butterfly 主題樣式</h3><p>另外可以選擇其他樣式</p><p><img src="https://hackmd.io/_uploads/SydzvSNCn.png"></p><blockquote><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></blockquote><p>因為是我參考 ChanChanDev 圈圈工程師 寫的<a href="https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/#%E9%81%B8%E6%93%87%E4%B8%BB%E9%A1%8C%E6%A8%A3%E5%BC%8F">這篇文章</a> 實作的，比較起來我也感覺 Butterfly 這個主題最好看</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>下載 Butterfly 主題及配件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line">npm install cheerio@0.22.0 --save</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>下載完成後，在 .\Desktop\mywebsite\githubBlog\themes 裡，會看見多了個名叫 Butterfly 的 folder。</p><p>更改主題:開啓這個文件 .\githubBlog_config.yml，把主題改為 Butterfly</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: Butterfly</span><br></pre></td></tr></table></figure><p>參考官方教學:<a href="https://butterfly.js.org/posts/21cfbf15/#%E5%AE%89%E8%A3%9D">https://butterfly.js.org/posts/21cfbf15/#%E5%AE%89%E8%A3%9D</a></p><p>另外這個方式會遇到以下問題<br><img src="https://hackmd.io/_uploads/HkxXDItSC.png" alt="image"></p><p>這個警告表示你正在將另一個 git 儲存庫添加到當前的 git 儲存庫中。也就是說在我們原本的部落格git專案裡面還有別的git專案</p><p>可以用以下方式解決</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -f --cached themes/Butterfly</span><br><span class="line">git submodule add https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br></pre></td></tr></table></figure><p>第一個命令會從索引中刪除 themes&#x2F;Butterfly，第二個命令則將其重新添加為子模組。這樣做後，Git 應該能正確處理 themes&#x2F;Butterfly。</p><h4 id="方法二-這方法有個問題就是在-themes-底下沒有Butterfly-會沒辦法調整設置"><a href="#方法二-這方法有個問題就是在-themes-底下沒有Butterfly-會沒辦法調整設置" class="headerlink" title="方法二 (這方法有個問題就是在 themes&#x2F; 底下沒有Butterfly 會沒辦法調整設置)"></a>方法二 (這方法有個問題就是在 themes&#x2F; 底下沒有Butterfly 會沒辦法調整設置)</h4><p>安裝 Butterfly 主題樣式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安裝 Butterfly 所需的套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>開啓 _config.yml 檔，更改 theme 設定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>在本機端啓動 Hexo 的伺服器，就可以看到套用了 Butterfly 主題樣式的網站囉！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/By-YOrEC3.png"></p><h3 id="應用-Butterfly-主題"><a href="#應用-Butterfly-主題" class="headerlink" title="應用 Butterfly 主題"></a>應用 Butterfly 主題</h3><h4 id="Front-matter-設定"><a href="#Front-matter-設定" class="headerlink" title="Front-matter 設定"></a>Front-matter 設定</h4><p>Front-matter 是 markdown 文件最上方以 — 分隔的區域，用於指定個別檔案的變數。</p><p>Page Front-matter 用於頁面配置<br>Post Front-matter 用於文章頁配置</p><blockquote><p>如果標注<code>可選</code>的參數，可根據自己需要添加，不用全部都寫在 markdown 裏</p></blockquote><h5 id="調整頁面配置-Page-Front-matter"><a href="#調整頁面配置-Page-Front-matter" class="headerlink" title="調整頁面配置: Page Front-matter"></a>調整頁面配置: Page Front-matter</h5><p>開啓這個文件 .\githubBlog\scaffolds\page.md，改成下面這樣子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">type: （tags,link,categories這三個頁面需要配置）</span><br><span class="line">comments: (是否需要顯示評論，默認true)</span><br><span class="line">description:</span><br><span class="line">top_img: (設置頂部圖)</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多細節可以參考官方文件:<a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</a></p><h5 id="調整文章頁配置-Post-Front-matter"><a href="#調整文章頁配置-Post-Front-matter" class="headerlink" title="調整文章頁配置: Post Front-matter"></a>調整文章頁配置: Post Front-matter</h5><p>開啓這個文件 .\githubBlog\scaffolds\post.md，改成下面這樣子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img: （除非特定需要，可以不寫）</span><br><span class="line">comments  是否顯示評論（除非設置false,可以不寫）</span><br><span class="line">cover:  縮略圖</span><br><span class="line">toc:  是否顯示toc （除非特定文章設置，可以不寫）</span><br><span class="line">toc_number: 是否顯示toc數字 （除非特定文章設置，可以不寫）</span><br><span class="line">copyright: 是否顯示版權 （除非特定文章設置，可以不寫）</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">hide:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>更多細節可以參考官方文件:<a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</a></p><h4 id="創建標籤頁"><a href="#創建標籤頁" class="headerlink" title="創建標籤頁"></a>創建標籤頁</h4><p>輸入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>開啓這個文件 .\githubBlog\source\tags\index.md，把 type 設定為 “tags”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 標籤</span><br><span class="line">date: 2024-06-12 00:00:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這邊是產生的標籤頁效果 https:&#x2F;&#x2F;<username>.github.io&#x2F;tags&#x2F;<br><img src="https://hackmd.io/_uploads/S1uihFLH0.png" alt="image"></p><h4 id="創建分類頁"><a href="#創建分類頁" class="headerlink" title="創建分類頁"></a>創建分類頁</h4><p>輸入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>開啓這個文件 .\githubBlog\source\categories\index.md，把 type 設定為 “categories”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分類</span><br><span class="line">date: 2024-06-12 00:00:00</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="創建友情連結頁"><a href="#創建友情連結頁" class="headerlink" title="創建友情連結頁"></a>創建友情連結頁</h4><p>輸入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page link</span><br></pre></td></tr></table></figure><p>開啓這個文件 .\githubBlog\source\link\index.md，把 type 設定為 “link”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情連結</span><br><span class="line">date: 2024-06-12 00:00:00</span><br><span class="line">type: &quot;link&quot;</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>開啓這個文件（如沒有就自己新增）.\githubBlog\source_data\link.yml，內容如下：</p><h2 id="Hexo-常用指令"><a href="#Hexo-常用指令" class="headerlink" title="Hexo 常用指令"></a>Hexo 常用指令</h2><p>初始化專案 &#x2F; 建立專案資料夾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [資料夾名稱]</span><br></pre></td></tr></table></figure><p>建立一篇新的文章，若標題包括空格，請用引號括起來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;文章標題&gt;</span><br></pre></td></tr></table></figure><p>在本機端啓動伺服器，預設是 <a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><h2 id="指令新增第一篇文章"><a href="#指令新增第一篇文章" class="headerlink" title="指令新增第一篇文章"></a>指令新增第一篇文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;我的第一篇文章 By Hexo&quot;</span><br></pre></td></tr></table></figure><p>會發現在 source 的 _posts 的資料夾多了一個 我的第一篇文章-By-Hexo.md 的檔案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇文章 By Hexo</span><br><span class="line">date: 2021-03-07 17:15:57</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 我的第一篇文章的標題</span><br><span class="line">hihihi ~ 你好～ 我是第一篇文章的內容～</span><br><span class="line">在這裏可以用 `Markdown` 語法撰寫</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="部署-Deploy-設定"><a href="#部署-Deploy-設定" class="headerlink" title="部署 Deploy 設定"></a>部署 Deploy 設定</h2><h3 id="申請-Github-帳號"><a href="#申請-Github-帳號" class="headerlink" title="申請 Github 帳號"></a>申請 Github 帳號</h3><p><img src="https://hackmd.io/_uploads/rk0N6SV0h.png"></p><blockquote><p><a href="https://github.com/">https://github.com</a></p></blockquote><h3 id="設定-repository"><a href="#設定-repository" class="headerlink" title="設定 repository"></a>設定 repository</h3><p>新增一個public 的 repository，並且命名爲 githubusername.github.io</p><p>例如：你的 github 使用者帳號爲 abc_xyz 那麼這個 repository 的名稱就會是 abc_xyz.github.io</p><h3 id="安裝部署外掛"><a href="#安裝部署外掛" class="headerlink" title="安裝部署外掛"></a>安裝部署外掛</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="調整-config-yml-設定"><a href="#調整-config-yml-設定" class="headerlink" title="調整_config.yml 設定"></a>調整_config.yml 設定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:abc_xyz/abc_xyz.github.io.git # 貼上剛剛複製的 Github Repository 網址</span><br><span class="line">  branch: master # 預設分支名稱</span><br><span class="line">  message:</span><br></pre></td></tr></table></figure><h3 id="執行以下指令將-Hexo-產生的網站內容上傳到-Github"><a href="#執行以下指令將-Hexo-產生的網站內容上傳到-Github" class="headerlink" title="執行以下指令將 Hexo 產生的網站內容上傳到 Github"></a>執行以下指令將 Hexo 產生的網站內容上傳到 Github</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><p>用瀏覽器在網址輸入上述的網址 <code>https://&lt;username&gt;.github.io</code>，就可以看到 Hexo 的網站順利地架在 Github 的 Page 上了</p><p><img src="https://hackmd.io/_uploads/rk5SyU40n.png"></p><h2 id="常用的-Hexo-命令"><a href="#常用的-Hexo-命令" class="headerlink" title="常用的 Hexo 命令"></a>常用的 Hexo 命令</h2><h3 id="清理快取文件（db-json）和生成的文件（public）"><a href="#清理快取文件（db-json）和生成的文件（public）" class="headerlink" title="清理快取文件（db.json）和生成的文件（public）"></a>清理快取文件（db.json）和生成的文件（public）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="生成靜態文件"><a href="#生成靜態文件" class="headerlink" title="生成靜態文件"></a>生成靜態文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="啟動本地伺服器"><a href="#啟動本地伺服器" class="headerlink" title="啟動本地伺服器"></a>啟動本地伺服器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s       </span><br></pre></td></tr></table></figure><h3 id="部屬到github上"><a href="#部屬到github上" class="headerlink" title="部屬到github上"></a>部屬到github上</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="生成完成後再部署"><a href="#生成完成後再部署" class="headerlink" title="生成完成後再部署"></a>生成完成後再部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h3 id="生成完成後再部署時提交的訊息"><a href="#生成完成後再部署時提交的訊息" class="headerlink" title="生成完成後再部署時提交的訊息"></a>生成完成後再部署時提交的訊息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d -m &quot;message&quot;</span><br></pre></td></tr></table></figure><p>-m “message”: 在部署時提交的訊息（通常用於版本控制系統，如 Git）。</p><h3 id="建立新的文章"><a href="#建立新的文章" class="headerlink" title="建立新的文章"></a>建立新的文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;post-title&gt;</span><br></pre></td></tr></table></figure><h3 id="建立新的頁面"><a href="#建立新的頁面" class="headerlink" title="建立新的頁面"></a>建立新的頁面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &lt;page-title&gt;</span><br></pre></td></tr></table></figure><h3 id="總攬"><a href="#總攬" class="headerlink" title="總攬"></a>總攬</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   # 清理快取文件（db.json）和生成的文件（public）</span><br><span class="line">hexo g       # 生成靜態文件</span><br><span class="line">hexo s       # 啟動本地伺服器</span><br><span class="line">hexo d       # 部屬到github上</span><br><span class="line">hexo g -d    # 生成完成後再部署</span><br><span class="line">hexo g -d -m &quot;message&quot;      # 生成完成後再部署時提交的訊息</span><br><span class="line">hexo new &lt;post-title&gt;       # 建立新的文章</span><br><span class="line">hexo new page &lt;page-title&gt;  # 建立新的頁面</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://gahgah147.github.io/categories/%E6%9E%B6%E7%AB%99%E8%A8%98%E9%8C%84/">架站記錄</category>
      
      
      <category domain="https://gahgah147.github.io/tags/Github/">Github</category>
      
      <category domain="https://gahgah147.github.io/tags/Node-js/">Node.js</category>
      
      <category domain="https://gahgah147.github.io/tags/Hexo/">Hexo</category>
      
      
      <comments>https://gahgah147.github.io/2023/08/31/Hexo-Github-%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
